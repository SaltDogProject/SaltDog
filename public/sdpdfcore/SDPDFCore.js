/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/crypto-js/aes.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/aes.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ "./node_modules/crypto-js/cipher-core.js":
/*!***********************************************!*\
  !*** ./node_modules/crypto-js/cipher-core.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(/*! crypto */ "?9157");
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64url.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/enc-base64url.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64url encoding strategy.
	     */
	    var Base64url = C_enc.Base64url = {
	        /**
	         * Converts a word array to a Base64url string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {string} The Base64url string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
	         */
	        stringify: function (wordArray, urlSafe=true) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = urlSafe ? this._safe_map : this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64url string to a word array.
	         *
	         * @param {string} base64Str The Base64url string.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
	         */
	        parse: function (base64Str, urlSafe=true) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = urlSafe ? this._safe_map : this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                reverseMap = this._reverseMap = [];
	                for (var j = 0; j < map.length; j++) {
	                    reverseMap[map.charCodeAt(j)] = j;
	                }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
	        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	        var words = [];
	        var nBytes = 0;
	        for (var i = 0; i < base64StrLength; i++) {
	            if (i % 4) {
	                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	                var bitsCombined = bits1 | bits2;
	                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	                nBytes++;
	            }
	        }
	        return WordArray.create(words, nBytes);
	    }
	}());

	return CryptoJS.enc.Base64url;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-utf16.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/enc-utf16.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),

/***/ "./node_modules/crypto-js/evpkdf.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/evpkdf.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ "./node_modules/crypto-js/format-hex.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/format-hex.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),

/***/ "./node_modules/crypto-js/hmac.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/hmac.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ "./node_modules/crypto-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/crypto-js/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./lib-typedarrays */ "./node_modules/crypto-js/lib-typedarrays.js"), __webpack_require__(/*! ./enc-utf16 */ "./node_modules/crypto-js/enc-utf16.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./enc-base64url */ "./node_modules/crypto-js/enc-base64url.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"), __webpack_require__(/*! ./sha224 */ "./node_modules/crypto-js/sha224.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"), __webpack_require__(/*! ./sha384 */ "./node_modules/crypto-js/sha384.js"), __webpack_require__(/*! ./sha3 */ "./node_modules/crypto-js/sha3.js"), __webpack_require__(/*! ./ripemd160 */ "./node_modules/crypto-js/ripemd160.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"), __webpack_require__(/*! ./pbkdf2 */ "./node_modules/crypto-js/pbkdf2.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"), __webpack_require__(/*! ./mode-cfb */ "./node_modules/crypto-js/mode-cfb.js"), __webpack_require__(/*! ./mode-ctr */ "./node_modules/crypto-js/mode-ctr.js"), __webpack_require__(/*! ./mode-ctr-gladman */ "./node_modules/crypto-js/mode-ctr-gladman.js"), __webpack_require__(/*! ./mode-ofb */ "./node_modules/crypto-js/mode-ofb.js"), __webpack_require__(/*! ./mode-ecb */ "./node_modules/crypto-js/mode-ecb.js"), __webpack_require__(/*! ./pad-ansix923 */ "./node_modules/crypto-js/pad-ansix923.js"), __webpack_require__(/*! ./pad-iso10126 */ "./node_modules/crypto-js/pad-iso10126.js"), __webpack_require__(/*! ./pad-iso97971 */ "./node_modules/crypto-js/pad-iso97971.js"), __webpack_require__(/*! ./pad-zeropadding */ "./node_modules/crypto-js/pad-zeropadding.js"), __webpack_require__(/*! ./pad-nopadding */ "./node_modules/crypto-js/pad-nopadding.js"), __webpack_require__(/*! ./format-hex */ "./node_modules/crypto-js/format-hex.js"), __webpack_require__(/*! ./aes */ "./node_modules/crypto-js/aes.js"), __webpack_require__(/*! ./tripledes */ "./node_modules/crypto-js/tripledes.js"), __webpack_require__(/*! ./rc4 */ "./node_modules/crypto-js/rc4.js"), __webpack_require__(/*! ./rabbit */ "./node_modules/crypto-js/rabbit.js"), __webpack_require__(/*! ./rabbit-legacy */ "./node_modules/crypto-js/rabbit-legacy.js"));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),

/***/ "./node_modules/crypto-js/lib-typedarrays.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "./node_modules/crypto-js/mode-cfb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-cfb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        var keystream;

	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr-gladman.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr-gladman.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));

/***/ }),

/***/ "./node_modules/crypto-js/mode-ecb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ecb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));

/***/ }),

/***/ "./node_modules/crypto-js/mode-ofb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ofb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));

/***/ }),

/***/ "./node_modules/crypto-js/pad-ansix923.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-ansix923.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso10126.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso10126.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso97971.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso97971.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));

/***/ }),

/***/ "./node_modules/crypto-js/pad-nopadding.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/pad-nopadding.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));

/***/ }),

/***/ "./node_modules/crypto-js/pad-zeropadding.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/pad-zeropadding.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        for (var i = data.sigBytes - 1; i >= 0; i--) {
	            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	                data.sigBytes = i + 1;
	                break;
	            }
	        }
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));

/***/ }),

/***/ "./node_modules/crypto-js/pbkdf2.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/pbkdf2.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));

/***/ }),

/***/ "./node_modules/crypto-js/rabbit-legacy.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/rabbit-legacy.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));

/***/ }),

/***/ "./node_modules/crypto-js/rabbit.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/rabbit.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));

/***/ }),

/***/ "./node_modules/crypto-js/rc4.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/rc4.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));

/***/ }),

/***/ "./node_modules/crypto-js/ripemd160.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/ripemd160.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha1.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha224.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha224.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha256.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha256.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha3.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha3.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    var tMsw;
	                    var tLsw;

	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha384.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha384.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha512.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha512.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                var Wil;
	                var Wih;

	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    Wih = Wi.high = M[offset + i * 2]     | 0;
	                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    Wil = gamma0l + Wi7l;
	                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    Wil = Wil + gamma1l;
	                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    Wil = Wil + Wi16l;
	                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));

/***/ }),

/***/ "./node_modules/crypto-js/tripledes.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/tripledes.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            // Make sure the key length is valid (64, 128 or >= 192 bit)
	            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
	                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
	            }

	            // Extend the key according to the keying options defined in 3DES standard
	            var key1 = keyWords.slice(0, 2);
	            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
	            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(key1));
	            this._des2 = DES.createEncryptor(WordArray.create(key2));
	            this._des3 = DES.createEncryptor(WordArray.create(key3));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));

/***/ }),

/***/ "./node_modules/crypto-js/x64-core.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/x64-core.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Top level file is just a mixin of submodules & constants


const { Deflate, deflate, deflateRaw, gzip } = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");

const { Inflate, inflate, inflateRaw, ungzip } = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");

const constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = ungzip;
module.exports.constants = constants;


/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";



const zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  let status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = zlib_deflate.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";



const zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");
const GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = utils.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  let status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = zlib_inflate.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      zlib_inflate.inflateReset(strm);
      status = zlib_inflate.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || msg[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = inflate;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";



const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

module.exports.assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
module.exports.flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};


/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";
// String encode/decode helpers



// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
module.exports.string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
module.exports.buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
module.exports.utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


module.exports = adler32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


module.exports = crc32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");
const adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32   = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const msg     = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = msg[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


const deflate = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


module.exports.deflateInit = deflateInit;
module.exports.deflateInit2 = deflateInit2;
module.exports.deflateReset = deflateReset;
module.exports.deflateResetKeep = deflateResetKeep;
module.exports.deflateSetHeader = deflateSetHeader;
module.exports.deflate = deflate;
module.exports.deflateEnd = deflateEnd;
module.exports.deflateSetDictionary = deflateSetDictionary;
module.exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 30;       /* got a data error -- remain here until reset */
const TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32       = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32         = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const inflate_fast  = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");
const inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH, Z_BLOCK, Z_TREES,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
};


module.exports.inflateReset = inflateReset;
module.exports.inflateReset2 = inflateReset2;
module.exports.inflateResetKeep = inflateResetKeep;
module.exports.inflateInit = inflateInit;
module.exports.inflateInit2 = inflateInit2;
module.exports.inflate = inflate;
module.exports.inflateEnd = inflateEnd;
module.exports.inflateGetHeader = inflateGetHeader;
module.exports.inflateSetDictionary = inflateSetDictionary;
module.exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


module.exports = inflate_table;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

module.exports._tr_init  = _tr_init;
module.exports._tr_stored_block = _tr_stored_block;
module.exports._tr_flush_block  = _tr_flush_block;
module.exports._tr_tally = _tr_tally;
module.exports._tr_align = _tr_align;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "./node_modules/pdfjs-dist/build/pdf.js":
/*!**********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.LinkTarget = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;
exports.addLinkAttributes = addLinkAttributes;
exports.deprecated = deprecated;
exports.getFilenameFromUrl = getFilenameFromUrl;
exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
exports.getXfaPageViewport = getXfaPageViewport;
exports.isDataScheme = isDataScheme;
exports.isPdfFile = isPdfFile;
exports.isValidFetchUrl = isValidFetchUrl;
exports.loadScript = loadScript;

var _util = __w_pdfjs_require__(2);

var _base_factory = __w_pdfjs_require__(5);

const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
const SVG_NS = "http://www.w3.org/2000/svg";
const PixelsPerInch = {
  CSS: 96.0,
  PDF: 72.0,

  get PDF_TO_CSS_UNITS() {
    return (0, _util.shadow)(this, "PDF_TO_CSS_UNITS", this.CSS / this.PDF);
  }

};
exports.PixelsPerInch = PixelsPerInch;

class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this._document = ownerDocument;
  }

  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");

    canvas.width = width;
    canvas.height = height;
    return canvas;
  }

}

exports.DOMCanvasFactory = DOMCanvasFactory;

async function fetchData(url, asTypedArray = false) {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(response.statusText);
    }

    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());
  }

  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);

    if (asTypedArray) {
      request.responseType = "arraybuffer";
    }

    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }

      if (request.status === 200 || request.status === 0) {
        let data;

        if (asTypedArray && request.response) {
          data = new Uint8Array(request.response);
        } else if (!asTypedArray && request.responseText) {
          data = (0, _util.stringToBytes)(request.responseText);
        }

        if (data) {
          resolve(data);
          return;
        }
      }

      reject(new Error(request.statusText));
    };

    request.send(null);
  });
}

class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url, this.isCompressed).then(data => {
      return {
        cMapData: data,
        compressionType
      };
    });
  }

}

exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url, true);
  }

}

exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;

class DOMSVGFactory extends _base_factory.BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }

}

exports.DOMSVGFactory = DOMSVGFactory;

class PageViewport {
  constructor({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;

    if (rotation < 0) {
      rotation += 360;
    }

    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;

      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;

      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;

      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;

      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }

    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }

    let offsetCanvasX, offsetCanvasY;
    let width, height;

    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }

    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }

  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  convertToViewportPoint(x, y) {
    return _util.Util.applyTransform([x, y], this.transform);
  }

  convertToViewportRectangle(rect) {
    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }

  convertToPdfPoint(x, y) {
    return _util.Util.applyInverseTransform([x, y], this.transform);
  }

}

exports.PageViewport = PageViewport;

class RenderingCancelledException extends _util.BaseException {
  constructor(msg, type) {
    super(msg, "RenderingCancelledException");
    this.type = type;
  }

}

exports.RenderingCancelledException = RenderingCancelledException;
const LinkTarget = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
exports.LinkTarget = LinkTarget;

function addLinkAttributes(link, {
  url,
  target,
  rel,
  enabled = true
} = {}) {
  (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
  const urlNullRemoved = (0, _util.removeNullCharacters)(url);

  if (enabled) {
    link.href = link.title = urlNullRemoved;
  } else {
    link.href = "";
    link.title = `Disabled: ${urlNullRemoved}`;

    link.onclick = () => {
      return false;
    };
  }

  let targetStr = "";

  switch (target) {
    case LinkTarget.NONE:
      break;

    case LinkTarget.SELF:
      targetStr = "_self";
      break;

    case LinkTarget.BLANK:
      targetStr = "_blank";
      break;

    case LinkTarget.PARENT:
      targetStr = "_parent";
      break;

    case LinkTarget.TOP:
      targetStr = "_top";
      break;
  }

  link.target = targetStr;
  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
}

function isDataScheme(url) {
  const ii = url.length;
  let i = 0;

  while (i < ii && url[i].trim() === "") {
    i++;
  }

  return url.substring(i, i + 5).toLowerCase() === "data:";
}

function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}

function getFilenameFromUrl(url) {
  const anchor = url.indexOf("#");
  const query = url.indexOf("?");
  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
  return url.substring(url.lastIndexOf("/", end) + 1, end);
}

function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }

  if (isDataScheme(url)) {
    (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }

  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];

    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch (ex) {}
    }
  }

  return suggestedFilename || defaultFilename;
}

class StatTimer {
  constructor() {
    this.started = Object.create(null);
    this.times = [];
  }

  time(name) {
    if (name in this.started) {
      (0, _util.warn)(`Timer is already running for ${name}`);
    }

    this.started[name] = Date.now();
  }

  timeEnd(name) {
    if (!(name in this.started)) {
      (0, _util.warn)(`Timer has not been started for ${name}`);
    }

    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }

  toString() {
    const outBuf = [];
    let longest = 0;

    for (const time of this.times) {
      const name = time.name;

      if (name.length > longest) {
        longest = name.length;
      }
    }

    for (const time of this.times) {
      const duration = time.end - time.start;
      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`);
    }

    return outBuf.join("");
  }

}

exports.StatTimer = StatTimer;

function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch (ex) {
    return false;
  }
}

function loadScript(src, removeScriptElement = false) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;

    script.onload = function (evt) {
      if (removeScriptElement) {
        script.remove();
      }

      resolve(evt);
    };

    script.onerror = function () {
      reject(new Error(`Cannot load script at: ${script.src}`));
    };

    (document.head || document.documentElement).appendChild(script);
  });
}

function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}

let pdfDateStringRegex;

class PDFDateString {
  static toDateObject(input) {
    if (!input || !(0, _util.isString)(input)) {
      return null;
    }

    if (!pdfDateStringRegex) {
      pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
    }

    const matches = pdfDateStringRegex.exec(input);

    if (!matches) {
      return null;
    }

    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }

    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }

}

exports.PDFDateString = PDFDateString;

function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    scale,
    rotation
  });
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createObjectURL = createObjectURL;
exports.createPromiseCapability = createPromiseCapability;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.escapeString = escapeString;
exports.getModificationDate = getModificationDate;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isAscii = isAscii;
exports.isBool = isBool;
exports.isNum = isNum;
exports.isSameOrigin = isSameOrigin;
exports.isString = isString;
exports.objectFromMap = objectFromMap;
exports.objectSize = objectSize;
exports.removeNullCharacters = removeNullCharacters;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF16BEString = stringToUTF16BEString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;

__w_pdfjs_require__(3);

const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const RenderingIntentFlag = {
  ANY: 0x01,
  DISPLAY: 0x02,
  PRINT: 0x04,
  ANNOTATIONS_FORMS: 0x10,
  ANNOTATIONS_STORAGE: 0x20,
  ANNOTATIONS_DISABLE: 0x40,
  OPLIST: 0x100
};
exports.RenderingIntentFlag = RenderingIntentFlag;
const AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
exports.AnnotationMode = AnnotationMode;
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
const ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
const AnnotationStateModelType = {
  MARKED: "Marked",
  REVIEW: "Review"
};
exports.AnnotationStateModelType = AnnotationStateModelType;
const AnnotationMarkedState = {
  MARKED: "Marked",
  UNMARKED: "Unmarked"
};
exports.AnnotationMarkedState = AnnotationMarkedState;
const AnnotationReviewState = {
  ACCEPTED: "Accepted",
  REJECTED: "Rejected",
  CANCELLED: "Cancelled",
  COMPLETED: "Completed",
  NONE: "None"
};
exports.AnnotationReviewState = AnnotationReviewState;
const AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
const StreamType = {
  UNKNOWN: "UNKNOWN",
  FLATE: "FLATE",
  LZW: "LZW",
  DCT: "DCT",
  JPX: "JPX",
  JBIG: "JBIG",
  A85: "A85",
  AHX: "AHX",
  CCF: "CCF",
  RLX: "RLX"
};
exports.StreamType = StreamType;
const FontType = {
  UNKNOWN: "UNKNOWN",
  TYPE1: "TYPE1",
  TYPE1STANDARD: "TYPE1STANDARD",
  TYPE1C: "TYPE1C",
  CIDFONTTYPE0: "CIDFONTTYPE0",
  CIDFONTTYPE0C: "CIDFONTTYPE0C",
  TRUETYPE: "TRUETYPE",
  CIDFONTTYPE2: "CIDFONTTYPE2",
  TYPE3: "TYPE3",
  OPENTYPE: "OPENTYPE",
  TYPE0: "TYPE0",
  MMTYPE1: "MMTYPE1"
};
exports.FontType = FontType;
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
exports.CMapCompressionType = CMapCompressionType;
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
const UNSUPPORTED_FEATURES = {
  unknown: "unknown",
  forms: "forms",
  javaScript: "javaScript",
  signatures: "signatures",
  smask: "smask",
  shadingPattern: "shadingPattern",
  font: "font",
  errorTilingPattern: "errorTilingPattern",
  errorExtGState: "errorExtGState",
  errorXObject: "errorXObject",
  errorFontLoadType3: "errorFontLoadType3",
  errorFontState: "errorFontState",
  errorFontMissing: "errorFontMissing",
  errorFontTranslate: "errorFontTranslate",
  errorColorSpace: "errorColorSpace",
  errorOperatorList: "errorOperatorList",
  errorFontToUnicode: "errorFontToUnicode",
  errorFontLoadNative: "errorFontLoadNative",
  errorFontBuildPath: "errorFontBuildPath",
  errorFontGetPath: "errorFontGetPath",
  errorMarkedContent: "errorMarkedContent",
  errorContentSubStream: "errorContentSubStream"
};
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
let verbosity = VerbosityLevel.WARNINGS;

function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}

function getVerbosityLevel() {
  return verbosity;
}

function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function isSameOrigin(baseUrl, otherUrl) {
  let base;

  try {
    base = new URL(baseUrl);

    if (!base.origin || base.origin === "null") {
      return false;
    }
  } catch (e) {
    return false;
  }

  const other = new URL(otherUrl, base);
  return base.origin === other.origin;
}

function _isValidProtocol(url) {
  if (!url) {
    return false;
  }

  switch (url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;

    default:
      return false;
  }
}

function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }

  try {
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);

        if (dots && dots.length >= 2) {
          url = `http://${url}`;
        }
      }

      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch (ex) {}
      }
    }

    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}

  return null;
}

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}

const BaseException = function BaseExceptionClosure() {
  function BaseException(message, name) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }

    this.message = message;
    this.name = name;
  }

  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();

exports.BaseException = BaseException;

class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }

}

exports.PasswordException = PasswordException;

class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }

}

exports.UnknownErrorException = UnknownErrorException;

class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }

}

exports.InvalidPDFException = InvalidPDFException;

class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg, "MissingPDFException");
  }

}

exports.MissingPDFException = MissingPDFException;

class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg, "UnexpectedResponseException");
    this.status = status;
  }

}

exports.UnexpectedResponseException = UnexpectedResponseException;

class FormatError extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }

}

exports.FormatError = FormatError;

class AbortException extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }

}

exports.AbortException = AbortException;
const NullCharactersRegExp = /\x00+/g;
const InvisibleCharactersRegExp = /[\x01-\x1F]/g;

function removeNullCharacters(str, replaceInvisible = false) {
  if (typeof str !== "string") {
    warn("The argument for removeNullCharacters must be a string.");
    return str;
  }

  if (replaceInvisible) {
    str = str.replace(InvisibleCharactersRegExp, " ");
  }

  return str.replace(NullCharactersRegExp, "");
}

function bytesToString(bytes) {
  assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;

  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }

  const strBuf = [];

  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }

  return strBuf.join("");
}

function stringToBytes(str) {
  assert(typeof str === "string", "Invalid argument for stringToBytes");
  const length = str.length;
  const bytes = new Uint8Array(length);

  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }

  return bytes;
}

function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }

  assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
  return arr.byteLength;
}

function arraysToBytes(arr) {
  const length = arr.length;

  if (length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }

  let resultLength = 0;

  for (let i = 0; i < length; i++) {
    resultLength += arrayByteLength(arr[i]);
  }

  let pos = 0;
  const data = new Uint8Array(resultLength);

  for (let i = 0; i < length; i++) {
    let item = arr[i];

    if (!(item instanceof Uint8Array)) {
      if (typeof item === "string") {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }

    const itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }

  return data;
}

function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}

function objectSize(obj) {
  return Object.keys(obj).length;
}

function objectFromMap(map) {
  const obj = Object.create(null);

  for (const [key, value] of map) {
    obj[key] = value;
  }

  return obj;
}

function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}

const IsLittleEndianCached = {
  get value() {
    return shadow(this, "value", isLittleEndian());
  }

};
exports.IsLittleEndianCached = IsLittleEndianCached;

function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch (e) {
    return false;
  }
}

const IsEvalSupportedCached = {
  get value() {
    return shadow(this, "value", isEvalSupported());
  }

};
exports.IsEvalSupportedCached = IsEvalSupportedCached;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }

  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }

  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }

  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }

  static getAxialAlignedBoundingBox(r, m) {
    const p1 = Util.applyTransform(r, m);
    const p2 = Util.applyTransform(r.slice(2, 4), m);
    const p3 = Util.applyTransform([r[0], r[3]], m);
    const p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }

  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }

  static apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  }

  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }

  static normalizeRect(rect) {
    const r = rect.slice(0);

    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }

    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }

    return r;
  }

  static intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
    const result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return null;
    }

    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return null;
    }

    return result;
  }

  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    const tvalues = [],
          bounds = [[], []];
    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    for (let i = 0; i < 2; ++i) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }

        t = -c / b;

        if (0 < t && t < 1) {
          tvalues.push(t);
        }

        continue;
      }

      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);

      if (b2ac < 0) {
        continue;
      }

      t1 = (-b + sqrtb2ac) / (2 * a);

      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }

      t2 = (-b - sqrtb2ac) / (2 * a);

      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    let j = tvalues.length,
        mt;
    const jlen = j;

    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
  }

}

exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

function stringToPDFString(str) {
  const length = str.length,
        strBuf = [];

  if (str[0] === "\xFE" && str[1] === "\xFF") {
    for (let i = 2; i < length; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
    for (let i = 2; i < length; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
    }
  } else {
    for (let i = 0; i < length; ++i) {
      const code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }

  return strBuf.join("");
}

function escapeString(str) {
  return str.replace(/([()\\\n\r])/g, match => {
    if (match === "\n") {
      return "\\n";
    } else if (match === "\r") {
      return "\\r";
    }

    return `\\${match}`;
  });
}

function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}

function stringToUTF16BEString(str) {
  const buf = ["\xFE\xFF"];

  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));
  }

  return buf.join("");
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}

function isBool(v) {
  return typeof v === "boolean";
}

function isNum(v) {
  return typeof v === "number";
}

function isString(v) {
  return typeof v === "string";
}

function isArrayBuffer(v) {
  return typeof v === "object" && v !== null && v.byteLength !== undefined;
}

function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0, ii = arr1.length; i < ii; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}

function getModificationDate(date = new Date()) {
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}

function createPromiseCapability() {
  const capability = Object.create(null);
  let isSettled = false;
  Object.defineProperty(capability, "settled", {
    get() {
      return isSettled;
    }

  });
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = function (data) {
      isSettled = true;
      resolve(data);
    };

    capability.reject = function (reason) {
      isSettled = true;
      reject(reason);
    };
  });
  return capability;
}

function createObjectURL(data, contentType = "", forceDataSchema = false) {
  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
    return URL.createObjectURL(new Blob([data], {
      type: contentType
    }));
  }

  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let buffer = `data:${contentType};base64,`;

  for (let i = 0, ii = data.length; i < ii; i += 3) {
    const b1 = data[i] & 0xff;
    const b2 = data[i + 1] & 0xff;
    const b3 = data[i + 2] & 0xff;
    const d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
    const d4 = i + 2 < ii ? b3 & 0x3f : 64;
    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
  }

  return buffer;
}

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {



var _is_node = __w_pdfjs_require__(4);

;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNodeJS = void 0;
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;

var _util = __w_pdfjs_require__(2);

class BaseCanvasFactory {
  constructor() {
    if (this.constructor === BaseCanvasFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
    }
  }

  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    const canvas = this._createCanvas(width, height);

    return {
      canvas,
      context: canvas.getContext("2d")
    };
  }

  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }

  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }

  _createCanvas(width, height) {
    (0, _util.unreachable)("Abstract method `_createCanvas` called.");
  }

}

exports.BaseCanvasFactory = BaseCanvasFactory;

class BaseCMapReaderFactory {
  constructor({
    baseUrl = null,
    isCompressed = false
  }) {
    if (this.constructor === BaseCMapReaderFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
    }

    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }

  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
    }

    if (!name) {
      throw new Error("CMap name must be specified.");
    }

    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
    return this._fetchData(url, compressionType).catch(reason => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }

  _fetchData(url, compressionType) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }

}

exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

class BaseStandardFontDataFactory {
  constructor({
    baseUrl = null
  }) {
    if (this.constructor === BaseStandardFontDataFactory) {
      (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
    }

    this.baseUrl = baseUrl;
  }

  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
    }

    if (!filename) {
      throw new Error("Font filename must be specified.");
    }

    const url = `${this.baseUrl}${filename}`;
    return this._fetchData(url).catch(reason => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }

  _fetchData(url) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }

}

exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;

class BaseSVGFactory {
  constructor() {
    if (this.constructor === BaseSVGFactory) {
      (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
    }
  }

  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }

    const svg = this._createSVG("svg:svg");

    svg.setAttribute("version", "1.1");
    svg.setAttribute("width", `${width}px`);
    svg.setAttribute("height", `${height}px`);
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }

  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }

    return this._createSVG(type);
  }

  _createSVG(type) {
    (0, _util.unreachable)("Abstract method `_createSVG` called.");
  }

}

exports.BaseSVGFactory = BaseSVGFactory;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.build = exports.RenderTask = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
exports.getDocument = getDocument;
exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
exports.version = void 0;

var _util = __w_pdfjs_require__(2);

var _display_utils = __w_pdfjs_require__(1);

var _font_loader = __w_pdfjs_require__(7);

var _node_utils = __w_pdfjs_require__(8);

var _annotation_storage = __w_pdfjs_require__(9);

var _canvas = __w_pdfjs_require__(10);

var _worker_options = __w_pdfjs_require__(12);

var _is_node = __w_pdfjs_require__(4);

var _message_handler = __w_pdfjs_require__(13);

var _metadata = __w_pdfjs_require__(14);

var _optional_content_config = __w_pdfjs_require__(15);

var _transport_stream = __w_pdfjs_require__(16);

var _xfa_text = __w_pdfjs_require__(17);

const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
exports.DefaultCanvasFactory = DefaultCanvasFactory;
const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
const DefaultStandardFontDataFactory = _is_node.isNodeJS ? _node_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
let createPDFNetworkStream;

function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
  createPDFNetworkStream = pdfNetworkStreamFactory;
}

function getDocument(src) {
  const task = new PDFDocumentLoadingTask();
  let source;

  if (typeof src === "string" || src instanceof URL) {
    source = {
      url: src
    };
  } else if ((0, _util.isArrayBuffer)(src)) {
    source = {
      data: src
    };
  } else if (src instanceof PDFDataRangeTransport) {
    source = {
      range: src
    };
  } else {
    if (typeof src !== "object") {
      throw new Error("Invalid parameter in getDocument, " + "need either string, URL, Uint8Array, or parameter object.");
    }

    if (!src.url && !src.data && !src.range) {
      throw new Error("Invalid parameter object: need either .data, .range or .url");
    }

    source = src;
  }

  const params = Object.create(null);
  let rangeTransport = null,
      worker = null;

  for (const key in source) {
    const value = source[key];

    switch (key) {
      case "url":
        if (typeof window !== "undefined") {
          try {
            params[key] = new URL(value, window.location).href;
            continue;
          } catch (ex) {
            (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
          }
        } else if (typeof value === "string" || value instanceof URL) {
          params[key] = value.toString();
          continue;
        }

        throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");

      case "range":
        rangeTransport = value;
        continue;

      case "worker":
        worker = value;
        continue;

      case "data":
        if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
          params[key] = new Uint8Array(value);
        } else if (value instanceof Uint8Array) {
          break;
        } else if (typeof value === "string") {
          params[key] = (0, _util.stringToBytes)(value);
        } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
          params[key] = new Uint8Array(value);
        } else if ((0, _util.isArrayBuffer)(value)) {
          params[key] = new Uint8Array(value);
        } else {
          throw new Error("Invalid PDF binary data: either typed array, " + "string, or array-like object is expected in the data property.");
        }

        continue;
    }

    params[key] = value;
  }

  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
  params.ignoreErrors = params.stopAtErrors !== true;
  params.fontExtraProperties = params.fontExtraProperties === true;
  params.pdfBug = params.pdfBug === true;
  params.enableXfa = params.enableXfa === true;

  if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
    params.docBaseUrl = null;
  }

  if (!Number.isInteger(params.maxImageSize)) {
    params.maxImageSize = -1;
  }

  if (typeof params.useWorkerFetch !== "boolean") {
    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
  }

  if (typeof params.isEvalSupported !== "boolean") {
    params.isEvalSupported = true;
  }

  if (typeof params.disableFontFace !== "boolean") {
    params.disableFontFace = _is_node.isNodeJS;
  }

  if (typeof params.useSystemFonts !== "boolean") {
    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
  }

  if (typeof params.ownerDocument === "undefined") {
    params.ownerDocument = globalThis.document;
  }

  if (typeof params.disableRange !== "boolean") {
    params.disableRange = false;
  }

  if (typeof params.disableStream !== "boolean") {
    params.disableStream = false;
  }

  if (typeof params.disableAutoFetch !== "boolean") {
    params.disableAutoFetch = false;
  }

  (0, _util.setVerbosityLevel)(params.verbosity);

  if (!worker) {
    const workerParams = {
      verbosity: params.verbosity,
      port: _worker_options.GlobalWorkerOptions.workerPort
    };
    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
    task._worker = worker;
  }

  const docId = task.docId;
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }

    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

    const networkStreamPromise = new Promise(function (resolve) {
      let networkStream;

      if (rangeTransport) {
        networkStream = new _transport_stream.PDFDataTransportStream({
          length: params.length,
          initialData: params.initialData,
          progressiveDone: params.progressiveDone,
          contentDispositionFilename: params.contentDispositionFilename,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        }, rangeTransport);
      } else if (!params.data) {
        networkStream = createPDFNetworkStream({
          url: params.url,
          length: params.length,
          httpHeaders: params.httpHeaders,
          withCredentials: params.withCredentials,
          rangeChunkSize: params.rangeChunkSize,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        });
      }

      resolve(networkStream);
    });
    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }

      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, params);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}

async function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }

  if (pdfDataRangeTransport) {
    source.length = pdfDataRangeTransport.length;
    source.initialData = pdfDataRangeTransport.initialData;
    source.progressiveDone = pdfDataRangeTransport.progressiveDone;
    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
  }

  const workerId = await worker.messageHandler.sendWithPromise("GetDocRequest", {
    docId,
    apiVersion: '2.12.313',
    source: {
      data: source.data,
      url: source.url,
      password: source.password,
      disableAutoFetch: source.disableAutoFetch,
      rangeChunkSize: source.rangeChunkSize,
      length: source.length
    },
    maxImageSize: source.maxImageSize,
    disableFontFace: source.disableFontFace,
    docBaseUrl: source.docBaseUrl,
    ignoreErrors: source.ignoreErrors,
    isEvalSupported: source.isEvalSupported,
    fontExtraProperties: source.fontExtraProperties,
    enableXfa: source.enableXfa,
    useSystemFonts: source.useSystemFonts,
    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
  });

  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }

  return workerId;
}

class PDFDocumentLoadingTask {
  static get idCounters() {
    return (0, _util.shadow)(this, "idCounters", {
      doc: 0
    });
  }

  constructor() {
    this._capability = (0, _util.createPromiseCapability)();
    this._transport = null;
    this._worker = null;
    this.docId = `d${PDFDocumentLoadingTask.idCounters.doc++}`;
    this.destroyed = false;
    this.onPassword = null;
    this.onProgress = null;
    this.onUnsupportedFeature = null;
  }

  get promise() {
    return this._capability.promise;
  }

  async destroy() {
    this.destroyed = true;
    await this._transport?.destroy();
    this._transport = null;

    if (this._worker) {
      this._worker.destroy();

      this._worker = null;
    }
  }

}

exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;

class PDFDataRangeTransport {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this._readyCapability = (0, _util.createPromiseCapability)();
  }

  addRangeListener(listener) {
    this._rangeListeners.push(listener);
  }

  addProgressListener(listener) {
    this._progressListeners.push(listener);
  }

  addProgressiveReadListener(listener) {
    this._progressiveReadListeners.push(listener);
  }

  addProgressiveDoneListener(listener) {
    this._progressiveDoneListeners.push(listener);
  }

  onDataRange(begin, chunk) {
    for (const listener of this._rangeListeners) {
      listener(begin, chunk);
    }
  }

  onDataProgress(loaded, total) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressListeners) {
        listener(loaded, total);
      }
    });
  }

  onDataProgressiveRead(chunk) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveReadListeners) {
        listener(chunk);
      }
    });
  }

  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveDoneListeners) {
        listener();
      }
    });
  }

  transportReady() {
    this._readyCapability.resolve();
  }

  requestDataRange(begin, end) {
    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
  }

  abort() {}

}

exports.PDFDataRangeTransport = PDFDataRangeTransport;

class PDFDocumentProxy {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
    Object.defineProperty(this, "fingerprint", {
      get() {
        (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, " + "please use `PDFDocumentProxy.fingerprints` instead.");
        return this.fingerprints[0];
      }

    });
    Object.defineProperty(this, "getStats", {
      value: async () => {
        (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, " + "please use the `PDFDocumentProxy.stats`-getter instead.");
        return this.stats || {
          streamTypes: {},
          fontTypes: {}
        };
      }
    });
  }

  get annotationStorage() {
    return this._transport.annotationStorage;
  }

  get numPages() {
    return this._pdfInfo.numPages;
  }

  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }

  get stats() {
    return this._transport.stats;
  }

  get isPureXfa() {
    return !!this._transport._htmlForXfa;
  }

  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }

  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }

  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }

  getDestinations() {
    return this._transport.getDestinations();
  }

  getDestination(id) {
    return this._transport.getDestination(id);
  }

  getPageLabels() {
    return this._transport.getPageLabels();
  }

  getPageLayout() {
    return this._transport.getPageLayout();
  }

  getPageMode() {
    return this._transport.getPageMode();
  }

  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }

  getOpenAction() {
    return this._transport.getOpenAction();
  }

  getAttachments() {
    return this._transport.getAttachments();
  }

  getJavaScript() {
    return this._transport.getJavaScript();
  }

  getJSActions() {
    return this._transport.getDocJSActions();
  }

  getOutline() {
    return this._transport.getOutline();
  }

  getOptionalContentConfig() {
    return this._transport.getOptionalContentConfig();
  }

  getPermissions() {
    return this._transport.getPermissions();
  }

  getMetadata() {
    return this._transport.getMetadata();
  }

  getMarkInfo() {
    return this._transport.getMarkInfo();
  }

  getData() {
    return this._transport.getData();
  }

  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }

  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }

  destroy() {
    return this.loadingTask.destroy();
  }

  get loadingParams() {
    return this._transport.loadingParams;
  }

  get loadingTask() {
    return this._transport.loadingTask;
  }

  saveDocument() {
    if (this._transport.annotationStorage.size <= 0) {
      (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
    }

    return this._transport.saveDocument();
  }

  getFieldObjects() {
    return this._transport.getFieldObjects();
  }

  hasJSActions() {
    return this._transport.hasJSActions();
  }

  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }

}

exports.PDFDocumentProxy = PDFDocumentProxy;

class PDFPageProxy {
  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._ownerDocument = ownerDocument;
    this._transport = transport;
    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this.cleanupAfterRender = false;
    this.pendingCleanup = false;
    this._intentStates = new Map();
    this._annotationPromises = new Map();
    this.destroyed = false;
  }

  get pageNumber() {
    return this._pageIndex + 1;
  }

  get rotate() {
    return this._pageInfo.rotate;
  }

  get ref() {
    return this._pageInfo.ref;
  }

  get userUnit() {
    return this._pageInfo.userUnit;
  }

  get view() {
    return this._pageInfo.view;
  }

  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new _display_utils.PageViewport({
      viewBox: this.view,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  getAnnotations({
    intent = "display"
  } = {}) {
    const intentArgs = this._transport.getRenderingIntent(intent);

    let promise = this._annotationPromises.get(intentArgs.cacheKey);

    if (!promise) {
      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);

      this._annotationPromises.set(intentArgs.cacheKey, promise);

      promise = promise.then(annotations => {
        for (const annotation of annotations) {
          if (annotation.titleObj !== undefined) {
            Object.defineProperty(annotation, "title", {
              get() {
                (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                return annotation.titleObj.str;
              }

            });
          }

          if (annotation.contentsObj !== undefined) {
            Object.defineProperty(annotation, "contents", {
              get() {
                (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                return annotation.contentsObj.str;
              }

            });
          }
        }

        return annotations;
      });
    }

    return promise;
  }

  getJSActions() {
    return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);
  }

  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }

  render({
    canvasContext,
    viewport,
    intent = "display",
    annotationMode = _util.AnnotationMode.ENABLE,
    transform = null,
    imageLayer = null,
    canvasFactory = null,
    background = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null
  }) {
    if (arguments[0]?.renderInteractiveForms !== undefined) {
      (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, " + "please use the `annotationMode`-option instead.");

      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
        annotationMode = _util.AnnotationMode.ENABLE_FORMS;
      }
    }

    if (arguments[0]?.includeAnnotationStorage !== undefined) {
      (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, " + "please use the `annotationMode`-option instead.");

      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
      }
    }

    if (this._stats) {
      this._stats.time("Overall");
    }

    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode);

    this.pendingCleanup = false;

    if (!optionalContentConfigPromise) {
      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
    }

    let intentState = this._intentStates.get(intentArgs.cacheKey);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(intentArgs.cacheKey, intentState);
    }

    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }

    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
      ownerDocument: this._ownerDocument
    });
    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);

    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList(intentArgs);
    }

    const complete = error => {
      intentState.renderTasks.delete(internalRenderTask);

      if (this.cleanupAfterRender || intentPrint) {
        this.pendingCleanup = true;
      }

      this._tryCleanup();

      if (error) {
        internalRenderTask.capability.reject(error);

        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }

      if (this._stats) {
        this._stats.timeEnd("Rendering");

        this._stats.timeEnd("Overall");
      }
    };

    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvasContext,
        viewport,
        transform,
        imageLayer,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: canvasFactoryInstance,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug
    });
    (intentState.renderTasks ||= new Set()).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      if (this.pendingCleanup) {
        complete();
        return;
      }

      if (this._stats) {
        this._stats.time("Rendering");
      }

      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }

  getOperatorList({
    intent = "display",
    annotationMode = _util.AnnotationMode.ENABLE
  } = {}) {
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }

    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);

    let intentState = this._intentStates.get(intentArgs.cacheKey);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(intentArgs.cacheKey, intentState);
    }

    let opListTask;

    if (!intentState.opListReadCapability) {
      opListTask = Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
      (intentState.renderTasks ||= new Set()).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList(intentArgs);
    }

    return intentState.opListReadCapability.promise;
  }

  streamTextContent({
    normalizeWhitespace = false,
    disableCombineTextItems = false,
    includeMarkedContent = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      normalizeWhitespace: normalizeWhitespace === true,
      combineTextItems: disableCombineTextItems !== true,
      includeMarkedContent: includeMarkedContent === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,

      size(textContent) {
        return textContent.items.length;
      }

    });
  }

  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then(xfa => {
        return _xfa_text.XfaText.textContent(xfa);
      });
    }

    const readableStream = this.streamTextContent(params);
    return new Promise(function (resolve, reject) {
      function pump() {
        reader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            resolve(textContent);
            return;
          }

          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }

      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: Object.create(null)
      };
      pump();
    });
  }

  getStructTree() {
    return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);
  }

  _destroy() {
    this.destroyed = true;
    const waitOn = [];

    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });

      if (intentState.opListReadCapability) {
        continue;
      }

      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }

    this.objs.clear();

    this._annotationPromises.clear();

    this._jsActionsPromise = null;
    this._structTreePromise = null;
    this.pendingCleanup = false;
    return Promise.all(waitOn);
  }

  cleanup(resetStats = false) {
    this.pendingCleanup = true;
    return this._tryCleanup(resetStats);
  }

  _tryCleanup(resetStats = false) {
    if (!this.pendingCleanup) {
      return false;
    }

    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }

    this._intentStates.clear();

    this.objs.clear();

    this._annotationPromises.clear();

    this._jsActionsPromise = null;
    this._structTreePromise = null;

    if (resetStats && this._stats) {
      this._stats = new _display_utils.StatTimer();
    }

    this.pendingCleanup = false;
    return true;
  }

  _startRenderPage(transparency, cacheKey) {
    const intentState = this._intentStates.get(cacheKey);

    if (!intentState) {
      return;
    }

    if (this._stats) {
      this._stats.timeEnd("Page Request");
    }

    if (intentState.displayReadyCapability) {
      intentState.displayReadyCapability.resolve(transparency);
    }
  }

  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }

    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }

    if (operatorListChunk.lastChunk) {
      this._tryCleanup();
    }
  }

  _pumpOperatorList({
    renderingIntent,
    cacheKey
  }) {
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null
    });

    const reader = readableStream.getReader();

    const intentState = this._intentStates.get(cacheKey);

    intentState.streamReader = reader;

    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }

        if (this._transport.destroyed) {
          return;
        }

        this._renderPageChunk(value, intentState);

        pump();
      }, reason => {
        intentState.streamReader = null;

        if (this._transport.destroyed) {
          return;
        }

        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;

          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }

          this._tryCleanup();
        }

        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };

    pump();
  }

  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }

    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }

      if (reason instanceof _display_utils.RenderingCancelledException) {
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });

          intentState.streamReaderCancelTimeout = null;
        }, RENDERING_CANCELLED_TIMEOUT);
        return;
      }
    }

    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});
    intentState.streamReader = null;

    if (this._transport.destroyed) {
      return;
    }

    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);

        break;
      }
    }

    this.cleanup();
  }

  get stats() {
    return this._stats;
  }

}

exports.PDFPageProxy = PDFPageProxy;

class LoopbackPort {
  constructor() {
    this._listeners = [];
    this._deferred = Promise.resolve();
  }

  postMessage(obj, transfers) {
    function cloneValue(object) {
      if (globalThis.structuredClone) {
        return globalThis.structuredClone(object, transfers);
      }

      function fallbackCloneValue(value) {
        if (typeof value === "function" || typeof value === "symbol" || value instanceof URL) {
          throw new Error(`LoopbackPort.postMessage - cannot clone: ${value?.toString()}`);
        }

        if (typeof value !== "object" || value === null) {
          return value;
        }

        if (cloned.has(value)) {
          return cloned.get(value);
        }

        let buffer, result;

        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
          if (transfers?.includes(buffer)) {
            result = new value.constructor(buffer, value.byteOffset, value.byteLength);
          } else {
            result = new value.constructor(value);
          }

          cloned.set(value, result);
          return result;
        }

        if (value instanceof Map) {
          result = new Map();
          cloned.set(value, result);

          for (const [key, val] of value) {
            result.set(key, fallbackCloneValue(val));
          }

          return result;
        }

        if (value instanceof Set) {
          result = new Set();
          cloned.set(value, result);

          for (const val of value) {
            result.add(fallbackCloneValue(val));
          }

          return result;
        }

        result = Array.isArray(value) ? [] : Object.create(null);
        cloned.set(value, result);

        for (const i in value) {
          let desc,
              p = value;

          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
            p = Object.getPrototypeOf(p);
          }

          if (typeof desc.value === "undefined") {
            continue;
          }

          if (typeof desc.value === "function" && !value.hasOwnProperty?.(i)) {
            continue;
          }

          result[i] = fallbackCloneValue(desc.value);
        }

        return result;
      }

      const cloned = new WeakMap();
      return fallbackCloneValue(object);
    }

    const event = {
      data: cloneValue(obj)
    };

    this._deferred.then(() => {
      for (const listener of this._listeners) {
        listener.call(this, event);
      }
    });
  }

  addEventListener(name, listener) {
    this._listeners.push(listener);
  }

  removeEventListener(name, listener) {
    const i = this._listeners.indexOf(listener);

    this._listeners.splice(i, 1);
  }

  terminate() {
    this._listeners.length = 0;
  }

}

exports.LoopbackPort = LoopbackPort;
const PDFWorkerUtil = {
  isWorkerDisabled: false,
  fallbackWorkerSrc: null,
  fakeWorkerId: 0
};
{
  if (_is_node.isNodeJS && "function" === "function") {
    PDFWorkerUtil.isWorkerDisabled = true;
    PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
  } else if (typeof document === "object") {
    const pdfjsFilePath = document?.currentScript?.src;

    if (pdfjsFilePath) {
      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
    }
  }

  PDFWorkerUtil.createCDNWrapper = function (url) {
    const wrapper = `importScripts("${url}");`;
    return URL.createObjectURL(new Blob([wrapper]));
  };
}

class PDFWorker {
  static get _workerPorts() {
    return (0, _util.shadow)(this, "_workerPorts", new WeakMap());
  }

  constructor({
    name = null,
    port = null,
    verbosity = (0, _util.getVerbosityLevel)()
  } = {}) {
    if (port && PDFWorker._workerPorts.has(port)) {
      throw new Error("Cannot use more than one PDFWorker per port.");
    }

    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity;
    this._readyCapability = (0, _util.createPromiseCapability)();
    this._port = null;
    this._webWorker = null;
    this._messageHandler = null;

    if (port) {
      PDFWorker._workerPorts.set(port, this);

      this._initializeFromPort(port);

      return;
    }

    this._initialize();
  }

  get promise() {
    return this._readyCapability.promise;
  }

  get port() {
    return this._port;
  }

  get messageHandler() {
    return this._messageHandler;
  }

  _initializeFromPort(port) {
    this._port = port;
    this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

    this._messageHandler.on("ready", function () {});

    this._readyCapability.resolve();
  }

  _initialize() {
    if (typeof Worker !== "undefined" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
      let workerSrc = PDFWorker.workerSrc;

      try {
        if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
        }

        const worker = new Worker(workerSrc);
        const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

        const terminateEarly = () => {
          worker.removeEventListener("error", onWorkerError);
          messageHandler.destroy();
          worker.terminate();

          if (this.destroyed) {
            this._readyCapability.reject(new Error("Worker was destroyed"));
          } else {
            this._setupFakeWorker();
          }
        };

        const onWorkerError = () => {
          if (!this._webWorker) {
            terminateEarly();
          }
        };

        worker.addEventListener("error", onWorkerError);
        messageHandler.on("test", data => {
          worker.removeEventListener("error", onWorkerError);

          if (this.destroyed) {
            terminateEarly();
            return;
          }

          if (data) {
            this._messageHandler = messageHandler;
            this._port = worker;
            this._webWorker = worker;

            this._readyCapability.resolve();

            messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          } else {
            this._setupFakeWorker();

            messageHandler.destroy();
            worker.terminate();
          }
        });
        messageHandler.on("ready", data => {
          worker.removeEventListener("error", onWorkerError);

          if (this.destroyed) {
            terminateEarly();
            return;
          }

          try {
            sendTest();
          } catch (e) {
            this._setupFakeWorker();
          }
        });

        const sendTest = () => {
          const testObj = new Uint8Array([255]);

          try {
            messageHandler.send("test", testObj, [testObj.buffer]);
          } catch (ex) {
            (0, _util.warn)("Cannot use postMessage transfers.");
            testObj[0] = 0;
            messageHandler.send("test", testObj);
          }
        };

        sendTest();
        return;
      } catch (e) {
        (0, _util.info)("The worker has been disabled.");
      }
    }

    this._setupFakeWorker();
  }

  _setupFakeWorker() {
    if (!PDFWorkerUtil.isWorkerDisabled) {
      (0, _util.warn)("Setting up fake worker.");
      PDFWorkerUtil.isWorkerDisabled = true;
    }

    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));

        return;
      }

      const port = new LoopbackPort();
      this._port = port;
      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
      const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
      WorkerMessageHandler.setup(workerHandler, port);
      const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
      this._messageHandler = messageHandler;

      this._readyCapability.resolve();

      messageHandler.send("configure", {
        verbosity: this.verbosity
      });
    }).catch(reason => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  }

  destroy() {
    this.destroyed = true;

    if (this._webWorker) {
      this._webWorker.terminate();

      this._webWorker = null;
    }

    PDFWorker._workerPorts.delete(this._port);

    this._port = null;

    if (this._messageHandler) {
      this._messageHandler.destroy();

      this._messageHandler = null;
    }
  }

  static fromPort(params) {
    if (!params?.port) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }

    if (this._workerPorts.has(params.port)) {
      return this._workerPorts.get(params.port);
    }

    return new PDFWorker(params);
  }

  static get workerSrc() {
    if (_worker_options.GlobalWorkerOptions.workerSrc) {
      return _worker_options.GlobalWorkerOptions.workerSrc;
    }

    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
      if (!_is_node.isNodeJS) {
        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
      }

      return PDFWorkerUtil.fallbackWorkerSrc;
    }

    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }

  static get _mainThreadWorkerMessageHandler() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch (ex) {
      return null;
    }
  }

  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;

      if (mainWorkerMessageHandler) {
        return mainWorkerMessageHandler;
      }

      if (_is_node.isNodeJS && "function" === "function") {
        const worker = eval("require")(this.workerSrc);
        return worker.WorkerMessageHandler;
      }

      await (0, _display_utils.loadScript)(this.workerSrc);
      return window.pdfjsWorker.WorkerMessageHandler;
    };

    return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
  }

}

exports.PDFWorker = PDFWorker;
{
  PDFWorker.getWorkerSrc = function () {
    (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
    return this.workerSrc;
  };
}

class WorkerTransport {
  #docStats = null;
  #pageCache = new Map();
  #pagePromises = new Map();
  #metadataPromise = null;

  constructor(messageHandler, loadingTask, networkStream, params) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new _font_loader.FontLoader({
      docId: loadingTask.docId,
      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this._params = params;

    if (!params.useWorkerFetch) {
      this.CMapReaderFactory = new params.CMapReaderFactory({
        baseUrl: params.cMapUrl,
        isCompressed: params.cMapPacked
      });
      this.StandardFontDataFactory = new params.StandardFontDataFactory({
        baseUrl: params.standardFontDataUrl
      });
    }

    this.destroyed = false;
    this.destroyCapability = null;
    this._passwordCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
    this.setupMessageHandler();
  }

  get annotationStorage() {
    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
  }

  get stats() {
    return this.#docStats;
  }

  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, isOpList = false) {
    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
    let lastModified = "";

    switch (intent) {
      case "any":
        renderingIntent = _util.RenderingIntentFlag.ANY;
        break;

      case "display":
        break;

      case "print":
        renderingIntent = _util.RenderingIntentFlag.PRINT;
        break;

      default:
        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
    }

    switch (annotationMode) {
      case _util.AnnotationMode.DISABLE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;

      case _util.AnnotationMode.ENABLE:
        break;

      case _util.AnnotationMode.ENABLE_FORMS:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;

      case _util.AnnotationMode.ENABLE_STORAGE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
        lastModified = this.annotationStorage.lastModified;
        break;

      default:
        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }

    if (isOpList) {
      renderingIntent += _util.RenderingIntentFlag.OPLIST;
    }

    return {
      renderingIntent,
      cacheKey: `${renderingIntent}_${lastModified}`
    };
  }

  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }

    this.destroyed = true;
    this.destroyCapability = (0, _util.createPromiseCapability)();

    if (this._passwordCapability) {
      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
    }

    const waitOn = [];

    for (const page of this.#pageCache.values()) {
      waitOn.push(page._destroy());
    }

    this.#pageCache.clear();
    this.#pagePromises.clear();

    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }

    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();
      this.#metadataPromise = null;
      this._getFieldObjectsPromise = null;
      this._hasJSActionsPromise = null;

      if (this._networkStream) {
        this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
      }

      if (this.messageHandler) {
        this.messageHandler.destroy();
        this.messageHandler = null;
      }

      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }

  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();

      this._fullReader.onProgress = evt => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };

      sink.onPull = () => {
        this._fullReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        this._fullReader.cancel(reason);

        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", data => {
      const headersCapability = (0, _util.createPromiseCapability)();
      const fullReader = this._fullReader;
      fullReader.headersReady.then(() => {
        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
          if (this._lastProgress) {
            loadingTask.onProgress?.(this._lastProgress);
          }

          fullReader.onProgress = evt => {
            loadingTask.onProgress?.({
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }

        headersCapability.resolve({
          isStreamingSupported: fullReader.isStreamingSupported,
          isRangeSupported: fullReader.isRangeSupported,
          contentLength: fullReader.contentLength
        });
      }, headersCapability.reject);
      return headersCapability.promise;
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

      if (!rangeReader) {
        sink.close();
        return;
      }

      sink.onPull = () => {
        rangeReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        rangeReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;

      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", function (ex) {
      let reason;

      switch (ex.name) {
        case "PasswordException":
          reason = new _util.PasswordException(ex.message, ex.code);
          break;

        case "InvalidPDFException":
          reason = new _util.InvalidPDFException(ex.message);
          break;

        case "MissingPDFException":
          reason = new _util.MissingPDFException(ex.message);
          break;

        case "UnexpectedResponseException":
          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
          break;

        case "UnknownErrorException":
          reason = new _util.UnknownErrorException(ex.message, ex.details);
          break;

        default:
          (0, _util.unreachable)("DocException - expected a valid Error.");
      }

      loadingTask._capability.reject(reason);
    });
    messageHandler.on("PasswordRequest", exception => {
      this._passwordCapability = (0, _util.createPromiseCapability)();

      if (loadingTask.onPassword) {
        const updatePassword = password => {
          this._passwordCapability.resolve({
            password
          });
        };

        try {
          loadingTask.onPassword(updatePassword, exception.code);
        } catch (ex) {
          this._passwordCapability.reject(ex);
        }
      } else {
        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
      }

      return this._passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", data => {
      loadingTask.onProgress?.({
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", data => {
      if (this.destroyed) {
        return;
      }

      const page = this.#pageCache.get(data.pageIndex);

      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", ([id, type, exportedData]) => {
      if (this.destroyed) {
        return;
      }

      if (this.commonObjs.has(id)) {
        return;
      }

      switch (type) {
        case "Font":
          const params = this._params;

          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            (0, _util.warn)(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }

          let fontRegistry = null;

          if (params.pdfBug && globalThis.FontInspector?.enabled) {
            fontRegistry = {
              registerFont(font, url) {
                globalThis.FontInspector.fontAdded(font, url);
              }

            };
          }

          const font = new _font_loader.FontFaceObject(exportedData, {
            isEvalSupported: params.isEvalSupported,
            disableFontFace: params.disableFontFace,
            ignoreErrors: params.ignoreErrors,
            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
            fontRegistry
          });
          this.fontLoader.bind(font).catch(reason => {
            return messageHandler.sendWithPromise("FontFallback", {
              id
            });
          }).finally(() => {
            if (!params.fontExtraProperties && font.data) {
              font.data = null;
            }

            this.commonObjs.resolve(id, font);
          });
          break;

        case "FontPath":
        case "Image":
          this.commonObjs.resolve(id, exportedData);
          break;

        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
    });
    messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
      if (this.destroyed) {
        return;
      }

      const pageProxy = this.#pageCache.get(pageIndex);

      if (pageProxy.objs.has(id)) {
        return;
      }

      switch (type) {
        case "Image":
          pageProxy.objs.resolve(id, imageData);
          const MAX_IMAGE_SIZE_TO_STORE = 8000000;

          if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {
            pageProxy.cleanupAfterRender = true;
          }

          break;

        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;

        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", data => {
      if (this.destroyed) {
        return;
      }

      loadingTask.onProgress?.({
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("DocStats", data => {
      if (this.destroyed) {
        return;
      }

      this.#docStats = Object.freeze({
        streamTypes: Object.freeze(data.streamTypes),
        fontTypes: Object.freeze(data.fontTypes)
      });
    });
    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
    messageHandler.on("FetchBuiltInCMap", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }

      if (!this.CMapReaderFactory) {
        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
      }

      return this.CMapReaderFactory.fetch(data);
    });
    messageHandler.on("FetchStandardFontData", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }

      if (!this.StandardFontDataFactory) {
        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
      }

      return this.StandardFontDataFactory.fetch(data);
    });
  }

  _onUnsupportedFeature({
    featureId
  }) {
    if (this.destroyed) {
      return;
    }

    this.loadingTask.onUnsupportedFeature?.(featureId);
  }

  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }

  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request"));
    }

    const pageIndex = pageNumber - 1,
          cachedPromise = this.#pagePromises.get(pageIndex);

    if (cachedPromise) {
      return cachedPromise;
    }

    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then(pageInfo => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }

      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
      this.#pageCache.set(pageIndex, page);
      return page;
    });
    this.#pagePromises.set(pageIndex, promise);
    return promise;
  }

  getPageIndex(ref) {
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      ref
    });
  }

  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }

  saveDocument() {
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: this.annotationStorage.serializable,
      filename: this._fullReader?.filename ?? null
    }).finally(() => {
      this.annotationStorage.resetModified();
    });
  }

  getFieldObjects() {
    return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise("GetFieldObjects", null);
  }

  hasJSActions() {
    return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise("HasJSActions", null);
  }

  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }

  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }

  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }

    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }

  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }

  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }

  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }

  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }

  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }

  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }

  getJavaScript() {
    return this.messageHandler.sendWithPromise("GetJavaScript", null);
  }

  getDocJSActions() {
    return this.messageHandler.sendWithPromise("GetDocJSActions", null);
  }

  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }

  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }

  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }

  getOptionalContentConfig() {
    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
      return new _optional_content_config.OptionalContentConfig(results);
    });
  }

  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }

  getMetadata() {
    return this.#metadataPromise ||= this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
      return {
        info: results[0],
        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
        contentDispositionFilename: this._fullReader?.filename ?? null,
        contentLength: this._fullReader?.contentLength ?? null
      };
    });
  }

  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }

  async startCleanup(keepLoadedFonts = false) {
    await this.messageHandler.sendWithPromise("Cleanup", null);

    if (this.destroyed) {
      return;
    }

    for (const page of this.#pageCache.values()) {
      const cleanupSuccessful = page.cleanup();

      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }

    this.commonObjs.clear();

    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }

    this.#metadataPromise = null;
    this._getFieldObjectsPromise = null;
    this._hasJSActionsPromise = null;
  }

  get loadingParams() {
    const params = this._params;
    return (0, _util.shadow)(this, "loadingParams", {
      disableAutoFetch: params.disableAutoFetch,
      enableXfa: params.enableXfa
    });
  }

}

class PDFObjects {
  constructor() {
    this._objs = Object.create(null);
  }

  _ensureObj(objId) {
    if (this._objs[objId]) {
      return this._objs[objId];
    }

    return this._objs[objId] = {
      capability: (0, _util.createPromiseCapability)(),
      data: null,
      resolved: false
    };
  }

  get(objId, callback = null) {
    if (callback) {
      this._ensureObj(objId).capability.promise.then(callback);

      return null;
    }

    const obj = this._objs[objId];

    if (!obj || !obj.resolved) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }

    return obj.data;
  }

  has(objId) {
    const obj = this._objs[objId];
    return obj?.resolved || false;
  }

  resolve(objId, data) {
    const obj = this._ensureObj(objId);

    obj.resolved = true;
    obj.data = data;
    obj.capability.resolve(data);
  }

  clear() {
    this._objs = Object.create(null);
  }

}

class RenderTask {
  constructor(internalRenderTask) {
    this._internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }

  get promise() {
    return this._internalRenderTask.capability.promise;
  }

  cancel() {
    this._internalRenderTask.cancel();
  }

}

exports.RenderTask = RenderTask;

class InternalRenderTask {
  static get canvasInUse() {
    return (0, _util.shadow)(this, "canvasInUse", new WeakSet());
  }

  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    useRequestAnimationFrame = false,
    pdfBug = false
  }) {
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this._pdfBug = pdfBug;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = (0, _util.createPromiseCapability)();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvasContext.canvas;
  }

  get completed() {
    return this.capability.promise.catch(function () {});
  }

  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    if (this.cancelled) {
      return;
    }

    if (this._canvas) {
      if (InternalRenderTask.canvasInUse.has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
      }

      InternalRenderTask.canvasInUse.add(this._canvas);
    }

    if (this._pdfBug && globalThis.StepperManager?.enabled) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }

    const {
      canvasContext,
      viewport,
      transform,
      imageLayer,
      background
    } = this.params;
    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;

    if (this.graphicsReadyCallback) {
      this.graphicsReadyCallback();
    }
  }

  cancel(error = null) {
    this.running = false;
    this.cancelled = true;

    if (this.gfx) {
      this.gfx.endDrawing();
    }

    if (this._canvas) {
      InternalRenderTask.canvasInUse.delete(this._canvas);
    }

    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
  }

  operatorListChanged() {
    if (!this.graphicsReady) {
      if (!this.graphicsReadyCallback) {
        this.graphicsReadyCallback = this._continueBound;
      }

      return;
    }

    if (this.stepper) {
      this.stepper.updateOperatorList(this.operatorList);
    }

    if (this.running) {
      return;
    }

    this._continue();
  }

  _continue() {
    this.running = true;

    if (this.cancelled) {
      return;
    }

    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }

  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      window.requestAnimationFrame(() => {
        this._nextBound().catch(this._cancelBound);
      });
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }

  async _next() {
    if (this.cancelled) {
      return;
    }

    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;

      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();

        if (this._canvas) {
          InternalRenderTask.canvasInUse.delete(this._canvas);
        }

        this.callback();
      }
    }
  }

}

const version = '2.12.313';
exports.version = version;
const build = 'a2ae56f39';
exports.build = build;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontLoader = exports.FontFaceObject = void 0;

var _util = __w_pdfjs_require__(2);

class BaseFontLoader {
  constructor({
    docId,
    onUnsupportedFeature,
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    if (this.constructor === BaseFontLoader) {
      (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
    }

    this.docId = docId;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this._document = ownerDocument;
    this.nativeFontFaces = [];
    this.styleElement = null;
  }

  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.push(nativeFontFace);

    this._document.fonts.add(nativeFontFace);
  }

  insertRule(rule) {
    let styleElement = this.styleElement;

    if (!styleElement) {
      styleElement = this.styleElement = this._document.createElement("style");
      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;

      this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
    }

    const styleSheet = styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }

  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }

    this.nativeFontFaces.length = 0;

    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }

  async bind(font) {
    if (font.attached || font.missingFile) {
      return;
    }

    font.attached = true;

    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();

      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);

        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          this._onUnsupportedFeature({
            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
          });

          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }

      return;
    }

    const rule = font.createFontFaceRule();

    if (rule) {
      this.insertRule(rule);

      if (this.isSyncFontLoadingSupported) {
        return;
      }

      await new Promise(resolve => {
        const request = this._queueLoadingCallback(resolve);

        this._prepareFontLoadEvent([rule], [font], request);
      });
    }
  }

  _queueLoadingCallback(callback) {
    (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
  }

  get isFontLoadingAPISupported() {
    const hasFonts = !!this._document?.fonts;
    return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
  }

  get isSyncFontLoadingSupported() {
    (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
  }

  get _loadTestFont() {
    (0, _util.unreachable)("Abstract method `_loadTestFont`.");
  }

  _prepareFontLoadEvent(rules, fontsToLoad, request) {
    (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
  }

}

let FontLoader;
exports.FontLoader = FontLoader;
{
  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
    constructor(params) {
      super(params);
      this.loadingContext = {
        requests: [],
        nextRequestId: 0
      };
      this.loadTestFontId = 0;
    }

    get isSyncFontLoadingSupported() {
      let supported = false;

      if (typeof navigator === "undefined") {
        supported = true;
      } else {
        const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

        if (m?.[1] >= 14) {
          supported = true;
        }
      }

      return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
    }

    _queueLoadingCallback(callback) {
      function completeRequest() {
        (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
        request.done = true;

        while (context.requests.length > 0 && context.requests[0].done) {
          const otherRequest = context.requests.shift();
          setTimeout(otherRequest.callback, 0);
        }
      }

      const context = this.loadingContext;
      const request = {
        id: `pdfjs-font-loading-${context.nextRequestId++}`,
        done: false,
        complete: completeRequest,
        callback
      };
      context.requests.push(request);
      return request;
    }

    get _loadTestFont() {
      const getLoadTestFont = function () {
        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
      };

      return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
    }

    _prepareFontLoadEvent(rules, fonts, request) {
      function int32(data, offset) {
        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
      }

      function spliceString(s, offset, remove, insert) {
        const chunk1 = s.substring(0, offset);
        const chunk2 = s.substring(offset + remove);
        return chunk1 + insert + chunk2;
      }

      let i, ii;

      const canvas = this._document.createElement("canvas");

      canvas.width = 1;
      canvas.height = 1;
      const ctx = canvas.getContext("2d");
      let called = 0;

      function isFontReady(name, callback) {
        called++;

        if (called > 30) {
          (0, _util.warn)("Load test font never loaded.");
          callback();
          return;
        }

        ctx.font = "30px " + name;
        ctx.fillText(".", 0, 20);
        const imageData = ctx.getImageData(0, 0, 1, 1);

        if (imageData.data[3] > 0) {
          callback();
          return;
        }

        setTimeout(isFontReady.bind(null, name, callback));
      }

      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
      let data = this._loadTestFont;
      const COMMENT_OFFSET = 976;
      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
      const CFF_CHECKSUM_OFFSET = 16;
      const XXXX_VALUE = 0x58585858;
      let checksum = int32(data, CFF_CHECKSUM_OFFSET);

      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
      }

      if (i < loadTestFontId.length) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
      }

      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
      const url = `url(data:font/opentype;base64,${btoa(data)});`;
      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
      this.insertRule(rule);
      const names = [];

      for (const font of fonts) {
        names.push(font.loadedName);
      }

      names.push(loadTestFontId);

      const div = this._document.createElement("div");

      div.style.visibility = "hidden";
      div.style.width = div.style.height = "10px";
      div.style.position = "absolute";
      div.style.top = div.style.left = "0px";

      for (const name of names) {
        const span = this._document.createElement("span");

        span.textContent = "Hi";
        span.style.fontFamily = name;
        div.appendChild(span);
      }

      this._document.body.appendChild(div);

      isFontReady(loadTestFontId, () => {
        div.remove();
        request.complete();
      });
    }

  };
}

class FontFaceObject {
  constructor(translatedData, {
    isEvalSupported = true,
    disableFontFace = false,
    ignoreErrors = false,
    onUnsupportedFeature,
    fontRegistry = null
  }) {
    this.compiledGlyphs = Object.create(null);

    for (const i in translatedData) {
      this[i] = translatedData[i];
    }

    this.isEvalSupported = isEvalSupported !== false;
    this.disableFontFace = disableFontFace === true;
    this.ignoreErrors = ignoreErrors === true;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this.fontRegistry = fontRegistry;
  }

  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    let nativeFontFace;

    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };

      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }

      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this);
    }

    return nativeFontFace;
  }

  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    const data = (0, _util.bytesToString)(this.data);
    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
    let rule;

    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;

      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }

      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this, url);
    }

    return rule;
  }

  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== undefined) {
      return this.compiledGlyphs[character];
    }

    let cmds;

    try {
      cmds = objs.get(this.loadedName + "_path_" + character);
    } catch (ex) {
      if (!this.ignoreErrors) {
        throw ex;
      }

      this._onUnsupportedFeature({
        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
      });

      (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
      return this.compiledGlyphs[character] = function (c, size) {};
    }

    if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {
      const jsBuf = [];

      for (const current of cmds) {
        const args = current.args !== undefined ? current.args.join(",") : "";
        jsBuf.push("c.", current.cmd, "(", args, ");\n");
      }

      return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
    }

    return this.compiledGlyphs[character] = function (c, size) {
      for (const current of cmds) {
        if (current.cmd === "scale") {
          current.args = [size, -size];
        }

        c[current.cmd].apply(c, current.args);
      }
    };
  }

}

exports.FontFaceObject = FontFaceObject;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;

var _base_factory = __w_pdfjs_require__(5);

var _is_node = __w_pdfjs_require__(4);

var _util = __w_pdfjs_require__(2);

let NodeCanvasFactory = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: NodeCanvasFactory");
  }

};
exports.NodeCanvasFactory = NodeCanvasFactory;
let NodeCMapReaderFactory = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory");
  }

};
exports.NodeCMapReaderFactory = NodeCMapReaderFactory;
let NodeStandardFontDataFactory = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: NodeStandardFontDataFactory");
  }

};
exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

if (_is_node.isNodeJS) {
  const fetchData = function (url) {
    return new Promise((resolve, reject) => {
      const fs = __webpack_require__(/*! fs */ "?fe90");

      fs.readFile(url, (error, data) => {
        if (error || !data) {
          reject(new Error(error));
          return;
        }

        resolve(new Uint8Array(data));
      });
    });
  };

  exports.NodeCanvasFactory = NodeCanvasFactory = class extends _base_factory.BaseCanvasFactory {
    _createCanvas(width, height) {
      const Canvas = __webpack_require__(/*! canvas */ "?4a14");

      return Canvas.createCanvas(width, height);
    }

  };
  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _base_factory.BaseCMapReaderFactory {
    _fetchData(url, compressionType) {
      return fetchData(url).then(data => {
        return {
          cMapData: data,
          compressionType
        };
      });
    }

  };
  exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory = class extends _base_factory.BaseStandardFontDataFactory {
    _fetchData(url) {
      return fetchData(url);
    }

  };
}

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationStorage = void 0;

var _util = __w_pdfjs_require__(2);

class AnnotationStorage {
  constructor() {
    this._storage = new Map();
    this._timeStamp = Date.now();
    this._modified = false;
    this.onSetModified = null;
    this.onResetModified = null;
  }

  getValue(key, defaultValue) {
    const value = this._storage.get(key);

    if (value === undefined) {
      return defaultValue;
    }

    return Object.assign(defaultValue, value);
  }

  setValue(key, value) {
    const obj = this._storage.get(key);

    let modified = false;

    if (obj !== undefined) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;

      this._storage.set(key, value);
    }

    if (modified) {
      this._timeStamp = Date.now();

      this._setModified();
    }
  }

  getAll() {
    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
  }

  get size() {
    return this._storage.size;
  }

  _setModified() {
    if (!this._modified) {
      this._modified = true;

      if (typeof this.onSetModified === "function") {
        this.onSetModified();
      }
    }
  }

  resetModified() {
    if (this._modified) {
      this._modified = false;

      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }

  get serializable() {
    return this._storage.size > 0 ? this._storage : null;
  }

  get lastModified() {
    return this._timeStamp.toString();
  }

}

exports.AnnotationStorage = AnnotationStorage;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CanvasGraphics = void 0;

var _util = __w_pdfjs_require__(2);

var _pattern_helper = __w_pdfjs_require__(11);

var _display_utils = __w_pdfjs_require__(1);

const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const MAX_GROUP_SIZE = 4096;
const EXECUTION_TIME = 15;
const EXECUTION_STEPS = 10;
const COMPILE_TYPE3_GLYPHS = true;
const MAX_SIZE_TO_COMPILE = 1000;
const FULL_CHUNK_HEIGHT = 16;
const LINEWIDTH_SCALE_FACTOR = 1.000001;

function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }

  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;

  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };

  ctx.save = function ctxSave() {
    destCtx.save();

    this.__originalSave();
  };

  ctx.restore = function ctxRestore() {
    destCtx.restore();

    this.__originalRestore();
  };

  ctx.translate = function ctxTranslate(x, y) {
    destCtx.translate(x, y);

    this.__originalTranslate(x, y);
  };

  ctx.scale = function ctxScale(x, y) {
    destCtx.scale(x, y);

    this.__originalScale(x, y);
  };

  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);

    this.__originalTransform(a, b, c, d, e, f);
  };

  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);

    this.__originalSetTransform(a, b, c, d, e, f);
  };

  ctx.resetTransform = function ctxResetTransform() {
    destCtx.resetTransform();

    this.__originalResetTransform();
  };

  ctx.rotate = function ctxRotate(angle) {
    destCtx.rotate(angle);

    this.__originalRotate(angle);
  };

  ctx.clip = function ctxRotate(rule) {
    destCtx.clip(rule);

    this.__originalClip(rule);
  };

  ctx.moveTo = function (x, y) {
    destCtx.moveTo(x, y);

    this.__originalMoveTo(x, y);
  };

  ctx.lineTo = function (x, y) {
    destCtx.lineTo(x, y);

    this.__originalLineTo(x, y);
  };

  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);

    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };

  ctx.rect = function (x, y, width, height) {
    destCtx.rect(x, y, width, height);

    this.__originalRect(x, y, width, height);
  };

  ctx.closePath = function () {
    destCtx.closePath();

    this.__originalClosePath();
  };

  ctx.beginPath = function () {
    destCtx.beginPath();

    this.__originalBeginPath();
  };
}

function addContextCurrentTransform(ctx) {
  if (ctx.mozCurrentTransform) {
    return;
  }

  ctx._originalSave = ctx.save;
  ctx._originalRestore = ctx.restore;
  ctx._originalRotate = ctx.rotate;
  ctx._originalScale = ctx.scale;
  ctx._originalTranslate = ctx.translate;
  ctx._originalTransform = ctx.transform;
  ctx._originalSetTransform = ctx.setTransform;
  ctx._originalResetTransform = ctx.resetTransform;
  ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
  ctx._transformStack = [];

  try {
    const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
    ctx._setLineWidth = desc.set;
    ctx._getLineWidth = desc.get;
    Object.defineProperty(ctx, "lineWidth", {
      set: function setLineWidth(width) {
        this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
      },
      get: function getLineWidth() {
        return this._getLineWidth();
      }
    });
  } catch (_) {}

  Object.defineProperty(ctx, "mozCurrentTransform", {
    get: function getCurrentTransform() {
      return this._transformMatrix;
    }
  });
  Object.defineProperty(ctx, "mozCurrentTransformInverse", {
    get: function getCurrentTransformInverse() {
      const [a, b, c, d, e, f] = this._transformMatrix;
      const ad_bc = a * d - b * c;
      const bc_ad = b * c - a * d;
      return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
    }
  });

  ctx.save = function ctxSave() {
    const old = this._transformMatrix;

    this._transformStack.push(old);

    this._transformMatrix = old.slice(0, 6);

    this._originalSave();
  };

  ctx.restore = function ctxRestore() {
    const prev = this._transformStack.pop();

    if (prev) {
      this._transformMatrix = prev;

      this._originalRestore();
    }
  };

  ctx.translate = function ctxTranslate(x, y) {
    const m = this._transformMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];

    this._originalTranslate(x, y);
  };

  ctx.scale = function ctxScale(x, y) {
    const m = this._transformMatrix;
    m[0] *= x;
    m[1] *= x;
    m[2] *= y;
    m[3] *= y;

    this._originalScale(x, y);
  };

  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
    const m = this._transformMatrix;
    this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

    ctx._originalTransform(a, b, c, d, e, f);
  };

  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
    this._transformMatrix = [a, b, c, d, e, f];

    ctx._originalSetTransform(a, b, c, d, e, f);
  };

  ctx.resetTransform = function ctxResetTransform() {
    this._transformMatrix = [1, 0, 0, 1, 0, 0];

    ctx._originalResetTransform();
  };

  ctx.rotate = function ctxRotate(angle) {
    const cosValue = Math.cos(angle);
    const sinValue = Math.sin(angle);
    const m = this._transformMatrix;
    this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

    this._originalRotate(angle);
  };
}

class CachedCanvases {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }

  getCanvas(id, width, height, trackTransform) {
    let canvasEntry;

    if (this.cache[id] !== undefined) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }

    if (trackTransform) {
      addContextCurrentTransform(canvasEntry.context);
    }

    return canvasEntry;
  }

  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }

}

function compileType3Glyph(imgData) {
  const POINT_TO_PROCESS_LIMIT = 1000;
  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  const width = imgData.width,
        height = imgData.height,
        width1 = width + 1;
  let i, ii, j, j0;
  const points = new Uint8Array(width1 * (height + 1));
  const lineSize = width + 7 & ~7,
        data0 = imgData.data;
  const data = new Uint8Array(lineSize * height);
  let pos = 0;

  for (i = 0, ii = data0.length; i < ii; i++) {
    const elem = data0[i];
    let mask = 128;

    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }

  let count = 0;
  pos = 0;

  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }

  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;

    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }

    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }

      pos++;
    }

    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }

    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }

  pos = lineSize * (height - 1);
  j0 = i * width1;

  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }

  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }

  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  const outlines = [];

  for (i = 0; count && i <= height; i++) {
    let p = i * width1;
    const end = p + width;

    while (p < end && !points[p]) {
      p++;
    }

    if (p === end) {
      continue;
    }

    const coords = [p % width1, i];
    const p0 = p;
    let type = points[p];

    do {
      const step = steps[type];

      do {
        p += step;
      } while (!points[p]);

      const pp = points[p];

      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }

      coords.push(p % width1, p / width1 | 0);

      if (!points[p]) {
        --count;
      }
    } while (p0 !== p);

    outlines.push(coords);
    --i;
  }

  const drawOutline = function (c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.beginPath();

    for (let k = 0, kk = outlines.length; k < kk; k++) {
      const o = outlines[k];
      c.moveTo(o[0], o[1]);

      for (let l = 2, ll = o.length; l < ll; l += 2) {
        c.lineTo(o[l], o[l + 1]);
      }
    }

    c.fill();
    c.beginPath();
    c.restore();
  };

  return drawOutline;
}

class CanvasExtraState {
  constructor(width, height) {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = "#000000";
    this.strokeColor = "#000000";
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.transferMaps = null;
    this.startNewPathAndClipBox([0, 0, width, height]);
  }

  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    return clone;
  }

  setCurrentPoint(x, y) {
    this.x = x;
    this.y = y;
  }

  updatePathMinMax(transform, x, y) {
    [x, y] = _util.Util.applyTransform([x, y], transform);
    this.minX = Math.min(this.minX, x);
    this.minY = Math.min(this.minY, y);
    this.maxX = Math.max(this.maxX, x);
    this.maxY = Math.max(this.maxY, y);
  }

  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3) {
    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);

    this.updatePathMinMax(transform, box[0], box[1]);
    this.updatePathMinMax(transform, box[2], box[3]);
  }

  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
    const box = [this.minX, this.minY, this.maxX, this.maxY];

    if (pathType === _pattern_helper.PathType.STROKE) {
      if (!transform) {
        (0, _util.unreachable)("Stroke bounding box must include transform.");
      }

      const scale = _util.Util.singularValueDecompose2dScale(transform);

      const xStrokePad = scale[0] * this.lineWidth / 2;
      const yStrokePad = scale[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }

    return box;
  }

  updateClipFromPath() {
    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());

    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }

  startNewPathAndClipBox(box) {
    this.clipBox = box;
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = 0;
    this.maxY = 0;
  }

  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }

}

function putBinaryImageData(ctx, imgData, transferMaps = null) {
  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }

  const height = imgData.height,
        width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0,
      destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

  if (transferMaps) {
    switch (transferMaps.length) {
      case 1:
        transferMapRed = transferMaps[0];
        transferMapGreen = transferMaps[0];
        transferMapBlue = transferMaps[0];
        transferMapGray = transferMaps[0];
        break;

      case 4:
        transferMapRed = transferMaps[0];
        transferMapGreen = transferMaps[1];
        transferMapBlue = transferMaps[2];
        transferMapGray = transferMaps[3];
        break;
    }
  }

  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    let white = 0xffffffff;
    let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;

    if (transferMapGray) {
      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
        [white, black] = [black, white];
      }
    }

    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;

      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;

        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }

        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }

          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }

      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;

      if (hasTransferMaps) {
        for (let k = 0; k < elemsInThisChunk; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }

    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

      if (hasTransferMaps) {
        for (let k = 0; k < elemsInThisChunk; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;

    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }

      destPos = 0;

      for (j = elemsInThisChunk; j--;) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }

      if (hasTransferMaps) {
        for (let k = 0; k < destPos; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}

function putBinaryImageMask(ctx, imgData) {
  const height = imgData.height,
        width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;

  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    let destPos = 3;

    for (let j = 0; j < thisChunkHeight; j++) {
      let elem,
          mask = 0;

      for (let k = 0; k < width; k++) {
        if (!mask) {
          elem = src[srcPos++];
          mask = 128;
        }

        dest[destPos] = elem & mask ? 0 : 255;
        destPos += 4;
        mask >>= 1;
      }
    }

    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}

function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

  for (let i = 0, ii = properties.length; i < ii; i++) {
    const property = properties[i];

    if (sourceCtx[property] !== undefined) {
      destCtx[property] = sourceCtx[property];
    }
  }

  if (sourceCtx.setLineDash !== undefined) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}

function resetCtxToDefault(ctx) {
  ctx.strokeStyle = "#000000";
  ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";

  if (ctx.setLineDash !== undefined) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
}

function composeSMaskBackdrop(bytes, r0, g0, b0) {
  const length = bytes.length;

  for (let i = 3; i < length; i += 4) {
    const alpha = bytes[i];

    if (alpha === 0) {
      bytes[i - 3] = r0;
      bytes[i - 2] = g0;
      bytes[i - 1] = b0;
    } else if (alpha < 255) {
      const alpha_ = 255 - alpha;
      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
    }
  }
}

function composeSMaskAlpha(maskData, layerData, transferMap) {
  const length = maskData.length;
  const scale = 1 / 255;

  for (let i = 3; i < length; i += 4) {
    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
    layerData[i] = layerData[i] * alpha * scale | 0;
  }
}

function composeSMaskLuminosity(maskData, layerData, transferMap) {
  const length = maskData.length;

  for (let i = 3; i < length; i += 4) {
    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
  }
}

function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
  const hasBackdrop = !!backdrop;
  const r0 = hasBackdrop ? backdrop[0] : 0;
  const g0 = hasBackdrop ? backdrop[1] : 0;
  const b0 = hasBackdrop ? backdrop[2] : 0;
  let composeFn;

  if (subtype === "Luminosity") {
    composeFn = composeSMaskLuminosity;
  } else {
    composeFn = composeSMaskAlpha;
  }

  const PIXELS_TO_PROCESS = 1048576;
  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

  for (let row = 0; row < height; row += chunkSize) {
    const chunkHeight = Math.min(chunkSize, height - row);
    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);

    if (hasBackdrop) {
      composeSMaskBackdrop(maskData.data, r0, g0, b0);
    }

    composeFn(maskData.data, layerData.data, transferMap);
    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
  }
}

function composeSMask(ctx, smask, layerCtx, layerBox) {
  const layerOffsetX = layerBox[0];
  const layerOffsetY = layerBox[1];
  const layerWidth = layerBox[2] - layerOffsetX;
  const layerHeight = layerBox[3] - layerOffsetY;

  if (layerWidth === 0 || layerHeight === 0) {
    return;
  }

  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.drawImage(layerCtx.canvas, 0, 0);
  ctx.restore();
}

function getImageSmoothingEnabled(transform, interpolate) {
  const scale = _util.Util.singularValueDecompose2dScale(transform);

  scale[0] = Math.fround(scale[0]);
  scale[1] = Math.fround(scale[1]);
  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);

  if (interpolate !== undefined) {
    return interpolate;
  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
    return true;
  }

  return false;
}

const LINE_CAP_STYLES = ["butt", "round", "square"];
const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
const NORMAL_CLIP = {};
const EO_CLIP = {};

class CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.imageLayer = imageLayer;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;

    if (canvasCtx) {
      addContextCurrentTransform(canvasCtx);
    }

    this._cachedGetSinglePixelWidth = null;
  }

  beginDrawing({
    transform,
    viewport,
    transparency = false,
    background = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    this.ctx.save();
    this.ctx.fillStyle = background || "rgb(255, 255, 255)";
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.restore();

    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
    }

    this.ctx.save();
    resetCtxToDefault(this.ctx);

    if (transform) {
      this.ctx.transform.apply(this.ctx, transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }

    this.ctx.transform.apply(this.ctx, viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = this.ctx.mozCurrentTransform.slice();
    this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);

    if (this.imageLayer) {
      this.imageLayer.beginLayout();
    }
  }

  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;

    if (argsArrayLen === i) {
      return i;
    }

    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId;

    while (true) {
      if (stepper !== undefined && i === stepper.nextBreakPoint) {
        stepper.breakIt(i, continueCallback);
        return i;
      }

      fnId = fnArray[i];

      if (fnId !== _util.OPS.dependency) {
        this[fnId].apply(this, argsArray[i]);
      } else {
        for (const depObjId of argsArray[i]) {
          const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

          if (!objsPool.has(depObjId)) {
            objsPool.get(depObjId, continueCallback);
            return i;
          }
        }
      }

      i++;

      if (i === argsArrayLen) {
        return i;
      }

      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i;
        }

        steps = 0;
      }
    }
  }

  endDrawing() {
    while (this.stateStack.length || this.current.activeSMask !== null) {
      this.restore();
    }

    this.ctx.restore();

    if (this.transparentCanvas) {
      this.ctx = this.compositeCtx;
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.drawImage(this.transparentCanvas, 0, 0);
      this.ctx.restore();
      this.transparentCanvas = null;
    }

    this.cachedCanvases.clear();
    this.cachedPatterns.clear();

    if (this.imageLayer) {
      this.imageLayer.endLayout();
    }
  }

  _scaleImage(img, inverseTransform) {
    const width = img.width;
    const height = img.height;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width,
        paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;

    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth,
          newHeight = paintHeight;

      if (widthScale > 2 && paintWidth > 1) {
        newWidth = Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }

      if (heightScale > 2 && paintHeight > 1) {
        newHeight = Math.ceil(paintHeight / 2);
        heightScale /= paintHeight / newHeight;
      }

      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }

    return {
      img,
      paintWidth,
      paintHeight
    };
  }

  _createMaskCanvas(img) {
    const ctx = this.ctx;
    const width = img.width,
          height = img.height;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
    const maskCtx = maskCanvas.context;
    putBinaryImageMask(maskCtx, img);
    const objToCanvas = ctx.mozCurrentTransform;

    let maskToCanvas = _util.Util.transform(objToCanvas, [1 / width, 0, 0, -1 / height, 0, 0]);

    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);

    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);

    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);

    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);

    const drawnWidth = Math.ceil(rect[2] - rect[0]);
    const drawnHeight = Math.ceil(rect[3] - rect[1]);
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight, true);
    const fillCtx = fillCanvas.context;
    const offsetX = Math.min(cord1[0], cord2[0]);
    const offsetY = Math.min(cord1[1], cord2[1]);
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform.apply(fillCtx, maskToCanvas);

    const scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);

    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);
    fillCtx.drawImage(scaled.img, 0, 0, scaled.img.width, scaled.img.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";

    const inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);

    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
    fillCtx.fillRect(0, 0, width, height);
    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }

  setLineWidth(width) {
    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }

  setLineCap(style) {
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }

  setLineJoin(style) {
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }

  setMiterLimit(limit) {
    this.ctx.miterLimit = limit;
  }

  setDash(dashArray, dashPhase) {
    const ctx = this.ctx;

    if (ctx.setLineDash !== undefined) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }

  setRenderingIntent(intent) {}

  setFlatness(flatness) {}

  setGState(states) {
    for (let i = 0, ii = states.length; i < ii; i++) {
      const state = states[i];
      const key = state[0];
      const value = state[1];

      switch (key) {
        case "LW":
          this.setLineWidth(value);
          break;

        case "LC":
          this.setLineCap(value);
          break;

        case "LJ":
          this.setLineJoin(value);
          break;

        case "ML":
          this.setMiterLimit(value);
          break;

        case "D":
          this.setDash(value[0], value[1]);
          break;

        case "RI":
          this.setRenderingIntent(value);
          break;

        case "FL":
          this.setFlatness(value);
          break;

        case "Font":
          this.setFont(value[0], value[1]);
          break;

        case "CA":
          this.current.strokeAlpha = state[1];
          break;

        case "ca":
          this.current.fillAlpha = state[1];
          this.ctx.globalAlpha = state[1];
          break;

        case "BM":
          this.ctx.globalCompositeOperation = value;
          break;

        case "SMask":
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;

        case "TR":
          this.current.transferMaps = value;
      }
    }
  }

  checkSMaskState() {
    const inSMaskMode = !!this.suspendedCtx;

    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }

  beginSMaskMode() {
    if (this.suspendedCtx) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }

    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
    this.suspendedCtx = this.ctx;
    this.ctx = scratchCanvas.context;
    const ctx = this.ctx;
    ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }

  endSMaskMode() {
    if (!this.suspendedCtx) {
      throw new Error("endSMaskMode called while not in smask mode");
    }

    this.ctx._removeMirroring();

    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.current.activeSMask = null;
    this.suspendedCtx = null;
  }

  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }

    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }

    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }

  save() {
    this.ctx.save();
    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
  }

  restore() {
    if (this.stateStack.length === 0 && this.current.activeSMask) {
      this.endSMaskMode();
    }

    if (this.stateStack.length !== 0) {
      this.current = this.stateStack.pop();
      this.ctx.restore();
      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedGetSinglePixelWidth = null;
    }
  }

  transform(a, b, c, d, e, f) {
    this.ctx.transform(a, b, c, d, e, f);
    this._cachedGetSinglePixelWidth = null;
  }

  constructPath(ops, args) {
    const ctx = this.ctx;
    const current = this.current;
    let x = current.x,
        y = current.y;
    let startX, startY;

    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
      switch (ops[i] | 0) {
        case _util.OPS.rectangle:
          x = args[j++];
          y = args[j++];
          const width = args[j++];
          const height = args[j++];
          const xw = x + width;
          const yh = y + height;
          ctx.moveTo(x, y);

          if (width === 0 || height === 0) {
            ctx.lineTo(xw, yh);
          } else {
            ctx.lineTo(xw, y);
            ctx.lineTo(xw, yh);
            ctx.lineTo(x, yh);
          }

          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);
          current.updatePathMinMax(ctx.mozCurrentTransform, xw, yh);
          ctx.closePath();
          break;

        case _util.OPS.moveTo:
          x = args[j++];
          y = args[j++];
          ctx.moveTo(x, y);
          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);
          break;

        case _util.OPS.lineTo:
          x = args[j++];
          y = args[j++];
          ctx.lineTo(x, y);
          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);
          break;

        case _util.OPS.curveTo:
          startX = x;
          startY = y;
          x = args[j + 4];
          y = args[j + 5];
          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
          j += 6;
          break;

        case _util.OPS.curveTo2:
          startX = x;
          startY = y;
          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
          x = args[j + 2];
          y = args[j + 3];
          j += 4;
          break;

        case _util.OPS.curveTo3:
          startX = x;
          startY = y;
          x = args[j + 2];
          y = args[j + 3];
          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], x, y, x, y);
          j += 4;
          break;

        case _util.OPS.closePath:
          ctx.closePath();
          break;
      }
    }

    current.setCurrentPoint(x, y);
  }

  closePath() {
    this.ctx.closePath();
  }

  stroke(consumePath) {
    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;

    if (this.contentVisible) {
      if (typeof strokeColor === "object" && strokeColor?.getPattern) {
        const lineWidth = this.getSinglePixelWidth();
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);
        ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
        ctx.stroke();
        ctx.restore();
      } else {
        const lineWidth = this.getSinglePixelWidth();

        if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {
          ctx.save();
          ctx.resetTransform();
          ctx.lineWidth = Math.round(this._combinedScaleFactor);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
          ctx.stroke();
        }
      }
    }

    if (consumePath) {
      this.consumePath(this.current.getClippedPathBoundingBox());
    }

    ctx.globalAlpha = this.current.fillAlpha;
  }

  closeStroke() {
    this.closePath();
    this.stroke();
  }

  fill(consumePath) {
    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;

    if (isPatternFill) {
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
      needRestore = true;
    }

    const intersect = this.current.getClippedPathBoundingBox();

    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill("evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }
    }

    if (needRestore) {
      ctx.restore();
    }

    if (consumePath) {
      this.consumePath(intersect);
    }
  }

  eoFill() {
    this.pendingEOFill = true;
    this.fill();
  }

  fillStroke() {
    this.fill(false);
    this.stroke(false);
    this.consumePath();
  }

  eoFillStroke() {
    this.pendingEOFill = true;
    this.fillStroke();
  }

  closeFillStroke() {
    this.closePath();
    this.fillStroke();
  }

  closeEOFillStroke() {
    this.pendingEOFill = true;
    this.closePath();
    this.fillStroke();
  }

  endPath() {
    this.consumePath();
  }

  clip() {
    this.pendingClip = NORMAL_CLIP;
  }

  eoClip() {
    this.pendingClip = EO_CLIP;
  }

  beginText() {
    this.current.textMatrix = _util.IDENTITY_MATRIX;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }

  endText() {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;

    if (paths === undefined) {
      ctx.beginPath();
      return;
    }

    ctx.save();
    ctx.beginPath();

    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];
      ctx.setTransform.apply(ctx, path.transform);
      ctx.translate(path.x, path.y);
      path.addToPath(ctx, path.fontSize);
    }

    ctx.restore();
    ctx.clip();
    ctx.beginPath();
    delete this.pendingTextPaths;
  }

  setCharSpacing(spacing) {
    this.current.charSpacing = spacing;
  }

  setWordSpacing(spacing) {
    this.current.wordSpacing = spacing;
  }

  setHScale(scale) {
    this.current.textHScale = scale / 100;
  }

  setLeading(leading) {
    this.current.leading = -leading;
  }

  setFont(fontRefName, size) {
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;

    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }

    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      (0, _util.warn)("Invalid font matrix for font " + fontRefName);
    }

    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }

    this.current.font = fontObj;
    this.current.fontSize = size;

    if (fontObj.isType3Font) {
      return;
    }

    const name = fontObj.loadedName || "sans-serif";
    let bold = "normal";

    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }

    const italic = fontObj.italic ? "italic" : "normal";
    const typeface = `"${name}", ${fontObj.fallbackName}`;
    let browserFontSize = size;

    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }

    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }

  setTextRenderingMode(mode) {
    this.current.textRenderingMode = mode;
  }

  setTextRise(rise) {
    this.current.textRise = rise;
  }

  moveText(x, y) {
    this.current.x = this.current.lineX += x;
    this.current.y = this.current.lineY += y;
  }

  setLeadingMoveText(x, y) {
    this.setLeading(-y);
    this.moveText(x, y);
  }

  setTextMatrix(a, b, c, d, e, f) {
    this.current.textMatrix = [a, b, c, d, e, f];
    this.current.textMatrixScale = Math.hypot(a, b);
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }

  nextLine() {
    this.moveText(0, this.current.leading);
  }

  paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    let addToPath;

    if (font.disableFontFace || isAddToPathSet || patternFill) {
      addToPath = font.getPathGenerator(this.commonObjs, character);
    }

    if (font.disableFontFace || patternFill) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      addToPath(ctx, fontSize);

      if (patternTransform) {
        ctx.setTransform.apply(ctx, patternTransform);
      }

      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fill();
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        if (resetLineWidthToOne) {
          ctx.resetTransform();
          ctx.lineWidth = Math.round(this._combinedScaleFactor);
        }

        ctx.stroke();
      }

      ctx.restore();
    } else {
      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x, y);
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        if (resetLineWidthToOne) {
          ctx.save();
          ctx.moveTo(x, y);
          ctx.resetTransform();
          ctx.lineWidth = Math.round(this._combinedScaleFactor);
          ctx.strokeText(character, 0, 0);
          ctx.restore();
        } else {
          ctx.strokeText(character, x, y);
        }
      }
    }

    if (isAddToPathSet) {
      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
      paths.push({
        transform: ctx.mozCurrentTransform,
        x,
        y,
        fontSize,
        addToPath
      });
    }
  }

  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;

    for (let i = 3; i < data.length; i += 4) {
      if (data[i] > 0 && data[i] < 255) {
        enabled = true;
        break;
      }
    }

    return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
  }

  showText(glyphs) {
    const current = this.current;
    const font = current.font;

    if (font.isType3Font) {
      return this.showType3Text(glyphs);
    }

    const fontSize = current.fontSize;

    if (fontSize === 0) {
      return undefined;
    }

    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    ctx.transform.apply(ctx, current.textMatrix);
    ctx.translate(current.x, current.y + current.textRise);

    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }

    let patternTransform;

    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
      patternTransform = ctx.mozCurrentTransform;
      ctx.restore();
      ctx.fillStyle = pattern;
    }

    let lineWidth = current.lineWidth;
    let resetLineWidthToOne = false;
    const scale = current.textMatrixScale;

    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        this._cachedGetSinglePixelWidth = null;
        lineWidth = this.getSinglePixelWidth();
        resetLineWidthToOne = lineWidth < 0;
      }
    } else {
      lineWidth /= scale;
    }

    if (fontSizeScale !== 1.0) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }

    ctx.lineWidth = lineWidth;
    let x = 0,
        i;

    for (i = 0; i < glyphsLength; ++i) {
      const glyph = glyphs[i];

      if ((0, _util.isNum)(glyph)) {
        x += spacingDir * glyph * fontSize / 1000;
        continue;
      }

      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;

      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }

      if (font.remeasure && width > 0) {
        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
        }
      }

      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
        } else {
          this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);

          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
          }
        }
      }

      let charWidth;

      if (vertical) {
        charWidth = width * widthAdvanceScale - spacing * fontDirection;
      } else {
        charWidth = width * widthAdvanceScale + spacing * fontDirection;
      }

      x += charWidth;

      if (restoreNeeded) {
        ctx.restore();
      }
    }

    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }

    ctx.restore();
    this.compose();
    return undefined;
  }

  showType3Text(glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
    let i, glyph, width, spacingLength;

    if (isTextInvisible || fontSize === 0) {
      return;
    }

    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    ctx.transform.apply(ctx, current.textMatrix);
    ctx.translate(current.x, current.y);
    ctx.scale(textHScale, fontDirection);

    for (i = 0; i < glyphsLength; ++i) {
      glyph = glyphs[i];

      if ((0, _util.isNum)(glyph)) {
        spacingLength = spacingDir * glyph * fontSize / 1000;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }

      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];

      if (!operatorList) {
        (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
        continue;
      }

      if (this.contentVisible) {
        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform.apply(ctx, fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }

      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

      width = transformed[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }

    ctx.restore();
    this.processingType3 = null;
  }

  setCharWidth(xWidth, yWidth) {}

  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
    this.ctx.rect(llx, lly, urx - llx, ury - lly);
    this.clip();
    this.endPath();
  }

  getColorN_Pattern(IR) {
    let pattern;

    if (IR[0] === "TilingPattern") {
      const color = IR[1];
      const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
      const canvasGraphicsFactory = {
        createCanvasGraphics: ctx => {
          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
        }
      };
      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(IR[1], IR[2]);
    }

    return pattern;
  }

  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }

  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments);
    this.current.patternFill = true;
  }

  setStrokeRGBColor(r, g, b) {
    const color = _util.Util.makeHexColor(r, g, b);

    this.ctx.strokeStyle = color;
    this.current.strokeColor = color;
  }

  setFillRGBColor(r, g, b) {
    const color = _util.Util.makeHexColor(r, g, b);

    this.ctx.fillStyle = color;
    this.current.fillColor = color;
    this.current.patternFill = false;
  }

  _getPattern(objId, matrix = null) {
    let pattern;

    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
      this.cachedPatterns.set(objId, pattern);
    }

    if (matrix) {
      pattern.matrix = matrix;
    }

    return pattern;
  }

  shadingFill(objId) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    this.save();

    const pattern = this._getPattern(objId);

    ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);
    const inv = ctx.mozCurrentTransformInverse;

    if (inv) {
      const canvas = ctx.canvas;
      const width = canvas.width;
      const height = canvas.height;

      const bl = _util.Util.applyTransform([0, 0], inv);

      const br = _util.Util.applyTransform([0, height], inv);

      const ul = _util.Util.applyTransform([width, 0], inv);

      const ur = _util.Util.applyTransform([width, height], inv);

      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }

    this.compose(this.current.getClippedPathBoundingBox());
    this.restore();
  }

  beginInlineImage() {
    (0, _util.unreachable)("Should not call beginInlineImage");
  }

  beginImageData() {
    (0, _util.unreachable)("Should not call beginImageData");
  }

  paintFormXObjectBegin(matrix, bbox) {
    if (!this.contentVisible) {
      return;
    }

    this.save();
    this.baseTransformStack.push(this.baseTransform);

    if (Array.isArray(matrix) && matrix.length === 6) {
      this.transform.apply(this, matrix);
    }

    this.baseTransform = this.ctx.mozCurrentTransform;

    if (bbox) {
      const width = bbox[2] - bbox[0];
      const height = bbox[3] - bbox[1];
      this.ctx.rect(bbox[0], bbox[1], width, height);
      this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[0], bbox[1]);
      this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[2], bbox[3]);
      this.clip();
      this.endPath();
    }
  }

  paintFormXObjectEnd() {
    if (!this.contentVisible) {
      return;
    }

    this.restore();
    this.baseTransform = this.baseTransformStack.pop();
  }

  beginGroup(group) {
    if (!this.contentVisible) {
      return;
    }

    this.save();
    const suspendedCtx = this.suspendedCtx;

    if (this.current.activeSMask) {
      this.suspendedCtx = null;
      this.current.activeSMask = null;
    }

    const currentCtx = this.ctx;

    if (!group.isolated) {
      (0, _util.info)("TODO: Support non-isolated groups.");
    }

    if (group.knockout) {
      (0, _util.warn)("Knockout groups not supported.");
    }

    const currentTransform = currentCtx.mozCurrentTransform;

    if (group.matrix) {
      currentCtx.transform.apply(currentCtx, group.matrix);
    }

    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }

    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    let scaleX = 1,
        scaleY = 1;

    if (drawnWidth > MAX_GROUP_SIZE) {
      scaleX = drawnWidth / MAX_GROUP_SIZE;
      drawnWidth = MAX_GROUP_SIZE;
    }

    if (drawnHeight > MAX_GROUP_SIZE) {
      scaleY = drawnHeight / MAX_GROUP_SIZE;
      drawnHeight = MAX_GROUP_SIZE;
    }

    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;

    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }

    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
    const groupCtx = scratchCanvas.context;
    groupCtx.scale(1 / scaleX, 1 / scaleY);
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform.apply(groupCtx, currentTransform);

    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        scaleX,
        scaleY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    } else {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.scale(scaleX, scaleY);
      currentCtx.save();
    }

    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push({
      ctx: currentCtx,
      suspendedCtx
    });
    this.groupLevel++;
  }

  endGroup(group) {
    if (!this.contentVisible) {
      return;
    }

    this.groupLevel--;
    const groupCtx = this.ctx;
    const {
      ctx,
      suspendedCtx
    } = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;

    if (suspendedCtx) {
      this.suspendedCtx = suspendedCtx;
    }

    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore();
    } else {
      this.ctx.restore();
      const currentMtx = this.ctx.mozCurrentTransform;
      this.restore();
      this.ctx.save();
      this.ctx.setTransform.apply(this.ctx, currentMtx);

      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);

      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }

  beginAnnotations() {
    this.save();

    if (this.baseTransform) {
      this.ctx.setTransform.apply(this.ctx, this.baseTransform);
    }
  }

  endAnnotations() {
    this.restore();
  }

  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
    this.save();

    if (Array.isArray(rect) && rect.length === 4) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];

      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;

        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform);

        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        canvas.style.width = `calc(${width}px * var(--viewport-scale-factor))`;
        canvas.style.height = `calc(${height}px * var(--viewport-scale-factor))`;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
        addContextCurrentTransform(this.ctx);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.ctx.rect(rect[0], rect[1], width, height);
        this.clip();
        this.endPath();
      }
    }

    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform.apply(this, transform);
    this.transform.apply(this, matrix);
  }

  endAnnotation() {
    if (this.annotationCanvas) {
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }

    this.restore();
  }

  paintImageMaskXObject(img) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    const width = img.width,
          height = img.height;
    const glyph = this.processingType3;

    if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
      if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
        glyph.compiled = compileType3Glyph({
          data: img.data,
          width,
          height
        });
      } else {
        glyph.compiled = null;
      }
    }

    if (glyph?.compiled) {
      glyph.compiled(ctx);
      return;
    }

    const mask = this._createMaskCanvas(img);

    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    ctx.restore();
    this.compose();
  }

  paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    ctx.save();
    const currentTransform = ctx.mozCurrentTransform;
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);

    const mask = this._createMaskCanvas(imgData);

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);

      const [x, y] = _util.Util.applyTransform([0, 0], trans);

      ctx.drawImage(mask.canvas, x, y);
    }

    ctx.restore();
    this.compose();
  }

  paintImageMaskXObjectGroup(images) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;

    for (let i = 0, ii = images.length; i < ii; i++) {
      const image = images[i];
      const width = image.width,
            height = image.height;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      putBinaryImageMask(maskCtx, image);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform.apply(ctx, image.transform);
      ctx.scale(1, -1);
      ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      ctx.restore();
    }

    this.compose();
  }

  paintImageXObject(objId) {
    if (!this.contentVisible) {
      return;
    }

    const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }

    this.paintInlineImageXObject(imgData);
  }

  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }

    const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }

    const width = imgData.width;
    const height = imgData.height;
    const map = [];

    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }

    this.paintInlineImageXObjectGroup(imgData, map);
  }

  paintInlineImageXObject(imgData) {
    if (!this.contentVisible) {
      return;
    }

    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save();
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;

    if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
      imgToPaint = tmpCanvas.canvas;
    }

    const scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);

    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);
    ctx.drawImage(scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);

    if (this.imageLayer) {
      const position = this.getCanvasPosition(0, -height);
      this.imageLayer.appendImage({
        imgData,
        left: position[0],
        top: position[1],
        width: width / ctx.mozCurrentTransformInverse[0],
        height: height / ctx.mozCurrentTransformInverse[3]
      });
    }

    this.compose();
    this.restore();
  }

  paintInlineImageXObjectGroup(imgData, map) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    const w = imgData.width;
    const h = imgData.height;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
    const tmpCtx = tmpCanvas.context;
    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

    for (let i = 0, ii = map.length; i < ii; i++) {
      const entry = map[i];
      ctx.save();
      ctx.transform.apply(ctx, entry.transform);
      ctx.scale(1, -1);
      ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

      if (this.imageLayer) {
        const position = this.getCanvasPosition(entry.x, entry.y);
        this.imageLayer.appendImage({
          imgData,
          left: position[0],
          top: position[1],
          width: w,
          height: h
        });
      }

      ctx.restore();
    }

    this.compose();
  }

  paintSolidColorImageMask() {
    if (!this.contentVisible) {
      return;
    }

    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }

  markPoint(tag) {}

  markPointProps(tag, properties) {}

  beginMarkedContent(tag) {
    this.markedContentStack.push({
      visible: true
    });
  }

  beginMarkedContentProps(tag, properties) {
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }

    this.contentVisible = this.isContentVisible();
  }

  endMarkedContent() {
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }

  beginCompat() {}

  endCompat() {}

  consumePath(clipBox) {
    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }

    if (!this.pendingClip) {
      this.compose(clipBox);
    }

    const ctx = this.ctx;

    if (this.pendingClip) {
      if (this.pendingClip === EO_CLIP) {
        ctx.clip("evenodd");
      } else {
        ctx.clip();
      }

      this.pendingClip = null;
    }

    this.current.startNewPathAndClipBox(this.current.clipBox);
    ctx.beginPath();
  }

  getSinglePixelWidth() {
    if (this._cachedGetSinglePixelWidth === null) {
      const m = this.ctx.mozCurrentTransform;
      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
      const sqNorm1 = m[0] ** 2 + m[2] ** 2;
      const sqNorm2 = m[1] ** 2 + m[3] ** 2;
      const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;

      if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
        this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
      } else if (absDet > Number.EPSILON) {
        this._cachedGetSinglePixelWidth = pixelHeight;
      } else {
        this._cachedGetSinglePixelWidth = 1;
      }
    }

    return this._cachedGetSinglePixelWidth;
  }

  getCanvasPosition(x, y) {
    const transform = this.ctx.mozCurrentTransform;
    return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
  }

  isContentVisible() {
    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
      if (!this.markedContentStack[i].visible) {
        return false;
      }
    }

    return true;
  }

}

exports.CanvasGraphics = CanvasGraphics;

for (const op in _util.OPS) {
  if (CanvasGraphics.prototype[op] !== undefined) {
    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
  }
}

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TilingPattern = exports.PathType = void 0;
exports.getShadingPattern = getShadingPattern;

var _util = __w_pdfjs_require__(2);

const PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
exports.PathType = PathType;

function applyBoundingBox(ctx, bbox) {
  if (!bbox || typeof Path2D === "undefined") {
    return;
  }

  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}

class BaseShadingPattern {
  constructor() {
    if (this.constructor === BaseShadingPattern) {
      (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
    }
  }

  getPattern() {
    (0, _util.unreachable)("Abstract method `getPattern` called.");
  }

}

class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }

  _createGradient(ctx) {
    let grad;

    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }

    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }

    return grad;
  }

  getPattern(ctx, owner, inverse, pathType) {
    let pattern;

    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform.apply(tmpCtx, owner.baseTransform);

      if (this.matrix) {
        tmpCtx.transform.apply(tmpCtx, this.matrix);
      }

      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);

      try {
        pattern.setTransform(domMatrix);
      } catch (ex) {
        (0, _util.warn)(`RadialAxialShadingPattern.getPattern: "${ex?.message}".`);
      }
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }

    return pattern;
  }

}

function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords,
        colors = context.colors;
  const bytes = data.data,
        rowSize = data.width * 4;
  let tmp;

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

  if (y1 >= y3) {
    return;
  }

  const c1r = colors[c1],
        c1g = colors[c1 + 1],
        c1b = colors[c1 + 2];
  const c2r = colors[c2],
        c2g = colors[c2 + 1],
        c2b = colors[c2 + 2];
  const c3r = colors[c3],
        c3g = colors[c3 + 1],
        c3b = colors[c3 + 2];
  const minY = Math.round(y1),
        maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;

  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      let k;

      if (y < y1) {
        k = 0;
      } else {
        k = (y1 - y) / (y1 - y2);
      }

      xa = x1 - (x1 - x2) * k;
      car = c1r - (c1r - c2r) * k;
      cag = c1g - (c1g - c2g) * k;
      cab = c1b - (c1b - c2b) * k;
    } else {
      let k;

      if (y > y3) {
        k = 1;
      } else if (y2 === y3) {
        k = 0;
      } else {
        k = (y2 - y) / (y2 - y3);
      }

      xa = x2 - (x2 - x3) * k;
      car = c2r - (c2r - c3r) * k;
      cag = c2g - (c2g - c3g) * k;
      cab = c2b - (c2b - c3b) * k;
    }

    let k;

    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }

    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;

    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);

      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }

      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}

function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;

  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;

      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;

        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }

      break;

    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }

      break;

    default:
      throw new Error("illegal figure");
  }
}

class MeshShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[7];
    this._background = IR[8];
    this.matrix = null;
  }

  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3000;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);

    if (backgroundColor) {
      const bytes = data.data;

      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }

    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }

    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }

  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    let scale;

    if (pathType === PathType.SHADING) {
      scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
    } else {
      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

      if (this.matrix) {
        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
      }
    }

    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);

    if (pathType !== PathType.SHADING) {
      ctx.setTransform.apply(ctx, owner.baseTransform);

      if (this.matrix) {
        ctx.transform.apply(ctx, this.matrix);
      }
    }

    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }

}

class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }

}

function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);

    case "Mesh":
      return new MeshShadingPattern(IR);

    case "Dummy":
      return new DummyShadingPattern();
  }

  throw new Error(`Unknown IR type: ${IR[0]}`);
}

const PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};

class TilingPattern {
  static get MAX_PATTERN_SIZE() {
    return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
  }

  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }

  createPatternCanvas(owner) {
    const operatorList = this.operatorList;
    const bbox = this.bbox;
    const xstep = this.xstep;
    const ystep = this.ystep;
    const paintType = this.paintType;
    const tilingType = this.tilingType;
    const color = this.color;
    const canvasGraphicsFactory = this.canvasGraphicsFactory;
    (0, _util.info)("TilingType: " + tilingType);
    const x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3];

    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    let adjustedX0 = x0;
    let adjustedY0 = y0;
    let adjustedX1 = x1;
    let adjustedY1 = y1;

    if (x0 < 0) {
      adjustedX0 = 0;
      adjustedX1 += Math.abs(x0);
    }

    if (y0 < 0) {
      adjustedY0 = 0;
      adjustedY1 += Math.abs(y0);
    }

    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
    graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: adjustedX0,
      offsetY: adjustedY0
    };
  }

  getSizeAndScale(step, realOutputSize, scale) {
    step = Math.abs(step);
    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);

    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }

    return {
      scale,
      size
    };
  }

  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    graphics.clip();
    graphics.endPath();
  }

  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx,
          current = graphics.current;

    switch (paintType) {
      case PaintType.COLORED:
        const ctx = this.ctx;
        context.fillStyle = ctx.fillStyle;
        context.strokeStyle = ctx.strokeStyle;
        current.fillColor = ctx.fillStyle;
        current.strokeColor = ctx.strokeStyle;
        break;

      case PaintType.UNCOLORED:
        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

        context.fillStyle = cssColor;
        context.strokeStyle = cssColor;
        current.fillColor = cssColor;
        current.strokeColor = cssColor;
        break;

      default:
        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
    }
  }

  getPattern(ctx, owner, inverse, pathType) {
    let matrix = inverse;

    if (pathType !== PathType.SHADING) {
      matrix = _util.Util.transform(matrix, owner.baseTransform);

      if (this.matrix) {
        matrix = _util.Util.transform(matrix, this.matrix);
      }
    }

    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");

    try {
      pattern.setTransform(domMatrix);
    } catch (ex) {
      (0, _util.warn)(`TilingPattern.getPattern: "${ex?.message}".`);
    }

    return pattern;
  }

}

exports.TilingPattern = TilingPattern;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlobalWorkerOptions = void 0;
const GlobalWorkerOptions = Object.create(null);
exports.GlobalWorkerOptions = GlobalWorkerOptions;
GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;

var _util = __w_pdfjs_require__(2);

const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};

function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    (0, _util.warn)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
    return reason;
  }

  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);

    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);

    case "PasswordException":
      return new _util.PasswordException(reason.message, reason.code);

    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);

    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);

    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}

class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);

    this._onComObjOnMessage = event => {
      const data = event.data;

      if (data.targetName !== this.sourceName) {
        return;
      }

      if (data.stream) {
        this._processStreamMessage(data);

        return;
      }

      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];

        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }

        delete this.callbackCapabilities[callbackId];

        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }

        return;
      }

      const action = this.actionHandler[data.action];

      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }

      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }

      if (data.streamId) {
        this._createStreamSink(data);

        return;
      }

      action(data.data);
    };

    comObj.addEventListener("message", this._onComObjOnMessage);
  }

  on(actionName, handler) {
    const ah = this.actionHandler;

    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }

    ah[actionName] = handler;
  }

  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }

  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = (0, _util.createPromiseCapability)();
    this.callbackCapabilities[callbackId] = capability;

    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }

    return capability.promise;
  }

  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++,
          sourceName = this.sourceName,
          targetName = this.targetName,
          comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }

  _createStreamSink(data) {
    const streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
    const self = this,
          action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }

        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;

        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = (0, _util.createPromiseCapability)();
          this.ready = this.sinkCapability.promise;
        }

        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },

      close() {
        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },

      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },

      sinkCapability: (0, _util.createPromiseCapability)(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }

  _processStreamMessage(data) {
    const streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
    const streamController = this.streamControllers[streamId],
          streamSink = this.streamSinks[streamId];

    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }

        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }

        streamSink.desiredSize = data.desiredSize;
        new Promise(function (resolve) {
          resolve(streamSink.onPull && streamSink.onPull());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;

      case StreamKind.ENQUEUE:
        (0, _util.assert)(streamController, "enqueue should have stream controller");

        if (streamController.isClosed) {
          break;
        }

        streamController.controller.enqueue(data.chunk);
        break;

      case StreamKind.CLOSE:
        (0, _util.assert)(streamController, "close should have stream controller");

        if (streamController.isClosed) {
          break;
        }

        streamController.isClosed = true;
        streamController.controller.close();

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.ERROR:
        (0, _util.assert)(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }

        new Promise(function (resolve) {
          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;

      default:
        throw new Error("Unexpected stream case");
    }
  }

  async _deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
    delete this.streamControllers[streamId];
  }

  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }

}

exports.MessageHandler = MessageHandler;

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Metadata = void 0;

var _util = __w_pdfjs_require__(2);

class Metadata {
  #metadataMap;
  #data;

  constructor({
    parsedData,
    rawData
  }) {
    this.#metadataMap = parsedData;
    this.#data = rawData;
  }

  getRaw() {
    return this.#data;
  }

  get(name) {
    return this.#metadataMap.get(name) ?? null;
  }

  getAll() {
    return (0, _util.objectFromMap)(this.#metadataMap);
  }

  has(name) {
    return this.#metadataMap.has(name);
  }

}

exports.Metadata = Metadata;

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionalContentConfig = void 0;

var _util = __w_pdfjs_require__(2);

class OptionalContentGroup {
  constructor(name, intent) {
    this.visible = true;
    this.name = name;
    this.intent = intent;
  }

}

class OptionalContentConfig {
  constructor(data) {
    this.name = null;
    this.creator = null;
    this._order = null;
    this._groups = new Map();

    if (data === null) {
      return;
    }

    this.name = data.name;
    this.creator = data.creator;
    this._order = data.order;

    for (const group of data.groups) {
      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
    }

    if (data.baseState === "OFF") {
      for (const group of this._groups) {
        group.visible = false;
      }
    }

    for (const on of data.on) {
      this._groups.get(on).visible = true;
    }

    for (const off of data.off) {
      this._groups.get(off).visible = false;
    }
  }

  _evaluateVisibilityExpression(array) {
    const length = array.length;

    if (length < 2) {
      return true;
    }

    const operator = array[0];

    for (let i = 1; i < length; i++) {
      const element = array[i];
      let state;

      if (Array.isArray(element)) {
        state = this._evaluateVisibilityExpression(element);
      } else if (this._groups.has(element)) {
        state = this._groups.get(element).visible;
      } else {
        (0, _util.warn)(`Optional content group not found: ${element}`);
        return true;
      }

      switch (operator) {
        case "And":
          if (!state) {
            return false;
          }

          break;

        case "Or":
          if (state) {
            return true;
          }

          break;

        case "Not":
          return !state;

        default:
          return true;
      }
    }

    return operator === "And";
  }

  isVisible(group) {
    if (this._groups.size === 0) {
      return true;
    }

    if (!group) {
      (0, _util.warn)("Optional content group not defined.");
      return true;
    }

    if (group.type === "OCG") {
      if (!this._groups.has(group.id)) {
        (0, _util.warn)(`Optional content group not found: ${group.id}`);
        return true;
      }

      return this._groups.get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return this._evaluateVisibilityExpression(group.expression);
      }

      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (this._groups.get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!this._groups.get(id).visible) {
            return false;
          }
        }

        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!this._groups.get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (this._groups.get(id).visible) {
            return false;
          }
        }

        return true;
      }

      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
      return true;
    }

    (0, _util.warn)(`Unknown group type ${group.type}.`);
    return true;
  }

  setVisibility(id, visible = true) {
    if (!this._groups.has(id)) {
      (0, _util.warn)(`Optional content group not found: ${id}`);
      return;
    }

    this._groups.get(id).visible = !!visible;
  }

  getOrder() {
    if (!this._groups.size) {
      return null;
    }

    if (this._order) {
      return this._order.slice();
    }

    return Array.from(this._groups.keys());
  }

  getGroups() {
    return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;
  }

  getGroup(id) {
    return this._groups.get(id) || null;
  }

}

exports.OptionalContentConfig = OptionalContentConfig;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDataTransportStream = void 0;

var _util = __w_pdfjs_require__(2);

var _display_utils = __w_pdfjs_require__(1);

class PDFDataTransportStream {
  constructor(params, pdfDataRangeTransport) {
    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    this._queuedChunks = [];
    this._progressiveDone = params.progressiveDone || false;
    this._contentDispositionFilename = params.contentDispositionFilename || null;
    const initialData = params.initialData;

    if (initialData?.length > 0) {
      const buffer = new Uint8Array(initialData).buffer;

      this._queuedChunks.push(buffer);
    }

    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !params.disableStream;
    this._isRangeSupported = !params.disableRange;
    this._contentLength = params.length;
    this._fullRequestReader = null;
    this._rangeReaders = [];

    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });

    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
      this._onReceiveData({
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });

    this._pdfDataRangeTransport.transportReady();
  }

  _onReceiveData(args) {
    const buffer = new Uint8Array(args.chunk).buffer;

    if (args.begin === undefined) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function (rangeReader) {
        if (rangeReader._begin !== args.begin) {
          return false;
        }

        rangeReader._enqueue(buffer);

        return true;
      });

      (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  _onProgress(evt) {
    if (evt.total === undefined) {
      const firstReader = this._rangeReaders[0];

      if (firstReader?.onProgress) {
        firstReader.onProgress({
          loaded: evt.loaded
        });
      }
    } else {
      const fullReader = this._fullRequestReader;

      if (fullReader?.onProgress) {
        fullReader.onProgress({
          loaded: evt.loaded,
          total: evt.total
        });
      }
    }
  }

  _onProgressiveDone() {
    if (this._fullRequestReader) {
      this._fullRequestReader.progressiveDone();
    }

    this._progressiveDone = true;
  }

  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);

    this._pdfDataRangeTransport.requestDataRange(begin, end);

    this._rangeReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }

    this._pdfDataRangeTransport.abort();
  }

}

exports.PDFDataTransportStream = PDFDataTransportStream;

class PDFDataTransportStreamReader {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;

    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }

    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }

    this._loaded += chunk.byteLength;
  }

  get headersReady() {
    return this._headersReady;
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }

  get contentLength() {
    return this._stream._contentLength;
  }

  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  progressiveDone() {
    if (this._done) {
      return;
    }

    this._done = true;
  }

}

class PDFDataTransportStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();

      requestsCapability.resolve({
        value: chunk,
        done: false
      });

      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      }

      this._requests.length = 0;
    }

    this._done = true;

    this._stream._removeRangeReader(this);
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._stream._removeRangeReader(this);
  }

}

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaText = void 0;

class XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: Object.create(null)
    };

    function walk(node) {
      if (!node) {
        return;
      }

      let str = null;
      const name = node.name;

      if (name === "#text") {
        str = node.value;
      } else if (!XfaText.shouldBuildText(name)) {
        return;
      } else if (node?.attributes?.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }

      if (str !== null) {
        items.push({
          str
        });
      }

      if (!node.children) {
        return;
      }

      for (const child of node.children) {
        walk(child);
      }
    }

    walk(xfa);
    return output;
  }

  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }

}

exports.XfaText = XfaText;

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationLayer = void 0;

var _util = __w_pdfjs_require__(2);

var _display_utils = __w_pdfjs_require__(1);

var _annotation_storage = __w_pdfjs_require__(9);

var _scripting_utils = __w_pdfjs_require__(19);

var _xfa_layer = __w_pdfjs_require__(20);

const DEFAULT_TAB_INDEX = 1000;
const GetElementsByNameSet = new WeakSet();

class AnnotationElementFactory {
  static create(parameters) {
    const subtype = parameters.data.annotationType;

    switch (subtype) {
      case _util.AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);

      case _util.AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);

      case _util.AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;

        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);

          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }

            return new PushButtonWidgetAnnotationElement(parameters);

          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
        }

        return new WidgetAnnotationElement(parameters);

      case _util.AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);

      case _util.AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);

      case _util.AnnotationType.LINE:
        return new LineAnnotationElement(parameters);

      case _util.AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);

      case _util.AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);

      case _util.AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);

      case _util.AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);

      case _util.AnnotationType.INK:
        return new InkAnnotationElement(parameters);

      case _util.AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);

      case _util.AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);

      case _util.AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);

      case _util.AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);

      case _util.AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);

      case _util.AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);

      case _util.AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);

      default:
        return new AnnotationElement(parameters);
    }
  }

}

class AnnotationElement {
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.page = parameters.page;
    this.viewport = parameters.viewport;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this._mouseState = parameters.mouseState;

    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }

    if (createQuadrilaterals) {
      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
    }
  }

  _createContainer(ignoreBorder = false) {
    const data = this.data,
          page = this.page,
          viewport = this.viewport;
    const container = document.createElement("section");
    let width = data.rect[2] - data.rect[0];
    let height = data.rect[3] - data.rect[1];
    container.setAttribute("data-annotation-id", data.id);

    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

    if (data.hasOwnCanvas) {
      const transform = viewport.transform.slice();

      const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(transform);

      width = Math.ceil(width * scaleX);
      height = Math.ceil(height * scaleY);
      rect[0] *= scaleX;
      rect[1] *= scaleY;

      for (let i = 0; i < 4; i++) {
        transform[i] = Math.sign(transform[i]);
      }

      container.style.transform = `matrix(${transform.join(",")})`;
    } else {
      container.style.transform = `matrix(${viewport.transform.join(",")})`;
    }

    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;

    if (!ignoreBorder && data.borderStyle.width > 0) {
      container.style.borderWidth = `${data.borderStyle.width}px`;

      if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
        width -= 2 * data.borderStyle.width;
        height -= 2 * data.borderStyle.width;
      }

      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;

      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `${horizontalRadius}px / ${verticalRadius}px`;
        container.style.borderRadius = radius;
      }

      switch (data.borderStyle.style) {
        case _util.AnnotationBorderStyleType.SOLID:
          container.style.borderStyle = "solid";
          break;

        case _util.AnnotationBorderStyleType.DASHED:
          container.style.borderStyle = "dashed";
          break;

        case _util.AnnotationBorderStyleType.BEVELED:
          (0, _util.warn)("Unimplemented border style: beveled");
          break;

        case _util.AnnotationBorderStyleType.INSET:
          (0, _util.warn)("Unimplemented border style: inset");
          break;

        case _util.AnnotationBorderStyleType.UNDERLINE:
          container.style.borderBottomStyle = "solid";
          break;

        default:
          break;
      }

      const borderColor = data.borderColor || data.color || null;

      if (borderColor) {
        container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
      } else {
        container.style.borderWidth = 0;
      }
    }

    container.style.left = `${rect[0]}px`;
    container.style.top = `${rect[1]}px`;

    if (data.hasOwnCanvas) {
      container.style.width = container.style.height = "auto";
    } else {
      container.style.width = `${width}px`;
      container.style.height = `${height}px`;
    }

    return container;
  }

  _createQuadrilaterals(ignoreBorder = false) {
    if (!this.data.quadPoints) {
      return null;
    }

    const quadrilaterals = [];
    const savedRect = this.data.rect;

    for (const quadPoint of this.data.quadPoints) {
      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
      quadrilaterals.push(this._createContainer(ignoreBorder));
    }

    this.data.rect = savedRect;
    return quadrilaterals;
  }

  _createPopup(trigger, data) {
    let container = this.container;

    if (this.quadrilaterals) {
      trigger = trigger || this.quadrilaterals;
      container = this.quadrilaterals[0];
    }

    if (!trigger) {
      trigger = document.createElement("div");
      trigger.style.height = container.style.height;
      trigger.style.width = container.style.width;
      container.appendChild(trigger);
    }

    const popupElement = new PopupElement({
      container,
      trigger,
      color: data.color,
      titleObj: data.titleObj,
      modificationDate: data.modificationDate,
      contentsObj: data.contentsObj,
      richText: data.richText,
      hideWrapper: true
    });
    const popup = popupElement.render();
    popup.style.left = container.style.width;
    container.appendChild(popup);
  }

  _renderQuadrilaterals(className) {
    for (const quadrilateral of this.quadrilaterals) {
      quadrilateral.className = className;
    }

    return this.quadrilaterals;
  }

  render() {
    (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
  }

  _getElementsByName(name, skipId = null) {
    const fields = [];

    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];

      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }

          if (id === skipId) {
            continue;
          }

          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.getElementById(id);

          if (domElement && !GetElementsByNameSet.has(domElement)) {
            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }

          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }

      return fields;
    }

    for (const domElement of document.getElementsByName(name)) {
      const {
        id,
        exportValue
      } = domElement;

      if (id === skipId) {
        continue;
      }

      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }

      fields.push({
        id,
        exportValue,
        domElement
      });
    }

    return fields;
  }

  static get platform() {
    const platform = typeof navigator !== "undefined" ? navigator.platform : "";
    return (0, _util.shadow)(this, "platform", {
      isWin: platform.includes("Win"),
      isMac: platform.includes("Mac")
    });
  }

}

class LinkAnnotationElement extends AnnotationElement {
  constructor(parameters, options = null) {
    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
    super(parameters, {
      isRenderable,
      ignoreBorder: !!options?.ignoreBorder,
      createQuadrilaterals: true
    });
  }

  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");

    if (data.url) {
      if (!linkService.addLinkAttributes) {
        (0, _util.warn)("LinkAnnotationElement.render - missing `addLinkAttributes`-method on the `linkService`-instance.");
      }

      linkService.addLinkAttributes?.(link, data.url, data.newWindow);
    } else if (data.action) {
      this._bindNamedAction(link, data.action);
    } else if (data.dest) {
      this._bindLink(link, data.dest);
    } else {
      let hasClickAction = false;

      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        hasClickAction = true;

        this._bindJSAction(link, data);
      }

      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);
      } else if (!hasClickAction) {
        this._bindLink(link, "");
      }
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
        const linkElement = index === 0 ? link : link.cloneNode();
        quadrilateral.appendChild(linkElement);
        return quadrilateral;
      });
    }

    this.container.className = "linkAnnotation";
    this.container.appendChild(link);
    return this.container;
  }

  _bindLink(link, destination) {
    link.href = this.linkService.getDestinationHash(destination);

    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }

      return false;
    };

    if (destination || destination === "") {
      link.className = "internalLink";
    }
  }

  _bindNamedAction(link, action) {
    link.href = this.linkService.getAnchorUrl("");

    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };

    link.className = "internalLink";
  }

  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);

      if (!jsName) {
        continue;
      }

      link[jsName] = () => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }

    if (!link.onclick) {
      link.onclick = () => false;
    }

    link.className = "internalLink";
  }

  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;

    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }

    link.className = "internalLink";

    if (!this._fieldObjects) {
      (0, _util.warn)(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");

      if (!otherClickAction) {
        link.onclick = () => false;
      }

      return;
    }

    link.onclick = () => {
      if (otherClickAction) {
        otherClickAction();
      }

      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];

      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);

        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];

          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }

        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }

      const storage = this.annotationStorage;
      const allIds = [];

      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);

        switch (field.type) {
          case "text":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value,
                valueAsString: value
              });
              break;
            }

          case "checkbox":
          case "radiobutton":
            {
              const value = field.defaultValue === field.exportValues;
              storage.setValue(id, {
                value
              });
              break;
            }

          case "combobox":
          case "listbox":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }

          default:
            continue;
        }

        const domElement = document.getElementById(id);

        if (!domElement || !GetElementsByNameSet.has(domElement)) {
          continue;
        }

        domElement.dispatchEvent(new Event("resetform"));
      }

      if (this.enableScripting) {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }

      return false;
    };
  }

}

class TextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    this.container.className = "textAnnotation";
    const image = document.createElement("img");
    image.style.height = this.container.style.height;
    image.style.width = this.container.style.width;
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.alt = "[{{type}} Annotation]";
    image.dataset.l10nId = "text_annotation_type";
    image.dataset.l10nArgs = JSON.stringify({
      type: this.data.name
    });

    if (!this.data.hasPopup) {
      this._createPopup(image, this.data);
    }

    this.container.appendChild(image);
    return this.container;
  }

}

class WidgetAnnotationElement extends AnnotationElement {
  render() {
    if (this.data.alternativeText) {
      this.container.title = this.data.alternativeText;
    }

    return this.container;
  }

  _getKeyModifier(event) {
    const {
      isWin,
      isMac
    } = AnnotationElement.platform;
    return isWin && event.ctrlKey || isMac && event.metaKey;
  }

  _setEventListener(element, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: event.target.checked
          }
        });
      });
    }
  }

  _setEventListeners(element, names, getter) {
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || this.data.actions?.[eventName]) {
        this._setEventListener(element, baseName, eventName, getter);
      }
    }
  }

  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
  }

  _dispatchEventFromSandbox(actions, jsEvent) {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
    };

    const commonActions = {
      display: event => {
        const hidden = event.detail.display % 2 === 1;
        event.target.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden,
          print: event.detail.display === 0 || event.detail.display === 3
        });
      },
      print: event => {
        this.annotationStorage.setValue(this.data.id, {
          print: event.detail.print
        });
      },
      hidden: event => {
        event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden: event.detail.hidden
        });
      },
      focus: event => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: event => {
        event.target.title = event.detail.userName;
      },
      readonly: event => {
        if (event.detail.readonly) {
          event.target.setAttribute("readonly", "");
        } else {
          event.target.removeAttribute("readonly");
        }
      },
      required: event => {
        if (event.detail.required) {
          event.target.setAttribute("required", "");
        } else {
          event.target.removeAttribute("required");
        }
      },
      bgColor: event => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: event => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: event => {
        setColor("fgColor", "color", event);
      },
      textColor: event => {
        setColor("textColor", "color", event);
      },
      borderColor: event => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: event => {
        setColor("strokeColor", "borderColor", event);
      }
    };

    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];

      if (action) {
        action(jsEvent);
      }
    }
  }

}

class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }

  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;

    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }

      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }

  render() {
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.className = "textWidgetAnnotation";
    let element = null;

    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue,
        valueAsString: this.data.fieldValue
      });
      const textContent = storedData.valueAsString || storedData.value || "";
      const elementData = {
        userValue: null,
        formattedValue: null,
        beforeInputSelectionRange: null,
        beforeInputValue: null
      };

      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = textContent;
      } else {
        element = document.createElement("input");
        element.type = "text";
        element.setAttribute("value", textContent);
      }

      GetElementsByNameSet.add(element);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = DEFAULT_TAB_INDEX;
      elementData.userValue = textContent;
      element.setAttribute("id", id);
      element.addEventListener("input", event => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
      });
      element.addEventListener("resetform", event => {
        const defaultValue = this.data.defaultFieldValue || "";
        element.value = elementData.userValue = defaultValue;
        delete elementData.formattedValue;
      });

      let blurListener = event => {
        if (elementData.formattedValue) {
          event.target.value = elementData.formattedValue;
        }

        event.target.scrollLeft = 0;
        elementData.beforeInputSelectionRange = null;
      };

      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", event => {
          if (elementData.userValue) {
            event.target.value = elementData.userValue;
          }
        });
        element.addEventListener("updatefromsandbox", jsEvent => {
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value || "";
              storage.setValue(id, {
                value: elementData.userValue.toString()
              });

              if (!elementData.formattedValue) {
                event.target.value = elementData.userValue;
              }
            },

            valueAsString(event) {
              elementData.formattedValue = event.detail.valueAsString || "";

              if (event.target !== document.activeElement) {
                event.target.value = elementData.formattedValue;
              }

              storage.setValue(id, {
                formattedValue: elementData.formattedValue
              });
            },

            selRange(event) {
              const [selStart, selEnd] = event.detail.selRange;

              if (selStart >= 0 && selEnd < event.target.value.length) {
                event.target.setSelectionRange(selStart, selEnd);
              }
            }

          };

          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", event => {
          elementData.beforeInputValue = event.target.value;
          let commitKey = -1;

          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter") {
            commitKey = 2;
          } else if (event.key === "Tab") {
            commitKey = 3;
          }

          if (commitKey === -1) {
            return;
          }

          elementData.userValue = event.target.value;
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value: event.target.value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", event => {
          if (this._mouseState.isDown) {
            elementData.userValue = event.target.value;
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value: event.target.value,
                willCommit: true,
                commitKey: 1,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }

          _blurListener(event);
        });
        element.addEventListener("mousedown", event => {
          elementData.beforeInputValue = event.target.value;
          elementData.beforeInputSelectionRange = null;
        });
        element.addEventListener("keyup", event => {
          if (event.target.selectionStart === event.target.selectionEnd) {
            elementData.beforeInputSelectionRange = null;
          }
        });
        element.addEventListener("select", event => {
          elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
        });

        if (this.data.actions?.Keystroke) {
          element.addEventListener("input", event => {
            let selStart = -1;
            let selEnd = -1;

            if (elementData.beforeInputSelectionRange) {
              [selStart, selEnd] = elementData.beforeInputSelectionRange;
            }

            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value: elementData.beforeInputValue,
                change: event.data,
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }

        this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
      }

      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }

      if (this.data.maxLen !== null) {
        element.maxLength = this.data.maxLen;
      }

      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / this.data.maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
    }

    this._setTextStyle(element);

    this._setBackgroundColor(element);

    this.container.appendChild(element);
    return this.container;
  }

  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontSize,
      fontColor
    } = this.data.defaultAppearanceData;
    const style = element.style;

    if (fontSize) {
      style.fontSize = `${fontSize}px`;
    }

    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }

}

class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;

    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }

    this.container.className = "buttonWidgetAnnotation checkBox";
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.disabled = data.readOnly;
    element.type = "checkbox";
    element.name = data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.setAttribute("id", id);
    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;

      for (const checkbox of this._getElementsByName(name, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;

        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }

        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }

      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });

    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this._setBackgroundColor(element);

    this.container.appendChild(element);
    return this.container;
  }

}

class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    this.container.className = "buttonWidgetAnnotation radioButton";
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;

    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }

    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.disabled = data.readOnly;
    element.type = "radio";
    element.name = data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.setAttribute("id", id);
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;

      for (const radio of this._getElementsByName(name, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }

      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
    });

    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value: event => {
            const checked = pdfButtonValue === event.detail.value;

            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;

              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }

              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this._setBackgroundColor(element);

    this.container.appendChild(element);
    return this.container;
  }

}

class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }

  render() {
    const container = super.render();
    container.className = "buttonWidgetAnnotation pushButton";

    if (this.data.alternativeText) {
      container.title = this.data.alternativeText;
    }

    return container;
  }

}

class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    this.container.className = "choiceWidgetAnnotation";
    const storage = this.annotationStorage;
    const id = this.data.id;
    storage.getValue(id, {
      value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined
    });
    let {
      fontSize
    } = this.data.defaultAppearanceData;

    if (!fontSize) {
      fontSize = 9;
    }

    const fontSizeStyle = `calc(${fontSize}px * var(--zoom-factor))`;
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.disabled = this.data.readOnly;
    selectElement.name = this.data.fieldName;
    selectElement.setAttribute("id", id);
    selectElement.tabIndex = DEFAULT_TAB_INDEX;
    selectElement.style.fontSize = `${fontSize}px`;

    if (!this.data.combo) {
      selectElement.size = this.data.options.length;

      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }

    selectElement.addEventListener("resetform", event => {
      const defaultValue = this.data.defaultFieldValue;

      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });

    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;

      if (this.data.combo) {
        optionElement.style.fontSize = fontSizeStyle;
      }

      if (this.data.fieldValue.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
      }

      selectElement.appendChild(optionElement);
    }

    const getValue = (event, isExport) => {
      const name = isExport ? "value" : "textContent";
      const options = event.target.options;

      if (!event.target.multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }

      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
    };

    const getItems = event => {
      const options = event.target.options;
      return Array.prototype.map.call(options, option => {
        return {
          displayValue: option.textContent,
          exportValue: option.value
        };
      });
    };

    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);

            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }

            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          multipleSelection(event) {
            selectElement.multiple = true;
          },

          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);

            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, option => option.selected);

              if (i === -1) {
                options[0].selected = true;
              }
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            storage.setValue(id, {
              value: null,
              items: []
            });
          },

          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            selectElement.insertBefore(optionElement, selectElement.children[index]);
            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          items(event) {
            const {
              items
            } = event.detail;

            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.appendChild(optionElement);
            }

            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          indices(event) {
            const indices = new Set(event.detail.indices);

            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }

            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          editable(event) {
            event.target.disabled = !event.detail.editable;
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", event => {
        const exportValue = getValue(event, true);
        const value = getValue(event, false);
        storage.setValue(id, {
          value: exportValue
        });
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value,
            changeEx: exportValue,
            willCommit: true,
            commitKey: 1,
            keyDown: false
          }
        });
      });

      this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], event => event.target.checked);
    } else {
      selectElement.addEventListener("input", function (event) {
        storage.setValue(id, {
          value: getValue(event)
        });
      });
    }

    this._setBackgroundColor(selectElement);

    this.container.appendChild(selectElement);
    return this.container;
  }

}

class PopupAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
    this.container.className = "popupAnnotation";

    if (IGNORE_TYPES.includes(this.data.parentType)) {
      return this.container;
    }

    const selector = `[data-annotation-id="${this.data.parentId}"]`;
    const parentElements = this.layer.querySelectorAll(selector);

    if (parentElements.length === 0) {
      return this.container;
    }

    const popup = new PopupElement({
      container: this.container,
      trigger: Array.from(parentElements),
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText
    });
    const page = this.page;

    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
    const popupTop = rect[1];
    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;
    this.container.style.left = `${popupLeft}px`;
    this.container.style.top = `${popupTop}px`;
    this.container.appendChild(popup.render());
    return this.container;
  }

}

class PopupElement {
  constructor(parameters) {
    this.container = parameters.container;
    this.trigger = parameters.trigger;
    this.color = parameters.color;
    this.titleObj = parameters.titleObj;
    this.modificationDate = parameters.modificationDate;
    this.contentsObj = parameters.contentsObj;
    this.richText = parameters.richText;
    this.hideWrapper = parameters.hideWrapper || false;
    this.pinned = false;
  }

  render() {
    const BACKGROUND_ENLIGHT = 0.7;
    const wrapper = document.createElement("div");
    wrapper.className = "popupWrapper";
    this.hideElement = this.hideWrapper ? wrapper : this.container;
    this.hideElement.hidden = true;
    const popup = document.createElement("div");
    popup.className = "popup";
    const color = this.color;

    if (color) {
      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
    }

    const title = document.createElement("h1");
    title.dir = this.titleObj.dir;
    title.textContent = this.titleObj.str;
    popup.appendChild(title);

    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

    if (dateObject) {
      const modificationDate = document.createElement("span");
      modificationDate.className = "popupDate";
      modificationDate.textContent = "{{date}}, {{time}}";
      modificationDate.dataset.l10nId = "annotation_date_string";
      modificationDate.dataset.l10nArgs = JSON.stringify({
        date: dateObject.toLocaleDateString(),
        time: dateObject.toLocaleTimeString()
      });
      popup.appendChild(modificationDate);
    }

    if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {
      _xfa_layer.XfaLayer.render({
        xfaHtml: this.richText.html,
        intent: "richText",
        div: popup
      });

      popup.lastChild.className = "richText popupContent";
    } else {
      const contents = this._formatContents(this.contentsObj);

      popup.appendChild(contents);
    }

    if (!Array.isArray(this.trigger)) {
      this.trigger = [this.trigger];
    }

    for (const element of this.trigger) {
      element.addEventListener("click", this._toggle.bind(this));
      element.addEventListener("mouseover", this._show.bind(this, false));
      element.addEventListener("mouseout", this._hide.bind(this, false));
    }

    popup.addEventListener("click", this._hide.bind(this, true));
    wrapper.appendChild(popup);
    return wrapper;
  }

  _formatContents({
    str,
    dir
  }) {
    const p = document.createElement("p");
    p.className = "popupContent";
    p.dir = dir;
    const lines = str.split(/(?:\r\n?|\n)/);

    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.appendChild(document.createTextNode(line));

      if (i < ii - 1) {
        p.appendChild(document.createElement("br"));
      }
    }

    return p;
  }

  _toggle() {
    if (this.pinned) {
      this._hide(true);
    } else {
      this._show(true);
    }
  }

  _show(pin = false) {
    if (pin) {
      this.pinned = true;
    }

    if (this.hideElement.hidden) {
      this.hideElement.hidden = false;
      this.container.style.zIndex += 1;
    }
  }

  _hide(unpin = true) {
    if (unpin) {
      this.pinned = false;
    }

    if (!this.hideElement.hidden && !this.pinned) {
      this.hideElement.hidden = true;
      this.container.style.zIndex -= 1;
    }
  }

}

class FreeTextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "freeTextAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class LineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "lineAnnotation";
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    const line = this.svgFactory.createElement("svg:line");
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.appendChild(line);
    this.container.append(svg);

    this._createPopup(line, data);

    return this.container;
  }

}

class SquareAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "squareAnnotation";
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    const borderWidth = data.borderStyle.width;
    const square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.appendChild(square);
    this.container.append(svg);

    this._createPopup(square, data);

    return this.container;
  }

}

class CircleAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "circleAnnotation";
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    const borderWidth = data.borderStyle.width;
    const circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.appendChild(circle);
    this.container.append(svg);

    this._createPopup(circle, data);

    return this.container;
  }

}

class PolylineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    let points = [];

    for (const coordinate of data.vertices) {
      const x = coordinate.x - data.rect[0];
      const y = data.rect[3] - coordinate.y;
      points.push(x + "," + y);
    }

    points = points.join(" ");
    const polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.appendChild(polyline);
    this.container.append(svg);

    this._createPopup(polyline, data);

    return this.container;
  }

}

class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }

}

class CaretAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "caretAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class InkAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);

    for (const inkList of data.inkLists) {
      let points = [];

      for (const coordinate of inkList) {
        const x = coordinate.x - data.rect[0];
        const y = data.rect[3] - coordinate.y;
        points.push(`${x},${y}`);
      }

      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "transparent");

      this._createPopup(polyline, data);

      svg.appendChild(polyline);
    }

    this.container.append(svg);
    return this.container;
  }

}

class HighlightAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("highlightAnnotation");
    }

    this.container.className = "highlightAnnotation";
    return this.container;
  }

}

class UnderlineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("underlineAnnotation");
    }

    this.container.className = "underlineAnnotation";
    return this.container;
  }

}

class SquigglyAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("squigglyAnnotation");
    }

    this.container.className = "squigglyAnnotation";
    return this.container;
  }

}

class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("strikeoutAnnotation");
    }

    this.container.className = "strikeoutAnnotation";
    return this.container;
  }

}

class StampAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "stampAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class FileAttachmentAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
    const {
      filename,
      content
    } = this.data.file;
    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
    this.content = content;
    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      id: (0, _util.stringToPDFString)(filename),
      filename,
      content
    });
  }

  render() {
    this.container.className = "fileAttachmentAnnotation";
    const trigger = document.createElement("div");
    trigger.style.height = this.container.style.height;
    trigger.style.width = this.container.style.width;
    trigger.addEventListener("dblclick", this._download.bind(this));

    if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {
      this._createPopup(trigger, this.data);
    }

    this.container.appendChild(trigger);
    return this.container;
  }

  _download() {
    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
  }

}

class AnnotationLayer {
  static render(parameters) {
    const sortedAnnotations = [],
          popupAnnotations = [];

    for (const data of parameters.annotations) {
      if (!data) {
        continue;
      }

      if (data.annotationType === _util.AnnotationType.POPUP) {
        popupAnnotations.push(data);
        continue;
      }

      sortedAnnotations.push(data);
    }

    if (popupAnnotations.length) {
      sortedAnnotations.push(...popupAnnotations);
    }

    const div = parameters.div;

    for (const data of sortedAnnotations) {
      const element = AnnotationElementFactory.create({
        data,
        layer: div,
        page: parameters.page,
        viewport: parameters.viewport,
        linkService: parameters.linkService,
        downloadManager: parameters.downloadManager,
        imageResourcesPath: parameters.imageResourcesPath || "",
        renderForms: parameters.renderForms !== false,
        svgFactory: new _display_utils.DOMSVGFactory(),
        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
        enableScripting: parameters.enableScripting,
        hasJSActions: parameters.hasJSActions,
        fieldObjects: parameters.fieldObjects,
        mouseState: parameters.mouseState || {
          isDown: false
        }
      });

      if (element.isRenderable) {
        const rendered = element.render();

        if (data.hidden) {
          rendered.style.visibility = "hidden";
        }

        if (Array.isArray(rendered)) {
          for (const renderedElement of rendered) {
            div.appendChild(renderedElement);
          }
        } else {
          if (element instanceof PopupAnnotationElement) {
            div.prepend(rendered);
          } else {
            div.appendChild(rendered);
          }
        }
      }
    }

    this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);
  }

  static update(parameters) {
    const {
      page,
      viewport,
      annotations,
      annotationCanvasMap,
      div
    } = parameters;
    const transform = viewport.transform;
    const matrix = `matrix(${transform.join(",")})`;
    let scale, ownMatrix;

    for (const data of annotations) {
      const elements = div.querySelectorAll(`[data-annotation-id="${data.id}"]`);

      if (elements) {
        for (const element of elements) {
          if (data.hasOwnCanvas) {
            const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

            if (!ownMatrix) {
              scale = Math.abs(transform[0] || transform[1]);
              const ownTransform = transform.slice();

              for (let i = 0; i < 4; i++) {
                ownTransform[i] = Math.sign(ownTransform[i]);
              }

              ownMatrix = `matrix(${ownTransform.join(",")})`;
            }

            const left = rect[0] * scale;
            const top = rect[1] * scale;
            element.style.left = `${left}px`;
            element.style.top = `${top}px`;
            element.style.transformOrigin = `${-left}px ${-top}px`;
            element.style.transform = ownMatrix;
          } else {
            element.style.transform = matrix;
          }
        }
      }
    }

    this.#setAnnotationCanvasMap(div, annotationCanvasMap);
    div.hidden = false;
  }

  static #setAnnotationCanvasMap(div, annotationCanvasMap) {
    if (!annotationCanvasMap) {
      return;
    }

    for (const [id, canvas] of annotationCanvasMap) {
      const element = div.querySelector(`[data-annotation-id="${id}"]`);

      if (!element) {
        continue;
      }

      const {
        firstChild
      } = element;

      if (firstChild.nodeName === "CANVAS") {
        element.replaceChild(canvas, firstChild);
      } else {
        element.insertBefore(canvas, firstChild);
      }
    }

    annotationCanvasMap.clear();
  }

}

exports.AnnotationLayer = AnnotationLayer;

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorConverters = void 0;

function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}

class ColorConverters {
  static CMYK_G([c, y, m, k]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }

  static G_CMYK([g]) {
    return ["CMYK", 0, 0, 0, 1 - g];
  }

  static G_RGB([g]) {
    return ["RGB", g, g, g];
  }

  static G_HTML([g]) {
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }

  static RGB_G([r, g, b]) {
    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
  }

  static RGB_HTML([r, g, b]) {
    const R = makeColorComp(r);
    const G = makeColorComp(g);
    const B = makeColorComp(b);
    return `#${R}${G}${B}`;
  }

  static T_HTML() {
    return "#00000000";
  }

  static CMYK_RGB([c, y, m, k]) {
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }

  static CMYK_HTML(components) {
    return this.RGB_HTML(this.CMYK_RGB(components));
  }

  static RGB_CMYK([r, g, b]) {
    const c = 1 - r;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }

}

exports.ColorConverters = ColorConverters;

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaLayer = void 0;

var _util = __w_pdfjs_require__(2);

var _xfa_text = __w_pdfjs_require__(17);

class XfaLayer {
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });

    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }

        if (intent === "print") {
          break;
        }

        html.addEventListener("input", event => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;

      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }

          if (intent === "print") {
            break;
          }

          html.addEventListener("change", event => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }

          if (intent === "print") {
            break;
          }

          html.addEventListener("input", event => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }

        break;

      case "select":
        if (storedData.value !== null) {
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            }
          }
        }

        html.addEventListener("input", event => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }

  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;

    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }

    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === undefined || key === "dataId") {
        continue;
      }

      if (key !== "style") {
        if (key === "textContent") {
          html.textContent = value;
        } else if (key === "class") {
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }
        } else {
          if (isHTMLAnchorElement && (key === "href" || key === "newWindow")) {
            continue;
          }

          html.setAttribute(key, value);
        }
      } else {
        Object.assign(html.style, value);
      }
    }

    if (isHTMLAnchorElement) {
      if (!linkService.addLinkAttributes) {
        (0, _util.warn)("XfaLayer.setAttribute - missing `addLinkAttributes`-method on the `linkService`-instance.");
      }

      linkService.addLinkAttributes?.(html, attributes.href, attributes.newWindow);
    }

    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }

  static render(parameters) {
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);

    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }

    const stack = [[root, -1, rootHtml]];
    const rootDiv = parameters.div;
    rootDiv.appendChild(rootHtml);

    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }

    if (intent !== "richText") {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }

    const textDivs = [];

    while (stack.length > 0) {
      const [parent, i, html] = stack[stack.length - 1];

      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }

      const child = parent.children[++stack[stack.length - 1][1]];

      if (child === null) {
        continue;
      }

      const {
        name
      } = child;

      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.appendChild(node);
        continue;
      }

      let childHtml;

      if (child?.attributes?.xmlns) {
        childHtml = document.createElementNS(child.attributes.xmlns, name);
      } else {
        childHtml = document.createElement(name);
      }

      html.appendChild(childHtml);

      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }

      if (child.children && child.children.length > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);

        if (_xfa_text.XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }

        childHtml.appendChild(node);
      }
    }

    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }

    return {
      textDivs
    };
  }

  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }

}

exports.XfaLayer = XfaLayer;

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.renderTextLayer = renderTextLayer;

var _util = __w_pdfjs_require__(2);

const MAX_TEXT_DIVS_TO_RENDER = 100000;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
const ascentCache = new Map();
const AllWhitespaceRegexp = /^\s+$/g;

function getAscent(fontFamily, ctx) {
  const cachedAscent = ascentCache.get(fontFamily);

  if (cachedAscent) {
    return cachedAscent;
  }

  ctx.save();
  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
  const metrics = ctx.measureText("");
  let ascent = metrics.fontBoundingBoxAscent;
  let descent = Math.abs(metrics.fontBoundingBoxDescent);

  if (ascent) {
    ctx.restore();
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ctx.strokeStyle = "red";
  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("g", 0, 0);
  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  descent = 0;

  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
    if (pixels[i] > 0) {
      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  ascent = 0;

  for (let i = 0, ii = pixels.length; i < ii; i += 4) {
    if (pixels[i] > 0) {
      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.restore();

  if (ascent) {
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
  return DEFAULT_FONT_ASCENT;
}

function appendText(task, geom, styles, ctx) {
  const textDiv = document.createElement("span");
  const textDivProperties = task._enhanceTextSelection ? {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    originalTransform: null,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    scale: 1
  } : {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL
  };

  task._textDivs.push(textDiv);

  const tx = _util.Util.transform(task._viewport.transform, geom.transform);

  let angle = Math.atan2(tx[1], tx[0]);
  const style = styles[geom.fontName];

  if (style.vertical) {
    angle += Math.PI / 2;
  }

  const fontHeight = Math.hypot(tx[2], tx[3]);
  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
  let left, top;

  if (angle === 0) {
    left = tx[4];
    top = tx[5] - fontAscent;
  } else {
    left = tx[4] + fontAscent * Math.sin(angle);
    top = tx[5] - fontAscent * Math.cos(angle);
  }

  textDiv.style.left = `${left}px`;
  textDiv.style.top = `${top}px`;
  textDiv.style.fontSize = `${fontHeight}px`;
  textDiv.style.fontFamily = style.fontFamily;
  textDiv.setAttribute("role", "presentation");
  textDiv.textContent = geom.str;
  textDiv.dir = geom.dir;

  if (task._fontInspectorEnabled) {
    textDiv.dataset.fontName = geom.fontName;
  }

  if (angle !== 0) {
    textDivProperties.angle = angle * (180 / Math.PI);
  }

  let shouldScaleText = false;

  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
    shouldScaleText = true;
  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
    const absScaleX = Math.abs(geom.transform[0]),
          absScaleY = Math.abs(geom.transform[3]);

    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
      shouldScaleText = true;
    }
  }

  if (shouldScaleText) {
    if (style.vertical) {
      textDivProperties.canvasWidth = geom.height * task._viewport.scale;
    } else {
      textDivProperties.canvasWidth = geom.width * task._viewport.scale;
    }
  }

  task._textDivProperties.set(textDiv, textDivProperties);

  if (task._textContentStream) {
    task._layoutText(textDiv);
  }

  if (task._enhanceTextSelection && textDivProperties.hasText) {
    let angleCos = 1,
        angleSin = 0;

    if (angle !== 0) {
      angleCos = Math.cos(angle);
      angleSin = Math.sin(angle);
    }

    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
    const divHeight = fontHeight;
    let m, b;

    if (angle !== 0) {
      m = [angleCos, angleSin, -angleSin, angleCos, left, top];
      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
    } else {
      b = [left, top, left + divWidth, top + divHeight];
    }

    task._bounds.push({
      left: b[0],
      top: b[1],
      right: b[2],
      bottom: b[3],
      div: textDiv,
      size: [divWidth, divHeight],
      m
    });
  }
}

function render(task) {
  if (task._canceled) {
    return;
  }

  const textDivs = task._textDivs;
  const capability = task._capability;
  const textDivsLength = textDivs.length;

  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
    task._renderingDone = true;
    capability.resolve();
    return;
  }

  if (!task._textContentStream) {
    for (let i = 0; i < textDivsLength; i++) {
      task._layoutText(textDivs[i]);
    }
  }

  task._renderingDone = true;
  capability.resolve();
}

function findPositiveMin(ts, offset, count) {
  let result = 0;

  for (let i = 0; i < count; i++) {
    const t = ts[offset++];

    if (t > 0) {
      result = result ? Math.min(t, result) : t;
    }
  }

  return result;
}

function expand(task) {
  const bounds = task._bounds;
  const viewport = task._viewport;
  const expanded = expandBounds(viewport.width, viewport.height, bounds);

  for (let i = 0; i < expanded.length; i++) {
    const div = bounds[i].div;

    const divProperties = task._textDivProperties.get(div);

    if (divProperties.angle === 0) {
      divProperties.paddingLeft = bounds[i].left - expanded[i].left;
      divProperties.paddingTop = bounds[i].top - expanded[i].top;
      divProperties.paddingRight = expanded[i].right - bounds[i].right;
      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

      task._textDivProperties.set(div, divProperties);

      continue;
    }

    const e = expanded[i],
          b = bounds[i];
    const m = b.m,
          c = m[0],
          s = m[1];
    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
    const ts = new Float64Array(64);

    for (let j = 0, jj = points.length; j < jj; j++) {
      const t = _util.Util.applyTransform(points[j], m);

      ts[j + 0] = c && (e.left - t[0]) / c;
      ts[j + 4] = s && (e.top - t[1]) / s;
      ts[j + 8] = c && (e.right - t[0]) / c;
      ts[j + 12] = s && (e.bottom - t[1]) / s;
      ts[j + 16] = s && (e.left - t[0]) / -s;
      ts[j + 20] = c && (e.top - t[1]) / c;
      ts[j + 24] = s && (e.right - t[0]) / -s;
      ts[j + 28] = c && (e.bottom - t[1]) / c;
      ts[j + 32] = c && (e.left - t[0]) / -c;
      ts[j + 36] = s && (e.top - t[1]) / -s;
      ts[j + 40] = c && (e.right - t[0]) / -c;
      ts[j + 44] = s && (e.bottom - t[1]) / -s;
      ts[j + 48] = s && (e.left - t[0]) / s;
      ts[j + 52] = c && (e.top - t[1]) / -c;
      ts[j + 56] = s && (e.right - t[0]) / s;
      ts[j + 60] = c && (e.bottom - t[1]) / -c;
    }

    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

    task._textDivProperties.set(div, divProperties);
  }
}

function expandBounds(width, height, boxes) {
  const bounds = boxes.map(function (box, i) {
    return {
      x1: box.left,
      y1: box.top,
      x2: box.right,
      y2: box.bottom,
      index: i,
      x1New: undefined,
      x2New: undefined
    };
  });
  expandBoundsLTR(width, bounds);
  const expanded = new Array(boxes.length);

  for (const b of bounds) {
    const i = b.index;
    expanded[i] = {
      left: b.x1New,
      top: 0,
      right: b.x2New,
      bottom: 0
    };
  }

  boxes.map(function (box, i) {
    const e = expanded[i],
          b = bounds[i];
    b.x1 = box.top;
    b.y1 = width - e.right;
    b.x2 = box.bottom;
    b.y2 = width - e.left;
    b.index = i;
    b.x1New = undefined;
    b.x2New = undefined;
  });
  expandBoundsLTR(height, bounds);

  for (const b of bounds) {
    const i = b.index;
    expanded[i].top = b.x1New;
    expanded[i].bottom = b.x2New;
  }

  return expanded;
}

function expandBoundsLTR(width, bounds) {
  bounds.sort(function (a, b) {
    return a.x1 - b.x1 || a.index - b.index;
  });
  const fakeBoundary = {
    x1: -Infinity,
    y1: -Infinity,
    x2: 0,
    y2: Infinity,
    index: -1,
    x1New: 0,
    x2New: 0
  };
  const horizon = [{
    start: -Infinity,
    end: Infinity,
    boundary: fakeBoundary
  }];

  for (const boundary of bounds) {
    let i = 0;

    while (i < horizon.length && horizon[i].end <= boundary.y1) {
      i++;
    }

    let j = horizon.length - 1;

    while (j >= 0 && horizon[j].start >= boundary.y2) {
      j--;
    }

    let horizonPart, affectedBoundary;
    let q,
        k,
        maxXNew = -Infinity;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      let xNew;

      if (affectedBoundary.x2 > boundary.x1) {
        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
      } else if (affectedBoundary.x2New === undefined) {
        xNew = (affectedBoundary.x2 + boundary.x1) / 2;
      } else {
        xNew = affectedBoundary.x2New;
      }

      if (xNew > maxXNew) {
        maxXNew = xNew;
      }
    }

    boundary.x1New = maxXNew;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New === undefined) {
        if (affectedBoundary.x2 > boundary.x1) {
          if (affectedBoundary.index > boundary.index) {
            affectedBoundary.x2New = affectedBoundary.x2;
          }
        } else {
          affectedBoundary.x2New = maxXNew;
        }
      } else if (affectedBoundary.x2New > maxXNew) {
        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
      }
    }

    const changedHorizon = [];
    let lastBoundary = null;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

      if (lastBoundary === useBoundary) {
        changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
      } else {
        changedHorizon.push({
          start: horizonPart.start,
          end: horizonPart.end,
          boundary: useBoundary
        });
        lastBoundary = useBoundary;
      }
    }

    if (horizon[i].start < boundary.y1) {
      changedHorizon[0].start = boundary.y1;
      changedHorizon.unshift({
        start: horizon[i].start,
        end: boundary.y1,
        boundary: horizon[i].boundary
      });
    }

    if (boundary.y2 < horizon[j].end) {
      changedHorizon[changedHorizon.length - 1].end = boundary.y2;
      changedHorizon.push({
        start: boundary.y2,
        end: horizon[j].end,
        boundary: horizon[j].boundary
      });
    }

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New !== undefined) {
        continue;
      }

      let used = false;

      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = 0; !used && k < changedHorizon.length; k++) {
        used = changedHorizon[k].boundary === affectedBoundary;
      }

      if (!used) {
        affectedBoundary.x2New = maxXNew;
      }
    }

    Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
  }

  for (const horizonPart of horizon) {
    const affectedBoundary = horizonPart.boundary;

    if (affectedBoundary.x2New === undefined) {
      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
    }
  }
}

class TextLayerRenderTask {
  constructor({
    textContent,
    textContentStream,
    container,
    viewport,
    textDivs,
    textContentItemsStr,
    enhanceTextSelection
  }) {
    this._textContent = textContent;
    this._textContentStream = textContentStream;
    this._container = container;
    this._document = container.ownerDocument;
    this._viewport = viewport;
    this._textDivs = textDivs || [];
    this._textContentItemsStr = textContentItemsStr || [];
    this._enhanceTextSelection = !!enhanceTextSelection;
    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
    this._reader = null;
    this._layoutTextLastFontSize = null;
    this._layoutTextLastFontFamily = null;
    this._layoutTextCtx = null;
    this._textDivProperties = new WeakMap();
    this._renderingDone = false;
    this._canceled = false;
    this._capability = (0, _util.createPromiseCapability)();
    this._renderTimer = null;
    this._bounds = [];

    this._capability.promise.finally(() => {
      if (!this._enhanceTextSelection) {
        this._textDivProperties = null;
      }

      if (this._layoutTextCtx) {
        this._layoutTextCtx.canvas.width = 0;
        this._layoutTextCtx.canvas.height = 0;
        this._layoutTextCtx = null;
      }
    }).catch(() => {});
  }

  get promise() {
    return this._capability.promise;
  }

  cancel() {
    this._canceled = true;

    if (this._reader) {
      this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")).catch(() => {});

      this._reader = null;
    }

    if (this._renderTimer !== null) {
      clearTimeout(this._renderTimer);
      this._renderTimer = null;
    }

    this._capability.reject(new Error("TextLayer task cancelled."));
  }

  _processItems(items, styleCache) {
    for (let i = 0, len = items.length; i < len; i++) {
      if (items[i].str === undefined) {
        if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
          const parent = this._container;
          this._container = document.createElement("span");

          this._container.classList.add("markedContent");

          if (items[i].id !== null) {
            this._container.setAttribute("id", `${items[i].id}`);
          }

          parent.appendChild(this._container);
        } else if (items[i].type === "endMarkedContent") {
          this._container = this._container.parentNode;
        }

        continue;
      }

      this._textContentItemsStr.push(items[i].str);

      appendText(this, items[i], styleCache, this._layoutTextCtx);
    }
  }

  _layoutText(textDiv) {
    const textDivProperties = this._textDivProperties.get(textDiv);

    let transform = "";

    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
      const {
        fontSize,
        fontFamily
      } = textDiv.style;

      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
        this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
        this._layoutTextLastFontSize = fontSize;
        this._layoutTextLastFontFamily = fontFamily;
      }

      const {
        width
      } = this._layoutTextCtx.measureText(textDiv.textContent);

      if (width > 0) {
        const scale = textDivProperties.canvasWidth / width;

        if (this._enhanceTextSelection) {
          textDivProperties.scale = scale;
        }

        transform = `scaleX(${scale})`;
      }
    }

    if (textDivProperties.angle !== 0) {
      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
    }

    if (transform.length > 0) {
      if (this._enhanceTextSelection) {
        textDivProperties.originalTransform = transform;
      }

      textDiv.style.transform = transform;
    }

    if (textDivProperties.hasText) {
      this._container.appendChild(textDiv);
    }

    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");

      this._container.appendChild(br);
    }
  }

  _render(timeout = 0) {
    const capability = (0, _util.createPromiseCapability)();
    let styleCache = Object.create(null);

    const canvas = this._document.createElement("canvas");

    canvas.height = canvas.width = DEFAULT_FONT_SIZE;
    canvas.mozOpaque = true;
    this._layoutTextCtx = canvas.getContext("2d", {
      alpha: false
    });

    if (this._textContent) {
      const textItems = this._textContent.items;
      const textStyles = this._textContent.styles;

      this._processItems(textItems, textStyles);

      capability.resolve();
    } else if (this._textContentStream) {
      const pump = () => {
        this._reader.read().then(({
          value,
          done
        }) => {
          if (done) {
            capability.resolve();
            return;
          }

          Object.assign(styleCache, value.styles);

          this._processItems(value.items, styleCache);

          pump();
        }, capability.reject);
      };

      this._reader = this._textContentStream.getReader();
      pump();
    } else {
      throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
    }

    capability.promise.then(() => {
      styleCache = null;

      if (!timeout) {
        render(this);
      } else {
        this._renderTimer = setTimeout(() => {
          render(this);
          this._renderTimer = null;
        }, timeout);
      }
    }, this._capability.reject);
  }

  expandTextDivs(expandDivs = false) {
    if (!this._enhanceTextSelection || !this._renderingDone) {
      return;
    }

    if (this._bounds !== null) {
      expand(this);
      this._bounds = null;
    }

    const transformBuf = [],
          paddingBuf = [];

    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
      const div = this._textDivs[i];

      const divProps = this._textDivProperties.get(div);

      if (!divProps.hasText) {
        continue;
      }

      if (expandDivs) {
        transformBuf.length = 0;
        paddingBuf.length = 0;

        if (divProps.originalTransform) {
          transformBuf.push(divProps.originalTransform);
        }

        if (divProps.paddingTop > 0) {
          paddingBuf.push(`${divProps.paddingTop}px`);
          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingRight > 0) {
          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingBottom > 0) {
          paddingBuf.push(`${divProps.paddingBottom}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingLeft > 0) {
          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
        } else {
          paddingBuf.push(0);
        }

        div.style.padding = paddingBuf.join(" ");

        if (transformBuf.length) {
          div.style.transform = transformBuf.join(" ");
        }
      } else {
        div.style.padding = null;
        div.style.transform = divProps.originalTransform;
      }
    }
  }

}

function renderTextLayer(renderParameters) {
  const task = new TextLayerRenderTask({
    textContent: renderParameters.textContent,
    textContentStream: renderParameters.textContentStream,
    container: renderParameters.container,
    viewport: renderParameters.viewport,
    textDivs: renderParameters.textDivs,
    textContentItemsStr: renderParameters.textContentItemsStr,
    enhanceTextSelection: renderParameters.enhanceTextSelection
  });

  task._render(renderParameters.timeout);

  return task;
}

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SVGGraphics = void 0;

var _util = __w_pdfjs_require__(2);

var _display_utils = __w_pdfjs_require__(1);

var _is_node = __w_pdfjs_require__(4);

let SVGGraphics = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: SVGGraphics");
  }

};
exports.SVGGraphics = SVGGraphics;
{
  const SVG_DEFAULTS = {
    fontStyle: "normal",
    fontWeight: "normal",
    fillColor: "#000000"
  };
  const XML_NS = "http://www.w3.org/XML/1998/namespace";
  const XLINK_NS = "http://www.w3.org/1999/xlink";
  const LINE_CAP_STYLES = ["butt", "round", "square"];
  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];

  const convertImgDataToPng = function () {
    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
    const CHUNK_WRAPPER_SIZE = 12;
    const crcTable = new Int32Array(256);

    for (let i = 0; i < 256; i++) {
      let c = i;

      for (let h = 0; h < 8; h++) {
        if (c & 1) {
          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
        } else {
          c = c >> 1 & 0x7fffffff;
        }
      }

      crcTable[i] = c;
    }

    function crc32(data, start, end) {
      let crc = -1;

      for (let i = start; i < end; i++) {
        const a = (crc ^ data[i]) & 0xff;
        const b = crcTable[a];
        crc = crc >>> 8 ^ b;
      }

      return crc ^ -1;
    }

    function writePngChunk(type, body, data, offset) {
      let p = offset;
      const len = body.length;
      data[p] = len >> 24 & 0xff;
      data[p + 1] = len >> 16 & 0xff;
      data[p + 2] = len >> 8 & 0xff;
      data[p + 3] = len & 0xff;
      p += 4;
      data[p] = type.charCodeAt(0) & 0xff;
      data[p + 1] = type.charCodeAt(1) & 0xff;
      data[p + 2] = type.charCodeAt(2) & 0xff;
      data[p + 3] = type.charCodeAt(3) & 0xff;
      p += 4;
      data.set(body, p);
      p += body.length;
      const crc = crc32(data, offset + 4, p);
      data[p] = crc >> 24 & 0xff;
      data[p + 1] = crc >> 16 & 0xff;
      data[p + 2] = crc >> 8 & 0xff;
      data[p + 3] = crc & 0xff;
    }

    function adler32(data, start, end) {
      let a = 1;
      let b = 0;

      for (let i = start; i < end; ++i) {
        a = (a + (data[i] & 0xff)) % 65521;
        b = (b + a) % 65521;
      }

      return b << 16 | a;
    }

    function deflateSync(literals) {
      if (!_is_node.isNodeJS) {
        return deflateSyncUncompressed(literals);
      }

      try {
        let input;

        if (parseInt(process.versions.node) >= 8) {
          input = literals;
        } else {
          input = Buffer.from(literals);
        }

        const output = (__webpack_require__(/*! zlib */ "?afbb").deflateSync)(input, {
          level: 9
        });

        return output instanceof Uint8Array ? output : new Uint8Array(output);
      } catch (e) {
        (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
      }

      return deflateSyncUncompressed(literals);
    }

    function deflateSyncUncompressed(literals) {
      let len = literals.length;
      const maxBlockLength = 0xffff;
      const deflateBlocks = Math.ceil(len / maxBlockLength);
      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
      let pi = 0;
      idat[pi++] = 0x78;
      idat[pi++] = 0x9c;
      let pos = 0;

      while (len > maxBlockLength) {
        idat[pi++] = 0x00;
        idat[pi++] = 0xff;
        idat[pi++] = 0xff;
        idat[pi++] = 0x00;
        idat[pi++] = 0x00;
        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
        pi += maxBlockLength;
        pos += maxBlockLength;
        len -= maxBlockLength;
      }

      idat[pi++] = 0x01;
      idat[pi++] = len & 0xff;
      idat[pi++] = len >> 8 & 0xff;
      idat[pi++] = ~len & 0xffff & 0xff;
      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
      idat.set(literals.subarray(pos), pi);
      pi += literals.length - pos;
      const adler = adler32(literals, 0, literals.length);
      idat[pi++] = adler >> 24 & 0xff;
      idat[pi++] = adler >> 16 & 0xff;
      idat[pi++] = adler >> 8 & 0xff;
      idat[pi++] = adler & 0xff;
      return idat;
    }

    function encode(imgData, kind, forceDataSchema, isMask) {
      const width = imgData.width;
      const height = imgData.height;
      let bitDepth, colorType, lineSize;
      const bytes = imgData.data;

      switch (kind) {
        case _util.ImageKind.GRAYSCALE_1BPP:
          colorType = 0;
          bitDepth = 1;
          lineSize = width + 7 >> 3;
          break;

        case _util.ImageKind.RGB_24BPP:
          colorType = 2;
          bitDepth = 8;
          lineSize = width * 3;
          break;

        case _util.ImageKind.RGBA_32BPP:
          colorType = 6;
          bitDepth = 8;
          lineSize = width * 4;
          break;

        default:
          throw new Error("invalid format");
      }

      const literals = new Uint8Array((1 + lineSize) * height);
      let offsetLiterals = 0,
          offsetBytes = 0;

      for (let y = 0; y < height; ++y) {
        literals[offsetLiterals++] = 0;
        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
        offsetBytes += lineSize;
        offsetLiterals += lineSize;
      }

      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
        offsetLiterals = 0;

        for (let y = 0; y < height; y++) {
          offsetLiterals++;

          for (let i = 0; i < lineSize; i++) {
            literals[offsetLiterals++] ^= 0xff;
          }
        }
      }

      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
      const idat = deflateSync(literals);
      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
      const data = new Uint8Array(pngLength);
      let offset = 0;
      data.set(PNG_HEADER, offset);
      offset += PNG_HEADER.length;
      writePngChunk("IHDR", ihdr, data, offset);
      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
      writePngChunk("IDATA", idat, data, offset);
      offset += CHUNK_WRAPPER_SIZE + idat.length;
      writePngChunk("IEND", new Uint8Array(0), data, offset);
      return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
    }

    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
      return encode(imgData, kind, forceDataSchema, isMask);
    };
  }();

  class SVGExtraState {
    constructor() {
      this.fontSizeScale = 1;
      this.fontWeight = SVG_DEFAULTS.fontWeight;
      this.fontSize = 0;
      this.textMatrix = _util.IDENTITY_MATRIX;
      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
      this.leading = 0;
      this.textRenderingMode = _util.TextRenderingMode.FILL;
      this.textMatrixScale = 1;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRise = 0;
      this.fillColor = SVG_DEFAULTS.fillColor;
      this.strokeColor = "#000000";
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.lineJoin = "";
      this.lineCap = "";
      this.miterLimit = 0;
      this.dashArray = [];
      this.dashPhase = 0;
      this.dependencies = [];
      this.activeClipUrl = null;
      this.clipGroup = null;
      this.maskId = "";
    }

    clone() {
      return Object.create(this);
    }

    setCurrentPoint(x, y) {
      this.x = x;
      this.y = y;
    }

  }

  function opListToTree(opList) {
    let opTree = [];
    const tmp = [];

    for (const opListElement of opList) {
      if (opListElement.fn === "save") {
        opTree.push({
          fnId: 92,
          fn: "group",
          items: []
        });
        tmp.push(opTree);
        opTree = opTree[opTree.length - 1].items;
        continue;
      }

      if (opListElement.fn === "restore") {
        opTree = tmp.pop();
      } else {
        opTree.push(opListElement);
      }
    }

    return opTree;
  }

  function pf(value) {
    if (Number.isInteger(value)) {
      return value.toString();
    }

    const s = value.toFixed(10);
    let i = s.length - 1;

    if (s[i] !== "0") {
      return s;
    }

    do {
      i--;
    } while (s[i] === "0");

    return s.substring(0, s[i] === "." ? i : i + 1);
  }

  function pm(m) {
    if (m[4] === 0 && m[5] === 0) {
      if (m[1] === 0 && m[2] === 0) {
        if (m[0] === 1 && m[3] === 1) {
          return "";
        }

        return `scale(${pf(m[0])} ${pf(m[3])})`;
      }

      if (m[0] === m[3] && m[1] === -m[2]) {
        const a = Math.acos(m[0]) * 180 / Math.PI;
        return `rotate(${pf(a)})`;
      }
    } else {
      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
        return `translate(${pf(m[4])} ${pf(m[5])})`;
      }
    }

    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
  }

  let clipCount = 0;
  let maskCount = 0;
  let shadingCount = 0;
  exports.SVGGraphics = SVGGraphics = class {
    constructor(commonObjs, objs, forceDataSchema = false) {
      this.svgFactory = new _display_utils.DOMSVGFactory();
      this.current = new SVGExtraState();
      this.transformMatrix = _util.IDENTITY_MATRIX;
      this.transformStack = [];
      this.extraStack = [];
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.embedFonts = false;
      this.embeddedFonts = Object.create(null);
      this.cssStyle = null;
      this.forceDataSchema = !!forceDataSchema;
      this._operatorIdMapping = [];

      for (const op in _util.OPS) {
        this._operatorIdMapping[_util.OPS[op]] = op;
      }
    }

    save() {
      this.transformStack.push(this.transformMatrix);
      const old = this.current;
      this.extraStack.push(old);
      this.current = old.clone();
    }

    restore() {
      this.transformMatrix = this.transformStack.pop();
      this.current = this.extraStack.pop();
      this.pendingClip = null;
      this.tgrp = null;
    }

    group(items) {
      this.save();
      this.executeOpTree(items);
      this.restore();
    }

    loadDependencies(operatorList) {
      const fnArray = operatorList.fnArray;
      const argsArray = operatorList.argsArray;

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        if (fnArray[i] !== _util.OPS.dependency) {
          continue;
        }

        for (const obj of argsArray[i]) {
          const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
          const promise = new Promise(resolve => {
            objsPool.get(obj, resolve);
          });
          this.current.dependencies.push(promise);
        }
      }

      return Promise.all(this.current.dependencies);
    }

    transform(a, b, c, d, e, f) {
      const transformMatrix = [a, b, c, d, e, f];
      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
      this.tgrp = null;
    }

    getSVG(operatorList, viewport) {
      this.viewport = viewport;

      const svgElement = this._initialize(viewport);

      return this.loadDependencies(operatorList).then(() => {
        this.transformMatrix = _util.IDENTITY_MATRIX;
        this.executeOpTree(this.convertOpList(operatorList));
        return svgElement;
      });
    }

    convertOpList(operatorList) {
      const operatorIdMapping = this._operatorIdMapping;
      const argsArray = operatorList.argsArray;
      const fnArray = operatorList.fnArray;
      const opList = [];

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        const fnId = fnArray[i];
        opList.push({
          fnId,
          fn: operatorIdMapping[fnId],
          args: argsArray[i]
        });
      }

      return opListToTree(opList);
    }

    executeOpTree(opTree) {
      for (const opTreeElement of opTree) {
        const fn = opTreeElement.fn;
        const fnId = opTreeElement.fnId;
        const args = opTreeElement.args;

        switch (fnId | 0) {
          case _util.OPS.beginText:
            this.beginText();
            break;

          case _util.OPS.dependency:
            break;

          case _util.OPS.setLeading:
            this.setLeading(args);
            break;

          case _util.OPS.setLeadingMoveText:
            this.setLeadingMoveText(args[0], args[1]);
            break;

          case _util.OPS.setFont:
            this.setFont(args);
            break;

          case _util.OPS.showText:
            this.showText(args[0]);
            break;

          case _util.OPS.showSpacedText:
            this.showText(args[0]);
            break;

          case _util.OPS.endText:
            this.endText();
            break;

          case _util.OPS.moveText:
            this.moveText(args[0], args[1]);
            break;

          case _util.OPS.setCharSpacing:
            this.setCharSpacing(args[0]);
            break;

          case _util.OPS.setWordSpacing:
            this.setWordSpacing(args[0]);
            break;

          case _util.OPS.setHScale:
            this.setHScale(args[0]);
            break;

          case _util.OPS.setTextMatrix:
            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.setTextRise:
            this.setTextRise(args[0]);
            break;

          case _util.OPS.setTextRenderingMode:
            this.setTextRenderingMode(args[0]);
            break;

          case _util.OPS.setLineWidth:
            this.setLineWidth(args[0]);
            break;

          case _util.OPS.setLineJoin:
            this.setLineJoin(args[0]);
            break;

          case _util.OPS.setLineCap:
            this.setLineCap(args[0]);
            break;

          case _util.OPS.setMiterLimit:
            this.setMiterLimit(args[0]);
            break;

          case _util.OPS.setFillRGBColor:
            this.setFillRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeRGBColor:
            this.setStrokeRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeColorN:
            this.setStrokeColorN(args);
            break;

          case _util.OPS.setFillColorN:
            this.setFillColorN(args);
            break;

          case _util.OPS.shadingFill:
            this.shadingFill(args[0]);
            break;

          case _util.OPS.setDash:
            this.setDash(args[0], args[1]);
            break;

          case _util.OPS.setRenderingIntent:
            this.setRenderingIntent(args[0]);
            break;

          case _util.OPS.setFlatness:
            this.setFlatness(args[0]);
            break;

          case _util.OPS.setGState:
            this.setGState(args[0]);
            break;

          case _util.OPS.fill:
            this.fill();
            break;

          case _util.OPS.eoFill:
            this.eoFill();
            break;

          case _util.OPS.stroke:
            this.stroke();
            break;

          case _util.OPS.fillStroke:
            this.fillStroke();
            break;

          case _util.OPS.eoFillStroke:
            this.eoFillStroke();
            break;

          case _util.OPS.clip:
            this.clip("nonzero");
            break;

          case _util.OPS.eoClip:
            this.clip("evenodd");
            break;

          case _util.OPS.paintSolidColorImageMask:
            this.paintSolidColorImageMask();
            break;

          case _util.OPS.paintImageXObject:
            this.paintImageXObject(args[0]);
            break;

          case _util.OPS.paintInlineImageXObject:
            this.paintInlineImageXObject(args[0]);
            break;

          case _util.OPS.paintImageMaskXObject:
            this.paintImageMaskXObject(args[0]);
            break;

          case _util.OPS.paintFormXObjectBegin:
            this.paintFormXObjectBegin(args[0], args[1]);
            break;

          case _util.OPS.paintFormXObjectEnd:
            this.paintFormXObjectEnd();
            break;

          case _util.OPS.closePath:
            this.closePath();
            break;

          case _util.OPS.closeStroke:
            this.closeStroke();
            break;

          case _util.OPS.closeFillStroke:
            this.closeFillStroke();
            break;

          case _util.OPS.closeEOFillStroke:
            this.closeEOFillStroke();
            break;

          case _util.OPS.nextLine:
            this.nextLine();
            break;

          case _util.OPS.transform:
            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.constructPath:
            this.constructPath(args[0], args[1]);
            break;

          case _util.OPS.endPath:
            this.endPath();
            break;

          case 92:
            this.group(opTreeElement.items);
            break;

          default:
            (0, _util.warn)(`Unimplemented operator ${fn}`);
            break;
        }
      }
    }

    setWordSpacing(wordSpacing) {
      this.current.wordSpacing = wordSpacing;
    }

    setCharSpacing(charSpacing) {
      this.current.charSpacing = charSpacing;
    }

    nextLine() {
      this.moveText(0, this.current.leading);
    }

    setTextMatrix(a, b, c, d, e, f) {
      const current = this.current;
      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
      current.textMatrixScale = Math.hypot(a, b);
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtElement.appendChild(current.tspan);
    }

    beginText() {
      const current = this.current;
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.textMatrix = _util.IDENTITY_MATRIX;
      current.lineMatrix = _util.IDENTITY_MATRIX;
      current.textMatrixScale = 1;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtgrp = this.svgFactory.createElement("svg:g");
      current.xcoords = [];
      current.ycoords = [];
    }

    moveText(x, y) {
      const current = this.current;
      current.x = current.lineX += x;
      current.y = current.lineY += y;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
    }

    showText(glyphs) {
      const current = this.current;
      const font = current.font;
      const fontSize = current.fontSize;

      if (fontSize === 0) {
        return;
      }

      const fontSizeScale = current.fontSizeScale;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const fontDirection = current.fontDirection;
      const textHScale = current.textHScale * fontDirection;
      const vertical = font.vertical;
      const spacingDir = vertical ? 1 : -1;
      const defaultVMetrics = font.defaultVMetrics;
      const widthAdvanceScale = fontSize * current.fontMatrix[0];
      let x = 0;

      for (const glyph of glyphs) {
        if (glyph === null) {
          x += fontDirection * wordSpacing;
          continue;
        } else if ((0, _util.isNum)(glyph)) {
          x += spacingDir * glyph * fontSize / 1000;
          continue;
        }

        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const character = glyph.fontChar;
        let scaledX, scaledY;
        let width = glyph.width;

        if (vertical) {
          let vx;
          const vmetric = glyph.vmetric || defaultVMetrics;
          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
          vx = -vx * widthAdvanceScale;
          const vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }

        if (glyph.isInFont || font.missingFile) {
          current.xcoords.push(current.x + scaledX);

          if (vertical) {
            current.ycoords.push(-current.y + scaledY);
          }

          current.tspan.textContent += character;
        } else {}

        let charWidth;

        if (vertical) {
          charWidth = width * widthAdvanceScale - spacing * fontDirection;
        } else {
          charWidth = width * widthAdvanceScale + spacing * fontDirection;
        }

        x += charWidth;
      }

      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

      if (vertical) {
        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
      } else {
        current.tspan.setAttributeNS(null, "y", pf(-current.y));
      }

      if (vertical) {
        current.y -= x;
      } else {
        current.x += x * textHScale;
      }

      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);

      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
      }

      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
      }

      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
          current.tspan.setAttributeNS(null, "fill", current.fillColor);
        }

        if (current.fillAlpha < 1) {
          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        }
      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
        current.tspan.setAttributeNS(null, "fill", "transparent");
      } else {
        current.tspan.setAttributeNS(null, "fill", "none");
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        const lineWidthScale = 1 / (current.textMatrixScale || 1);

        this._setStrokeAttributes(current.tspan, lineWidthScale);
      }

      let textMatrix = current.textMatrix;

      if (current.textRise !== 0) {
        textMatrix = textMatrix.slice();
        textMatrix[5] += current.textRise;
      }

      current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
      current.txtElement.appendChild(current.tspan);
      current.txtgrp.appendChild(current.txtElement);

      this._ensureTransformGroup().appendChild(current.txtElement);
    }

    setLeadingMoveText(x, y) {
      this.setLeading(-y);
      this.moveText(x, y);
    }

    addFontStyle(fontObj) {
      if (!fontObj.data) {
        throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
      }

      if (!this.cssStyle) {
        this.cssStyle = this.svgFactory.createElement("svg:style");
        this.cssStyle.setAttributeNS(null, "type", "text/css");
        this.defs.appendChild(this.cssStyle);
      }

      const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
      this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
    }

    setFont(details) {
      const current = this.current;
      const fontObj = this.commonObjs.get(details[0]);
      let size = details[1];
      current.font = fontObj;

      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
        this.addFontStyle(fontObj);
        this.embeddedFonts[fontObj.loadedName] = fontObj;
      }

      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      let bold = "normal";

      if (fontObj.black) {
        bold = "900";
      } else if (fontObj.bold) {
        bold = "bold";
      }

      const italic = fontObj.italic ? "italic" : "normal";

      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }

      current.fontSize = size;
      current.fontFamily = fontObj.loadedName;
      current.fontWeight = bold;
      current.fontStyle = italic;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.xcoords = [];
      current.ycoords = [];
    }

    endText() {
      const current = this.current;

      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
        current.element = current.txtElement;
        this.clip("nonzero");
        this.endPath();
      }
    }

    setLineWidth(width) {
      if (width > 0) {
        this.current.lineWidth = width;
      }
    }

    setLineCap(style) {
      this.current.lineCap = LINE_CAP_STYLES[style];
    }

    setLineJoin(style) {
      this.current.lineJoin = LINE_JOIN_STYLES[style];
    }

    setMiterLimit(limit) {
      this.current.miterLimit = limit;
    }

    setStrokeAlpha(strokeAlpha) {
      this.current.strokeAlpha = strokeAlpha;
    }

    setStrokeRGBColor(r, g, b) {
      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
    }

    setFillAlpha(fillAlpha) {
      this.current.fillAlpha = fillAlpha;
    }

    setFillRGBColor(r, g, b) {
      this.current.fillColor = _util.Util.makeHexColor(r, g, b);
      this.current.tspan = this.svgFactory.createElement("svg:tspan");
      this.current.xcoords = [];
      this.current.ycoords = [];
    }

    setStrokeColorN(args) {
      this.current.strokeColor = this._makeColorN_Pattern(args);
    }

    setFillColorN(args) {
      this.current.fillColor = this._makeColorN_Pattern(args);
    }

    shadingFill(args) {
      const width = this.viewport.width;
      const height = this.viewport.height;

      const inv = _util.Util.inverseTransform(this.transformMatrix);

      const bl = _util.Util.applyTransform([0, 0], inv);

      const br = _util.Util.applyTransform([0, height], inv);

      const ul = _util.Util.applyTransform([width, 0], inv);

      const ur = _util.Util.applyTransform([width, height], inv);

      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", x0);
      rect.setAttributeNS(null, "y", y0);
      rect.setAttributeNS(null, "width", x1 - x0);
      rect.setAttributeNS(null, "height", y1 - y0);
      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

      if (this.current.fillAlpha < 1) {
        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
      }

      this._ensureTransformGroup().appendChild(rect);
    }

    _makeColorN_Pattern(args) {
      if (args[0] === "TilingPattern") {
        return this._makeTilingPattern(args);
      }

      return this._makeShadingPattern(args);
    }

    _makeTilingPattern(args) {
      const color = args[1];
      const operatorList = args[2];
      const matrix = args[3] || _util.IDENTITY_MATRIX;
      const [x0, y0, x1, y1] = args[4];
      const xstep = args[5];
      const ystep = args[6];
      const paintType = args[7];
      const tilingId = `shading${shadingCount++}`;

      const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);

      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);

      const txstep = xstep * xscale;
      const tystep = ystep * yscale;
      const tiling = this.svgFactory.createElement("svg:pattern");
      tiling.setAttributeNS(null, "id", tilingId);
      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
      tiling.setAttributeNS(null, "width", txstep);
      tiling.setAttributeNS(null, "height", tystep);
      tiling.setAttributeNS(null, "x", `${tx0}`);
      tiling.setAttributeNS(null, "y", `${ty0}`);
      const svg = this.svg;
      const transformMatrix = this.transformMatrix;
      const fillColor = this.current.fillColor;
      const strokeColor = this.current.strokeColor;
      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
      this.svg = bbox;
      this.transformMatrix = matrix;

      if (paintType === 2) {
        const cssColor = _util.Util.makeHexColor(...color);

        this.current.fillColor = cssColor;
        this.current.strokeColor = cssColor;
      }

      this.executeOpTree(this.convertOpList(operatorList));
      this.svg = svg;
      this.transformMatrix = transformMatrix;
      this.current.fillColor = fillColor;
      this.current.strokeColor = strokeColor;
      tiling.appendChild(bbox.childNodes[0]);
      this.defs.appendChild(tiling);
      return `url(#${tilingId})`;
    }

    _makeShadingPattern(args) {
      if (typeof args === "string") {
        args = this.objs.get(args);
      }

      switch (args[0]) {
        case "RadialAxial":
          const shadingId = `shading${shadingCount++}`;
          const colorStops = args[3];
          let gradient;

          switch (args[1]) {
            case "axial":
              const point0 = args[4];
              const point1 = args[5];
              gradient = this.svgFactory.createElement("svg:linearGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "x1", point0[0]);
              gradient.setAttributeNS(null, "y1", point0[1]);
              gradient.setAttributeNS(null, "x2", point1[0]);
              gradient.setAttributeNS(null, "y2", point1[1]);
              break;

            case "radial":
              const focalPoint = args[4];
              const circlePoint = args[5];
              const focalRadius = args[6];
              const circleRadius = args[7];
              gradient = this.svgFactory.createElement("svg:radialGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "cx", circlePoint[0]);
              gradient.setAttributeNS(null, "cy", circlePoint[1]);
              gradient.setAttributeNS(null, "r", circleRadius);
              gradient.setAttributeNS(null, "fx", focalPoint[0]);
              gradient.setAttributeNS(null, "fy", focalPoint[1]);
              gradient.setAttributeNS(null, "fr", focalRadius);
              break;

            default:
              throw new Error(`Unknown RadialAxial type: ${args[1]}`);
          }

          for (const colorStop of colorStops) {
            const stop = this.svgFactory.createElement("svg:stop");
            stop.setAttributeNS(null, "offset", colorStop[0]);
            stop.setAttributeNS(null, "stop-color", colorStop[1]);
            gradient.appendChild(stop);
          }

          this.defs.appendChild(gradient);
          return `url(#${shadingId})`;

        case "Mesh":
          (0, _util.warn)("Unimplemented pattern Mesh");
          return null;

        case "Dummy":
          return "hotpink";

        default:
          throw new Error(`Unknown IR type: ${args[0]}`);
      }
    }

    setDash(dashArray, dashPhase) {
      this.current.dashArray = dashArray;
      this.current.dashPhase = dashPhase;
    }

    constructPath(ops, args) {
      const current = this.current;
      let x = current.x,
          y = current.y;
      let d = [];
      let j = 0;

      for (const op of ops) {
        switch (op | 0) {
          case _util.OPS.rectangle:
            x = args[j++];
            y = args[j++];
            const width = args[j++];
            const height = args[j++];
            const xw = x + width;
            const yh = y + height;
            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
            break;

          case _util.OPS.moveTo:
            x = args[j++];
            y = args[j++];
            d.push("M", pf(x), pf(y));
            break;

          case _util.OPS.lineTo:
            x = args[j++];
            y = args[j++];
            d.push("L", pf(x), pf(y));
            break;

          case _util.OPS.curveTo:
            x = args[j + 4];
            y = args[j + 5];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
            j += 6;
            break;

          case _util.OPS.curveTo2:
            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
            x = args[j + 2];
            y = args[j + 3];
            j += 4;
            break;

          case _util.OPS.curveTo3:
            x = args[j + 2];
            y = args[j + 3];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
            j += 4;
            break;

          case _util.OPS.closePath:
            d.push("Z");
            break;
        }
      }

      d = d.join(" ");

      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
        d = current.path.getAttributeNS(null, "d") + d;
      } else {
        current.path = this.svgFactory.createElement("svg:path");

        this._ensureTransformGroup().appendChild(current.path);
      }

      current.path.setAttributeNS(null, "d", d);
      current.path.setAttributeNS(null, "fill", "none");
      current.element = current.path;
      current.setCurrentPoint(x, y);
    }

    endPath() {
      const current = this.current;
      current.path = null;

      if (!this.pendingClip) {
        return;
      }

      if (!current.element) {
        this.pendingClip = null;
        return;
      }

      const clipId = `clippath${clipCount++}`;
      const clipPath = this.svgFactory.createElement("svg:clipPath");
      clipPath.setAttributeNS(null, "id", clipId);
      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
      const clipElement = current.element.cloneNode(true);

      if (this.pendingClip === "evenodd") {
        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
      } else {
        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
      }

      this.pendingClip = null;
      clipPath.appendChild(clipElement);
      this.defs.appendChild(clipPath);

      if (current.activeClipUrl) {
        current.clipGroup = null;

        for (const prev of this.extraStack) {
          prev.clipGroup = null;
        }

        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
      }

      current.activeClipUrl = `url(#${clipId})`;
      this.tgrp = null;
    }

    clip(type) {
      this.pendingClip = type;
    }

    closePath() {
      const current = this.current;

      if (current.path) {
        const d = `${current.path.getAttributeNS(null, "d")}Z`;
        current.path.setAttributeNS(null, "d", d);
      }
    }

    setLeading(leading) {
      this.current.leading = -leading;
    }

    setTextRise(textRise) {
      this.current.textRise = textRise;
    }

    setTextRenderingMode(textRenderingMode) {
      this.current.textRenderingMode = textRenderingMode;
    }

    setHScale(scale) {
      this.current.textHScale = scale / 100;
    }

    setRenderingIntent(intent) {}

    setFlatness(flatness) {}

    setGState(states) {
      for (const [key, value] of states) {
        switch (key) {
          case "LW":
            this.setLineWidth(value);
            break;

          case "LC":
            this.setLineCap(value);
            break;

          case "LJ":
            this.setLineJoin(value);
            break;

          case "ML":
            this.setMiterLimit(value);
            break;

          case "D":
            this.setDash(value[0], value[1]);
            break;

          case "RI":
            this.setRenderingIntent(value);
            break;

          case "FL":
            this.setFlatness(value);
            break;

          case "Font":
            this.setFont(value);
            break;

          case "CA":
            this.setStrokeAlpha(value);
            break;

          case "ca":
            this.setFillAlpha(value);
            break;

          default:
            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
            break;
        }
      }
    }

    fill() {
      const current = this.current;

      if (current.element) {
        current.element.setAttributeNS(null, "fill", current.fillColor);
        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        this.endPath();
      }
    }

    stroke() {
      const current = this.current;

      if (current.element) {
        this._setStrokeAttributes(current.element);

        current.element.setAttributeNS(null, "fill", "none");
        this.endPath();
      }
    }

    _setStrokeAttributes(element, lineWidthScale = 1) {
      const current = this.current;
      let dashArray = current.dashArray;

      if (lineWidthScale !== 1 && dashArray.length > 0) {
        dashArray = dashArray.map(function (value) {
          return lineWidthScale * value;
        });
      }

      element.setAttributeNS(null, "stroke", current.strokeColor);
      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
    }

    eoFill() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fill();
    }

    fillStroke() {
      this.stroke();
      this.fill();
    }

    eoFillStroke() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fillStroke();
    }

    closeStroke() {
      this.closePath();
      this.stroke();
    }

    closeFillStroke() {
      this.closePath();
      this.fillStroke();
    }

    closeEOFillStroke() {
      this.closePath();
      this.eoFillStroke();
    }

    paintSolidColorImageMask() {
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", "1px");
      rect.setAttributeNS(null, "height", "1px");
      rect.setAttributeNS(null, "fill", this.current.fillColor);

      this._ensureTransformGroup().appendChild(rect);
    }

    paintImageXObject(objId) {
      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
        return;
      }

      this.paintInlineImageXObject(imgData);
    }

    paintInlineImageXObject(imgData, mask) {
      const width = imgData.width;
      const height = imgData.height;
      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
      const cliprect = this.svgFactory.createElement("svg:rect");
      cliprect.setAttributeNS(null, "x", "0");
      cliprect.setAttributeNS(null, "y", "0");
      cliprect.setAttributeNS(null, "width", pf(width));
      cliprect.setAttributeNS(null, "height", pf(height));
      this.current.element = cliprect;
      this.clip("nonzero");
      const imgEl = this.svgFactory.createElement("svg:image");
      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
      imgEl.setAttributeNS(null, "x", "0");
      imgEl.setAttributeNS(null, "y", pf(-height));
      imgEl.setAttributeNS(null, "width", pf(width) + "px");
      imgEl.setAttributeNS(null, "height", pf(height) + "px");
      imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);

      if (mask) {
        mask.appendChild(imgEl);
      } else {
        this._ensureTransformGroup().appendChild(imgEl);
      }
    }

    paintImageMaskXObject(imgData) {
      const current = this.current;
      const width = imgData.width;
      const height = imgData.height;
      const fillColor = current.fillColor;
      current.maskId = `mask${maskCount++}`;
      const mask = this.svgFactory.createElement("svg:mask");
      mask.setAttributeNS(null, "id", current.maskId);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", pf(width));
      rect.setAttributeNS(null, "height", pf(height));
      rect.setAttributeNS(null, "fill", fillColor);
      rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
      this.defs.appendChild(mask);

      this._ensureTransformGroup().appendChild(rect);

      this.paintInlineImageXObject(imgData, mask);
    }

    paintFormXObjectBegin(matrix, bbox) {
      if (Array.isArray(matrix) && matrix.length === 6) {
        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      }

      if (bbox) {
        const width = bbox[2] - bbox[0];
        const height = bbox[3] - bbox[1];
        const cliprect = this.svgFactory.createElement("svg:rect");
        cliprect.setAttributeNS(null, "x", bbox[0]);
        cliprect.setAttributeNS(null, "y", bbox[1]);
        cliprect.setAttributeNS(null, "width", pf(width));
        cliprect.setAttributeNS(null, "height", pf(height));
        this.current.element = cliprect;
        this.clip("nonzero");
        this.endPath();
      }
    }

    paintFormXObjectEnd() {}

    _initialize(viewport) {
      const svg = this.svgFactory.create(viewport.width, viewport.height);
      const definitions = this.svgFactory.createElement("svg:defs");
      svg.appendChild(definitions);
      this.defs = definitions;
      const rootGroup = this.svgFactory.createElement("svg:g");
      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
      svg.appendChild(rootGroup);
      this.svg = rootGroup;
      return svg;
    }

    _ensureClipGroup() {
      if (!this.current.clipGroup) {
        const clipGroup = this.svgFactory.createElement("svg:g");
        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
        this.svg.appendChild(clipGroup);
        this.current.clipGroup = clipGroup;
      }

      return this.current.clipGroup;
    }

    _ensureTransformGroup() {
      if (!this.tgrp) {
        this.tgrp = this.svgFactory.createElement("svg:g");
        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

        if (this.current.activeClipUrl) {
          this._ensureClipGroup().appendChild(this.tgrp);
        } else {
          this.svg.appendChild(this.tgrp);
        }
      }

      return this.tgrp;
    }

  };
}

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNodeStream = void 0;

var _util = __w_pdfjs_require__(2);

var _network_utils = __w_pdfjs_require__(24);

;

const fs = __webpack_require__(/*! fs */ "?fe90");

const http = __webpack_require__(/*! http */ "?d446");

const https = __webpack_require__(/*! https */ "?4c38");

const url = __webpack_require__(/*! url */ "?9f5f");

const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

function parseUrl(sourceUrl) {
  const parsedUrl = url.parse(sourceUrl);

  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
    return parsedUrl;
  }

  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse(`file:///${sourceUrl}`);
  }

  if (!parsedUrl.host) {
    parsedUrl.protocol = "file:";
  }

  return parsedUrl;
}

class PDFNodeStream {
  constructor(source) {
    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
    this.isFsUrl = this.url.protocol === "file:";
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

    this._rangeRequestReaders.push(rangeReader);

    return rangeReader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNodeStream = PDFNodeStream;

class BaseFullReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._headersCapability = (0, _util.createPromiseCapability)();
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new _util.AbortException("streaming is disabled"));
    }

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

class BaseRangeReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

function createRequestOptions(parsedUrl, headers) {
  return {
    protocol: parsedUrl.protocol,
    auth: parsedUrl.auth,
    host: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    method: "GET",
    headers
  };
}

class PDFNodeStreamFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._headersCapability.resolve();

      this._setReadableStream(response);

      const getResponseHeader = name => {
        return this._readableStream.headers[name.toLowerCase()];
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;

      this._headersCapability.reject(reason);
    });

    this._request.end();
  }

}

class PDFNodeStreamRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    this._httpHeaders = {};

    for (const property in stream.httpHeaders) {
      const value = stream.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      this._httpHeaders[property] = value;
    }

    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        return;
      }

      this._setReadableStream(response);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;
    });

    this._request.end();
  }

}

class PDFNodeStreamFsFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    fs.lstat(path, (error, stat) => {
      if (error) {
        if (error.code === "ENOENT") {
          error = new _util.MissingPDFException(`Missing PDF "${path}".`);
        }

        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._contentLength = stat.size;

      this._setReadableStream(fs.createReadStream(path));

      this._headersCapability.resolve();
    });
  }

}

class PDFNodeStreamFsRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    this._setReadableStream(fs.createReadStream(path, {
      start,
      end: end - 1
    }));
  }

}

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createResponseStatusError = createResponseStatusError;
exports.extractFilenameFromHeader = extractFilenameFromHeader;
exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
exports.validateResponseStatus = validateResponseStatus;

var _util = __w_pdfjs_require__(2);

var _content_disposition = __w_pdfjs_require__(25);

var _display_utils = __w_pdfjs_require__(1);

function validateRangeRequestCapabilities({
  getResponseHeader,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: undefined
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);

  if (!Number.isInteger(length)) {
    return returnValues;
  }

  returnValues.suggestedLength = length;

  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }

  if (disableRange || !isHttp) {
    return returnValues;
  }

  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }

  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";

  if (contentEncoding !== "identity") {
    return returnValues;
  }

  returnValues.allowRangeRequests = true;
  return returnValues;
}

function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");

  if (contentDisposition) {
    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch (ex) {}
    }

    if ((0, _display_utils.isPdfFile)(filename)) {
      return filename;
    }
  }

  return null;
}

function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new _util.MissingPDFException('Missing PDF "' + url + '".');
  }

  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}

function validateResponseStatus(status) {
  return status === 200 || status === 206;
}

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

var _util = __w_pdfjs_require__(2);

function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  tmp = rfc2231getparam(contentDisposition);

  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }

  tmp = toParamRegExp("filename", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
  }

  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }

      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = (0, _util.stringToBytes)(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch (e) {
        if (/^utf-?8$/i.test(encoding)) {
          try {
            value = decodeURIComponent(escape(value));
            needsEncodingFixup = false;
          } catch (err) {}
        }
      }
    }

    return value;
  }

  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);

      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }

    return value;
  }

  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);

      if (n in matches) {
        if (n === 0) {
          break;
        }

        continue;
      }

      matches[n] = [quot, part];
    }

    const parts = [];

    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }

      let [quot, part] = matches[n];
      part = rfc2616unquote(part);

      if (quot) {
        part = unescape(part);

        if (n === 0) {
          part = rfc5987decode(part);
        }
      }

      parts.push(part);
    }

    return parts.join("");
  }

  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');

      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');

        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }

        parts[i] = parts[i].replace(/\\(.)/g, "$1");
      }

      value = parts.join('"');
    }

    return value;
  }

  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");

    if (encodingend === -1) {
      return extvalue;
    }

    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }

  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }

    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replace(/_/g, " ");
        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }

      try {
        text = atob(text);
      } catch (e) {}

      return textdecode(charset, text);
    });
  }

  return "";
}

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNetworkStream = void 0;

var _util = __w_pdfjs_require__(2);

var _network_utils = __w_pdfjs_require__(24);

;
const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;

function getArrayBuffer(xhr) {
  const data = xhr.response;

  if (typeof data !== "string") {
    return data;
  }

  const array = (0, _util.stringToBytes)(data);
  return array.buffer;
}

class NetworkManager {
  constructor(url, args = {}) {
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
    this.withCredentials = args.withCredentials || false;

    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
      return new XMLHttpRequest();
    };

    this.currXhrId = 0;
    this.pendingRequests = Object.create(null);
  }

  requestRange(begin, end, listeners) {
    const args = {
      begin,
      end
    };

    for (const prop in listeners) {
      args[prop] = listeners[prop];
    }

    return this.request(args);
  }

  requestFull(listeners) {
    return this.request(listeners);
  }

  request(args) {
    const xhr = this.getXhr();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;

    for (const property in this.httpHeaders) {
      const value = this.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      xhr.setRequestHeader(property, value);
    }

    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }

    xhr.responseType = "arraybuffer";

    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }

    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }

  onProgress(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    pendingRequest.onProgress?.(evt);
  }

  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    const xhr = pendingRequest.xhr;

    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }

    if (xhr.readyState !== 4) {
      return;
    }

    if (!(xhrId in this.pendingRequests)) {
      return;
    }

    delete this.pendingRequests[xhrId];

    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError?.(xhr.status);
      return;
    }

    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError?.(xhr.status);
      return;
    }

    const chunk = getArrayBuffer(xhr);

    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      pendingRequest.onDone({
        begin: parseInt(matches[1], 10),
        chunk
      });
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError?.(xhr.status);
    }
  }

  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }

  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }

  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }

}

class PDFNetworkStream {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source.url, {
      httpHeaders: source.httpHeaders,
      withCredentials: source.withCredentials
    });
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNetworkStream = PDFNetworkStream;

class PDFNetworkStreamFullRequestReader {
  constructor(manager, source) {
    this._manager = manager;
    const args = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = source.url;
    this._fullRequestId = manager.requestFull(args);
    this._headersReceivedCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = undefined;
    this._filename = null;
    this.onProgress = null;
  }

  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;

    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

    const getResponseHeader = name => {
      return fullRequestXhr.getResponseHeader(name);
    };

    const {
      allowRangeRequests,
      suggestedLength
    } = (0, _network_utils.validateRangeRequestCapabilities)({
      getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });

    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }

    this._contentLength = suggestedLength || this._contentLength;
    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }

    this._headersReceivedCapability.resolve();
  }

  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();

        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }

    this._done = true;

    if (this._cachedChunks.length > 0) {
      return;
    }

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

    this._headersReceivedCapability.reject(this._storedError);

    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }

    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }

  _onProgress(evt) {
    this.onProgress?.({
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  get contentLength() {
    return this._contentLength;
  }

  get headersReady() {
    return this._headersReceivedCapability.promise;
  }

  async read() {
    if (this._storedError) {
      throw this._storedError;
    }

    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    this._headersReceivedCapability.reject(reason);

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }

    this._fullRequestReader = null;
  }

}

class PDFNetworkStreamRangeRequestReader {
  constructor(manager, begin, end) {
    this._manager = manager;
    const args = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = manager.url;
    this._requestId = manager.requestRange(begin, end, args);
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = undefined;
    this.onProgress = null;
    this.onClosed = null;
  }

  _close() {
    this.onClosed?.(this);
  }

  _onDone(data) {
    const chunk = data.chunk;

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }

    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._close();
  }

  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }

    this._requests.length = 0;
    this._queuedChunk = null;
  }

  _onProgress(evt) {
    if (!this.isStreamingSupported) {
      this.onProgress?.({
        loaded: evt.loaded
      });
    }
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._storedError) {
      throw this._storedError;
    }

    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }

    this._close();
  }

}

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFFetchStream = void 0;

var _util = __w_pdfjs_require__(2);

var _network_utils = __w_pdfjs_require__(24);

;

function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController?.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}

function createHeaders(httpHeaders) {
  const headers = new Headers();

  for (const property in httpHeaders) {
    const value = httpHeaders[property];

    if (typeof value === "undefined") {
      continue;
    }

    headers.append(property, value);
  }

  return headers;
}

class PDFFetchStream {
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFFetchStreamRangeReader(this, begin, end);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFFetchStream = PDFFetchStream;

class PDFFetchStreamReader {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    if (typeof AbortController !== "undefined") {
      this._abortController = new AbortController();
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = createHeaders(this._stream.httpHeaders);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._reader = response.body.getReader();

      this._headersCapability.resolve();

      const getResponseHeader = name => {
        return response.headers.get(name);
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new _util.AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    if (this._abortController) {
      this._abortController.abort();
    }
  }

}

class PDFFetchStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._isStreamingSupported = !source.disableStream;

    if (typeof AbortController !== "undefined") {
      this._abortController = new AbortController();
    }

    this._headers = createHeaders(this._stream.httpHeaders);

    this._headers.append("Range", `bytes=${begin}-${end - 1}`);

    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._readCapability.resolve();

      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    if (this._abortController) {
      this._abortController.abort();
    }
  }

}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AnnotationLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_layer.AnnotationLayer;
  }
}));
Object.defineProperty(exports, "AnnotationMode", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationMode;
  }
}));
Object.defineProperty(exports, "CMapCompressionType", ({
  enumerable: true,
  get: function () {
    return _util.CMapCompressionType;
  }
}));
Object.defineProperty(exports, "GlobalWorkerOptions", ({
  enumerable: true,
  get: function () {
    return _worker_options.GlobalWorkerOptions;
  }
}));
Object.defineProperty(exports, "InvalidPDFException", ({
  enumerable: true,
  get: function () {
    return _util.InvalidPDFException;
  }
}));
Object.defineProperty(exports, "LinkTarget", ({
  enumerable: true,
  get: function () {
    return _display_utils.LinkTarget;
  }
}));
Object.defineProperty(exports, "LoopbackPort", ({
  enumerable: true,
  get: function () {
    return _api.LoopbackPort;
  }
}));
Object.defineProperty(exports, "MissingPDFException", ({
  enumerable: true,
  get: function () {
    return _util.MissingPDFException;
  }
}));
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function () {
    return _util.OPS;
  }
}));
Object.defineProperty(exports, "PDFDataRangeTransport", ({
  enumerable: true,
  get: function () {
    return _api.PDFDataRangeTransport;
  }
}));
Object.defineProperty(exports, "PDFDateString", ({
  enumerable: true,
  get: function () {
    return _display_utils.PDFDateString;
  }
}));
Object.defineProperty(exports, "PDFWorker", ({
  enumerable: true,
  get: function () {
    return _api.PDFWorker;
  }
}));
Object.defineProperty(exports, "PasswordResponses", ({
  enumerable: true,
  get: function () {
    return _util.PasswordResponses;
  }
}));
Object.defineProperty(exports, "PermissionFlag", ({
  enumerable: true,
  get: function () {
    return _util.PermissionFlag;
  }
}));
Object.defineProperty(exports, "PixelsPerInch", ({
  enumerable: true,
  get: function () {
    return _display_utils.PixelsPerInch;
  }
}));
Object.defineProperty(exports, "RenderingCancelledException", ({
  enumerable: true,
  get: function () {
    return _display_utils.RenderingCancelledException;
  }
}));
Object.defineProperty(exports, "SVGGraphics", ({
  enumerable: true,
  get: function () {
    return _svg.SVGGraphics;
  }
}));
Object.defineProperty(exports, "UNSUPPORTED_FEATURES", ({
  enumerable: true,
  get: function () {
    return _util.UNSUPPORTED_FEATURES;
  }
}));
Object.defineProperty(exports, "UnexpectedResponseException", ({
  enumerable: true,
  get: function () {
    return _util.UnexpectedResponseException;
  }
}));
Object.defineProperty(exports, "Util", ({
  enumerable: true,
  get: function () {
    return _util.Util;
  }
}));
Object.defineProperty(exports, "VerbosityLevel", ({
  enumerable: true,
  get: function () {
    return _util.VerbosityLevel;
  }
}));
Object.defineProperty(exports, "XfaLayer", ({
  enumerable: true,
  get: function () {
    return _xfa_layer.XfaLayer;
  }
}));
Object.defineProperty(exports, "addLinkAttributes", ({
  enumerable: true,
  get: function () {
    return _display_utils.addLinkAttributes;
  }
}));
Object.defineProperty(exports, "build", ({
  enumerable: true,
  get: function () {
    return _api.build;
  }
}));
Object.defineProperty(exports, "createObjectURL", ({
  enumerable: true,
  get: function () {
    return _util.createObjectURL;
  }
}));
Object.defineProperty(exports, "createPromiseCapability", ({
  enumerable: true,
  get: function () {
    return _util.createPromiseCapability;
  }
}));
Object.defineProperty(exports, "createValidAbsoluteUrl", ({
  enumerable: true,
  get: function () {
    return _util.createValidAbsoluteUrl;
  }
}));
Object.defineProperty(exports, "getDocument", ({
  enumerable: true,
  get: function () {
    return _api.getDocument;
  }
}));
Object.defineProperty(exports, "getFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getPdfFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getPdfFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getXfaPageViewport", ({
  enumerable: true,
  get: function () {
    return _display_utils.getXfaPageViewport;
  }
}));
Object.defineProperty(exports, "isPdfFile", ({
  enumerable: true,
  get: function () {
    return _display_utils.isPdfFile;
  }
}));
Object.defineProperty(exports, "loadScript", ({
  enumerable: true,
  get: function () {
    return _display_utils.loadScript;
  }
}));
Object.defineProperty(exports, "removeNullCharacters", ({
  enumerable: true,
  get: function () {
    return _util.removeNullCharacters;
  }
}));
Object.defineProperty(exports, "renderTextLayer", ({
  enumerable: true,
  get: function () {
    return _text_layer.renderTextLayer;
  }
}));
Object.defineProperty(exports, "shadow", ({
  enumerable: true,
  get: function () {
    return _util.shadow;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _api.version;
  }
}));

var _display_utils = __w_pdfjs_require__(1);

var _util = __w_pdfjs_require__(2);

var _api = __w_pdfjs_require__(6);

var _annotation_layer = __w_pdfjs_require__(18);

var _worker_options = __w_pdfjs_require__(12);

var _is_node = __w_pdfjs_require__(4);

var _text_layer = __w_pdfjs_require__(21);

var _svg = __w_pdfjs_require__(22);

var _xfa_layer = __w_pdfjs_require__(20);

const pdfjsVersion = '2.12.313';
const pdfjsBuild = 'a2ae56f39';
{
  if (_is_node.isNodeJS) {
    const {
      PDFNodeStream
    } = __w_pdfjs_require__(23);

    (0, _api.setPDFNetworkStreamFactory)(params => {
      return new PDFNodeStream(params);
    });
  } else {
    const {
      PDFNetworkStream
    } = __w_pdfjs_require__(26);

    const {
      PDFFetchStream
    } = __w_pdfjs_require__(27);

    (0, _api.setPDFNetworkStreamFactory)(params => {
      if ((0, _display_utils.isValidFetchUrl)(params.url)) {
        return new PDFFetchStream(params);
      }

      return new PDFNetworkStream(params);
    });
  }
}
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.js.map

/***/ }),

/***/ "./src/annotate/annotation.ts":
/*!************************************!*\
  !*** ./src/annotate/annotation.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.AnnotationFactory = exports.ParameterParser = void 0;
var parser_1 = __webpack_require__(/*! ./parser */ "./src/annotate/parser.ts");
var text_annotation_1 = __webpack_require__(/*! ./annotations/text_annotation */ "./src/annotate/annotations/text_annotation.ts");
var text_markup_annotation_1 = __webpack_require__(/*! ./annotations/text_markup_annotation */ "./src/annotate/annotations/text_markup_annotation.ts");
var freetext_annotation_1 = __webpack_require__(/*! ./annotations/freetext_annotation */ "./src/annotate/annotations/freetext_annotation.ts");
var circle_square_annotation_1 = __webpack_require__(/*! ./annotations/circle_square_annotation */ "./src/annotate/annotations/circle_square_annotation.ts");
var polygon_polyline_annotation_1 = __webpack_require__(/*! ./annotations/polygon_polyline_annotation */ "./src/annotate/annotations/polygon_polyline_annotation.ts");
var ink_annotation_1 = __webpack_require__(/*! ./annotations/ink_annotation */ "./src/annotate/annotations/ink_annotation.ts");
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var writer_1 = __webpack_require__(/*! ./writer */ "./src/annotate/writer.ts");
var ParameterParser = /** @class */ (function () {
    function ParameterParser() {
    }
    /**
     * Parses and checks the parameter. This is for backward compatibility and to support arbitrary annotation parameters
     * */
    ParameterParser.parseParameters = function (values) {
        if (values.length === 0) {
            throw Error("No parameters provided");
        }
        var i = 0;
        if (typeof values[i] === 'number') {
            var ret_val = {};
            ret_val.page = values[i++];
            ret_val.rect = values[i++];
            ret_val.contents = values[i++];
            if (typeof ret_val.contents !== 'string') {
                throw Error("Invalid contents parameter");
            }
            ret_val.author = values[i++];
            if (typeof ret_val.author !== 'string') {
                throw Error("Invalid author parameter");
            }
            if (i >= values.length)
                return ret_val;
            if ("r" in values[i] && "g" in values[i] && "b" in values[i]) {
                ret_val.color = values[i++];
            }
            else if (Array.isArray(values[i]) && values[i].length > 0 && typeof values[i][0] === 'number') {
                ret_val.vertices = values[i++];
            }
            else if (Array.isArray(values[i]) && values[i].length > 0 && Array.isArray(values[i][0])) {
                ret_val.inkList = values[i++];
            }
            else {
                throw Error("Invalid parameter provided - is neither color, nor quadpoints array or an inklist");
            }
            if (i >= values.length)
                return ret_val;
            if ("r" in values[i] && "g" in values[i] && "b" in values[i]) {
                if (ret_val.color) {
                    ret_val.fill = values[i++];
                }
                else {
                    ret_val.color = values[i++];
                }
            }
            else if (Array.isArray(values[i]) && values[i].length > 0 && typeof values[i][0] === 'number') {
                ret_val.quadPoints = values[i++];
            }
            else if (typeof values[i] === 'object') {
                ret_val.config = true;
                ret_val = Object.assign(ret_val, values[i++]);
            }
            else {
                throw Error("Invalid parameter provided");
            }
            if (i >= values.length)
                return ret_val;
            if (!ret_val.config && typeof values[i] === 'object') {
                ret_val = Object.assign(ret_val, values[i++]);
            }
            else {
                throw Error("Invalid configuration provided");
            }
            return ret_val;
        }
        else if (typeof values[i] === 'object') {
            return values[0];
        }
        else {
            throw Error("Invalid configuration object");
        }
    };
    return ParameterParser;
}());
exports.ParameterParser = ParameterParser;
/**
 * The annotation factory provides methods to create annotations. Those are stored temporarily
 * and than encoded into PDF code when the PDF document is written.
 * */
var AnnotationFactory = /** @class */ (function () {
    function AnnotationFactory(data, userPassword, ownerPassword) {
        if (userPassword === void 0) { userPassword = ""; }
        if (ownerPassword === void 0) { ownerPassword = ""; }
        this.data = data;
        this.userPassword = userPassword;
        this.ownerPassword = ownerPassword;
        this.annotations = [];
        this.toDelete = [];
        this.data = data;
        this.parser = new parser_1.PDFDocumentParser(this.data, this.userPassword, this.ownerPassword);
    }
    /**
     * Returns the number of annotations that will be added to the PDF document
     * */
    AnnotationFactory.prototype.getAnnotationCount = function () {
        return this.annotations.length;
    };
    /**
     * Load a PDF file referenced by the given 'path'
     * */
    AnnotationFactory.loadFile = function (path, userPassword, ownerPassword) {
        if (userPassword === void 0) { userPassword = ""; }
        if (ownerPassword === void 0) { ownerPassword = ""; }
        return new Promise(function (resolve) {
            if (typeof window !== 'undefined') { // browser environment
                fetch(path).then(function (r) { return r.blob(); }).then(function (data) {
                    var reader = new FileReader();
                    reader.onload = function () {
                        resolve(new AnnotationFactory(reader.result, userPassword, ownerPassword));
                    };
                    reader.readAsArrayBuffer(data);
                });
            }
            else if (typeof process === 'object') { // node environment
                var fs = __webpack_require__(/*! fs */ "?4a96");
                var data = fs.readFileSync(path);
                resolve(new AnnotationFactory(data, userPassword, ownerPassword));
            }
            else {
                throw Error("Unsupported environment");
            }
        });
    };
    /**
     * Generates a unique identifier necessary for creating the annotation
     * */
    AnnotationFactory.prototype.generateUniqueIdentifier = function () {
        return "pdfAnnotate-" + util_1.Util.convertDateToPDFDate(new Date()).slice(3, 17) + "-" + this.annotations.length;
    };
    /**
     * Generates a default border
     * */
    AnnotationFactory.prototype.createDefaultBorder = function () {
        return {
            vertical_corner_radius: 0,
            horizontal_corner_radius: 0,
            border_width: 1
        };
    };
    /**
     * Writes the created annotations into a bytestream
     * */
    AnnotationFactory.prototype.write = function () {
        if (this.annotations.length === 0 && this.toDelete.length === 0)
            return this.data;
        var writer = new writer_1.Writer(this.data, this.annotations, this.toDelete, this.parser);
        return writer.write();
    };
    /**
     * Checks the 'rect' parameter, whether all the entries are of type number and if the the number of entries is correct
     * */
    AnnotationFactory.prototype.checkRect = function (nr, rect) {
        if (!Array.isArray(rect)) {
            throw Error("invalid rect parameter");
        }
        if (rect.length !== nr)
            throw Error("Rect has invalid number of entries: " + rect + " has " + rect.length + " entries, but should have " + nr + " entries");
        rect.forEach(function (a) {
            if ('number' !== typeof a)
                throw Error("Rect " + rect + " has invalid entry: " + a);
        });
    };
    /**
     * Creates a base annotation that means the raw object of annotation or those parts that exist
     * in equal form in all types of annotations
     * */
    AnnotationFactory.prototype.createBaseAnnotation = function (page) {
        if (page < 0) {
            throw Error("Invalid page number: ".concat(page));
        }
        var annot = {
            object_id: this.parser.getFreeObjectId(),
            id: this.generateUniqueIdentifier(),
            pageReference: this.parser.getPage(page),
            updateDate: util_1.Util.convertDateToPDFDate(new Date()),
            border: this.createDefaultBorder(),
            page: page, rect: [], factory: this
        };
        return annot;
    };
    /**
     * Creates a text annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * options : dictionary containing additional configuration values, see documentation
     * */
    AnnotationFactory.prototype.createTextAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new text_annotation_1.TextAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a highlight annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * quadPoints : regions to mark with the highlight
     * */
    AnnotationFactory.prototype.createHighlightAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new text_markup_annotation_1.HighlightAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates an underline annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * quadPoints : regions to mark with the highlight
     * */
    AnnotationFactory.prototype.createUnderlineAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new text_markup_annotation_1.UnderlineAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a squiggle annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * quadPoints : regions to mark with the highlight
     * */
    AnnotationFactory.prototype.createSquigglyAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new text_markup_annotation_1.SquigglyAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a strike out annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * quadPoints : regions to mark with the highlight
     * */
    AnnotationFactory.prototype.createStrikeOutAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new text_markup_annotation_1.StrikeOutAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a free text annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createFreeTextAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new freetext_annotation_1.FreeTextAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    AnnotationFactory.prototype.createLineAnnotation = function () {
        throw Error("No yet implemented");
    };
    /**
     * Creates a square annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * fill : the filling color of  the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createSquareAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new circle_square_annotation_1.SquareAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a circle annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * fill : the filling color of  the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createCircleAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new circle_square_annotation_1.CircleAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a polygon annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * vertices : the vertices defining the arrangement of the object
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createPolygonAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new polygon_polyline_annotation_1.PolygonAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a polyline annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * vertices : the vertices defining the arrangement of the object
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createPolyLineAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new polygon_polyline_annotation_1.PolyLineAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates an ink annotation
     * page : the number of the PDF document page, where the annotation must be attached
     * rect : the position of the annotation on the page
     * contents : the content of the annotation
     * author : the author of the annotation
     * inkList : a list of list containing the points for drawing the lines
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createInkAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = new ink_annotation_1.InkAnnotationObj();
        annot = Object.assign(annot, this.createBaseAnnotation(params.page));
        annot = Object.assign(annot, params);
        annot.validate();
        this.annotations.push(annot);
        return annot;
    };
    /**
     * Creates a stamp annotation. There exists a number of predifined stamps that can be attached to PDF documents.
     * page : the number of the PDF document page, where the annotation must be attached
     * contents : the content of the annotation
     * author : the author of the annotation
     * stampType : the name of the used stamp type. Can be: [Approved, Experimental, NotApproved, AsIs, Expired, NotForPublicRelease, Confidential, Final, Sold, Departmental, ForComment, TopSecret, Draft, ForPublicRelease]
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createStampAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = Object.assign(this.createBaseAnnotation(params.page), {
            opacity: 1,
            initiallyOpen: false,
            annotation_flag: 4,
            color: params.color,
            stampType: params.stampType
        });
        annot.type = "/Stamp";
        this.annotations.push(annot);
    };
    /**
     * Creates a visual symbol that indcates the existance of text edits.
     * page : the number of the PDF document page, where the annotation must be attached
     * contents : the content of the annotation
     * author : the author of the annotation
     * caretSymbol : None or P, with P for using the paragraph symbol as caret
     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1
     * */
    AnnotationFactory.prototype.createCaretAnnotation = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var params = ParameterParser.parseParameters(values);
        var annot = Object.assign(this.createBaseAnnotation(params.page), {
            opacity: 1,
            initiallyOpen: false,
            annotation_flag: 4,
            color: params.color,
            caretSymbol: params.caretSymbol
        });
        annot.type = "/Caret";
        this.annotations.push(annot);
    };
    AnnotationFactory.prototype.createPopupAnnotation = function () {
        throw Error("No yet implemented");
    };
    /**
     * Deletes the annotation with the given id or the given reference object
     * */
    AnnotationFactory.prototype.deleteAnnotation = function (id) {
        var _this = this;
        return new Promise(function (resolve) {
            // delete if it was just created but is not in the pdf document
            for (var i = 0; i < _this.annotations.length; ++i) {
                if ('string' === typeof id && _this.annotations[i].id === id) {
                    _this.annotations = _this.annotations = __spreadArray(__spreadArray([], _this.annotations.slice(0, i), true), _this.annotations.slice(i + 1), true);
                    resolve(_this.toDelete);
                    return;
                }
                else if (id.obj && _this.annotations[i].object_id && id.obj === _this.annotations[i].object_id.obj && id.generation && id.generation === _this.annotations[i].object_id.generation) {
                    _this.annotations = _this.annotations = __spreadArray(__spreadArray([], _this.annotations.slice(0, i), true), _this.annotations.slice(i + 1), true);
                    resolve(_this.toDelete);
                    return;
                }
            }
            _this.getAnnotations().then(function (annots) {
                for (var _i = 0, annots_1 = annots; _i < annots_1.length; _i++) {
                    var _annots = annots_1[_i];
                    for (var _a = 0, _annots_1 = _annots; _a < _annots_1.length; _a++) {
                        var annot = _annots_1[_a];
                        if ('string' === typeof id && annot.id === id) {
                            _this.toDelete.push(annot);
                            resolve(_this.toDelete);
                            return;
                        }
                        else if (id.obj && annot.object_id && id.obj === annot.object_id.obj && id.generation && id.generation === annot.object_id.generation) {
                            _this.toDelete.push(annot);
                            resolve(_this.toDelete);
                            return;
                        }
                    }
                }
            });
        });
    };
    AnnotationFactory.prototype._getAnnotations = function () {
        var existingAnnots = this.parser.extractAnnotations(this);
        for (var _i = 0, _a = this.annotations; _i < _a.length; _i++) {
            var newAnnot = _a[_i];
            existingAnnots[newAnnot.page].push(newAnnot);
        }
        return existingAnnots;
    };
    /**
     * Returns a promise with all the annotations that are part of the document. This
     * comprises annotations, that are already part of the parsed document and those that were created using this library and
     * not yet appended to the document.
     * */
    AnnotationFactory.prototype.getAnnotations = function () {
        var _this = this;
        return new Promise(function (resolve) {
            resolve(_this._getAnnotations());
        });
    };
    /**
     * Returns the fonts, that are available in the PDF document
     * */
    AnnotationFactory.prototype.getFonts = function () {
        var _this = this;
        return new Promise(function (resolve) {
            resolve(_this.parser.getFonts().fonts);
        });
    };
    /**
     * Downloads the adapted PDF document
     * */
    AnnotationFactory.prototype.download = function (fileName) {
        if (fileName === void 0) { fileName = "output.pdf"; }
        var a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        var extended_pdf = this.write();
        var blob = new Blob([extended_pdf], { type: "application/pdf" });
        var url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = fileName;
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
    };
    /**
     * Saves the adapted PDF document in a nodejs environment and downloads it in a browser environment.
     * */
    AnnotationFactory.prototype.save = function (fileName) {
        if (fileName === void 0) { fileName = "output.pdf"; }
        if (typeof window !== 'undefined') { // browser environment
            this.download(fileName);
        }
        else if (typeof process === 'object') { // node environment
            var fs = __webpack_require__(/*! fs */ "?4a96");
            var data = this.write();
            fs.writeFile(fileName, Buffer.from(new Uint8Array(data)), function (err) {
                if (err) {
                    throw Error(err);
                }
            });
        }
        else {
            throw Error("Unsupported environment");
        }
    };
    return AnnotationFactory;
}());
exports.AnnotationFactory = AnnotationFactory;


/***/ }),

/***/ "./src/annotate/annotations/annotation_errors.ts":
/*!*******************************************************!*\
  !*** ./src/annotate/annotations/annotation_errors.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.InvalidFontError = exports.InvalidFontSizeError = exports.InvalidAppearanceStreamError = exports.InvalidAnnotationReference = exports.InvalidVerticesError = exports.InvalidQuadPointError = exports.InvalidStateError = exports.InvalidIDError = exports.InvalidRectError = exports.InvalidDateError = exports.InvalidReferencePointerError = exports.ColorOutOfRangeError = exports.InvalidColorError = exports.InvalidOpacityError = exports.InvalidAnnotationTypeError = void 0;
var InvalidAnnotationTypeError = /** @class */ (function (_super) {
    __extends(InvalidAnnotationTypeError, _super);
    function InvalidAnnotationTypeError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidAnnotationTypeError";
        return _this;
    }
    return InvalidAnnotationTypeError;
}(Error));
exports.InvalidAnnotationTypeError = InvalidAnnotationTypeError;
var InvalidOpacityError = /** @class */ (function (_super) {
    __extends(InvalidOpacityError, _super);
    function InvalidOpacityError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidOpacityError";
        return _this;
    }
    return InvalidOpacityError;
}(Error));
exports.InvalidOpacityError = InvalidOpacityError;
var InvalidColorError = /** @class */ (function (_super) {
    __extends(InvalidColorError, _super);
    function InvalidColorError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidColorError";
        return _this;
    }
    return InvalidColorError;
}(Error));
exports.InvalidColorError = InvalidColorError;
var ColorOutOfRangeError = /** @class */ (function (_super) {
    __extends(ColorOutOfRangeError, _super);
    function ColorOutOfRangeError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "ColorOutOfRangeError";
        return _this;
    }
    return ColorOutOfRangeError;
}(Error));
exports.ColorOutOfRangeError = ColorOutOfRangeError;
var InvalidReferencePointerError = /** @class */ (function (_super) {
    __extends(InvalidReferencePointerError, _super);
    function InvalidReferencePointerError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidReferencePointerError";
        return _this;
    }
    return InvalidReferencePointerError;
}(Error));
exports.InvalidReferencePointerError = InvalidReferencePointerError;
var InvalidDateError = /** @class */ (function (_super) {
    __extends(InvalidDateError, _super);
    function InvalidDateError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidDateError";
        return _this;
    }
    return InvalidDateError;
}(Error));
exports.InvalidDateError = InvalidDateError;
var InvalidRectError = /** @class */ (function (_super) {
    __extends(InvalidRectError, _super);
    function InvalidRectError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidRectError";
        return _this;
    }
    return InvalidRectError;
}(Error));
exports.InvalidRectError = InvalidRectError;
var InvalidIDError = /** @class */ (function (_super) {
    __extends(InvalidIDError, _super);
    function InvalidIDError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidIDError";
        return _this;
    }
    return InvalidIDError;
}(Error));
exports.InvalidIDError = InvalidIDError;
var InvalidStateError = /** @class */ (function (_super) {
    __extends(InvalidStateError, _super);
    function InvalidStateError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidStateError";
        return _this;
    }
    return InvalidStateError;
}(Error));
exports.InvalidStateError = InvalidStateError;
var InvalidQuadPointError = /** @class */ (function (_super) {
    __extends(InvalidQuadPointError, _super);
    function InvalidQuadPointError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidQuadPointError";
        return _this;
    }
    return InvalidQuadPointError;
}(Error));
exports.InvalidQuadPointError = InvalidQuadPointError;
var InvalidVerticesError = /** @class */ (function (_super) {
    __extends(InvalidVerticesError, _super);
    function InvalidVerticesError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidVerticesError";
        return _this;
    }
    return InvalidVerticesError;
}(Error));
exports.InvalidVerticesError = InvalidVerticesError;
var InvalidAnnotationReference = /** @class */ (function (_super) {
    __extends(InvalidAnnotationReference, _super);
    function InvalidAnnotationReference(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidAnnotationError";
        return _this;
    }
    return InvalidAnnotationReference;
}(Error));
exports.InvalidAnnotationReference = InvalidAnnotationReference;
var InvalidAppearanceStreamError = /** @class */ (function (_super) {
    __extends(InvalidAppearanceStreamError, _super);
    function InvalidAppearanceStreamError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidAppearanceStreamError";
        return _this;
    }
    return InvalidAppearanceStreamError;
}(Error));
exports.InvalidAppearanceStreamError = InvalidAppearanceStreamError;
var InvalidFontSizeError = /** @class */ (function (_super) {
    __extends(InvalidFontSizeError, _super);
    function InvalidFontSizeError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidFontSizeError";
        return _this;
    }
    return InvalidFontSizeError;
}(Error));
exports.InvalidFontSizeError = InvalidFontSizeError;
var InvalidFontError = /** @class */ (function (_super) {
    __extends(InvalidFontError, _super);
    function InvalidFontError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "InvalidFontError";
        return _this;
    }
    return InvalidFontError;
}(Error));
exports.InvalidFontError = InvalidFontError;


/***/ }),

/***/ "./src/annotate/annotations/annotation_types.ts":
/*!******************************************************!*\
  !*** ./src/annotate/annotations/annotation_types.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.MarkupAnnotationObj = exports.ReplyTypes = exports.RawAnnotationObj = exports.BaseAnnotationObj = exports.BorderStyles = exports.LineEndingStyle = void 0;
var parser_1 = __webpack_require__(/*! ../parser */ "./src/annotate/parser.ts");
var util_1 = __webpack_require__(/*! ../util */ "./src/annotate/util.ts");
var annotation_errors_1 = __webpack_require__(/*! ./annotation_errors */ "./src/annotate/annotations/annotation_errors.ts");
var writer_util_1 = __webpack_require__(/*! ../writer-util */ "./src/annotate/writer-util.ts");
var LineEndingStyle;
(function (LineEndingStyle) {
    LineEndingStyle[LineEndingStyle["Square"] = 0] = "Square";
    LineEndingStyle[LineEndingStyle["Circle"] = 1] = "Circle";
    LineEndingStyle[LineEndingStyle["Diamond"] = 2] = "Diamond";
    LineEndingStyle[LineEndingStyle["OpenArrow"] = 3] = "OpenArrow";
    LineEndingStyle[LineEndingStyle["ClosedArrow"] = 4] = "ClosedArrow";
    LineEndingStyle[LineEndingStyle["Butt"] = 5] = "Butt";
    LineEndingStyle[LineEndingStyle["ROpenArrow"] = 6] = "ROpenArrow";
    LineEndingStyle[LineEndingStyle["RClosedArrow"] = 7] = "RClosedArrow";
    LineEndingStyle[LineEndingStyle["Slash"] = 8] = "Slash";
    LineEndingStyle[LineEndingStyle["None"] = 9] = "None";
})(LineEndingStyle = exports.LineEndingStyle || (exports.LineEndingStyle = {}));
var BorderStyles;
(function (BorderStyles) {
    BorderStyles[BorderStyles["Solid"] = 0] = "Solid";
    BorderStyles[BorderStyles["Dashed"] = 1] = "Dashed";
    BorderStyles[BorderStyles["Beveled"] = 2] = "Beveled";
    BorderStyles[BorderStyles["Inset"] = 3] = "Inset";
    BorderStyles[BorderStyles["Underline"] = 4] = "Underline";
})(BorderStyles = exports.BorderStyles || (exports.BorderStyles = {}));
var BaseAnnotationObj = /** @class */ (function () {
    function BaseAnnotationObj() {
        this.object_id = undefined; // an unused object id
        this.is_deleted = false; // internal flag to determine whether the annotation was deleted
        this.additional_objects_to_write = []; // holds objects, that must be written, since they are used by the annotation
        this.page = -1;
        this.pageReference = undefined; // The reference to the page object to which the annotation is added
        this.type = "";
        this.type_encoded = [];
        this.rect = [];
        this.contents = "";
        this.id = ""; // /NM
        this.updateDate = ""; // /M
        this.takeAppearanceStreamFrom = undefined;
        this.factory = undefined;
    }
    /**
     * Creates a default appearance stream for the given annotation type and assigns it to the annotation
     * */
    BaseAnnotationObj.prototype.createDefaultAppearanceStream = function () { };
    BaseAnnotationObj.prototype.writeAnnotationPreamble = function () {
        var ret = writer_util_1.WriterUtil.writeReferencePointer(this.object_id);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.OBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);
        ret = ret.concat(writer_util_1.WriterUtil.TYPE_ANNOT);
        ret.push(writer_util_1.WriterUtil.SPACE);
        return ret;
    };
    BaseAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = [];
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.PAGE_REFERENCE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(this.pageReference.object_id, true));
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.SUBTYPE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(this.type_encoded);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.RECT);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.rect));
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.CONTENTS);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret.push(writer_util_1.WriterUtil.BRACKET_START);
        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.contents)), this.object_id))));
        ret.push(writer_util_1.WriterUtil.BRACKET_END);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.ID);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret.push(writer_util_1.WriterUtil.BRACKET_START);
        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.id)), this.object_id))));
        ret.push(writer_util_1.WriterUtil.BRACKET_END);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.UPDATE_DATE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret.push(writer_util_1.WriterUtil.BRACKET_START);
        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.updateDate)), this.object_id))));
        ret.push(writer_util_1.WriterUtil.BRACKET_END);
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (this.appearanceStream) {
            ret = ret.concat(writer_util_1.WriterUtil.AP);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.appearanceStream.writeAppearanceStream());
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.annotationFlags) {
            var flags_value = this.encodeAnnotationFlags();
            ret = ret.concat(writer_util_1.WriterUtil.FLAG);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(flags_value));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.border) {
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.BORDER);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([this.border.horizontal_corner_radius || 0, this.border.vertical_corner_radius || 0, this.border.border_width || 1]));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.color) {
            this.color = util_1.Util.colorToRange01(this.color);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.COLOR);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([this.color.r, this.color.g, this.color.b]));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.raw_parameters && this.raw_parameters.length > 0) {
            for (var _i = 0, _a = this.raw_parameters; _i < _a.length; _i++) {
                var i = _a[_i];
                ret.push(writer_util_1.WriterUtil.SPACE);
                ret = ret.concat(i);
                ret.push(writer_util_1.WriterUtil.SPACE);
            }
        }
        return ret;
    };
    BaseAnnotationObj.prototype.convertLineEndingStyle = function (lne) {
        switch (lne) {
            case LineEndingStyle.Square:
                return util_1.Util.convertStringToAscii("/Square");
            case LineEndingStyle.Circle:
                return util_1.Util.convertStringToAscii("/Circle");
            case LineEndingStyle.Diamond:
                return util_1.Util.convertStringToAscii("/Diamond");
            case LineEndingStyle.OpenArrow:
                return util_1.Util.convertStringToAscii("/OpenArrow");
            case LineEndingStyle.ClosedArrow:
                return util_1.Util.convertStringToAscii("/ClosedArrow");
            case LineEndingStyle.Butt:
                return util_1.Util.convertStringToAscii("/Butt");
            case LineEndingStyle.ROpenArrow:
                return util_1.Util.convertStringToAscii("/ROpenArrow");
            case LineEndingStyle.RClosedArrow:
                return util_1.Util.convertStringToAscii("/RClosedArrow");
            case LineEndingStyle.Slash:
                return util_1.Util.convertStringToAscii("/Slash");
            default:
                return util_1.Util.convertStringToAscii("/None");
        }
    };
    BaseAnnotationObj.prototype.writeAnnotationPostamble = function () {
        var ret = __spreadArray([], writer_util_1.WriterUtil.DICT_END, true);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        return ret;
    };
    BaseAnnotationObj.prototype.encodeAnnotationFlags = function () {
        if (!this.annotationFlags) {
            return 0;
        }
        var val = 0;
        if (this.annotationFlags.invisible) {
            val |= 1;
        }
        if (this.annotationFlags.hidden) {
            val |= 2;
        }
        if (this.annotationFlags.print) {
            val |= 4;
        }
        if (this.annotationFlags.noZoom) {
            val |= 8;
        }
        if (this.annotationFlags.noRotate) {
            val |= 16;
        }
        if (this.annotationFlags.noView) {
            val |= 32;
        }
        if (this.annotationFlags.readOnly) {
            val |= 64;
        }
        if (this.annotationFlags.locked) {
            val |= 128;
        }
        if (this.annotationFlags.toggleNoView) {
            val |= 256;
        }
        if (this.annotationFlags.lockedContents) {
            val |= 512;
        }
        return val;
    };
    /**
     * If enact is true, the error will be thrown directly, otherwise the errors are collected
     * and returned as error list.
     * */
    BaseAnnotationObj.prototype.validate = function (enact) {
        var _this = this;
        if (enact === void 0) { enact = true; }
        var errorList = this.checkRect(4, this.rect);
        errorList = errorList.concat(this.checkReferencePointer(this.object_id));
        if (!this.pageReference || typeof this.pageReference !== 'object') {
            errorList.push(new annotation_errors_1.InvalidReferencePointerError("Inalid page reference"));
        }
        var res = this.checkDate(this.updateDate);
        if (res[1]) {
            this.updateDate = res[1];
        }
        errorList = errorList.concat(res[0]);
        errorList = errorList.concat(this.checkColor(this.color));
        if (!this.id || this.id === "") {
            errorList.push(new annotation_errors_1.InvalidIDError("Invalid ID provided"));
        }
        // Check referenced appearance streams
        if (this.takeAppearanceStreamFrom) {
            if (typeof this.takeAppearanceStreamFrom === 'string') { // lookup appearance stream
                var res_1 = [];
                this.factory._getAnnotations().forEach(function (annots) {
                    res_1 = annots.filter(function (value) { return value.id === _this.takeAppearanceStreamFrom; });
                });
                if (res_1.length === 0 || res_1.length > 1) {
                    errorList.push(new annotation_errors_1.InvalidAnnotationReference("The provided string referencing the annotation to take the appearance stream from is not valid."));
                }
                if (!res_1[0].appearanceStream) {
                    errorList.push(new annotation_errors_1.InvalidAppearanceStreamError("The referenced annotation has no specified appearance stream."));
                }
                this.appearanceStream = res_1[0].appearanceStream;
            }
            else if (this.takeAppearanceStreamFrom instanceof BaseAnnotationObj) {
                this.appearanceStream = this.takeAppearanceStreamFrom.appearanceStream;
            }
        }
        if (enact) {
            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {
                var error = errorList_1[_i];
                throw error;
            }
        }
        return errorList;
    };
    BaseAnnotationObj.prototype.checkColor = function (color) {
        var errorList = [];
        if (!color) {
            return errorList;
        }
        if (!(color && "r" in color && "g" in color && "b" in color)) {
            errorList.push(new annotation_errors_1.InvalidColorError("Not {r: <r>, g: <g>, b: <b>}"));
        }
        if (color.r > 255 || color.r < 0) {
            errorList.push(new annotation_errors_1.ColorOutOfRangeError("Red value out of range"));
        }
        if (color.g > 255 || color.g < 0) {
            errorList.push(new annotation_errors_1.ColorOutOfRangeError("Green value out of range"));
        }
        if (color.b > 255 && color.b < 0) {
            errorList.push(new annotation_errors_1.ColorOutOfRangeError("Blue value out of range"));
        }
        return errorList;
    };
    BaseAnnotationObj.prototype.checkReferencePointer = function (ptr) {
        var errorList = [];
        if (!(ptr && "obj" in ptr && ptr.obj >= 0 && "generation" in ptr && ptr.generation >= 0)) {
            errorList.push(new annotation_errors_1.InvalidReferencePointerError("Invalid reference pointer"));
        }
        return errorList;
    };
    BaseAnnotationObj.prototype.checkDate = function (date) {
        if (typeof date === 'string') {
            return [[], date];
        }
        var errorList = [];
        var ret_val = undefined;
        try {
            ret_val = util_1.Util.convertDateToPDFDate(date);
        }
        catch (e) {
            errorList.push(new annotation_errors_1.InvalidDateError("Invalid update date provided"));
        }
        return [errorList, ret_val];
    };
    BaseAnnotationObj.prototype.checkRect = function (nr, rect) {
        var errorList = [];
        if (!Array.isArray(rect)) {
            errorList.push(new annotation_errors_1.InvalidRectError("invalid rect parameter"));
        }
        if (rect.length !== nr) {
            errorList.push(new annotation_errors_1.InvalidRectError("Rect has invalid number of entries: " + rect + " has " + rect.length + " entries, but should have " + nr + " entries"));
        }
        rect.forEach(function (a) {
            if ('number' !== typeof a) {
                errorList.push(new annotation_errors_1.InvalidRectError("Rect " + rect + " has invalid entry: " + a));
            }
        });
        return errorList;
    };
    /**
     * Extracts the information of the raw annotation obj that is provided by the PDF document parser
     * */
    BaseAnnotationObj.prototype.extract = function (annot_obj, page, cryptoInterface) {
        this.pageReference = page;
        this.type = annot_obj["/Subtype"];
        this.rect = annot_obj["/Rect"];
        if (annot_obj["/M"])
            this.updateDate = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj["/M"], this.object_id));
        if (annot_obj["/Border"])
            this.border = annot_obj["/Border"];
        if (annot_obj["/C"])
            this.color = annot_obj["/C"];
        if (annot_obj["/NM"])
            this.id = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj["/NM"], this.object_id));
        if (annot_obj["/Contents"])
            this.contents = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj["/Contents"], this.object_id));
        if (annot_obj["/AP"])
            this.appearanceStream = parser_1.AppearanceStreamParser.parse(this, annot_obj["/AP"]);
    };
    return BaseAnnotationObj;
}());
exports.BaseAnnotationObj = BaseAnnotationObj;
/**
 * A helper class that is only used if a parsed annotation type cannot be identified and translated into a supported annotation type
 * */
var RawAnnotationObj = /** @class */ (function (_super) {
    __extends(RawAnnotationObj, _super);
    function RawAnnotationObj() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RawAnnotationObj;
}(BaseAnnotationObj));
exports.RawAnnotationObj = RawAnnotationObj;
var ReplyTypes;
(function (ReplyTypes) {
    ReplyTypes[ReplyTypes["Reply"] = 0] = "Reply";
    ReplyTypes[ReplyTypes["Group"] = 1] = "Group";
})(ReplyTypes = exports.ReplyTypes || (exports.ReplyTypes = {}));
var MarkupAnnotationObj = /** @class */ (function (_super) {
    __extends(MarkupAnnotationObj, _super);
    function MarkupAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.author = "";
        _this.opacity = 1; // /CA
        _this.subject = "";
        return _this;
    }
    MarkupAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        ret = ret.concat(writer_util_1.WriterUtil.AUTHOR);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret.push(writer_util_1.WriterUtil.BRACKET_START);
        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.author)), this.object_id))));
        ret.push(writer_util_1.WriterUtil.BRACKET_END);
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (this.opacity) {
            ret = ret.concat(writer_util_1.WriterUtil.OPACITY);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.opacity));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.creationDate) {
            ret = ret.concat(writer_util_1.WriterUtil.CREATION_DATE);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret.push(writer_util_1.WriterUtil.BRACKET_START);
            ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.creationDate)), this.object_id))));
            ret.push(writer_util_1.WriterUtil.BRACKET_END);
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.subject !== "") {
            ret = ret.concat(writer_util_1.WriterUtil.SUBJ);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret.push(writer_util_1.WriterUtil.BRACKET_START);
            ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.subject)), this.object_id))));
            ret.push(writer_util_1.WriterUtil.BRACKET_END);
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.richtextString) {
            ret = ret.concat(writer_util_1.WriterUtil.RC);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret.push(writer_util_1.WriterUtil.BRACKET_START);
            ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.richtextString)), this.object_id))));
            ret.push(writer_util_1.WriterUtil.BRACKET_END);
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        return ret;
    };
    MarkupAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.opacity) {
            try {
                this.opacity = +this.opacity;
            }
            catch (e) {
                errorList.push(new annotation_errors_1.InvalidOpacityError("Opacity no numerical value"));
            }
            if (this.opacity < 0 || this.opacity > 255) {
                errorList.push(new annotation_errors_1.InvalidOpacityError("Opacity out of range"));
            }
        }
        if (this.creationDate) {
            var res = this.checkDate(this.creationDate);
            this.creationDate = res[1];
            errorList = errorList.concat(res[0]);
        }
        if (enact) {
            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {
                var error = errorList_2[_i];
                throw error;
            }
        }
        return errorList;
    };
    MarkupAnnotationObj.prototype.extract = function (annot_obj, page, cryptoInterface) {
        _super.prototype.extract.call(this, annot_obj, page, cryptoInterface);
        if (annot_obj["/T"])
            this.author = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj["/T"], this.object_id));
    };
    return MarkupAnnotationObj;
}(BaseAnnotationObj));
exports.MarkupAnnotationObj = MarkupAnnotationObj;


/***/ }),

/***/ "./src/annotate/annotations/circle_square_annotation.ts":
/*!**************************************************************!*\
  !*** ./src/annotate/annotations/circle_square_annotation.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.SquareAnnotationObj = exports.CircleAnnotationObj = exports.CircleSquareAnnotationObj = void 0;
var annotation_types_1 = __webpack_require__(/*! ./annotation_types */ "./src/annotate/annotations/annotation_types.ts");
var annotation_errors_1 = __webpack_require__(/*! ./annotation_errors */ "./src/annotate/annotations/annotation_errors.ts");
var writer_util_1 = __webpack_require__(/*! ../writer-util */ "./src/annotate/writer-util.ts");
var appearance_stream_1 = __webpack_require__(/*! ../appearance-stream */ "./src/annotate/appearance-stream.ts");
var resources_1 = __webpack_require__(/*! ../resources */ "./src/annotate/resources.ts");
var content_stream_1 = __webpack_require__(/*! ../content-stream */ "./src/annotate/content-stream.ts");
var CircleSquareAnnotationObj = /** @class */ (function (_super) {
    __extends(CircleSquareAnnotationObj, _super);
    function CircleSquareAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.differenceRectangle = [];
        return _this;
    }
    CircleSquareAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        if (this.fill) {
            var fill = this.fill;
            if (fill.r > 1)
                fill.r /= 255;
            if (fill.g > 1)
                fill.g /= 255;
            if (fill.b > 1)
                fill.b /= 255;
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.FILL);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([fill.r, fill.g, fill.b]));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.differenceRectangle && this.differenceRectangle.length > 0) {
            ret = ret.concat(writer_util_1.WriterUtil.DIFFERENCE_RECTANGLE);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.differenceRectangle));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        return ret;
    };
    CircleSquareAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.fill) {
            errorList = errorList.concat(this.checkColor(this.fill));
        }
        if (enact) {
            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {
                var error = errorList_1[_i];
                throw error;
            }
        }
        return errorList;
    };
    return CircleSquareAnnotationObj;
}(annotation_types_1.MarkupAnnotationObj));
exports.CircleSquareAnnotationObj = CircleSquareAnnotationObj;
var CircleAnnotationObj = /** @class */ (function (_super) {
    __extends(CircleAnnotationObj, _super);
    function CircleAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.type = "/Circle";
        _this.type_encoded = [47, 67, 105, 114, 99, 108, 101]; // = '/Circle'
        return _this;
    }
    CircleAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Circle") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {
                var error = errorList_2[_i];
                throw error;
            }
        }
        return errorList;
    };
    CircleAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = this.rect;
        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillCircle(this.rect[0], this.rect[1], this.rect[2], this.rect[3]);
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return CircleAnnotationObj;
}(CircleSquareAnnotationObj));
exports.CircleAnnotationObj = CircleAnnotationObj;
var SquareAnnotationObj = /** @class */ (function (_super) {
    __extends(SquareAnnotationObj, _super);
    function SquareAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.type = "/Square";
        _this.type_encoded = [47, 83, 113, 117, 97, 114, 101]; // = '/Square'
        return _this;
    }
    SquareAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Square") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_3 = errorList; _i < errorList_3.length; _i++) {
                var error = errorList_3[_i];
                throw error;
            }
        }
        return errorList;
    };
    SquareAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = this.rect;
        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob, cryptoInterface) { return ob.writeGStateParameter(cryptoInterface); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillRect(this.rect[0], this.rect[1], this.rect[2], this.rect[3]);
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return SquareAnnotationObj;
}(CircleSquareAnnotationObj));
exports.SquareAnnotationObj = SquareAnnotationObj;


/***/ }),

/***/ "./src/annotate/annotations/freetext_annotation.ts":
/*!*********************************************************!*\
  !*** ./src/annotate/annotations/freetext_annotation.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.FreeTextAnnotationObj = exports.FreeTextType = exports.TextJustification = void 0;
var annotation_types_1 = __webpack_require__(/*! ./annotation_types */ "./src/annotate/annotations/annotation_types.ts");
var annotation_errors_1 = __webpack_require__(/*! ./annotation_errors */ "./src/annotate/annotations/annotation_errors.ts");
var writer_util_1 = __webpack_require__(/*! ../writer-util */ "./src/annotate/writer-util.ts");
var util_1 = __webpack_require__(/*! ../util */ "./src/annotate/util.ts");
var appearance_stream_1 = __webpack_require__(/*! ../appearance-stream */ "./src/annotate/appearance-stream.ts");
var resources_1 = __webpack_require__(/*! ../resources */ "./src/annotate/resources.ts");
var content_stream_1 = __webpack_require__(/*! ../content-stream */ "./src/annotate/content-stream.ts");
var fonts_1 = __webpack_require__(/*! ../fonts */ "./src/annotate/fonts.ts");
var TextJustification;
(function (TextJustification) {
    TextJustification[TextJustification["Left"] = 0] = "Left";
    TextJustification[TextJustification["Centered"] = 1] = "Centered";
    TextJustification[TextJustification["Right"] = 2] = "Right";
})(TextJustification = exports.TextJustification || (exports.TextJustification = {}));
var FreeTextType;
(function (FreeTextType) {
    FreeTextType[FreeTextType["FreeText"] = 0] = "FreeText";
    FreeTextType[FreeTextType["FreeTextCallout"] = 1] = "FreeTextCallout";
    FreeTextType[FreeTextType["FreeTextTypeWriter"] = 2] = "FreeTextTypeWriter";
})(FreeTextType = exports.FreeTextType || (exports.FreeTextType = {}));
var FreeTextAnnotationObj = /** @class */ (function (_super) {
    __extends(FreeTextAnnotationObj, _super);
    function FreeTextAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.defaultAppearance = new content_stream_1.ContentStream(); // /DA
        _this.differenceRectangle = [];
        _this.textJustification = TextJustification.Left; // /Q
        _this.calloutLine = [];
        _this.freeTextType = FreeTextType.FreeText;
        _this.lineEndingStyle = annotation_types_1.LineEndingStyle.None;
        _this.font = "/Helvetica";
        _this.fontSize = 18;
        _this.resources = undefined;
        _this.textColor = undefined;
        _this.type = "/FreeText";
        _this.type_encoded = [47, 70, 114, 101, 101, 84, 101, 120, 116]; // = '/FreeText'
        return _this;
    }
    FreeTextAnnotationObj.prototype.convertJustification = function (just) {
        switch (just) {
            case TextJustification.Left:
                return 0;
            case TextJustification.Centered:
                return 1;
            case TextJustification.Right:
                return 2;
            default:
                return 0;
        }
    };
    FreeTextAnnotationObj.prototype.convertFreeTextType = function (ft) {
        switch (ft) {
            case FreeTextType.FreeText:
                return util_1.Util.convertStringToAscii("/FreeText");
            case FreeTextType.FreeTextCallout:
                return util_1.Util.convertStringToAscii("/FreeTextCallout");
            case FreeTextType.FreeTextTypeWriter:
                return util_1.Util.convertStringToAscii("/FreeTextTypeWriter");
            default:
                return util_1.Util.convertStringToAscii("/FreeText");
        }
    };
    FreeTextAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        var font = this.factory.parser.getFonts().getFont(this.font);
        if (!font) {
            font = this.factory.parser.getFonts().addFont(this.font);
        }
        if (!this.resources) {
            this.resources = new resources_1.Resource();
        }
        if (!font.name) {
            throw Error("Selected font has no name");
        }
        this.resources.addFontDef({ name: font.name, refPtr: font.object_id });
        if (this.defaultAppearance.isEmpty()) {
            if (this.textColor) {
                this.defaultAppearance.addOperator("rg", [this.textColor.r, this.textColor.g, this.textColor.b]);
            }
            this.defaultAppearance.addOperator("Tf", [font.name, this.fontSize]);
        }
        if (!this.defaultStyleString || "" === this.defaultStyleString) {
            if (font.fontType === fonts_1.FontType.Type1) {
                if (!font.baseFont) {
                    throw Error("Type 1 font has no defined baseFont");
                }
                var font_family = font.baseFont.substring(1);
                this.defaultStyleString = "font:".concat(this.fontSize, "pt \"").concat(font_family, "\";");
                if (this.color) {
                    this.defaultStyleString += "color:".concat(util_1.Util.colorToHex(this.color), ";");
                }
            }
            else {
                this.defaultStyleString = undefined;
            }
        }
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.DEFAULT_APPEARANCE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret.push(writer_util_1.WriterUtil.BRACKET_START);
        ret = ret.concat(this.defaultAppearance.writeContentStream(true));
        ret.push(writer_util_1.WriterUtil.BRACKET_END);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.TEXT_JUSTIFICATION);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.convertJustification(this.textJustification)));
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.IT);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(this.convertFreeTextType(this.freeTextType));
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (this.calloutLine.length > 0) {
            ret = ret.concat(writer_util_1.WriterUtil.CALLOUT_LINE);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.calloutLine));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.lineEndingStyle !== annotation_types_1.LineEndingStyle.None) {
            ret = ret.concat(writer_util_1.WriterUtil.LINE_ENDING);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.convertLineEndingStyle(this.lineEndingStyle));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.defaultStyleString && this.defaultStyleString !== "") {
            ret = ret.concat(writer_util_1.WriterUtil.DEFAULT_STYLE_STRING);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret.push(writer_util_1.WriterUtil.BRACKET_START);
            ret = ret.concat(util_1.Util.convertStringToAscii(this.defaultStyleString));
            ret.push(writer_util_1.WriterUtil.BRACKET_END);
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.differenceRectangle && this.differenceRectangle.length > 0) {
            ret = ret.concat(writer_util_1.WriterUtil.DIFFERENCE_RECTANGLE);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.differenceRectangle));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.resources) {
            ret = ret.concat(writer_util_1.WriterUtil.RESOURCES);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.resources.writeResource());
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        return ret;
    };
    FreeTextAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/FreeText") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        errorList = errorList.concat(this.checkColor(this.textColor));
        if (this.calloutLine && this.calloutLine.length > 0 && this.freeTextType !== FreeTextType.FreeTextCallout) {
            console.log("Warning: Callout line only relevant for free text type: 'Callout'");
        }
        if (this.fontSize < 0) {
            errorList.push(new annotation_errors_1.InvalidFontSizeError("A font size < 0 is not allowed"));
        }
        if (typeof this.font === 'string' || this.font instanceof fonts_1.Font) {
            if (typeof this.font === 'string') {
                if (!this.font.startsWith("/")) {
                    this.font = "/".concat(this.font);
                }
            }
            if (!this.factory.parser.getFonts().isRegisteredFont(this.font)) {
                errorList.push(new annotation_errors_1.InvalidFontError("Only fonts registered in the PDF and standard fonts are allowed"));
            }
        }
        else {
            errorList.push(new annotation_errors_1.InvalidFontError("Only fonts registered in the PDF and standard fonts are allowed"));
        }
        if (enact) {
            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {
                var error = errorList_1[_i];
                throw error;
            }
        }
        return errorList;
    };
    FreeTextAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        var font = this.factory.parser.getFonts().getFont(this.font);
        if (!font) {
            font = this.factory.parser.getFonts().addFont(this.font);
        }
        if (!font.name) {
            font.name = this.factory.parser.getFonts().getUnusedFontName();
        }
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = this.rect;
        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];
        if (!xobj.resources) {
            xobj.resources = new resources_1.Resource();
        }
        xobj.resources.addFontDef({ name: font.name, refPtr: font.object_id });
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        go.setFillColor(this.color);
        go.fillRect(this.rect[0], this.rect[1], this.rect[2], this.rect[3]);
        var to = go.addTextObject();
        to.setColor(this.textColor);
        to.setFont(font.name, this.fontSize);
        to.formatText(this.contents, font, this.fontSize, this.rect, this.textJustification);
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return FreeTextAnnotationObj;
}(annotation_types_1.MarkupAnnotationObj));
exports.FreeTextAnnotationObj = FreeTextAnnotationObj;


/***/ }),

/***/ "./src/annotate/annotations/ink_annotation.ts":
/*!****************************************************!*\
  !*** ./src/annotate/annotations/ink_annotation.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.InkAnnotationObj = void 0;
var annotation_types_1 = __webpack_require__(/*! ./annotation_types */ "./src/annotate/annotations/annotation_types.ts");
var annotation_errors_1 = __webpack_require__(/*! ./annotation_errors */ "./src/annotate/annotations/annotation_errors.ts");
var writer_util_1 = __webpack_require__(/*! ../writer-util */ "./src/annotate/writer-util.ts");
var appearance_stream_1 = __webpack_require__(/*! ../appearance-stream */ "./src/annotate/appearance-stream.ts");
var resources_1 = __webpack_require__(/*! ../resources */ "./src/annotate/resources.ts");
var content_stream_1 = __webpack_require__(/*! ../content-stream */ "./src/annotate/content-stream.ts");
var InkAnnotationObj = /** @class */ (function (_super) {
    __extends(InkAnnotationObj, _super);
    function InkAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.inkList = [];
        _this.type = "/Ink";
        _this.type_encoded = [47, 73, 110, 107]; // = '/Ink'
        return _this;
    }
    InkAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        if (this.inkList && this.inkList.length > 0) {
            ret = ret.concat(writer_util_1.WriterUtil.INKLIST);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNestedNumberArray(this.inkList));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        return ret;
    };
    InkAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Ink") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if ('number' === typeof this.inkList[0]) {
            this.inkList = [this.inkList];
        }
        if (enact) {
            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {
                var error = errorList_1[_i];
                throw error;
            }
        }
        return errorList;
    };
    InkAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = this.rect;
        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color);
        for (var _i = 0, _a = this.inkList; _i < _a.length; _i++) {
            var inkl = _a[_i];
            go.drawPolygon(inkl);
        }
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return InkAnnotationObj;
}(annotation_types_1.MarkupAnnotationObj));
exports.InkAnnotationObj = InkAnnotationObj;


/***/ }),

/***/ "./src/annotate/annotations/polygon_polyline_annotation.ts":
/*!*****************************************************************!*\
  !*** ./src/annotate/annotations/polygon_polyline_annotation.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.PolygonAnnotationObj = exports.PolyLineAnnotationObj = exports.PolygonPolyLineAnnotationObj = exports.PolygonPolyLineIntent = void 0;
var annotation_types_1 = __webpack_require__(/*! ./annotation_types */ "./src/annotate/annotations/annotation_types.ts");
var annotation_errors_1 = __webpack_require__(/*! ./annotation_errors */ "./src/annotate/annotations/annotation_errors.ts");
var writer_util_1 = __webpack_require__(/*! ../writer-util */ "./src/annotate/writer-util.ts");
var appearance_stream_1 = __webpack_require__(/*! ../appearance-stream */ "./src/annotate/appearance-stream.ts");
var resources_1 = __webpack_require__(/*! ../resources */ "./src/annotate/resources.ts");
var content_stream_1 = __webpack_require__(/*! ../content-stream */ "./src/annotate/content-stream.ts");
var PolygonPolyLineIntent;
(function (PolygonPolyLineIntent) {
    PolygonPolyLineIntent[PolygonPolyLineIntent["PolygonCloud"] = 0] = "PolygonCloud";
    PolygonPolyLineIntent[PolygonPolyLineIntent["PolyLineDimension"] = 1] = "PolyLineDimension";
    PolygonPolyLineIntent[PolygonPolyLineIntent["PolygonDimension"] = 2] = "PolygonDimension";
})(PolygonPolyLineIntent = exports.PolygonPolyLineIntent || (exports.PolygonPolyLineIntent = {}));
var PolygonPolyLineAnnotationObj = /** @class */ (function (_super) {
    __extends(PolygonPolyLineAnnotationObj, _super);
    function PolygonPolyLineAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.vertices = [];
        return _this;
    }
    PolygonPolyLineAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        if (this.fill) {
            var fill = this.fill;
            if (fill.r > 1)
                fill.r /= 255;
            if (fill.g > 1)
                fill.g /= 255;
            if (fill.b > 1)
                fill.b /= 255;
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.FILL);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([fill.r, fill.g, fill.b]));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret = ret.concat(writer_util_1.WriterUtil.VERTICES);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.vertices));
        ret.push(writer_util_1.WriterUtil.SPACE);
        return ret;
    };
    PolygonPolyLineAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.fill) {
            errorList = errorList.concat(this.checkColor(this.fill));
        }
        if (!this.vertices || this.vertices.length == 0) {
            errorList.push(new annotation_errors_1.InvalidVerticesError("No vertices provided"));
        }
        if (this.vertices.length % 2 !== 0) {
            errorList.push(new annotation_errors_1.InvalidVerticesError("number of vertices must be an even number"));
        }
        if (enact) {
            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {
                var error = errorList_1[_i];
                throw error;
            }
        }
        return errorList;
    };
    return PolygonPolyLineAnnotationObj;
}(annotation_types_1.MarkupAnnotationObj));
exports.PolygonPolyLineAnnotationObj = PolygonPolyLineAnnotationObj;
var PolyLineAnnotationObj = /** @class */ (function (_super) {
    __extends(PolyLineAnnotationObj, _super);
    function PolyLineAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.lineEndingStyles = [];
        _this.type = "/PolyLine";
        _this.type_encoded = [47, 80, 111, 108, 121, 76, 105, 110, 101]; // '/PolyLine
        return _this;
    }
    PolyLineAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        if (this.lineEndingStyles && this.lineEndingStyles.length >= 2) {
            ret = ret.concat(writer_util_1.WriterUtil.LINE_ENDING);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret.push(writer_util_1.WriterUtil.ARRAY_START);
            ret = ret.concat(this.convertLineEndingStyle(this.lineEndingStyles[0]));
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.convertLineEndingStyle(this.lineEndingStyles[1]));
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret.push(writer_util_1.WriterUtil.ARRAY_END);
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        return ret;
    };
    PolyLineAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/PolyLine") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {
                var error = errorList_2[_i];
                throw error;
            }
        }
        return errorList;
    };
    PolyLineAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = this.rect;
        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawPolygon(this.vertices);
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return PolyLineAnnotationObj;
}(PolygonPolyLineAnnotationObj));
exports.PolyLineAnnotationObj = PolyLineAnnotationObj;
var PolygonAnnotationObj = /** @class */ (function (_super) {
    __extends(PolygonAnnotationObj, _super);
    function PolygonAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.type = "/Polygon";
        _this.type_encoded = [47, 80, 111, 108, 121, 103, 111, 110]; // = '/Polygon
        return _this;
    }
    PolygonAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Polygon") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_3 = errorList; _i < errorList_3.length; _i++) {
                var error = errorList_3[_i];
                throw error;
            }
        }
        return errorList;
    };
    PolygonAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = this.rect;
        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillPolygon(this.vertices);
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return PolygonAnnotationObj;
}(PolygonPolyLineAnnotationObj));
exports.PolygonAnnotationObj = PolygonAnnotationObj;


/***/ }),

/***/ "./src/annotate/annotations/text_annotation.ts":
/*!*****************************************************!*\
  !*** ./src/annotate/annotations/text_annotation.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.TextAnnotationObj = exports.AnnotationState = exports.AnnotationStateModel = exports.AnnotationIcon = void 0;
var annotation_types_1 = __webpack_require__(/*! ./annotation_types */ "./src/annotate/annotations/annotation_types.ts");
var annotation_errors_1 = __webpack_require__(/*! ./annotation_errors */ "./src/annotate/annotations/annotation_errors.ts");
var writer_util_1 = __webpack_require__(/*! ../writer-util */ "./src/annotate/writer-util.ts");
var util_1 = __webpack_require__(/*! ../util */ "./src/annotate/util.ts");
var appearance_stream_1 = __webpack_require__(/*! ../appearance-stream */ "./src/annotate/appearance-stream.ts");
var resources_1 = __webpack_require__(/*! ../resources */ "./src/annotate/resources.ts");
var content_stream_1 = __webpack_require__(/*! ../content-stream */ "./src/annotate/content-stream.ts");
var AnnotationIcon;
(function (AnnotationIcon) {
    AnnotationIcon[AnnotationIcon["Comment"] = 0] = "Comment";
    AnnotationIcon[AnnotationIcon["Key"] = 1] = "Key";
    AnnotationIcon[AnnotationIcon["Note"] = 2] = "Note";
    AnnotationIcon[AnnotationIcon["Help"] = 3] = "Help";
    AnnotationIcon[AnnotationIcon["NewParagraph"] = 4] = "NewParagraph";
    AnnotationIcon[AnnotationIcon["Paragraph"] = 5] = "Paragraph";
    AnnotationIcon[AnnotationIcon["Insert"] = 6] = "Insert";
})(AnnotationIcon = exports.AnnotationIcon || (exports.AnnotationIcon = {}));
var AnnotationStateModel;
(function (AnnotationStateModel) {
    AnnotationStateModel[AnnotationStateModel["Marked"] = 0] = "Marked";
    AnnotationStateModel[AnnotationStateModel["Review"] = 1] = "Review";
})(AnnotationStateModel = exports.AnnotationStateModel || (exports.AnnotationStateModel = {}));
var AnnotationState;
(function (AnnotationState) {
    AnnotationState[AnnotationState["Marked"] = 0] = "Marked";
    AnnotationState[AnnotationState["Unmarked"] = 1] = "Unmarked";
    AnnotationState[AnnotationState["Accepted"] = 2] = "Accepted";
    AnnotationState[AnnotationState["Rejected"] = 3] = "Rejected";
    AnnotationState[AnnotationState["Cancelled"] = 4] = "Cancelled";
    AnnotationState[AnnotationState["Completed"] = 5] = "Completed";
    AnnotationState[AnnotationState["None"] = 6] = "None";
})(AnnotationState = exports.AnnotationState || (exports.AnnotationState = {}));
var TextAnnotationObj = /** @class */ (function (_super) {
    __extends(TextAnnotationObj, _super);
    function TextAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.open = false;
        _this.icon = AnnotationIcon.Note;
        _this.state = undefined;
        _this.type = "/Text";
        _this.type_encoded = [47, 84, 101, 120, 116]; // = '/Text'
        // demanded by PDF specification (p. 394 - 12.5.6.4 Text Annotations)
        _this.annotationFlags = { noZoom: true, noRotate: true };
        return _this;
    }
    TextAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = [0, 0, 100, 100];
        xobj.matrix = [1, 0, 0, 1, 0, 0];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillRect(0, 0, 100, 100, 25);
        switch (this.icon) {
            case AnnotationIcon.Help:
                go.addTextObject().setColor().setFont("/F1", 120).setText("?", [20, 10]);
                break;
            case AnnotationIcon.Insert:
                throw Error("Not yet implemented. Pls. create ticket on Github with feature request.");
                break;
            case AnnotationIcon.Key:
                throw Error("Not yet implemented. Pls. create ticket on Github with feature request.");
                break;
            case AnnotationIcon.NewParagraph:
                throw Error("Not yet implemented. Pls. create ticket on Github with feature request.");
                break;
            case AnnotationIcon.Paragraph:
                throw Error("Not yet implemented. Pls. create ticket on Github with feature request.");
                break;
            default:
                go.drawPolygon([10, 10, 10, 90, 80, 90, 80, 80, 90, 80, 90, 10, 10, 10]).drawLine(80, 90, 90, 80);
        }
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    TextAnnotationObj.prototype.convertAnnotationIcon = function (icon) {
        switch (icon) {
            case AnnotationIcon.Comment:
                return [47, 67, 111, 109, 109, 101, 110, 116]; // = '/Comment'
            case AnnotationIcon.Key:
                return [47, 75, 101, 121]; // = '/Key'
            case AnnotationIcon.Note:
                return [47, 78, 111, 116, 101]; // = '/Note'
            case AnnotationIcon.Help:
                return [47, 72, 101, 108, 112]; // = '/Help'
            case AnnotationIcon.NewParagraph:
                return [47, 78, 101, 119, 80, 97, 114, 97, 103, 114, 97, 112, 104]; // = '/NewParagraph'
            case AnnotationIcon.Paragraph:
                return [47, 80, 97, 114, 97, 103, 114, 97, 112, 104]; // = '/Paragraph'
            case AnnotationIcon.Insert:
                return [47, 73, 110, 115, 101, 114, 116]; // = '/Insert'
        }
        return [];
    };
    TextAnnotationObj.prototype.convertState = function (state) {
        switch (state) {
            case AnnotationState.Marked:
                return util_1.Util.convertStringToAscii("/Marked");
            case AnnotationState.Unmarked:
                return util_1.Util.convertStringToAscii("/Unmarked");
            case AnnotationState.Accepted:
                return util_1.Util.convertStringToAscii("/Accepted");
            case AnnotationState.Rejected:
                return util_1.Util.convertStringToAscii("/Rejected");
            case AnnotationState.Cancelled:
                return util_1.Util.convertStringToAscii("/Cancelled");
            case AnnotationState.Completed:
                return util_1.Util.convertStringToAscii("/Completed");
            case AnnotationState.None:
                return util_1.Util.convertStringToAscii("/None");
        }
        return [];
    };
    TextAnnotationObj.prototype.convertStateModel = function (stateModel) {
        switch (stateModel) {
            case AnnotationStateModel.Marked:
                return util_1.Util.convertStringToAscii("/Marked");
            case AnnotationStateModel.Review:
                return util_1.Util.convertStringToAscii("/Review");
        }
        return [];
    };
    TextAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        if (this.open) {
            ret = ret.concat(writer_util_1.WriterUtil.OPEN);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.TRUE);
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.icon) {
            ret = ret.concat(writer_util_1.WriterUtil.NAME);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.convertAnnotationIcon(this.icon));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.state) {
            ret = ret.concat(writer_util_1.WriterUtil.STATE);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.convertState(this.state));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.stateModel) {
            ret = ret.concat(writer_util_1.WriterUtil.STATEMODEL);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.convertStateModel(this.stateModel));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        return ret;
    };
    TextAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Text") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (this.state && !this.stateModel) {
            errorList.push(new annotation_errors_1.InvalidStateError("You need to specify a state model, when specifying a state"));
        }
        if (this.stateModel && !this.state) {
            if (this.stateModel.valueOf() === AnnotationStateModel.Marked) {
                this.state = AnnotationState.Unmarked;
            }
            else if (this.stateModel.valueOf() === AnnotationStateModel.Review) {
                this.state = AnnotationState.None;
            }
            else {
                errorList.push(new annotation_errors_1.InvalidStateError("Invalid state model selected"));
            }
        }
        if (this.state && this.stateModel) {
            if (this.stateModel.valueOf() === AnnotationStateModel.Marked) {
                if (this.state.valueOf() !== AnnotationState.Marked && this.state.valueOf() !== AnnotationState.Unmarked) {
                    errorList.push(new annotation_errors_1.InvalidStateError("Invalid annotation state for state model 'Marked' only 'Marked' and 'Unmarked' are legal values"));
                }
            }
            else if (this.stateModel.valueOf() === AnnotationStateModel.Review) {
                if (this.state.valueOf() !== AnnotationState.Accepted && this.state.valueOf() !== AnnotationState.Rejected &&
                    this.state.valueOf() !== AnnotationState.Cancelled && this.state.valueOf() !== AnnotationState.Completed &&
                    this.state.valueOf() !== AnnotationState.None) {
                    errorList.push(new annotation_errors_1.InvalidStateError("Invalid annotation state for state model 'Review' only 'Accepted', 'Rejected', 'Cancelled', 'Completed' and 'None' are legal values"));
                }
            }
            else {
                errorList.push(new annotation_errors_1.InvalidStateError("Invalid state model selected"));
            }
        }
        if (enact) {
            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {
                var error = errorList_1[_i];
                throw error;
            }
        }
        return errorList;
    };
    return TextAnnotationObj;
}(annotation_types_1.MarkupAnnotationObj));
exports.TextAnnotationObj = TextAnnotationObj;


/***/ }),

/***/ "./src/annotate/annotations/text_markup_annotation.ts":
/*!************************************************************!*\
  !*** ./src/annotate/annotations/text_markup_annotation.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.StrikeOutAnnotationObj = exports.SquigglyAnnotationObj = exports.UnderlineAnnotationObj = exports.HighlightAnnotationObj = exports.TextMarkupAnnotationObj = void 0;
var annotation_types_1 = __webpack_require__(/*! ./annotation_types */ "./src/annotate/annotations/annotation_types.ts");
var annotation_errors_1 = __webpack_require__(/*! ./annotation_errors */ "./src/annotate/annotations/annotation_errors.ts");
var writer_util_1 = __webpack_require__(/*! ../writer-util */ "./src/annotate/writer-util.ts");
var appearance_stream_1 = __webpack_require__(/*! ../appearance-stream */ "./src/annotate/appearance-stream.ts");
var resources_1 = __webpack_require__(/*! ../resources */ "./src/annotate/resources.ts");
var content_stream_1 = __webpack_require__(/*! ../content-stream */ "./src/annotate/content-stream.ts");
var TextMarkupAnnotationObj = /** @class */ (function (_super) {
    __extends(TextMarkupAnnotationObj, _super);
    function TextMarkupAnnotationObj() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.quadPoints = [];
        return _this;
    }
    TextMarkupAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {
        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);
        ret = ret.concat(writer_util_1.WriterUtil.QUADPOINTS);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.quadPoints));
        ret.push(writer_util_1.WriterUtil.SPACE);
        return ret;
    };
    TextMarkupAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (errorList.length === 1 && errorList[0] instanceof annotation_errors_1.InvalidRectError) {
            if (this.quadPoints && this.quadPoints.length > 0) {
                this.rect = this.extractRectFromQuadPoints(this.quadPoints);
                errorList = this.checkRect(4, this.rect);
            }
        }
        if (!this.quadPoints || this.quadPoints.length === 0) {
            var rect = this.rect;
            this.quadPoints = [rect[0], rect[3], rect[2], rect[3], rect[0], rect[1], rect[2], rect[1]];
        }
        errorList = errorList.concat(this.checkQuadPoints(this.quadPoints));
        if (enact) {
            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {
                var error = errorList_1[_i];
                throw error;
            }
        }
        return errorList;
    };
    /**
     * Extracts the rectangular hull from a quadPoint definition
     * */
    TextMarkupAnnotationObj.prototype.extractRectFromQuadPoints = function (quadPoints) {
        var x_values = quadPoints.filter(function (element, index) { return index % 2 === 0; });
        var y_values = quadPoints.filter(function (element, index) { return index % 2 !== 0; });
        return [Math.min.apply(Math, x_values), Math.min.apply(Math, y_values), Math.max.apply(Math, x_values), Math.max.apply(Math, y_values)];
    };
    /**
     * Checks the 'quadPoints' parameter
     * */
    TextMarkupAnnotationObj.prototype.checkQuadPoints = function (quadPoints) {
        var errorList = [];
        if (quadPoints.length % 8 !== 0)
            errorList.push(new annotation_errors_1.InvalidQuadPointError("Quadpoints array has length ".concat(quadPoints.length, " but must be a multiple of 8")));
        quadPoints.forEach(function (a) {
            if ('number' !== typeof a)
                errorList.push(new annotation_errors_1.InvalidQuadPointError("Quadpoint " + quadPoints + " has invalid entry: " + a));
        });
        return errorList;
    };
    return TextMarkupAnnotationObj;
}(annotation_types_1.MarkupAnnotationObj));
exports.TextMarkupAnnotationObj = TextMarkupAnnotationObj;
var HighlightAnnotationObj = /** @class */ (function (_super) {
    __extends(HighlightAnnotationObj, _super);
    function HighlightAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.type = "/Highlight";
        _this.type_encoded = [47, 72, 105, 103, 104, 108, 105, 103, 104, 116]; // = '/Highlight'
        return _this;
    }
    HighlightAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        var _this = this;
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = [0, 0, 100, 100];
        xobj.matrix = [1, 0, 0, 1, 0, 0];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        if (this.quadPoints && this.quadPoints.length > 8) {
            go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color);
            var _loop_1 = function (i) {
                var points = [];
                this_1.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });
                go.fillPolygon([points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]]);
            };
            var this_1 = this;
            for (var i = 0; i < this.quadPoints.length; i += 8) {
                _loop_1(i);
            }
        }
        else {
            go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).fillRect(0, 0, 100, 100, 25);
        }
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    HighlightAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Highlight") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {
                var error = errorList_2[_i];
                throw error;
            }
        }
        return errorList;
    };
    return HighlightAnnotationObj;
}(TextMarkupAnnotationObj));
exports.HighlightAnnotationObj = HighlightAnnotationObj;
var UnderlineAnnotationObj = /** @class */ (function (_super) {
    __extends(UnderlineAnnotationObj, _super);
    function UnderlineAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.type = "/Underline";
        _this.type_encoded = [47, 85, 110, 100, 101, 114, 108, 105, 110, 101]; // = '/Underline'
        return _this;
    }
    UnderlineAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Underline") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_3 = errorList; _i < errorList_3.length; _i++) {
                var error = errorList_3[_i];
                throw error;
            }
        }
        return errorList;
    };
    UnderlineAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        var _this = this;
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = [0, 0, 100, 100];
        xobj.matrix = [1, 0, 0, 1, 0, 0];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        if (this.quadPoints && this.quadPoints.length > 8) {
            go.setLineColor(this.color);
            var _loop_2 = function (i) {
                var points = [];
                this_2.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });
                go.drawLine(points[0], points[1], points[2], points[1]);
            };
            var this_2 = this;
            for (var i = 0; i < this.quadPoints.length; i += 8) {
                _loop_2(i);
            }
        }
        else {
            go.setLineColor(this.color).drawLine(0, 0, 100, 0);
        }
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return UnderlineAnnotationObj;
}(TextMarkupAnnotationObj));
exports.UnderlineAnnotationObj = UnderlineAnnotationObj;
var SquigglyAnnotationObj = /** @class */ (function (_super) {
    __extends(SquigglyAnnotationObj, _super);
    function SquigglyAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.type = "/Squiggly";
        _this.type_encoded = [47, 83, 113, 117, 105, 103, 103, 108, 121]; // = '/Squiggly'
        return _this;
    }
    SquigglyAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/Squiggly") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_4 = errorList; _i < errorList_4.length; _i++) {
                var error = errorList_4[_i];
                throw error;
            }
        }
        return errorList;
    };
    /**
     * Draws a horizontal squiggly line
     * */
    SquigglyAnnotationObj.prototype.drawSquigglyLine = function (go, x1, x2, y) {
        for (var i = x1; i < x2; i += 5) {
            if (i % 2 === 0) {
                go.drawLine(i, y, i + 5, y + 5);
            }
            else {
                go.drawLine(i, y + 5, i + 5, y);
            }
        }
    };
    SquigglyAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        var _this = this;
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = [0, 0, 100, 100];
        xobj.matrix = [1, 0, 0, 1, 0, 0];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        if (this.quadPoints && this.quadPoints.length > 8) {
            go.setLineColor(this.color);
            var _loop_3 = function (i) {
                var points = [];
                this_3.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });
                this_3.drawSquigglyLine(go, points[0], points[2], points[1]);
            };
            var this_3 = this;
            for (var i = 0; i < this.quadPoints.length; i += 8) {
                _loop_3(i);
            }
        }
        else {
            go.setLineColor(this.color);
            this.drawSquigglyLine(go, 0, 100, 0);
        }
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return SquigglyAnnotationObj;
}(TextMarkupAnnotationObj));
exports.SquigglyAnnotationObj = SquigglyAnnotationObj;
var StrikeOutAnnotationObj = /** @class */ (function (_super) {
    __extends(StrikeOutAnnotationObj, _super);
    function StrikeOutAnnotationObj() {
        var _this = _super.call(this) || this;
        _this.type = "/StrikeOut";
        _this.type_encoded = [47, 83, 116, 114, 105, 107, 101, 79, 117, 116]; // = '/StrikeOut'
        return _this;
    }
    StrikeOutAnnotationObj.prototype.validate = function (enact) {
        if (enact === void 0) { enact = true; }
        var errorList = _super.prototype.validate.call(this, false);
        if (this.type !== "/StrikeOut") {
            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError("Invalid annotation type ".concat(this.type)));
        }
        if (enact) {
            for (var _i = 0, errorList_5 = errorList; _i < errorList_5.length; _i++) {
                var error = errorList_5[_i];
                throw error;
            }
        }
        return errorList;
    };
    StrikeOutAnnotationObj.prototype.createDefaultAppearanceStream = function () {
        var _this = this;
        this.appearanceStream = new appearance_stream_1.AppStream(this);
        this.appearanceStream.new_object = true;
        var xobj = new appearance_stream_1.XObjectObj();
        xobj.object_id = this.factory.parser.getFreeObjectId();
        xobj.new_object = true;
        xobj.bBox = [0, 0, 100, 100];
        xobj.matrix = [1, 0, 0, 1, 0, 0];
        var cs = new content_stream_1.ContentStream();
        xobj.contentStream = cs;
        var cmo = cs.addMarkedContentObject(["/Tx"]);
        var go = cmo.addGraphicObject();
        if (this.opacity !== 1) {
            go.addOperator("gs", ["/GParameters"]);
            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());
            gsp.CA = gsp.ca = this.opacity;
            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });
            var res = new resources_1.Resource();
            res.addGStateDef({ name: "/GParameters", refPtr: gsp.object_id });
            xobj.resources = res;
        }
        if (this.quadPoints && this.quadPoints.length > 8) {
            go.setLineColor(this.color);
            var _loop_4 = function (i) {
                var points = [];
                this_4.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });
                var y_value = (points[5] - points[1]) / 2 + points[1];
                go.drawLine(points[0], y_value, points[2], y_value);
            };
            var this_4 = this;
            for (var i = 0; i < this.quadPoints.length; i += 8) {
                _loop_4(i);
            }
        }
        else {
            go.setLineColor(this.color).drawLine(0, 50, 100, 50);
        }
        this.appearanceStream.N = xobj;
        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });
    };
    return StrikeOutAnnotationObj;
}(TextMarkupAnnotationObj));
exports.StrikeOutAnnotationObj = StrikeOutAnnotationObj;


/***/ }),

/***/ "./src/annotate/appearance-stream.ts":
/*!*******************************************!*\
  !*** ./src/annotate/appearance-stream.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.GraphicsStateParameter = exports.XObjectObj = exports.AppStream = void 0;
var writer_util_1 = __webpack_require__(/*! ./writer-util */ "./src/annotate/writer-util.ts");
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var content_stream_1 = __webpack_require__(/*! ./content-stream */ "./src/annotate/content-stream.ts");
var stream_1 = __webpack_require__(/*! ./stream */ "./src/annotate/stream.ts");
var AppStream = /** @class */ (function () {
    function AppStream(annot) {
        this.object_id = undefined;
        this.new_object = false; // indicates to the factory that this object must be created when writing the document
        this.N = undefined;
        this.R = undefined;
        this.D = undefined;
        this.annot = annot;
    }
    /**
     * Lookups the N content stream. If it is only provided by a reference pointer it will parse
     * the corresponding Xobject
     * */
    AppStream.prototype.lookupNContentStream = function () {
        if (!this.N) {
            console.warn("call lookupNContentStream without set content stream value");
            return;
        }
        else if (util_1.Util.isReferencePointer(this.N)) {
            this.N = this.annot.factory.parser.extractXObject(this.N);
        }
        else if (this.N instanceof XObjectObj) {
            return; // already looked up
        }
        else {
            throw Error("Could not lookup N content stream");
        }
    };
    /**
     * Helper writer function of the references. Resolves different types
     * */
    AppStream.prototype.writeAppearanceStreamObj = function (ap) {
        var ret = [];
        if (util_1.Util.isReferencePointer(ap)) {
            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(ap, true));
        }
        else if (ap instanceof XObjectObj) {
            if (!ap.object_id) {
                throw Error("No object id specified in XObject");
            }
            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(ap.object_id, true));
        }
        else {
            throw Error("Invalid appearance stream object");
        }
        return ret;
    };
    /**
     * Writes the appearance stream object
     * */
    AppStream.prototype.writeAppearanceStream = function () {
        var ret = [];
        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);
        if (this.N) {
            ret = ret.concat(writer_util_1.WriterUtil.AP_N);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.writeAppearanceStreamObj(this.N));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.R) {
            ret = ret.concat(writer_util_1.WriterUtil.AP_R);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.writeAppearanceStreamObj(this.R));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.D) {
            ret = ret.concat(writer_util_1.WriterUtil.AP_D);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.writeAppearanceStreamObj(this.D));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);
        return ret;
    };
    return AppStream;
}());
exports.AppStream = AppStream;
var XObjectObj = /** @class */ (function () {
    // note that Type is /XObject instead of /Annot in annotation objects
    function XObjectObj() {
        this.object_id = undefined;
        this.new_object = false; // indicates to the factory that this object must be created when writing the document
        this.type = "/Form";
        this.type_encoded = writer_util_1.WriterUtil.SUBTYPE; // = '/Form'
        this.bBox = [];
        this.name = "/ARM";
        this.matrix = [1, 0, 0, 1, 0, 0];
        this.formType = 1;
        this.contentStream = undefined;
        this.resources = undefined;
    }
    /**
     * Adds a content stream operator
     * */
    XObjectObj.prototype.addOperator = function (operator, parameters) {
        if (parameters === void 0) { parameters = []; }
        if (!this.contentStream)
            this.contentStream = new content_stream_1.ContentStream();
        this.contentStream.addOperator(operator, parameters);
    };
    XObjectObj.prototype.writeXObject = function (cryptoInterface) {
        if (!this.object_id)
            throw Error("object_id of XObject not set");
        var ret = [];
        ret = ret.concat(writer_util_1.WriterUtil.TYPE_XOBJECT);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.SUBTYPE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.FORM);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.FORMTYPE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.formType));
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.BBOX);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.bBox));
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.NAME);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(util_1.Util.convertStringToAscii(this.name));
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (this.resources) {
            ret = ret.concat(writer_util_1.WriterUtil.RESOURCES);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.resources.writeResource());
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret = ret.concat(writer_util_1.WriterUtil.MATRIX);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.matrix));
        ret.push(writer_util_1.WriterUtil.SPACE);
        var stream_data = (this.contentStream) ? this.contentStream.writeContentStream() : [];
        return writer_util_1.WriterUtil.writeStreamObject(this.object_id, ret, new stream_1.FlateStream(new Uint8Array(stream_data), undefined, true, cryptoInterface, this.object_id));
    };
    return XObjectObj;
}());
exports.XObjectObj = XObjectObj;
var GraphicsStateParameter = /** @class */ (function () {
    function GraphicsStateParameter(object_id) {
        if (object_id === void 0) { object_id = undefined; }
        this.object_id = undefined;
        this.new_object = false; // indicates to the factory that this object must be created when writing the document
        this.type = "/ExtGState";
        this.type_encoded = writer_util_1.WriterUtil.EXTGSTATE; // = '/ExtGState'
        this.CA = undefined;
        this.ca = undefined;
        this.object_id = object_id;
    }
    GraphicsStateParameter.prototype.writeGStateParameter = function () {
        if (!this.object_id)
            throw Error("GStateParameter dictionary has no object id");
        var ret = writer_util_1.WriterUtil.writeReferencePointer(this.object_id);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.OBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.TYPE_EXTGSTATE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        // opacity stroking operations
        if (this.CA) {
            ret = ret.concat(writer_util_1.WriterUtil.OPACITY);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.CA));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        // opacity non stroking operations
        if (this.ca) {
            ret = ret.concat(writer_util_1.WriterUtil._OPACITY);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.ca));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        return ret;
    };
    return GraphicsStateParameter;
}());
exports.GraphicsStateParameter = GraphicsStateParameter;


/***/ }),

/***/ "./src/annotate/array-util.ts":
/*!************************************!*\
  !*** ./src/annotate/array-util.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.ArrayUtil = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var object_util_1 = __webpack_require__(/*! ./object-util */ "./src/annotate/object-util.ts");
/**
 * Holds the logic for extracting arrays
 * */
var ArrayUtil = /** @class */ (function () {
    function ArrayUtil() {
    }
    /**
     * Extracts array of numbers and arrays of references
     *
     * The function supports arbitrarily nesting of arrays and multiple types.
     * */
    ArrayUtil.extractArray = function (data, ptr) {
        ptr = util_1.Util.skipSpaces(data, ptr);
        var start_index = ptr;
        if (data[ptr] !== util_1.Util.ARRAY_START[0])
            throw Error("Invalid array sequence -- does not start with '['");
        ptr += 1;
        var next = util_1.Util.readNextWord(data, ptr);
        var next_string = next.result;
        ptr = next.start_index;
        var ret_list = [];
        while (next_string) {
            if (next_string[0] === util_1.Util.ARRAY_START[0]) {
                var sub_array = ArrayUtil.extractArray(data, ptr);
                ptr = sub_array.end_index;
                ret_list.push(sub_array.result);
            }
            else if (util_1.Util.areArraysEqual(next_string, util_1.Util.NULL)) {
                ret_list.push("null");
                ptr += next_string.length - 1;
            }
            else if (next_string[0] === util_1.Util.LITERAL_STRING_END[0]) {
                return { result: ret_list, start_index: start_index, end_index: next.end_index };
            }
            else if (next_string[0] === util_1.Util.LITERAL_STRING_START[0]) {
                var extracted_string = util_1.Util.extractString(data, ptr);
                ret_list.push(extracted_string.result);
                ptr = extracted_string.end_index;
            }
            else if (next_string[0] === util_1.Util.DICT_START[0]) { // <
                var lookup_word = util_1.Util.readNextWord(data, next.end_index + 1);
                if (lookup_word.result && lookup_word.result[0] === util_1.Util.DICT_START[0]) {
                    var dict = {};
                    ptr = object_util_1.ObjectUtil.extractDictValueRec(data, ptr, dict);
                    ret_list.push(dict);
                }
                else {
                    var hex_string = util_1.Util.extractHexString(data, ptr);
                    ret_list.push(hex_string.result);
                    ptr = hex_string.end_index;
                }
            }
            else if (next_string[0] === 47) { // /
                var opt_value = util_1.Util.extractOptionValue(data, ptr);
                ret_list.push("/" + opt_value.result);
                ptr = opt_value.end_index;
            }
            else if (next_string[0] === util_1.Util.R[0]) { // Reference pointer
                var obj = ret_list[ret_list.length - 2];
                var generation = ret_list[ret_list.length - 1];
                ret_list = ret_list.slice(0, ret_list.length - 2);
                ret_list.push({ obj: obj, generation: generation });
                ptr = next.end_index;
            }
            else if (next_string[0] === util_1.Util.ARRAY_END[0]) {
                break;
            }
            else {
                var nbr = util_1.Util.extractNumber(data, ptr);
                ret_list.push(nbr.result);
                ptr = nbr.end_index;
            }
            ++ptr;
            ptr = util_1.Util.skipSpaces(data, ptr);
            next = util_1.Util.readNextWord(data, ptr);
            next_string = next.result;
            ptr = next.start_index;
        }
        return { result: ret_list, start_index: start_index, end_index: next.end_index };
    };
    return ArrayUtil;
}());
exports.ArrayUtil = ArrayUtil;


/***/ }),

/***/ "./src/annotate/content-stream.ts":
/*!****************************************!*\
  !*** ./src/annotate/content-stream.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.ContentStream = exports.TextObject = exports.GraphicsObject = exports.MarkedContent = exports.Operator = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var writer_util_1 = __webpack_require__(/*! ./writer-util */ "./src/annotate/writer-util.ts");
var freetext_annotation_1 = __webpack_require__(/*! ./annotations/freetext_annotation */ "./src/annotate/annotations/freetext_annotation.ts");
var Operator = /** @class */ (function () {
    function Operator(name, parameters) {
        if (name === void 0) { name = ""; }
        if (parameters === void 0) { parameters = []; }
        this.name = name;
        this.parameters = parameters;
        this.operators = [];
    }
    /**
     * Transforms operator to byte array
     * */
    Operator.prototype.toByteArray = function (noLineFeed) {
        if (noLineFeed === void 0) { noLineFeed = false; }
        var ret = [];
        for (var _i = 0, _a = this.operators; _i < _a.length; _i++) {
            var op = _a[_i];
            for (var _b = 0, _c = op.parameters; _b < _c.length; _b++) {
                var param = _c[_b];
                ret = ret.concat(util_1.Util.convertStringToAscii("".concat(param)));
                ret.push(util_1.Util.SPACE);
            }
            if (op instanceof MarkedContent) {
                ret = ret.concat(writer_util_1.WriterUtil.BMC);
                if (!noLineFeed) {
                    ret.push(util_1.Util.LF);
                }
                else {
                    ret.push(util_1.Util.SPACE);
                }
                ret = ret.concat(op.toByteArray());
                ret = ret.concat(writer_util_1.WriterUtil.EMC);
            }
            else if (op instanceof GraphicsObject) {
                ret.push(writer_util_1.WriterUtil.q);
                if (!noLineFeed) {
                    ret.push(util_1.Util.LF);
                }
                else {
                    ret.push(util_1.Util.SPACE);
                }
                ret = ret.concat(op.toByteArray());
                ret.push(writer_util_1.WriterUtil.Q);
            }
            else if (op instanceof TextObject) {
                ret = ret.concat(writer_util_1.WriterUtil.BT);
                if (!noLineFeed) {
                    ret.push(util_1.Util.LF);
                }
                else {
                    ret.push(util_1.Util.SPACE);
                }
                ret = ret.concat(op.toByteArray());
                ret = ret.concat(writer_util_1.WriterUtil.ET);
            }
            else {
                ret = ret.concat(util_1.Util.convertStringToAscii(op.name));
                if (!noLineFeed) {
                    ret.push(util_1.Util.LF);
                }
                else {
                    ret.push(util_1.Util.SPACE);
                }
            }
        }
        if (ret[ret.length - 1] !== util_1.Util.LF) {
            if (!noLineFeed) {
                ret.push(util_1.Util.LF);
            }
            else {
                ret.push(util_1.Util.SPACE);
            }
        }
        return ret;
    };
    /**
     * Adds the provided operator
     * */
    Operator.prototype.addOperator = function (arg, params) {
        if (params === void 0) { params = []; }
        if (arg instanceof Operator) {
            this.operators.push(arg);
        }
        else {
            this.operators.push(new Operator(arg, params));
        }
    };
    /**
     * Add marked content object to stream
     * */
    Operator.prototype.addMarkedContentObject = function (params) {
        if (params === void 0) { params = []; }
        var mco = new MarkedContent(params);
        this.operators.push(mco);
        return mco;
    };
    /**
     * Add a graphic state to the content stream
     * */
    Operator.prototype.addGraphicObject = function () {
        var go = new GraphicsObject();
        this.operators.push(go);
        return go;
    };
    /**
     * Add a text objct to the content stream
     * */
    Operator.prototype.addTextObject = function () {
        var to = new TextObject();
        this.operators.push(to);
        return to;
    };
    return Operator;
}());
exports.Operator = Operator;
var MarkedContent = /** @class */ (function (_super) {
    __extends(MarkedContent, _super);
    function MarkedContent(params) {
        if (params === void 0) { params = []; }
        return _super.call(this, "BMC", params) || this;
    }
    return MarkedContent;
}(Operator));
exports.MarkedContent = MarkedContent;
var GraphicsObject = /** @class */ (function (_super) {
    __extends(GraphicsObject, _super);
    function GraphicsObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GraphicsObject.prototype.drawFillRect = function (x_1, y_1, x_2, y_2, cornerRadius, linewidth) {
        if (cornerRadius === void 0) { cornerRadius = undefined; }
        if (linewidth === void 0) { linewidth = 2; }
        this.addOperator("w", [linewidth]);
        if (cornerRadius && (2 * cornerRadius > Math.abs(x_1 - x_2) || 2 * cornerRadius > Math.abs(y_1 - y_2))) {
            throw Error("Invalid corner radius. Must be small than two times the linewidth");
        }
        if (cornerRadius) {
            this.addOperator("m", [x_1, y_1 + cornerRadius]);
            this.addOperator("l", [x_1, y_2 - cornerRadius]);
            this.addOperator("c", [x_1, y_2, x_1, y_2, x_1 + cornerRadius, y_2]);
            this.addOperator("l", [x_2 - cornerRadius, y_2]);
            this.addOperator("c", [x_2, y_2, x_2, y_2, x_2, y_2 - cornerRadius]);
            this.addOperator("l", [x_2, y_1 + cornerRadius]);
            this.addOperator("c", [x_2, y_1, x_2, y_1, x_2 - cornerRadius, y_1]);
            this.addOperator("l", [x_1 + cornerRadius, y_1]);
            this.addOperator("c", [x_1, y_1, x_1, y_1, x_1, y_1 + cornerRadius]);
        }
        else {
            this.addOperator("m", [x_1, y_1]);
            this.addOperator("l", [x_2, y_1]);
            this.addOperator("l", [x_2, y_2]);
            this.addOperator("l", [x_1, y_2]);
            this.addOperator("l", [x_1, y_1]);
        }
        this.addOperator("B");
        return this;
    };
    GraphicsObject.prototype.fillRect = function (x_1, y_1, x_2, y_2, cornerRadius) {
        if (cornerRadius === void 0) { cornerRadius = undefined; }
        if (cornerRadius && (2 * cornerRadius > Math.abs(x_1 - x_2) || 2 * cornerRadius > Math.abs(y_1 - y_2))) {
            throw Error("Invalid corner radius. Must be small than two times the linewidth");
        }
        if (cornerRadius) {
            this.addOperator("m", [x_1, y_1 + cornerRadius]);
            this.addOperator("l", [x_1, y_2 - cornerRadius]);
            this.addOperator("c", [x_1, y_2, x_1, y_2, x_1 + cornerRadius, y_2]);
            this.addOperator("l", [x_2 - cornerRadius, y_2]);
            this.addOperator("c", [x_2, y_2, x_2, y_2, x_2, y_2 - cornerRadius]);
            this.addOperator("l", [x_2, y_1 + cornerRadius]);
            this.addOperator("c", [x_2, y_1, x_2, y_1, x_2 - cornerRadius, y_1]);
            this.addOperator("l", [x_1 + cornerRadius, y_1]);
            this.addOperator("c", [x_1, y_1, x_1, y_1, x_1, y_1 + cornerRadius]);
        }
        else {
            this.addOperator("m", [x_1, y_1]);
            this.addOperator("l", [x_2, y_1]);
            this.addOperator("l", [x_2, y_2]);
            this.addOperator("l", [x_1, y_2]);
            this.addOperator("l", [x_1, y_1]);
        }
        this.addOperator("f");
        return this;
    };
    GraphicsObject.prototype.drawFillCircle = function (x_1, y_1, x_2, y_2, linewidth) {
        if (linewidth === void 0) { linewidth = 2; }
        x_1 += linewidth;
        y_1 += linewidth;
        x_2 -= linewidth;
        y_2 -= linewidth;
        var rect_width = Math.abs(x_2 - x_1);
        var rect_height = Math.abs(y_2 - y_1);
        this.addOperator("w", [linewidth]);
        this.addOperator("m", [x_1 + rect_width / 2, y_1]);
        this.addOperator("c", [x_1 + rect_width / 2, y_1, x_2, y_1, x_2, y_1 + rect_height / 2]);
        this.addOperator("c", [x_2, y_1 + rect_height / 2, x_2, y_2, x_1 + rect_width / 2, y_2]);
        this.addOperator("c", [x_1 + rect_width / 2, y_2, x_1, y_2, x_1, y_1 + rect_height / 2]);
        this.addOperator("c", [x_1, y_1 + rect_height / 2, x_1, y_1, x_1 + rect_width / 2, y_1]);
        this.addOperator("B");
        return this;
    };
    GraphicsObject.prototype.fillCircle = function (x_1, y_1, x_2, y_2) {
        var rect_width = Math.abs(x_2 - x_1);
        var rect_height = Math.abs(y_2 - y_1);
        this.addOperator("m", [x_1 + rect_width / 2, y_1]);
        this.addOperator("v", [x_2, y_1, x_2, y_1 + rect_height / 2]);
        this.addOperator("v", [x_2, y_2, x_1 + rect_width / 2, y_2]);
        this.addOperator("v", [x_1, y_2, x_1, y_1 + rect_height / 2]);
        this.addOperator("v", [x_1, y_1, x_1 + rect_width / 2, y_1]);
        this.addOperator("f");
        return this;
    };
    /**
     * Draws a circle (or an oval) where the rectangle defined by the coordinates represents the bounding box
     * */
    GraphicsObject.prototype.drawCircle = function (x_1, y_1, x_2, y_2, linewidth) {
        if (linewidth === void 0) { linewidth = 2; }
        x_1 += linewidth;
        y_1 += linewidth;
        x_2 -= linewidth;
        y_2 -= linewidth;
        var rect_width = Math.abs(x_2 - x_1);
        var rect_height = Math.abs(y_2 - y_1);
        this.addOperator("w", [linewidth]);
        this.addOperator("m", [x_1 + rect_width / 2, y_1]);
        this.addOperator("v", [x_2, y_1, x_2, y_1 + rect_height / 2]);
        this.addOperator("v", [x_2, y_2, x_1 + rect_width / 2, y_2]);
        this.addOperator("v", [x_1, y_2, x_1, y_1 + rect_height / 2]);
        this.addOperator("v", [x_1, y_1, x_1 + rect_width / 2, y_1]);
        this.addOperator("s");
        return this;
    };
    GraphicsObject.prototype.drawRect = function (x_1, y_1, x_2, y_2, cornerRadius, linewidth) {
        if (cornerRadius === void 0) { cornerRadius = undefined; }
        if (linewidth === void 0) { linewidth = 2; }
        this.addOperator("w", [linewidth]);
        if (cornerRadius && (2 * cornerRadius > Math.abs(x_1 - x_2) || 2 * cornerRadius > Math.abs(y_1 - y_2))) {
            throw Error("Invalid corner radius. Must be small than two times the linewidth");
        }
        if (cornerRadius) {
            this.addOperator("m", [x_1, y_1 + cornerRadius]);
            this.addOperator("l", [x_1, y_2 - cornerRadius]);
            this.addOperator("c", [x_1, y_2, x_1, y_2, x_1 + cornerRadius, y_2]);
            this.addOperator("l", [x_2 - cornerRadius, y_2]);
            this.addOperator("c", [x_2, y_2, x_2, y_2, x_2, y_2 - cornerRadius]);
            this.addOperator("l", [x_2, y_1 + cornerRadius]);
            this.addOperator("c", [x_2, y_1, x_2, y_1, x_2 - cornerRadius, y_1]);
            this.addOperator("l", [x_1 + cornerRadius, y_1]);
            this.addOperator("c", [x_1, y_1, x_1, y_1, x_1, y_1 + cornerRadius]);
        }
        else {
            this.addOperator("m", [x_1, y_1]);
            this.addOperator("l", [x_2, y_1]);
            this.addOperator("l", [x_2, y_2]);
            this.addOperator("l", [x_1, y_2]);
            this.addOperator("l", [x_1, y_1]);
        }
        this.addOperator("s");
        return this;
    };
    GraphicsObject.prototype.drawFillPolygon = function (points, linewidth) {
        if (linewidth === void 0) { linewidth = 2; }
        if (points.length <= 2)
            return this;
        if (points.length % 2 !== 0)
            throw Error("Number of points must be even");
        this.addOperator("w", [linewidth]);
        this.addOperator("m", [points[0], points[1]]);
        for (var i = 2; i < points.length; i += 2) {
            this.addOperator("l", [points[i], points[i + 1]]);
        }
        this.addOperator("B");
        return this;
    };
    GraphicsObject.prototype.drawPolygon = function (points, linewidth) {
        if (linewidth === void 0) { linewidth = 2; }
        if (points.length <= 2)
            return this;
        if (points.length % 2 !== 0)
            throw Error("Number of points must be even");
        this.addOperator("w", [linewidth]);
        this.addOperator("m", [points[0], points[1]]);
        for (var i = 2; i < points.length; i += 2) {
            this.addOperator("l", [points[i], points[i + 1]]);
        }
        this.addOperator("S");
        return this;
    };
    GraphicsObject.prototype.fillPolygon = function (points) {
        if (points.length <= 2)
            return this;
        if (points.length % 2 !== 0)
            throw Error("Number of points must be even");
        this.addOperator("m", [points[0], points[1]]);
        for (var i = 2; i < points.length; i += 2) {
            this.addOperator("l", [points[i], points[i + 1]]);
        }
        this.addOperator("f");
        return this;
    };
    GraphicsObject.prototype.drawLine = function (x_1, y_1, x_2, y_2, linewidth) {
        if (linewidth === void 0) { linewidth = 2; }
        this.addOperator("w", [linewidth]);
        this.addOperator("m", [x_1, y_1]);
        this.addOperator("l", [x_2, y_2]);
        this.addOperator("S");
        return this;
    };
    GraphicsObject.prototype.setLineColor = function (color) {
        if (color === void 0) { color = undefined; }
        if (!color)
            color = { r: 0, g: 0, b: 0 };
        color = util_1.Util.colorToRange01(color);
        this.addOperator("RG", [color.r, color.g, color.b]);
        return this;
    };
    GraphicsObject.prototype.setFillColor = function (color) {
        if (color === void 0) { color = undefined; }
        if (!color)
            color = { r: 0, g: 0, b: 0 };
        color = util_1.Util.colorToRange01(color);
        this.addOperator("rg", [color.r, color.g, color.b]);
        return this;
    };
    return GraphicsObject;
}(Operator));
exports.GraphicsObject = GraphicsObject;
var TextObject = /** @class */ (function (_super) {
    __extends(TextObject, _super);
    function TextObject() {
        return _super.call(this, "BT") || this;
    }
    /**
     * Places text relative from the last given position or Tm object (origin) with + x_rel, + y_rel location
     * */
    TextObject.prototype.setTextRelative = function (text, x_rel, y_rel) {
        if (x_rel === void 0) { x_rel = undefined; }
        if (y_rel === void 0) { y_rel = undefined; }
        if (text === "")
            return this;
        if (x_rel && Array.isArray(x_rel)) {
            y_rel = x_rel[1];
            x_rel = x_rel[0];
        }
        else if (x_rel && typeof x_rel === 'number' && (!y_rel || typeof y_rel === 'number')) {
            throw Error("Invalid number of positioning elements. Must be x and y coordinate");
        }
        text = text.trim();
        if (text.charAt(0) !== "(" || text.charAt(text.length - 1) !== ")") {
            text = "(".concat(text, ")");
        }
        if (typeof x_rel !== 'undefined' && typeof y_rel !== 'undefined') {
            this.addOperator("Td", [x_rel, y_rel]);
        }
        this.addOperator("Tj", [text]);
    };
    /**
     * Places text absolut at the current position or if provided at the x, y coordinates
     *
     * Uses a '1 0 0 1 x y Tm' for placing. So this method cannot be used for scaling.
     * */
    TextObject.prototype.setText = function (text, x, y) {
        if (x === void 0) { x = undefined; }
        if (y === void 0) { y = undefined; }
        if (text === "")
            return this;
        if (x && Array.isArray(x) && x.length >= 2) {
            y = x[1];
            x = x[0];
        }
        else if (x && typeof x === 'number' && (!y || typeof y === 'number')) {
            throw Error("Invalid number of positioning elements. Must be x and y coordinate");
        }
        text = text.trim();
        if (text.charAt(0) !== "(" || text.charAt(text.length - 1) !== ")") {
            text = "(".concat(text, ")");
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined') {
            this.addOperator("Tm", [1, 0, 0, 1, x, y]);
        }
        this.addOperator("Tj", [text]);
        return this;
    };
    /**
     * Places a text in the rectangle defined by 'rect'. It applies text justification.
     *
     * It applies line breaks. It first tries linebreaking at spaces between words and if that is not possible it will break between letters
     * */
    TextObject.prototype.formatText = function (text, font, textSize, rect, justification) {
        if (justification === void 0) { justification = undefined; }
        var rect_width = Math.abs(rect[2] - rect[0]);
        var rect_height = Math.abs(rect[3] - rect[1]);
        var calc_just = function (textwidth) {
            if (justification === freetext_annotation_1.TextJustification.Centered) {
                return rect_width / 2 - textwidth / 2 + rect[0];
            }
            else if (justification === freetext_annotation_1.TextJustification.Right) {
                return rect_width + rect[0] - textwidth;
            }
            else {
                return rect[0];
            }
        };
        // If text fits into the rectangle
        // just place the text
        if (rect_width < TextObject.SINGLE_CHAR_WIDTH) { // if provided rectangle is too small to present a single letter just write it but warn
            console.warn("Overfull hbox ".concat(rect_width, " is below minimal threshold of ").concat(TextObject.SINGLE_CHAR_WIDTH));
            this.setText(text, [calc_just(font.calculateTextDimensions(text, textSize)[0]), rect_height - textSize * 1.2 + rect[1]]);
            return this;
        }
        else {
            var positions = font.proposeLinebreaks(text, textSize, rect_width);
            var last_pos = calc_just(positions[0].width);
            this.setText(text.substring(positions[0].start, positions[0].end + 1), [last_pos, rect_height - textSize * 1.2 + rect[1]]);
            for (var i = 1; i < positions.length; ++i) {
                var x_pos = calc_just(positions[i].width);
                this.setTextRelative(text.substring(positions[i].start, positions[i].end + 1), [x_pos - last_pos, -textSize]);
                last_pos = x_pos;
            }
        }
        return this;
    };
    TextObject.prototype.setFont = function (font, fontSize) {
        if (font === void 0) { font = "/F1"; }
        if (fontSize === void 0) { fontSize = 14; }
        this.addOperator("Tf", [font, fontSize]);
        return this;
    };
    TextObject.prototype.setColor = function (color) {
        if (color === void 0) { color = undefined; }
        if (!color)
            color = { r: 0, g: 0, b: 0 };
        color = util_1.Util.colorToRange01(color);
        this.addOperator("rg", [color.r, color.g, color.b]);
        return this;
    };
    TextObject.SINGLE_CHAR_WIDTH = 10;
    return TextObject;
}(Operator));
exports.TextObject = TextObject;
var ContentStream = /** @class */ (function (_super) {
    __extends(ContentStream, _super);
    function ContentStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * True, if the content stream is empty
     * */
    ContentStream.prototype.isEmpty = function () {
        return this.operators.length === 0;
    };
    /**
     * Outputs the content stream as byte sequence
     * */
    ContentStream.prototype.writeContentStream = function (noLineFeed) {
        if (noLineFeed === void 0) { noLineFeed = false; }
        return this.toByteArray(noLineFeed);
    };
    return ContentStream;
}(Operator));
exports.ContentStream = ContentStream;


/***/ }),

/***/ "./src/annotate/crypto-util.ts":
/*!*************************************!*\
  !*** ./src/annotate/crypto-util.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.CryptoUtil = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var crypto = __webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js");
var CryptoUtil = /** @class */ (function () {
    function CryptoUtil() {
    }
    /**
     * Transforms a uint8array into a crypto-js word array
     * */
    CryptoUtil.convertToWordArray = function (arr) {
        var new_val_int32 = util_1.Util.convertUint8ArrayToInt32Array(arr);
        return crypto.lib.WordArray.create(Array.from(new_val_int32), arr.length);
    };
    /**
     * Converts a given word array into a uint8 array
     * */
    CryptoUtil.convertWordArrayToByteArray = function (arr) {
        return util_1.Util.convertInt32ArrayToUint8Array(arr.words);
    };
    /**
     * Converts a number into a little endian byte array
     * */
    CryptoUtil.convertNumberToLittleEndianByteArray = function (nbr) {
        return util_1.Util.convertInt32ArrayToUint8Array(new Int32Array([nbr])).reverse();
    };
    /**
     * Returns the MD5 hash
     * */
    CryptoUtil.MD5 = function (data) {
        if (data instanceof Uint8Array) {
            data = CryptoUtil.convertToWordArray(data);
        }
        return crypto.MD5(data);
    };
    /**
     * Returns the MD5 hash as byte array
     * */
    CryptoUtil.MD5AsByteArray = function (data) {
        if (data instanceof Uint8Array) {
            data = CryptoUtil.convertToWordArray(data);
        }
        return CryptoUtil.convertWordArrayToByteArray(crypto.MD5(data));
    };
    /**
     * Returns the MD5 hash as hex string
     * */
    CryptoUtil.MD5Hex = function (data) {
        return CryptoUtil.MD5(data).toString(crypto.enc.Hex);
    };
    /**
     * Returns the RC4 encrypted data
     * */
    CryptoUtil.RC4 = function (data, key) {
        if (data instanceof Uint8Array) {
            data = CryptoUtil.convertToWordArray(data);
        }
        if (key instanceof Uint8Array) {
            key = CryptoUtil.convertToWordArray(key);
        }
        return crypto.RC4.encrypt(data, key).ciphertext;
    };
    /**
     * Returns the RC4 encrypted data as hex string
     * */
    CryptoUtil.RC4Hex = function (data, key) {
        return CryptoUtil.RC4(data, key).toString(crypto.enc.Hex);
    };
    /**
     * Pads the provided password string
     * */
    CryptoUtil.padPasswortString = function (password) {
        if (typeof password === 'string') {
            password = new Uint8Array(util_1.Util.convertStringToAscii(password));
        }
        var ret_val = new Uint8Array(32);
        ret_val.set(password.slice(0, 32));
        if (password.length < 32) {
            ret_val.set(CryptoUtil.PADDING_STRING.slice(0, 32 - password.length), password.length);
        }
        return ret_val;
    };
    /**
     * Xors every byte of the provided _byte_array with the value _k
     * */
    CryptoUtil.xorBytes = function (_byte_array, _k) {
        var _ret_val = [];
        for (var i = 0; i < _byte_array.length; ++i) {
            _ret_val.push(_byte_array[i] ^ _k);
        }
        return CryptoUtil.convertToWordArray(new Uint8Array(_ret_val));
    };
    CryptoUtil.PADDING_STRING = [
        0x28,
        0xBF,
        0x4E,
        0x5E,
        0x4E,
        0x75,
        0x8A,
        0x41,
        0x64,
        0x00,
        0x4E,
        0x56,
        0xFF,
        0xFA,
        0x01,
        0x08,
        0x2E,
        0x2E,
        0x00,
        0xB6,
        0xD0,
        0x68,
        0x3E,
        0x80,
        0x2F,
        0x0C,
        0xA9,
        0xFE,
        0x64,
        0x53,
        0x69,
        0x7A
    ];
    return CryptoUtil;
}());
exports.CryptoUtil = CryptoUtil;


/***/ }),

/***/ "./src/annotate/crypto.ts":
/*!********************************!*\
  !*** ./src/annotate/crypto.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.RC4CryptoEngine = exports.IdentityEngine = exports.RC4_40_BIT = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var crypto_util_1 = __webpack_require__(/*! ./crypto-util */ "./src/annotate/crypto-util.ts");
exports.RC4_40_BIT = true;
var IdentityEngine = /** @class */ (function () {
    function IdentityEngine() {
    }
    IdentityEngine.prototype.encrypt = function (data, reference) {
        return data;
    };
    IdentityEngine.prototype.decrypt = function (data, reference) {
        return data;
    };
    IdentityEngine.prototype.isUserPasswordCorrect = function () {
        return true;
    };
    IdentityEngine.prototype.isOwnerPasswordCorrect = function () {
        return true;
    };
    return IdentityEngine;
}());
exports.IdentityEngine = IdentityEngine;
var RC4CryptoEngine = /** @class */ (function () {
    function RC4CryptoEngine(cryptoConfiguration, file_id, rc4_40_bit) {
        if (rc4_40_bit === void 0) { rc4_40_bit = false; }
        this.cryptoConfiguration = cryptoConfiguration;
        this.file_id = file_id;
        this.rc4_40_bit = rc4_40_bit;
        this.encryptionKey = undefined;
        this.computed_user_password = undefined;
        this.computed_owner_password = undefined;
    }
    RC4CryptoEngine.prototype.encrypt = function (data, reference) {
        if (!reference)
            throw Error("Undefined reference pointer of encrypted object");
        var encryptionKey = this.computeEncryptionKey();
        var adapted_key = new Uint8Array(encryptionKey.length + 5);
        adapted_key.set(encryptionKey, 0);
        var obj = crypto_util_1.CryptoUtil.convertNumberToLittleEndianByteArray(reference.obj);
        adapted_key.set(obj.slice(0, 3), encryptionKey.length);
        var gen = crypto_util_1.CryptoUtil.convertNumberToLittleEndianByteArray(reference.generation);
        adapted_key.set(gen.slice(0, 2), encryptionKey.length + 3);
        var key_hash = crypto_util_1.CryptoUtil.MD5AsByteArray(adapted_key);
        var encrypted = crypto_util_1.CryptoUtil.RC4(data, key_hash.slice(0, Math.min(encryptionKey.length + 5, 16)));
        return crypto_util_1.CryptoUtil.convertWordArrayToByteArray(encrypted);
    };
    RC4CryptoEngine.prototype.decrypt = function (data, reference) {
        return this.encrypt(data, reference);
    };
    /**
     * Computes the RC4 encryption key
     * */
    RC4CryptoEngine.prototype.computeEncryptionKey = function () {
        if (this.encryptionKey)
            return this.encryptionKey;
        var userpwd = crypto_util_1.CryptoUtil.padPasswortString(this.cryptoConfiguration.user_pwd);
        if (!this.cryptoConfiguration.owner_pwd_c)
            throw Error("Invalid /O value (owner password)");
        var oValue = this.cryptoConfiguration.owner_pwd_c;
        if (oValue.length !== 32)
            throw Error("Invalid length of owner value. Is ".concat(oValue.length, " but must be 32."));
        if (!this.cryptoConfiguration.permissions)
            throw Error("Permissions not set");
        var permissions = crypto_util_1.CryptoUtil.convertNumberToLittleEndianByteArray(this.cryptoConfiguration.permissions);
        if (!this.file_id || this.file_id.length === 0)
            throw Error("File ID not set");
        var keylength = 40;
        if (this.cryptoConfiguration.length)
            keylength = this.cryptoConfiguration.length;
        var file_id = this.file_id[0];
        var stuff = new Uint8Array(userpwd.length + oValue.length + permissions.length + file_id.length);
        stuff.set(userpwd, 0);
        stuff.set(oValue, userpwd.length);
        stuff.set(permissions, userpwd.length + oValue.length);
        stuff.set(file_id, userpwd.length + oValue.length + permissions.length);
        var h = crypto_util_1.CryptoUtil.MD5AsByteArray(stuff);
        keylength = keylength >> 3;
        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {
            for (var i = 0; i < 50; ++i) {
                h = crypto_util_1.CryptoUtil.MD5AsByteArray(h.slice(0, keylength));
            }
        }
        if (this.rc4_40_bit) {
            this.encryptionKey = h.slice(0, 5);
        }
        else {
            this.encryptionKey = h;
        }
        return this.encryptionKey;
    };
    /**
     * Derives the user password (/U) value
     * */
    RC4CryptoEngine.prototype.computeUserPassword = function () {
        if (this.computed_user_password)
            return this.computed_user_password;
        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {
            return this.computeUserPasswordRevision3OrGreater();
        }
        else if (this.cryptoConfiguration.revision === 2) {
            return this.computeUserPasswordRevision2();
        }
        return new Uint8Array([]);
    };
    /**
     * Computes the user password for security handlers of revision 2
     * */
    RC4CryptoEngine.prototype.computeUserPasswordRevision2 = function () {
        var padding_str = new Uint8Array(crypto_util_1.CryptoUtil.PADDING_STRING);
        var enc_key = this.computeEncryptionKey();
        var x = crypto_util_1.CryptoUtil.RC4(padding_str, enc_key);
        this.computed_user_password = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(x);
        return this.computed_user_password;
    };
    /**
     * Computes the user password for security handlers of revision 3 or higher
     * */
    RC4CryptoEngine.prototype.computeUserPasswordRevision3OrGreater = function () {
        if (!this.file_id)
            throw Error("No file id");
        var id_str_array = this.file_id[0];
        var new_val = new Uint8Array(crypto_util_1.CryptoUtil.PADDING_STRING.length + id_str_array.length);
        new_val.set(crypto_util_1.CryptoUtil.PADDING_STRING, 0);
        new_val.set(id_str_array, crypto_util_1.CryptoUtil.PADDING_STRING.length);
        var x = crypto_util_1.CryptoUtil.MD5(new_val);
        var enc_key = this.computeEncryptionKey();
        for (var i = 0; i < 20; ++i) {
            x = crypto_util_1.CryptoUtil.RC4(x, crypto_util_1.CryptoUtil.xorBytes(enc_key, i));
        }
        this.computed_user_password = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(x);
        return this.computed_user_password;
    };
    /**
     * Derives the owner password (/O) value
     **/
    RC4CryptoEngine.prototype.computeOwnerPassword = function () {
        if (this.computed_owner_password)
            return this.computed_owner_password;
        var pwd_string = this.cryptoConfiguration.owner_pwd;
        // if no owner password is set, but a user password use this
        if (!this.cryptoConfiguration.owner_pwd || this.cryptoConfiguration.owner_pwd === "")
            pwd_string = this.cryptoConfiguration.user_pwd;
        var ownerpwd = crypto_util_1.CryptoUtil.padPasswortString(pwd_string);
        var h = crypto_util_1.CryptoUtil.MD5(ownerpwd);
        var count = 1;
        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {
            count = 20;
            for (var i = 0; i < 50; ++i) {
                h = crypto_util_1.CryptoUtil.MD5(h);
            }
        }
        var length = 128;
        if (this.cryptoConfiguration.length)
            length = this.cryptoConfiguration.length;
        var enc_key = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(h).slice(0, length / 8);
        var userpwd = crypto_util_1.CryptoUtil.padPasswortString(this.cryptoConfiguration.user_pwd);
        var x = crypto_util_1.CryptoUtil.convertToWordArray(userpwd);
        for (var i = 0; i < count; ++i) {
            x = crypto_util_1.CryptoUtil.RC4(x, crypto_util_1.CryptoUtil.xorBytes(enc_key, i));
        }
        this.computed_owner_password = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(x);
        return this.computed_owner_password;
    };
    /**
     * Returns true if the provided password corresponds to the defined /U value
     * */
    RC4CryptoEngine.prototype.isUserPasswordCorrect = function () {
        var user_pwd = this.computeUserPassword();
        if (!this.cryptoConfiguration.user_pwd_c)
            throw Error("Invalid /U value (user password)");
        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {
            return util_1.Util.areArraysEqual(user_pwd, this.cryptoConfiguration.user_pwd_c.slice(0, 16));
        }
        else {
            return util_1.Util.areArraysEqual(user_pwd, this.cryptoConfiguration.user_pwd_c);
        }
    };
    /**
     * Returns true if the provided password corresponds to the defined /O value
     * */
    RC4CryptoEngine.prototype.isOwnerPasswordCorrect = function () {
        var owner_pwd = this.computeOwnerPassword();
        if (!this.cryptoConfiguration.owner_pwd_c)
            throw Error("Invalid /O value (owner password)");
        return util_1.Util.areArraysEqual(owner_pwd, this.cryptoConfiguration.owner_pwd_c);
    };
    return RC4CryptoEngine;
}());
exports.RC4CryptoEngine = RC4CryptoEngine;


/***/ }),

/***/ "./src/annotate/document-history.ts":
/*!******************************************!*\
  !*** ./src/annotate/document-history.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.DocumentHistory = exports.CrossReferenceTable = exports.CrossReferenceStreamObject = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var object_util_1 = __webpack_require__(/*! ./object-util */ "./src/annotate/object-util.ts");
var generateDefaultTrailer = function () {
    return { size: -1, root: { obj: -1, generation: -1 }, is_encrypted: false };
};
/**
 * Holds the complete information of one update section in the Cross-Reference-Stream Object format.
 *
 * */
var CrossReferenceStreamObject = /** @class */ (function () {
    function CrossReferenceStreamObject(data) {
        this.data = data;
        this.refs = [];
        this.trailer = generateDefaultTrailer();
        this.streamLength = -1;
        this.w = [];
        this.index = [];
        this.start_pointer = 0;
    }
    /**
     * Extracts a cross reference section that is a continuous definition of cross reference entries
     * */
    CrossReferenceStreamObject.prototype.extractCrossReferenceSection = function (first_object_id, object_count, stream) {
        var current_object_id = first_object_id;
        for (var i = 0; i < object_count; ++i) {
            var _type = stream.getNBytesAsNumber(this.w[0]);
            var xref = undefined;
            switch (_type) {
                case 0:
                    xref = { id: current_object_id++, pointer: stream.getNBytesAsNumber(this.w[1]), generation: this.w[2] === 0 ? 0 : stream.getNBytesAsNumber(this.w[2]), free: true, update: false };
                    break;
                case 1:
                    xref = { id: current_object_id++, pointer: stream.getNBytesAsNumber(this.w[1]), generation: this.w[2] === 0 ? 0 : stream.getNBytesAsNumber(this.w[2]), free: false, update: true };
                    break;
                case 2:
                    // in this case the pointer becomes the stream object id that contains the compressed object and the generation represents the index of the object in the stream
                    xref = { id: current_object_id++, pointer: stream.getNBytesAsNumber(this.w[1]), generation: this.w[2] === 0 ? 0 : stream.getNBytesAsNumber(this.w[2]), free: true, update: false, compressed: true };
                    break;
            }
            if (xref)
                this.refs.push(xref);
            else
                throw Error("Invalid cross-reference-stream type ".concat(_type));
        }
    };
    /**
     * Extracts the cross-reference-table from the stream
     * */
    CrossReferenceStreamObject.prototype.extractStream = function (stream) {
        var cross_reference_length = this.w.reduce(function (a, b) { return a + b; }, 0);
        // check if the data stream has a valid size
        if (stream.getLength() !== cross_reference_length * this.index.filter(function (v, i) { return i % 2 === 1; }).reduce(function (a, b) { return a + b; }, 0))
            throw Error("Invalid stream length - is ".concat(stream.getLength(), " but should be ").concat(cross_reference_length * this.index.filter(function (v, i) { return i % 2 === 1; }).reduce(function (a, b) { return a + b; }, 0)));
        if (this.index.length % 2 === 1)
            throw Error("Invalid index flag ".concat(this.index));
        for (var i = 0; i < this.index.length; i += 2) {
            this.extractCrossReferenceSection(this.index[i], this.index[i + 1], stream);
        }
    };
    /**
     * Parses the Cross-Reference-Stream-Object at the given index
     * */
    CrossReferenceStreamObject.prototype.extract = function (xref) {
        var index = xref.pointer;
        this.start_pointer = index;
        var crs_object = object_util_1.ObjectUtil.extractObject(this.data, xref);
        var ptr_object_end = util_1.Util.locateSequence(util_1.Util.ENDOBJ, this.data, index);
        this.data = this.data.slice(index, ptr_object_end);
        // check type
        if (crs_object.value["/Type"] !== "/XRef")
            throw Error("Invalid Cross-Reference-Stream-object type: ".concat(crs_object.value["/Type"]));
        // extract size
        if (!crs_object.value["/Size"])
            throw Error("Invalid size value ".concat(crs_object.value["/Size"]));
        this.trailer.size = crs_object.value["/Size"];
        // extract ROOT if it exists
        if (crs_object.value["/Root"])
            this.trailer.root = crs_object.value["/Root"];
        // extract PREV if it exists
        if (crs_object.value["/Prev"])
            this.trailer.prev = crs_object.value["/Prev"];
        // extract W parameter
        this.w = crs_object.value["/W"];
        if (!this.w || 0 === this.w.length)
            throw Error("Invalid /W parameter in Cross-Reference-Stream-Object");
        // extract Index parameter
        this.index = crs_object.value["/Index"];
        if (!this.index || 0 === this.index.length)
            this.index = [0, crs_object.value["/Size"]];
        if (!crs_object.stream)
            throw Error("Missing stream at cross reference stream object");
        var stream = crs_object.stream;
        if (!stream)
            throw Error("Invalid stream object");
        this.streamLength = crs_object.value["/Length"];
        this.extractStream(stream);
        // the cross-reference-stream object is also a known reference
        this.refs.push({ id: crs_object.id.obj, pointer: this.start_pointer, generation: crs_object.id.generation, free: false, update: true });
    };
    /**
     * Returs the update section representing this CrossReferenceStreamObject
     * */
    CrossReferenceStreamObject.prototype.getUpdateSection = function () {
        return {
            start_pointer: this.start_pointer,
            size: this.trailer.size,
            prev: this.trailer.prev,
            root: this.trailer.root,
            refs: this.refs,
            is_encrypted: this.trailer.is_encrypted,
            encrypt: this.trailer.encrypt,
            id: this.trailer.id
        };
    };
    return CrossReferenceStreamObject;
}());
exports.CrossReferenceStreamObject = CrossReferenceStreamObject;
/**
 * Holds the complete information of one update section in the Cross-Reference-Table format. That comprises:
 * - the body update
 * - the crossiste reference table
 * - the trailer
 * */
var CrossReferenceTable = /** @class */ (function () {
    function CrossReferenceTable(data) {
        this.data = data;
        this.refs = [];
        this.start_pointer = -1;
        this.trailer = generateDefaultTrailer();
    }
    /**
     * Returns the reference with the given id
     * */
    CrossReferenceTable.prototype.getReference = function (id) {
        for (var _i = 0, _a = this.refs; _i < _a.length; _i++) {
            var ref = _a[_i];
            if (ref.id === id)
                return ref;
        }
        return undefined;
    };
    /**
     * Returs the update section representing this CrossReferenceTable
     * */
    CrossReferenceTable.prototype.getUpdateSection = function () {
        return {
            start_pointer: this.start_pointer,
            size: this.trailer.size,
            refs: this.refs,
            prev: this.trailer.prev,
            root: this.trailer.root,
            is_encrypted: this.trailer.is_encrypted,
            encrypt: this.trailer.encrypt,
            id: this.trailer.id
        };
    };
    /**
     * Extracts the header of a sub section. For instance
     *
     * 0 1 // <--
     * ...
     *
     * So the obejct id 0 and the number of sub section entries 1
     * */
    CrossReferenceTable.prototype.extractSubSectionHeader = function (index) {
        var ptr = util_1.Util.locateDelimiter(this.data, index);
        var obj_id = util_1.Util.extractNumber(this.data, index, ptr).result;
        ptr = util_1.Util.skipDelimiter(this.data, ptr + 1);
        var ptr_ref_count = ptr;
        ptr = util_1.Util.locateDelimiter(this.data, ptr);
        var reference_count = util_1.Util.extractNumber(this.data, ptr_ref_count, ptr).result;
        return { id: obj_id, count: reference_count, end_ptr: ptr };
    };
    /**
     * Extracts the references of a sub section. The index points to the start of
     * the first reference and count represents the number of references that are
     * contained in the subsection.
     *
     * The first_object_id is the id provided in the sub section header
     *
     * By definition of the PDF standard one entry is 20 bytes long, but since the standard is rarely respected we better make it failsafe
     * */
    CrossReferenceTable.prototype.extractReferences = function (index, count, first_object_id) {
        var _refs = [];
        var res = { result: null, start_index: -1, end_index: index };
        for (var i = 0; count === -1 || i < count; ++i) {
            res = util_1.Util.readNextWord(this.data, res.end_index + 1);
            var pointer = util_1.Util.extractNumber(res.result, 0).result;
            res = util_1.Util.readNextWord(this.data, res.end_index + 1);
            var generation = util_1.Util.extractNumber(res.result, 0).result;
            res = util_1.Util.readNextWord(this.data, res.end_index + 1);
            var ptr_flag = res.result;
            var isFree = ptr_flag[0] === 102; // 102 = f
            _refs.push({
                id: first_object_id + i,
                pointer: pointer,
                generation: generation,
                free: isFree,
                update: !isFree
            });
            // if the word trailer occurs stop since we reached the end
            if (this.data[util_1.Util.skipSpaces(this.data, res.end_index + 1)] === 116) {
                break;
            }
        }
        return { refs: _refs, end_index: res.end_index };
    };
    /**
     * Extracts the trailer of the subsection that means the part stating with the 'trailer' keyword and
     * in particular the trailer dictionary
     * */
    CrossReferenceTable.prototype.extractTrailer = function (index) {
        // run forward to the dictionary start
        index = util_1.Util.locateSequence(util_1.Util.DICT_START, this.data, index) + 2;
        var obj = {};
        object_util_1.ObjectUtil.extractDictKeyRec(this.data, index, obj);
        return {
            size: obj["/Size"],
            root: obj["/Root"],
            prev: obj["/Prev"] ? obj["/Prev"] : undefined,
            is_encrypted: obj["/Encrypt"] ? true : false,
            encrypt: obj["/Encrypt"] ? obj["/Encrypt"] : undefined,
            id: obj["/ID"] ? obj["/ID"] : undefined
        };
    };
    /**
     * Parses the Cross Reference Table at the given index
     * */
    CrossReferenceTable.prototype.extract = function (index, skipXREFString) {
        if (skipXREFString === void 0) { skipXREFString = false; }
        this.start_pointer = index;
        var start_ptr = index;
        if (!skipXREFString)
            start_ptr += 5; // + length(xref) + blank
        start_ptr = util_1.Util.skipDelimiter(this.data, start_ptr);
        // check if there actually is a subsection header
        // if the line finishes with an 'f' we know that it starts with the first cross reference entry
        var tmp_ptr = start_ptr;
        while (tmp_ptr < this.data.length && this.data[tmp_ptr] !== 102 && this.data[tmp_ptr] !== 13 && this.data[tmp_ptr] !== 10)
            tmp_ptr++;
        var first_header = { id: 0, count: -1, end_ptr: start_ptr - 1 };
        if (this.data[tmp_ptr] === 10 || this.data[tmp_ptr] === 13)
            first_header = this.extractSubSectionHeader(start_ptr);
        var ref_start = util_1.Util.skipDelimiter(this.data, first_header.end_ptr + 1);
        // extract first reference
        var reference_result = this.extractReferences(ref_start, first_header.count, first_header.id);
        this.refs = this.refs.concat(reference_result.refs);
        // extract remaining references
        start_ptr = util_1.Util.skipSpaces(this.data, reference_result.end_index + 1);
        while (first_header.count > 0 && this.data[start_ptr] !== 116) { // 116 = 't' start of the word trailer that concludes the crosssite reference section
            var header = this.extractSubSectionHeader(start_ptr);
            ref_start = util_1.Util.skipDelimiter(this.data, header.end_ptr + 1);
            var references = this.extractReferences(ref_start, header.count, header.id);
            this.refs = this.refs.concat(references.refs);
            start_ptr = util_1.Util.skipSpaces(this.data, references.end_index + 1);
        }
        this.trailer = this.extractTrailer(start_ptr);
    };
    return CrossReferenceTable;
}());
exports.CrossReferenceTable = CrossReferenceTable;
/**
 * Represents the complete PDF document history and therefore holds the
 * updated body parts, the crosssite references and the document trailers
 * */
var DocumentHistory = /** @class */ (function () {
    function DocumentHistory(data) {
        this.data = data;
        this.updates = [];
        this.trailerSize = -1;
        /**
         * Holds object ids that were formerly freed and are now 'already' reused.
         * This is used to prevent a freed object a second time */
        this.already_reused_ids = [];
        this.data = new Uint8Array(data);
    }
    /**
     * Extracts the cross reference table starting at the given index
     * */
    DocumentHistory.prototype.extractCrossReferenceTable = function (index, skipXREFString) {
        if (skipXREFString === void 0) { skipXREFString = false; }
        var crt = new CrossReferenceTable(this.data);
        crt.extract(index, skipXREFString);
        return crt;
    };
    /**
     * Extracts the cross reference stream object starting at the given index
     * */
    DocumentHistory.prototype.extractCrossReferenceStreamObject = function (xref) {
        var crs = new CrossReferenceStreamObject(this.data);
        crs.extract(xref);
        return crs;
    };
    /**
     * Extracts the last update section of a document (that means
     * the most recent update locating at the end of the file)
     *
     * Handles missing or wrong pointers
     * and also decides, whether the cross reference table is provided as stream object or regular
     * */
    DocumentHistory.prototype.extractDocumentEntry = function () {
        var _this = this;
        var ptr = this.data.length - 1;
        var ptr_startxref = util_1.Util.locateSequenceReversed(util_1.Util.STARTXREF, this.data, ptr, true) + 9;
        // identify cross reference section type
        var section_type = "UNKNOWN";
        var preceding_word_index = util_1.Util.skipSpacesReverse(this.data, ptr_startxref - 10);
        if (util_1.Util.areArraysEqual(this.data.slice(preceding_word_index - 5, preceding_word_index + 1), util_1.Util.ENDOBJ)) {
            section_type = "stream";
        }
        else {
            section_type = "trailer";
        }
        // try to locate cross reference table manually
        var locateXREFStartManually = function () {
            var new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.XREF, _this.data, _this.data.length);
            section_type = "trailer";
            while (new_ptr > 0 && _this.data[new_ptr - 1] === 116) { // 116 = 't' -> we are looking for 'xref' not 'startxref'
                new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.XREF, _this.data, new_ptr - 1);
            }
            if (new_ptr === -1) { // than we try to identify the word 'trailer' and run backwards as long as we find a symbol that is not a number or 'f' or 'n' - what could possibly go wrong
                section_type = "trailer_without_xref_start";
                new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.TRAILER, _this.data, _this.data.length);
                if (new_ptr > 0) {
                    new_ptr--;
                    while (new_ptr > 0 && (util_1.Util.isSpace(_this.data[new_ptr]) || util_1.Util.isNumber(_this.data[new_ptr]) || _this.data[new_ptr] === 110 || //110 = 'n' 102 = 'f'
                        _this.data[new_ptr] === 102))
                        --new_ptr;
                    new_ptr = util_1.Util.skipSpaces(_this.data, new_ptr + 1);
                }
            }
            return { pointer: new_ptr, sectionType: section_type };
        };
        try {
            ptr = util_1.Util.extractNumber(this.data, ptr_startxref).result;
        }
        catch (err) {
            return locateXREFStartManually();
        }
        if (ptr > this.data.length) {
            return locateXREFStartManually();
        }
        // start section with XREF?
        if (section_type !== "stream" && !(this.data[ptr] === util_1.Util.XREF[0] && this.data[ptr + 1] === util_1.Util.XREF[1] && this.data[ptr + 2] === util_1.Util.XREF[2] && this.data[ptr + 3] === util_1.Util.XREF[3])) {
            return locateXREFStartManually();
        }
        return { pointer: ptr, sectionType: section_type };
    };
    /**
     * Extracts the entire update sections
     *
     * Needs to adapt depending whether the document uses a cross-reference table or a cross-reference stream object
     * */
    DocumentHistory.prototype.extractDocumentHistory = function () {
        var document_entry = this.extractDocumentEntry();
        var ptr = document_entry.pointer;
        if (ptr === -1) {
            throw Error("Could not locate document entry");
        }
        var xref = {
            id: -1,
            pointer: ptr,
            generation: 0,
            free: false,
            update: true
        };
        this.extractCrossReferenceTables(document_entry, xref);
        // adapt pointer in case there is junk before the header
        var pdf_header_start = util_1.Util.locateSequence(util_1.Util.VERSION, this.data, 0);
        if (pdf_header_start !== 0 && pdf_header_start !== -1) {
            for (var _i = 0, _a = this.updates; _i < _a.length; _i++) {
                var updateSection = _a[_i];
                for (var _b = 0, _c = updateSection.refs; _b < _c.length; _b++) {
                    var ref = _c[_b];
                    ref.pointer += pdf_header_start;
                }
            }
        }
    };
    /**
     * Extracts the cross reference tables of the entire document
     * */
    DocumentHistory.prototype.extractCrossReferenceTables = function (document_entry, xref) {
        var ptr = document_entry.pointer;
        // Handle cross reference table
        if (document_entry.sectionType === "trailer") {
            var crt = this.extractCrossReferenceTable(ptr);
            this.updates.push(crt.getUpdateSection());
            var us = this.updates[0];
            while (us.prev) {
                crt = this.extractCrossReferenceTable(us.prev);
                this.updates.push(crt.getUpdateSection());
                us = this.updates[this.updates.length - 1];
            }
        }
        else if (document_entry.sectionType === "stream") { // handle cross reference stream object
            var crs = this.extractCrossReferenceStreamObject(xref);
            this.updates.push(crs.getUpdateSection());
            var us = this.updates[0];
            while (us.prev) {
                var _xref = {
                    id: -1,
                    pointer: us.prev,
                    generation: 0,
                    free: false,
                    update: true
                };
                crs = this.extractCrossReferenceStreamObject(_xref);
                this.updates.push(crs.getUpdateSection());
                us = this.updates[this.updates.length - 1];
            }
        }
        else if (document_entry.sectionType === "trailer_without_xref_start") {
            var crt = this.extractCrossReferenceTable(ptr, true);
            this.updates.push(crt.getUpdateSection());
            var us = this.updates[0];
            while (us.prev) {
                crt = this.extractCrossReferenceTable(us.prev);
                this.updates.push(crt.getUpdateSection());
                us = this.updates[this.updates.length - 1];
            }
        }
        else {
            throw Error("Could not part cross reference table");
        }
        this.trailerSize = this.extractReferenceNumberCount();
    };
    /**
     * Counts the number of specified objects
     * */
    DocumentHistory.prototype.extractReferenceNumberCount = function () {
        var visited = [];
        var count = 0;
        for (var _i = 0, _a = this.updates; _i < _a.length; _i++) {
            var update = _a[_i];
            for (var _b = 0, _c = update.refs; _b < _c.length; _b++) {
                var ref = _c[_b];
                if (!visited.includes(ref.id)) {
                    count++;
                    visited.push(ref.id);
                }
            }
        }
        return count;
    };
    /**
     * Primarily for clarification. The first element is the most recent. We parsed backwards.
     * */
    DocumentHistory.prototype.getRecentUpdate = function () {
        return this.updates[0];
    };
    /**
     * Indicates whether the PDF document is encrypted
     * */
    DocumentHistory.prototype.isEncrypted = function () {
        return this.getRecentUpdate().is_encrypted;
    };
    /**
     * By running through the PDf history we can for every object id determine the pointer address to the most recent version, and
     * whether the object id is still in used.
     *
     * So the object lookup table has an entry for every existing object id, a pointer to the the most recent object definition, as long
     * as the object exists, or an according indication otherwise.
     * */
    DocumentHistory.prototype.createObjectLookupTable = function () {
        var objTable = {};
        var update = this.getRecentUpdate();
        var i = 1;
        while (Object.keys(objTable).length < this.extractReferenceNumberCount()) {
            var refs = update.refs;
            for (var _i = 0, refs_1 = refs; _i < refs_1.length; _i++) {
                var ref = refs_1[_i];
                if (!objTable.hasOwnProperty(ref.id)) {
                    objTable[ref.id] = ref;
                }
            }
            update = this.updates[i];
            ++i;
        }
        return objTable;
    };
    /**
     * Returns the new object id. It primarily tries to reuse an existing id, but if no such exists it will return a
     * new one
     * */
    DocumentHistory.prototype.getFreeObjectId = function () {
        var _this = this;
        var objectLookupTable = this.createObjectLookupTable();
        var free_header = objectLookupTable[0];
        if (!free_header)
            throw Error("Crosssite reference has no header for the linked list of free objects");
        // if the pointer of object 0 points to 0 there is no freed object that can be reused
        if (0 === free_header.pointer) {
            if (-1 === this.trailerSize)
                throw Error("Trailer size not set");
            return { obj: this.trailerSize++, generation: 0, reused: false };
        }
        // get list head
        var ptr = free_header.pointer;
        var freedHeaderList = [];
        while (ptr !== 0) {
            freedHeaderList.push(free_header);
            free_header = objectLookupTable[ptr];
            if (!free_header.free) {
                // handle the case of an incosistent xref
                return { obj: this.trailerSize++, generation: 0, reused: false };
            }
            ptr = free_header.pointer;
        }
        var getFreeHeader = function (freeHeaderList) {
            for (var _i = 0, _a = freeHeaderList.reverse(); _i < _a.length; _i++) {
                var p = _a[_i];
                if (p.generation < 65535 && // max generation number
                    -1 === _this.already_reused_ids.indexOf(p)) { // not already reused
                    return p;
                }
            }
            return undefined;
        };
        var reused_free_header = getFreeHeader(freedHeaderList);
        if (reused_free_header) {
            free_header = reused_free_header;
            // store used id to make sure it will not be selected again
            this.already_reused_ids.push(free_header);
        }
        else {
            // handle the case that all freed object ids are already reused
            return { obj: this.trailerSize++, generation: 0, reused: false };
        }
        return { obj: free_header.pointer, generation: objectLookupTable[free_header.id].generation, reused: true };
    };
    return DocumentHistory;
}());
exports.DocumentHistory = DocumentHistory;


/***/ }),

/***/ "./src/annotate/font-data.ts":
/*!***********************************!*\
  !*** ./src/annotate/font-data.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

exports.__esModule = true;
exports.STANDARD_FONT_DATA = void 0;
exports.STANDARD_FONT_DATA = {
    "Times-Roman": { widths: [250, 333, 408, 500, 500, 833, 778, 333, 333, 333, 500, 564, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 564, 564, 564, 444, 921, 722, 667, 667, 722, 611, 556, 722, 722, 333, 389, 722, 611, 889, 722, 722, 556, 722, 667, 556, 611, 722, 722, 944, 722, 722, 611, 333, 278, 333, 469, 500, 333, 444, 500, 444, 500, 444, 333, 500, 500, 278, 278, 500, 278, 778, 500, 500, 500, 500, 333, 389, 278, 500, 500, 722, 500, 500, 444, 480, 200, 480, 541, 333, 500, 500, 167, 500, 500, 500, 500, 180, 444, 500, 333, 333, 556, 556, 500, 500, 500, 250, 453, 350, 333, 444, 444, 500, 1000, 1000, 444, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 889, 276, 611, 722, 889, 310, 667, 278, 278, 500, 722, 500, 333, 444, 444, 500, 444, 722, 564, 722, 722, 444, 722, 500, 389, 444, 722, 722, 444, 722, 500, 611, 722, 250, 760, 611, 444, 444, 722, 278, 444, 611, 667, 444, 611, 389, 389, 278, 471, 667, 722, 500, 444, 722, 333, 444, 611, 556, 722, 667, 556, 588, 722, 500, 300, 722, 722, 722, 564, 500, 611, 476, 500, 722, 278, 611, 444, 444, 444, 500, 500, 722, 333, 564, 200, 760, 722, 333, 600, 611, 333, 500, 611, 611, 549, 722, 667, 278, 326, 444, 722, 722, 722, 444, 444, 278, 722, 500, 444, 389, 278, 722, 722, 612, 500, 300, 722, 500, 278, 500, 611, 500, 750, 556, 344, 722, 611, 980, 444, 333, 333, 611, 750, 549, 500, 500, 722, 611, 444, 500, 750, 556, 556, 722, 400, 500, 667, 500, 453, 722, 333, 722, 500, 667, 611, 722, 722, 722, 722, 444, 611, 333, 500, 564, 333, 500, 278, 564, 500, 500, 549, 500, 500, 444, 500, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: "Times", fontWeight: "Roman", italicAngle: 0, fontBBox: [-168, -218, 1000, 898], capHeight: 662, xHeight: 450, ascent: 683, descent: -217, stemH: 28, stemV: 84, flag: 34, kernings: [[65, 67, -40], [65, 71, -40], [65, 79, -55], [65, 233, -55], [65, 81, -55], [65, 84, -111], [65, 85, -55], [65, 86, -135], [65, 87, -90], [65, 89, -105], [65, 39, -111], [65, 118, -74], [65, 119, -92], [65, 121, -92], [66, 65, -35], [66, 85, -10], [68, 65, -40], [68, 86, -40], [68, 87, -30], [68, 89, -55], [70, 65, -74], [70, 97, -15], [70, 44, -80], [70, 111, -15], [70, 249, -15], [70, 46, -80], [74, 65, -60], [75, 79, -30], [75, 233, -30], [75, 101, -25], [75, 111, -35], [75, 249, -35], [75, 117, -15], [75, 121, -25], [76, 84, -92], [76, 86, -100], [76, 87, -74], [76, 89, -100], [76, 39, -92], [76, 121, -55], [232, 84, -92], [232, 86, -100], [232, 87, -74], [232, 89, -100], [232, 39, -92], [232, 121, -55], [78, 65, -35], [79, 65, -35], [79, 84, -40], [79, 86, -50], [79, 87, -35], [79, 88, -40], [79, 89, -50], [233, 65, -35], [233, 84, -40], [233, 86, -50], [233, 87, -35], [233, 88, -40], [233, 89, -50], [80, 65, -92], [80, 97, -15], [80, 44, -111], [80, 46, -111], [81, 85, -10], [82, 79, -40], [82, 233, -40], [82, 84, -60], [82, 85, -40], [82, 86, -80], [82, 87, -55], [82, 89, -65], [84, 65, -93], [84, 79, -18], [84, 233, -18], [84, 97, -80], [84, 58, -50], [84, 44, -74], [84, 101, -70], [84, 45, -92], [84, 105, -35], [84, 111, -80], [84, 249, -80], [84, 46, -74], [84, 114, -35], [84, 59, -55], [84, 117, -45], [84, 119, -80], [84, 121, -80], [85, 65, -40], [86, 65, -135], [86, 71, -15], [86, 79, -40], [86, 233, -40], [86, 97, -111], [86, 58, -74], [86, 44, -129], [86, 101, -111], [86, 45, -100], [86, 105, -60], [86, 111, -129], [86, 249, -129], [86, 46, -129], [86, 59, -74], [86, 117, -75], [87, 65, -120], [87, 79, -10], [87, 233, -10], [87, 97, -80], [87, 58, -37], [87, 44, -92], [87, 101, -80], [87, 45, -65], [87, 105, -40], [87, 111, -80], [87, 249, -80], [87, 46, -92], [87, 59, -37], [87, 117, -50], [87, 121, -73], [89, 65, -120], [89, 79, -30], [89, 233, -30], [89, 97, -100], [89, 58, -92], [89, 44, -129], [89, 101, -100], [89, 45, -111], [89, 105, -55], [89, 111, -110], [89, 249, -110], [89, 46, -129], [89, 59, -92], [89, 117, -111], [97, 118, -20], [97, 119, -15], [98, 46, -40], [98, 117, -20], [98, 118, -15], [99, 121, -15], [44, 186, -70], [44, 39, -70], [101, 103, -15], [101, 118, -25], [101, 119, -25], [101, 120, -15], [101, 121, -15], [102, 97, -10], [102, 245, -50], [102, 102, -25], [102, 105, -20], [102, 39, 55], [103, 97, -5], [104, 121, -5], [105, 118, -25], [107, 101, -10], [107, 111, -10], [107, 249, -10], [107, 121, -15], [108, 119, -10], [248, 119, -10], [110, 118, -40], [110, 121, -15], [111, 118, -15], [111, 119, -25], [111, 121, -10], [249, 118, -15], [249, 119, -25], [249, 121, -10], [112, 121, -10], [46, 186, -70], [46, 39, -70], [170, 65, -80], [96, 65, -80], [96, 96, -74], [39, 100, -50], [39, 108, -10], [39, 248, -10], [39, 39, -74], [39, 114, -50], [39, 115, -55], [39, 32, -74], [39, 116, -18], [39, 118, -50], [114, 44, -40], [114, 103, -18], [114, 45, -20], [114, 46, -55], [32, 65, -55], [32, 84, -18], [32, 86, -50], [32, 87, -30], [32, 89, -90], [118, 97, -25], [118, 44, -65], [118, 101, -15], [118, 111, -20], [118, 249, -20], [118, 46, -65], [119, 97, -10], [119, 44, -65], [119, 111, -10], [119, 249, -10], [119, 46, -65], [120, 101, -15], [121, 44, -65], [121, 46, -65]] },
    "ZapfDingbats": { widths: [278, 974, 961, 974, 980, 719, 789, 790, 791, 690, 960, 939, 549, 855, 911, 933, 911, 945, 974, 755, 846, 762, 761, 571, 677, 763, 760, 759, 754, 494, 552, 537, 577, 692, 786, 788, 788, 790, 793, 794, 816, 823, 789, 841, 823, 833, 816, 831, 923, 744, 723, 749, 790, 792, 695, 776, 768, 792, 759, 707, 708, 682, 701, 826, 815, 789, 789, 707, 687, 696, 689, 786, 787, 713, 791, 785, 791, 873, 761, 762, 762, 759, 759, 892, 892, 788, 784, 438, 138, 277, 415, 392, 392, 668, 668, 390, 390, 317, 317, 276, 276, 509, 509, 410, 410, 234, 234, 334, 334, 732, 544, 544, 910, 667, 760, 760, 776, 595, 694, 626, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 894, 838, 1016, 458, 748, 924, 748, 918, 927, 928, 928, 834, 873, 828, 924, 924, 917, 930, 931, 463, 883, 836, 836, 867, 867, 696, 696, 874, 874, 760, 946, 771, 865, 771, 888, 967, 888, 831, 873, 927, 970, 918], firstChar: 32, lastChar: 254, familyName: "ZapfDingbats", fontWeight: "Medium", italicAngle: 0, fontBBox: [-1, -143, 981, 820], stemH: 28, stemV: 90, flag: 4, kernings: [] },
    "Helvetica": { widths: [278, 278, 355, 556, 556, 889, 667, 222, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 222, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 167, 556, 556, 556, 556, 191, 333, 556, 333, 333, 500, 500, 556, 556, 556, 278, 537, 350, 222, 333, 333, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 556, 778, 1000, 365, 889, 278, 222, 611, 944, 611, 278, 556, 556, 556, 556, 667, 584, 667, 667, 556, 722, 500, 500, 556, 722, 722, 556, 722, 556, 667, 722, 250, 737, 667, 500, 556, 722, 222, 556, 611, 722, 556, 667, 500, 500, 278, 471, 722, 778, 556, 556, 667, 333, 500, 611, 667, 778, 722, 667, 643, 722, 556, 333, 778, 667, 667, 584, 556, 611, 476, 500, 722, 278, 667, 556, 556, 500, 556, 556, 722, 278, 584, 260, 737, 778, 278, 600, 667, 333, 556, 611, 611, 549, 722, 722, 222, 317, 556, 722, 667, 667, 556, 500, 222, 778, 556, 556, 500, 278, 778, 722, 612, 556, 333, 778, 556, 278, 556, 667, 556, 834, 667, 299, 667, 556, 1000, 556, 278, 278, 556, 834, 549, 556, 556, 722, 667, 556, 556, 834, 667, 667, 778, 400, 556, 722, 556, 453, 722, 333, 722, 556, 722, 556, 667, 667, 667, 778, 500, 667, 278, 500, 584, 278, 556, 278, 584, 556, 556, 549, 556, 556, 500, 556, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: "Helvetica", fontWeight: "Medium", italicAngle: 0, fontBBox: [-166, -225, 1000, 931], capHeight: 718, xHeight: 523, ascent: 718, descent: -207, stemH: 76, stemV: 88, flag: 32, kernings: [[65, 67, -30], [65, 71, -30], [65, 79, -30], [65, 233, -30], [65, 81, -30], [65, 84, -120], [65, 85, -50], [65, 86, -70], [65, 87, -50], [65, 89, -100], [65, 117, -30], [65, 118, -40], [65, 119, -40], [65, 121, -40], [66, 85, -10], [66, 44, -20], [66, 46, -20], [67, 44, -30], [67, 46, -30], [68, 65, -40], [68, 86, -70], [68, 87, -40], [68, 89, -90], [68, 44, -70], [68, 46, -70], [70, 65, -80], [70, 97, -50], [70, 44, -150], [70, 101, -30], [70, 111, -30], [70, 249, -30], [70, 46, -150], [70, 114, -45], [74, 65, -20], [74, 97, -20], [74, 44, -30], [74, 46, -30], [74, 117, -20], [75, 79, -50], [75, 233, -50], [75, 101, -40], [75, 111, -40], [75, 249, -40], [75, 117, -30], [75, 121, -50], [76, 84, -110], [76, 86, -110], [76, 87, -70], [76, 89, -140], [76, 186, -140], [76, 39, -160], [76, 121, -30], [232, 84, -110], [232, 86, -110], [232, 87, -70], [232, 89, -140], [232, 186, -140], [232, 39, -160], [232, 121, -30], [79, 65, -20], [79, 84, -40], [79, 86, -50], [79, 87, -30], [79, 88, -60], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -20], [233, 84, -40], [233, 86, -50], [233, 87, -30], [233, 88, -60], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -120], [80, 97, -40], [80, 44, -180], [80, 101, -50], [80, 111, -50], [80, 249, -50], [80, 46, -180], [81, 85, -10], [82, 79, -20], [82, 233, -20], [82, 84, -30], [82, 85, -40], [82, 86, -50], [82, 87, -30], [82, 89, -50], [83, 44, -20], [83, 46, -20], [84, 65, -120], [84, 79, -40], [84, 233, -40], [84, 97, -120], [84, 58, -20], [84, 44, -120], [84, 101, -120], [84, 45, -140], [84, 111, -120], [84, 249, -120], [84, 46, -120], [84, 114, -120], [84, 59, -20], [84, 117, -120], [84, 119, -120], [84, 121, -120], [85, 65, -40], [85, 44, -40], [85, 46, -40], [86, 65, -80], [86, 71, -40], [86, 79, -40], [86, 233, -40], [86, 97, -70], [86, 58, -40], [86, 44, -125], [86, 101, -80], [86, 45, -80], [86, 111, -80], [86, 249, -80], [86, 46, -125], [86, 59, -40], [86, 117, -70], [87, 65, -50], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 44, -80], [87, 101, -30], [87, 45, -40], [87, 111, -30], [87, 249, -30], [87, 46, -80], [87, 117, -30], [87, 121, -20], [89, 65, -110], [89, 79, -85], [89, 233, -85], [89, 97, -140], [89, 58, -60], [89, 44, -140], [89, 101, -140], [89, 45, -140], [89, 105, -20], [89, 111, -140], [89, 249, -140], [89, 46, -140], [89, 59, -60], [89, 117, -110], [97, 118, -20], [97, 119, -20], [97, 121, -30], [98, 98, -10], [98, 44, -40], [98, 108, -20], [98, 248, -20], [98, 46, -40], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 44, -15], [99, 107, -20], [58, 32, -50], [44, 186, -100], [44, 39, -100], [101, 44, -15], [101, 46, -15], [101, 118, -30], [101, 119, -20], [101, 120, -30], [101, 121, -20], [102, 97, -30], [102, 44, -30], [102, 245, -28], [102, 101, -30], [102, 111, -30], [102, 249, -30], [102, 46, -30], [102, 186, 60], [102, 39, 50], [103, 114, -10], [104, 121, -30], [107, 101, -20], [107, 111, -20], [107, 249, -20], [109, 117, -10], [109, 121, -15], [110, 117, -10], [110, 118, -20], [110, 121, -15], [111, 44, -40], [111, 46, -40], [111, 118, -15], [111, 119, -15], [111, 120, -30], [111, 121, -30], [249, 97, -55], [249, 98, -55], [249, 99, -55], [249, 44, -95], [249, 100, -55], [249, 101, -55], [249, 102, -55], [249, 103, -55], [249, 104, -55], [249, 105, -55], [249, 106, -55], [249, 107, -55], [249, 108, -55], [249, 248, -55], [249, 109, -55], [249, 110, -55], [249, 111, -55], [249, 249, -55], [249, 112, -55], [249, 46, -95], [249, 113, -55], [249, 114, -55], [249, 115, -55], [249, 116, -55], [249, 117, -55], [249, 118, -70], [249, 119, -70], [249, 120, -85], [249, 121, -70], [249, 122, -55], [112, 44, -35], [112, 46, -35], [112, 121, -30], [46, 186, -100], [46, 39, -100], [46, 32, -60], [186, 32, -40], [96, 96, -57], [39, 100, -50], [39, 39, -57], [39, 114, -50], [39, 115, -50], [39, 32, -70], [114, 97, -10], [114, 58, 30], [114, 44, -50], [114, 105, 15], [114, 107, 15], [114, 108, 15], [114, 248, 15], [114, 109, 25], [114, 110, 25], [114, 112, 30], [114, 46, -50], [114, 59, 30], [114, 116, 40], [114, 117, 15], [114, 118, 30], [114, 121, 30], [115, 44, -15], [115, 46, -15], [115, 119, -30], [59, 32, -50], [32, 84, -50], [32, 86, -50], [32, 87, -40], [32, 89, -90], [32, 170, -30], [32, 96, -60], [118, 97, -25], [118, 44, -80], [118, 101, -25], [118, 111, -25], [118, 249, -25], [118, 46, -80], [119, 97, -15], [119, 44, -60], [119, 101, -10], [119, 111, -10], [119, 249, -10], [119, 46, -60], [120, 101, -30], [121, 97, -20], [121, 44, -100], [121, 101, -20], [121, 111, -20], [121, 249, -20], [121, 46, -100], [122, 101, -15], [122, 111, -15], [122, 249, -15]] },
    "Courier-Oblique": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: "Courier", fontWeight: "Medium", italicAngle: -12, fontBBox: [-27, -250, 849, 805], capHeight: 562, xHeight: 426, ascent: 629, descent: -157, stemH: 51, stemV: 51, flag: 35, kernings: [] },
    "Times-BoldItalic": { widths: [250, 389, 555, 500, 500, 833, 778, 333, 333, 333, 500, 570, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570, 570, 500, 832, 667, 667, 667, 722, 667, 667, 722, 778, 389, 500, 667, 611, 889, 722, 722, 611, 722, 667, 556, 611, 722, 667, 889, 667, 611, 611, 333, 278, 333, 570, 500, 333, 500, 500, 444, 500, 444, 333, 500, 556, 278, 278, 500, 278, 778, 556, 500, 500, 500, 389, 389, 278, 556, 444, 667, 500, 444, 389, 348, 220, 348, 570, 389, 500, 500, 167, 500, 500, 500, 500, 278, 500, 500, 333, 333, 556, 556, 500, 500, 500, 250, 500, 350, 333, 500, 500, 500, 1000, 1000, 500, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 944, 266, 611, 722, 944, 300, 722, 278, 278, 500, 722, 500, 389, 444, 500, 556, 444, 611, 570, 611, 667, 500, 722, 444, 389, 444, 722, 722, 500, 722, 556, 667, 722, 250, 747, 667, 444, 500, 722, 278, 500, 611, 667, 500, 667, 389, 389, 278, 494, 667, 722, 556, 500, 667, 389, 444, 611, 611, 722, 667, 556, 608, 722, 556, 300, 722, 667, 667, 570, 556, 611, 494, 444, 722, 278, 667, 500, 444, 444, 556, 556, 722, 389, 570, 220, 747, 722, 389, 600, 667, 389, 500, 611, 611, 549, 722, 667, 278, 366, 444, 722, 667, 667, 444, 389, 278, 722, 500, 500, 389, 278, 722, 722, 612, 500, 300, 722, 576, 278, 500, 667, 500, 750, 556, 382, 667, 611, 1000, 444, 389, 389, 611, 750, 549, 500, 556, 722, 667, 444, 500, 750, 556, 556, 722, 400, 500, 667, 556, 549, 722, 389, 722, 500, 667, 611, 667, 667, 667, 722, 389, 667, 389, 500, 606, 389, 556, 278, 606, 500, 556, 549, 500, 500, 389, 556, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: "Times", fontWeight: "Bold", italicAngle: -15, fontBBox: [-200, -218, 996, 921], capHeight: 669, xHeight: 462, ascent: 683, descent: -217, stemH: 42, stemV: 121, flag: 34, kernings: [[65, 67, -65], [65, 71, -60], [65, 79, -50], [65, 233, -50], [65, 81, -55], [65, 84, -55], [65, 85, -50], [65, 86, -95], [65, 87, -100], [65, 89, -70], [65, 39, -74], [65, 117, -30], [65, 118, -74], [65, 119, -74], [65, 121, -74], [66, 65, -25], [66, 85, -10], [68, 65, -25], [68, 86, -50], [68, 87, -40], [68, 89, -50], [70, 65, -100], [70, 97, -95], [70, 44, -129], [70, 101, -100], [70, 105, -40], [70, 111, -70], [70, 249, -70], [70, 46, -129], [70, 114, -50], [74, 65, -25], [74, 97, -40], [74, 44, -10], [74, 101, -40], [74, 111, -40], [74, 249, -40], [74, 46, -10], [74, 117, -40], [75, 79, -30], [75, 233, -30], [75, 101, -25], [75, 111, -25], [75, 249, -25], [75, 117, -20], [75, 121, -20], [76, 84, -18], [76, 86, -37], [76, 87, -37], [76, 89, -37], [76, 39, -55], [76, 121, -37], [232, 84, -18], [232, 86, -37], [232, 87, -37], [232, 89, -37], [232, 39, -55], [232, 121, -37], [78, 65, -30], [79, 65, -40], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -40], [79, 89, -50], [233, 65, -40], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -40], [233, 89, -50], [80, 65, -85], [80, 97, -40], [80, 44, -129], [80, 101, -50], [80, 111, -55], [80, 249, -55], [80, 46, -129], [81, 85, -10], [82, 79, -40], [82, 233, -40], [82, 84, -30], [82, 85, -40], [82, 86, -18], [82, 87, -18], [82, 89, -18], [84, 65, -55], [84, 79, -18], [84, 233, -18], [84, 97, -92], [84, 58, -74], [84, 44, -92], [84, 101, -92], [84, 45, -92], [84, 105, -37], [84, 111, -95], [84, 249, -95], [84, 46, -92], [84, 114, -37], [84, 59, -74], [84, 117, -37], [84, 119, -37], [84, 121, -37], [85, 65, -45], [86, 65, -85], [86, 71, -10], [86, 79, -30], [86, 233, -30], [86, 97, -111], [86, 58, -74], [86, 44, -129], [86, 101, -111], [86, 45, -70], [86, 105, -55], [86, 111, -111], [86, 249, -111], [86, 46, -129], [86, 59, -74], [86, 117, -55], [87, 65, -74], [87, 79, -15], [87, 233, -15], [87, 97, -85], [87, 58, -55], [87, 44, -74], [87, 101, -90], [87, 45, -50], [87, 105, -37], [87, 111, -80], [87, 249, -80], [87, 46, -74], [87, 59, -55], [87, 117, -55], [87, 121, -55], [89, 65, -74], [89, 79, -25], [89, 233, -25], [89, 97, -92], [89, 58, -92], [89, 44, -92], [89, 101, -111], [89, 45, -92], [89, 105, -55], [89, 111, -111], [89, 249, -111], [89, 46, -74], [89, 59, -92], [89, 117, -92], [98, 98, -10], [98, 46, -40], [98, 117, -20], [99, 104, -10], [99, 107, -10], [44, 186, -95], [44, 39, -95], [101, 98, -10], [102, 44, -10], [102, 245, -30], [102, 101, -10], [102, 102, -18], [102, 111, -10], [102, 249, -10], [102, 46, -10], [102, 39, 55], [107, 101, -30], [107, 111, -10], [107, 249, -10], [110, 118, -40], [111, 118, -15], [111, 119, -25], [111, 120, -10], [111, 121, -10], [249, 118, -15], [249, 119, -25], [249, 120, -10], [249, 121, -10], [46, 186, -95], [46, 39, -95], [96, 96, -74], [39, 100, -15], [39, 39, -74], [39, 114, -15], [39, 115, -74], [39, 32, -74], [39, 116, -37], [39, 118, -15], [114, 44, -65], [114, 46, -65], [32, 65, -37], [32, 86, -70], [32, 87, -70], [32, 89, -70], [118, 44, -37], [118, 101, -15], [118, 111, -15], [118, 249, -15], [118, 46, -37], [119, 97, -10], [119, 44, -37], [119, 101, -10], [119, 111, -15], [119, 249, -15], [119, 46, -37], [120, 101, -10], [121, 44, -37], [121, 46, -37]] },
    "Courier-BoldOblique": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: "Courier", fontWeight: "Bold", italicAngle: -12, fontBBox: [-57, -250, 869, 801], capHeight: 562, xHeight: 439, ascent: 629, descent: -157, stemH: 84, stemV: 106, flag: 35, kernings: [] },
    "Times-Bold": { widths: [250, 333, 555, 500, 500, 1000, 833, 333, 333, 333, 500, 570, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570, 570, 500, 930, 722, 667, 722, 722, 667, 611, 778, 778, 389, 500, 778, 667, 944, 722, 778, 611, 778, 722, 556, 667, 722, 722, 1000, 722, 722, 667, 333, 278, 333, 581, 500, 333, 500, 556, 444, 556, 444, 333, 500, 556, 278, 333, 556, 278, 833, 556, 500, 556, 556, 444, 389, 333, 556, 500, 722, 500, 500, 444, 394, 220, 394, 520, 333, 500, 500, 167, 500, 500, 500, 500, 278, 500, 500, 333, 333, 556, 556, 500, 500, 500, 250, 540, 350, 333, 500, 500, 500, 1000, 1000, 500, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 300, 667, 778, 1000, 330, 722, 278, 278, 500, 722, 556, 389, 444, 500, 556, 444, 722, 570, 722, 722, 500, 722, 500, 389, 444, 722, 722, 500, 722, 556, 667, 722, 250, 747, 667, 444, 500, 722, 278, 500, 667, 722, 500, 667, 389, 389, 278, 494, 722, 778, 556, 500, 722, 444, 444, 667, 611, 778, 722, 556, 672, 722, 556, 300, 778, 722, 722, 570, 556, 667, 494, 500, 722, 278, 667, 500, 444, 444, 556, 556, 722, 389, 570, 220, 747, 778, 389, 600, 667, 444, 500, 667, 667, 549, 722, 722, 278, 416, 444, 722, 722, 722, 444, 444, 278, 778, 500, 500, 389, 278, 778, 722, 612, 556, 300, 778, 556, 278, 500, 667, 556, 750, 556, 394, 778, 667, 1000, 444, 389, 389, 667, 750, 549, 500, 556, 722, 667, 444, 500, 750, 556, 556, 778, 400, 500, 722, 556, 549, 722, 444, 722, 500, 722, 667, 722, 722, 722, 778, 444, 667, 389, 556, 570, 389, 556, 333, 570, 500, 556, 549, 500, 500, 444, 556, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: "Times", fontWeight: "Bold", italicAngle: 0, fontBBox: [-168, -218, 1000, 935], capHeight: 676, xHeight: 461, ascent: 683, descent: -217, stemH: 44, stemV: 139, flag: 34, kernings: [[65, 67, -55], [65, 71, -55], [65, 79, -45], [65, 233, -45], [65, 81, -45], [65, 84, -95], [65, 85, -50], [65, 86, -145], [65, 87, -130], [65, 89, -100], [65, 112, -25], [65, 39, -74], [65, 117, -50], [65, 118, -100], [65, 119, -90], [65, 121, -74], [66, 65, -30], [66, 85, -10], [68, 65, -35], [68, 86, -40], [68, 87, -40], [68, 89, -40], [68, 46, -20], [70, 65, -90], [70, 97, -25], [70, 44, -92], [70, 101, -25], [70, 111, -25], [70, 249, -25], [70, 46, -110], [74, 65, -30], [74, 97, -15], [74, 101, -15], [74, 111, -15], [74, 249, -15], [74, 46, -20], [74, 117, -15], [75, 79, -30], [75, 233, -30], [75, 101, -25], [75, 111, -25], [75, 249, -25], [75, 117, -15], [75, 121, -45], [76, 84, -92], [76, 86, -92], [76, 87, -92], [76, 89, -92], [76, 186, -20], [76, 39, -110], [76, 121, -55], [232, 84, -92], [232, 86, -92], [232, 87, -92], [232, 89, -92], [232, 186, -20], [232, 39, -110], [232, 121, -55], [78, 65, -20], [79, 65, -40], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -40], [79, 89, -50], [233, 65, -40], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -40], [233, 89, -50], [80, 65, -74], [80, 97, -10], [80, 44, -92], [80, 101, -20], [80, 111, -20], [80, 249, -20], [80, 46, -110], [81, 85, -10], [81, 46, -20], [82, 79, -30], [82, 233, -30], [82, 84, -40], [82, 85, -30], [82, 86, -55], [82, 87, -35], [82, 89, -35], [84, 65, -90], [84, 79, -18], [84, 233, -18], [84, 97, -92], [84, 58, -74], [84, 44, -74], [84, 101, -92], [84, 45, -92], [84, 105, -18], [84, 111, -92], [84, 249, -92], [84, 46, -90], [84, 114, -74], [84, 59, -74], [84, 117, -92], [84, 119, -74], [84, 121, -34], [85, 65, -60], [85, 44, -50], [85, 46, -50], [86, 65, -135], [86, 71, -30], [86, 79, -45], [86, 233, -45], [86, 97, -92], [86, 58, -92], [86, 44, -129], [86, 101, -100], [86, 45, -74], [86, 105, -37], [86, 111, -100], [86, 249, -100], [86, 46, -145], [86, 59, -92], [86, 117, -92], [87, 65, -120], [87, 79, -10], [87, 233, -10], [87, 97, -65], [87, 58, -55], [87, 44, -92], [87, 101, -65], [87, 45, -37], [87, 105, -18], [87, 111, -75], [87, 249, -75], [87, 46, -92], [87, 59, -55], [87, 117, -50], [87, 121, -60], [89, 65, -110], [89, 79, -35], [89, 233, -35], [89, 97, -85], [89, 58, -92], [89, 44, -92], [89, 101, -111], [89, 45, -92], [89, 105, -37], [89, 111, -111], [89, 249, -111], [89, 46, -92], [89, 59, -92], [89, 117, -92], [97, 118, -25], [98, 98, -10], [98, 46, -40], [98, 117, -20], [98, 118, -15], [44, 186, -45], [44, 39, -55], [100, 119, -15], [101, 118, -15], [102, 44, -15], [102, 245, -35], [102, 105, -25], [102, 111, -25], [102, 249, -25], [102, 46, -15], [102, 186, 50], [102, 39, 55], [103, 46, -15], [104, 121, -15], [105, 118, -10], [107, 101, -10], [107, 111, -15], [107, 249, -15], [107, 121, -15], [110, 118, -40], [111, 118, -10], [111, 119, -10], [249, 118, -10], [249, 119, -10], [46, 186, -55], [46, 39, -55], [170, 65, -10], [96, 65, -10], [96, 96, -63], [39, 100, -20], [39, 39, -63], [39, 114, -20], [39, 115, -37], [39, 32, -74], [39, 118, -20], [114, 99, -18], [114, 44, -92], [114, 101, -18], [114, 103, -10], [114, 45, -37], [114, 110, -15], [114, 111, -18], [114, 249, -18], [114, 112, -10], [114, 46, -100], [114, 113, -18], [114, 118, -10], [32, 65, -55], [32, 84, -30], [32, 86, -45], [32, 87, -30], [32, 89, -55], [118, 97, -10], [118, 44, -55], [118, 101, -10], [118, 111, -10], [118, 249, -10], [118, 46, -70], [119, 44, -55], [119, 111, -10], [119, 249, -10], [119, 46, -70], [121, 44, -55], [121, 101, -10], [121, 111, -25], [121, 249, -25], [121, 46, -70]] },
    "Courier": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: "Courier", fontWeight: "Medium", italicAngle: 0, fontBBox: [-23, -250, 715, 805], capHeight: 562, xHeight: 426, ascent: 629, descent: -157, stemH: 51, stemV: 51, flag: 35, kernings: [] },
    "Helvetica-BoldOblique": { widths: [278, 333, 474, 556, 556, 889, 722, 278, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 278, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 167, 556, 556, 556, 556, 238, 500, 556, 333, 333, 611, 611, 556, 556, 556, 278, 556, 350, 278, 500, 500, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 611, 778, 1000, 365, 889, 278, 278, 611, 944, 611, 278, 556, 556, 611, 556, 667, 584, 667, 722, 556, 722, 556, 556, 556, 722, 722, 556, 722, 611, 667, 722, 250, 737, 667, 556, 556, 722, 278, 556, 611, 722, 556, 667, 556, 556, 278, 494, 722, 778, 611, 556, 722, 389, 556, 611, 667, 778, 722, 667, 743, 722, 611, 333, 778, 722, 722, 584, 611, 611, 494, 556, 722, 278, 667, 556, 556, 556, 611, 611, 722, 278, 584, 280, 737, 778, 278, 600, 667, 389, 611, 611, 611, 549, 722, 722, 278, 389, 556, 722, 722, 722, 556, 500, 278, 778, 611, 556, 556, 278, 778, 722, 612, 611, 333, 778, 611, 278, 611, 667, 611, 834, 667, 400, 722, 611, 1000, 556, 278, 278, 611, 834, 549, 611, 611, 722, 667, 556, 611, 834, 667, 667, 778, 400, 611, 722, 611, 549, 722, 389, 722, 611, 722, 611, 722, 722, 722, 778, 500, 667, 278, 556, 584, 278, 611, 333, 584, 611, 611, 549, 611, 611, 500, 611, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: "Helvetica", fontWeight: "Bold", italicAngle: -12, fontBBox: [-174, -228, 1114, 962], capHeight: 718, xHeight: 532, ascent: 718, descent: -207, stemH: 118, stemV: 140, flag: 32, kernings: [[65, 67, -40], [65, 71, -50], [65, 79, -40], [65, 233, -40], [65, 81, -40], [65, 84, -90], [65, 85, -50], [65, 86, -80], [65, 87, -60], [65, 89, -110], [65, 117, -30], [65, 118, -40], [65, 119, -30], [65, 121, -30], [66, 65, -30], [66, 85, -10], [68, 65, -40], [68, 86, -40], [68, 87, -40], [68, 89, -70], [68, 44, -30], [68, 46, -30], [70, 65, -80], [70, 97, -20], [70, 44, -100], [70, 46, -100], [74, 65, -20], [74, 44, -20], [74, 46, -20], [74, 117, -20], [75, 79, -30], [75, 233, -30], [75, 101, -15], [75, 111, -35], [75, 249, -35], [75, 117, -30], [75, 121, -40], [76, 84, -90], [76, 86, -110], [76, 87, -80], [76, 89, -120], [76, 186, -140], [76, 39, -140], [76, 121, -30], [232, 84, -90], [232, 86, -110], [232, 87, -80], [232, 89, -120], [232, 186, -140], [232, 39, -140], [232, 121, -30], [79, 65, -50], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -50], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -50], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -50], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -100], [80, 97, -30], [80, 44, -120], [80, 101, -30], [80, 111, -40], [80, 249, -40], [80, 46, -120], [81, 85, -10], [81, 44, 20], [81, 46, 20], [82, 79, -20], [82, 233, -20], [82, 84, -20], [82, 85, -20], [82, 86, -50], [82, 87, -40], [82, 89, -50], [84, 65, -90], [84, 79, -40], [84, 233, -40], [84, 97, -80], [84, 58, -40], [84, 44, -80], [84, 101, -60], [84, 45, -120], [84, 111, -80], [84, 249, -80], [84, 46, -80], [84, 114, -80], [84, 59, -40], [84, 117, -90], [84, 119, -60], [84, 121, -60], [85, 65, -50], [85, 44, -30], [85, 46, -30], [86, 65, -80], [86, 71, -50], [86, 79, -50], [86, 233, -50], [86, 97, -60], [86, 58, -40], [86, 44, -120], [86, 101, -50], [86, 45, -80], [86, 111, -90], [86, 249, -90], [86, 46, -120], [86, 59, -40], [86, 117, -60], [87, 65, -60], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 58, -10], [87, 44, -80], [87, 101, -35], [87, 45, -40], [87, 111, -60], [87, 249, -60], [87, 46, -80], [87, 59, -10], [87, 117, -45], [87, 121, -20], [89, 65, -110], [89, 79, -70], [89, 233, -70], [89, 97, -90], [89, 58, -50], [89, 44, -100], [89, 101, -80], [89, 111, -100], [89, 249, -100], [89, 46, -100], [89, 59, -50], [89, 117, -100], [97, 103, -10], [97, 118, -15], [97, 119, -15], [97, 121, -20], [98, 108, -10], [98, 248, -10], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 104, -10], [99, 107, -20], [99, 108, -20], [99, 248, -20], [99, 121, -10], [58, 32, -40], [44, 186, -120], [44, 39, -120], [44, 32, -40], [100, 100, -10], [100, 118, -15], [100, 119, -15], [100, 121, -15], [101, 44, 10], [101, 46, 20], [101, 118, -15], [101, 119, -15], [101, 120, -15], [101, 121, -15], [102, 44, -10], [102, 101, -10], [102, 111, -20], [102, 249, -20], [102, 46, -10], [102, 186, 30], [102, 39, 30], [103, 101, 10], [103, 103, -10], [104, 121, -20], [107, 111, -15], [107, 249, -15], [108, 119, -15], [108, 121, -15], [248, 119, -15], [248, 121, -15], [109, 117, -20], [109, 121, -30], [110, 117, -10], [110, 118, -40], [110, 121, -20], [111, 118, -20], [111, 119, -15], [111, 120, -30], [111, 121, -20], [249, 118, -20], [249, 119, -15], [249, 120, -30], [249, 121, -20], [112, 121, -15], [46, 186, -120], [46, 39, -120], [46, 32, -40], [186, 32, -80], [96, 96, -46], [39, 100, -80], [39, 108, -20], [39, 248, -20], [39, 39, -46], [39, 114, -40], [39, 115, -60], [39, 32, -80], [39, 118, -20], [114, 99, -20], [114, 44, -60], [114, 100, -20], [114, 103, -15], [114, 45, -20], [114, 111, -20], [114, 249, -20], [114, 46, -60], [114, 113, -20], [114, 115, -15], [114, 116, 20], [114, 118, 10], [114, 121, 10], [115, 119, -15], [59, 32, -40], [32, 84, -100], [32, 86, -80], [32, 87, -80], [32, 89, -120], [32, 170, -80], [32, 96, -60], [118, 97, -20], [118, 44, -80], [118, 111, -30], [118, 249, -30], [118, 46, -80], [119, 44, -40], [119, 111, -20], [119, 249, -20], [119, 46, -40], [120, 101, -10], [121, 97, -30], [121, 44, -80], [121, 101, -10], [121, 111, -25], [121, 249, -25], [121, 46, -80], [122, 101, 10]] },
    "Helvetica-Bold": { widths: [278, 333, 474, 556, 556, 889, 722, 278, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 278, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 167, 556, 556, 556, 556, 238, 500, 556, 333, 333, 611, 611, 556, 556, 556, 278, 556, 350, 278, 500, 500, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 611, 778, 1000, 365, 889, 278, 278, 611, 944, 611, 278, 556, 556, 611, 556, 667, 584, 667, 722, 556, 722, 556, 556, 556, 722, 722, 556, 722, 611, 667, 722, 250, 737, 667, 556, 556, 722, 278, 556, 611, 722, 556, 667, 556, 556, 278, 494, 722, 778, 611, 556, 722, 389, 556, 611, 667, 778, 722, 667, 743, 722, 611, 333, 778, 722, 722, 584, 611, 611, 494, 556, 722, 278, 667, 556, 556, 556, 611, 611, 722, 278, 584, 280, 737, 778, 278, 600, 667, 389, 611, 611, 611, 549, 722, 722, 278, 389, 556, 722, 722, 722, 556, 500, 278, 778, 611, 556, 556, 278, 778, 722, 612, 611, 333, 778, 611, 278, 611, 667, 611, 834, 667, 400, 722, 611, 1000, 556, 278, 278, 611, 834, 549, 611, 611, 722, 667, 556, 611, 834, 667, 667, 778, 400, 611, 722, 611, 549, 722, 389, 722, 611, 722, 611, 722, 722, 722, 778, 500, 667, 278, 556, 584, 278, 611, 333, 584, 611, 611, 549, 611, 611, 500, 611, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: "Helvetica", fontWeight: "Bold", italicAngle: 0, fontBBox: [-170, -228, 1003, 962], capHeight: 718, xHeight: 532, ascent: 718, descent: -207, stemH: 118, stemV: 140, flag: 32, kernings: [[65, 67, -40], [65, 71, -50], [65, 79, -40], [65, 233, -40], [65, 81, -40], [65, 84, -90], [65, 85, -50], [65, 86, -80], [65, 87, -60], [65, 89, -110], [65, 117, -30], [65, 118, -40], [65, 119, -30], [65, 121, -30], [66, 65, -30], [66, 85, -10], [68, 65, -40], [68, 86, -40], [68, 87, -40], [68, 89, -70], [68, 44, -30], [68, 46, -30], [70, 65, -80], [70, 97, -20], [70, 44, -100], [70, 46, -100], [74, 65, -20], [74, 44, -20], [74, 46, -20], [74, 117, -20], [75, 79, -30], [75, 233, -30], [75, 101, -15], [75, 111, -35], [75, 249, -35], [75, 117, -30], [75, 121, -40], [76, 84, -90], [76, 86, -110], [76, 87, -80], [76, 89, -120], [76, 186, -140], [76, 39, -140], [76, 121, -30], [232, 84, -90], [232, 86, -110], [232, 87, -80], [232, 89, -120], [232, 186, -140], [232, 39, -140], [232, 121, -30], [79, 65, -50], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -50], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -50], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -50], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -100], [80, 97, -30], [80, 44, -120], [80, 101, -30], [80, 111, -40], [80, 249, -40], [80, 46, -120], [81, 85, -10], [81, 44, 20], [81, 46, 20], [82, 79, -20], [82, 233, -20], [82, 84, -20], [82, 85, -20], [82, 86, -50], [82, 87, -40], [82, 89, -50], [84, 65, -90], [84, 79, -40], [84, 233, -40], [84, 97, -80], [84, 58, -40], [84, 44, -80], [84, 101, -60], [84, 45, -120], [84, 111, -80], [84, 249, -80], [84, 46, -80], [84, 114, -80], [84, 59, -40], [84, 117, -90], [84, 119, -60], [84, 121, -60], [85, 65, -50], [85, 44, -30], [85, 46, -30], [86, 65, -80], [86, 71, -50], [86, 79, -50], [86, 233, -50], [86, 97, -60], [86, 58, -40], [86, 44, -120], [86, 101, -50], [86, 45, -80], [86, 111, -90], [86, 249, -90], [86, 46, -120], [86, 59, -40], [86, 117, -60], [87, 65, -60], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 58, -10], [87, 44, -80], [87, 101, -35], [87, 45, -40], [87, 111, -60], [87, 249, -60], [87, 46, -80], [87, 59, -10], [87, 117, -45], [87, 121, -20], [89, 65, -110], [89, 79, -70], [89, 233, -70], [89, 97, -90], [89, 58, -50], [89, 44, -100], [89, 101, -80], [89, 111, -100], [89, 249, -100], [89, 46, -100], [89, 59, -50], [89, 117, -100], [97, 103, -10], [97, 118, -15], [97, 119, -15], [97, 121, -20], [98, 108, -10], [98, 248, -10], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 104, -10], [99, 107, -20], [99, 108, -20], [99, 248, -20], [99, 121, -10], [58, 32, -40], [44, 186, -120], [44, 39, -120], [44, 32, -40], [100, 100, -10], [100, 118, -15], [100, 119, -15], [100, 121, -15], [101, 44, 10], [101, 46, 20], [101, 118, -15], [101, 119, -15], [101, 120, -15], [101, 121, -15], [102, 44, -10], [102, 101, -10], [102, 111, -20], [102, 249, -20], [102, 46, -10], [102, 186, 30], [102, 39, 30], [103, 101, 10], [103, 103, -10], [104, 121, -20], [107, 111, -15], [107, 249, -15], [108, 119, -15], [108, 121, -15], [248, 119, -15], [248, 121, -15], [109, 117, -20], [109, 121, -30], [110, 117, -10], [110, 118, -40], [110, 121, -20], [111, 118, -20], [111, 119, -15], [111, 120, -30], [111, 121, -20], [249, 118, -20], [249, 119, -15], [249, 120, -30], [249, 121, -20], [112, 121, -15], [46, 186, -120], [46, 39, -120], [46, 32, -40], [186, 32, -80], [96, 96, -46], [39, 100, -80], [39, 108, -20], [39, 248, -20], [39, 39, -46], [39, 114, -40], [39, 115, -60], [39, 32, -80], [39, 118, -20], [114, 99, -20], [114, 44, -60], [114, 100, -20], [114, 103, -15], [114, 45, -20], [114, 111, -20], [114, 249, -20], [114, 46, -60], [114, 113, -20], [114, 115, -15], [114, 116, 20], [114, 118, 10], [114, 121, 10], [115, 119, -15], [59, 32, -40], [32, 84, -100], [32, 86, -80], [32, 87, -80], [32, 89, -120], [32, 170, -80], [32, 96, -60], [118, 97, -20], [118, 44, -80], [118, 111, -30], [118, 249, -30], [118, 46, -80], [119, 44, -40], [119, 111, -20], [119, 249, -20], [119, 46, -40], [120, 101, -10], [121, 97, -30], [121, 44, -80], [121, 101, -10], [121, 111, -25], [121, 249, -25], [121, 46, -80], [122, 101, 10]] },
    "Times-Italic": { widths: [250, 333, 420, 500, 500, 833, 778, 333, 333, 333, 500, 675, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 675, 675, 675, 500, 920, 611, 611, 667, 722, 611, 611, 722, 722, 333, 444, 667, 556, 833, 667, 722, 611, 722, 611, 500, 556, 722, 611, 833, 611, 556, 556, 389, 278, 389, 422, 500, 333, 500, 500, 444, 500, 444, 278, 500, 500, 278, 278, 444, 278, 722, 500, 500, 500, 500, 389, 389, 278, 500, 444, 667, 444, 444, 389, 400, 275, 400, 541, 389, 500, 500, 167, 500, 500, 500, 500, 214, 556, 500, 333, 333, 500, 500, 500, 500, 500, 250, 523, 350, 333, 556, 556, 500, 889, 1000, 500, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 889, 889, 276, 556, 722, 944, 310, 667, 278, 278, 500, 667, 500, 333, 444, 500, 500, 444, 556, 675, 556, 611, 500, 722, 444, 389, 444, 722, 722, 500, 722, 500, 611, 722, 250, 760, 611, 444, 500, 667, 278, 500, 556, 667, 500, 611, 389, 389, 278, 471, 611, 722, 500, 500, 611, 389, 444, 556, 611, 722, 611, 500, 544, 722, 500, 300, 722, 611, 611, 675, 500, 556, 476, 444, 667, 278, 611, 500, 444, 444, 500, 500, 667, 333, 675, 275, 760, 722, 333, 600, 611, 389, 500, 556, 556, 549, 722, 667, 278, 300, 444, 722, 611, 611, 444, 389, 278, 722, 500, 500, 389, 278, 722, 722, 612, 500, 300, 722, 500, 278, 500, 611, 500, 750, 500, 300, 667, 556, 980, 444, 333, 333, 611, 750, 549, 500, 500, 722, 611, 444, 500, 750, 500, 500, 722, 400, 500, 667, 500, 453, 722, 389, 667, 500, 611, 556, 611, 611, 611, 722, 389, 611, 333, 444, 675, 333, 500, 278, 675, 500, 500, 549, 500, 500, 389, 500, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: "Times", fontWeight: "Medium", italicAngle: -15.5, fontBBox: [-169, -217, 1010, 883], capHeight: 653, xHeight: 441, ascent: 683, descent: -217, stemH: 32, stemV: 76, flag: 34, kernings: [[65, 67, -30], [65, 71, -35], [65, 79, -40], [65, 233, -40], [65, 81, -40], [65, 84, -37], [65, 85, -50], [65, 86, -105], [65, 87, -95], [65, 89, -55], [65, 39, -37], [65, 117, -20], [65, 118, -55], [65, 119, -55], [65, 121, -55], [66, 65, -25], [66, 85, -10], [68, 65, -35], [68, 86, -40], [68, 87, -40], [68, 89, -40], [70, 65, -115], [70, 97, -75], [70, 44, -135], [70, 101, -75], [70, 105, -45], [70, 111, -105], [70, 249, -105], [70, 46, -135], [70, 114, -55], [74, 65, -40], [74, 97, -35], [74, 44, -25], [74, 101, -25], [74, 111, -25], [74, 249, -25], [74, 46, -25], [74, 117, -35], [75, 79, -50], [75, 233, -50], [75, 101, -35], [75, 111, -40], [75, 249, -40], [75, 117, -40], [75, 121, -40], [76, 84, -20], [76, 86, -55], [76, 87, -55], [76, 89, -20], [76, 39, -37], [76, 121, -30], [232, 84, -20], [232, 86, -55], [232, 87, -55], [232, 89, -20], [232, 39, -37], [232, 121, -30], [78, 65, -27], [79, 65, -55], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -40], [79, 89, -50], [233, 65, -55], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -40], [233, 89, -50], [80, 65, -90], [80, 97, -80], [80, 44, -135], [80, 101, -80], [80, 111, -80], [80, 249, -80], [80, 46, -135], [81, 85, -10], [82, 79, -40], [82, 233, -40], [82, 85, -40], [82, 86, -18], [82, 87, -18], [82, 89, -18], [84, 65, -50], [84, 79, -18], [84, 233, -18], [84, 97, -92], [84, 58, -55], [84, 44, -74], [84, 101, -92], [84, 45, -74], [84, 105, -55], [84, 111, -92], [84, 249, -92], [84, 46, -74], [84, 114, -55], [84, 59, -65], [84, 117, -55], [84, 119, -74], [84, 121, -74], [85, 65, -40], [85, 44, -25], [85, 46, -25], [86, 65, -60], [86, 79, -30], [86, 233, -30], [86, 97, -111], [86, 58, -65], [86, 44, -129], [86, 101, -111], [86, 45, -55], [86, 105, -74], [86, 111, -111], [86, 249, -111], [86, 46, -129], [86, 59, -74], [86, 117, -74], [87, 65, -60], [87, 79, -25], [87, 233, -25], [87, 97, -92], [87, 58, -65], [87, 44, -92], [87, 101, -92], [87, 45, -37], [87, 105, -55], [87, 111, -92], [87, 249, -92], [87, 46, -92], [87, 59, -65], [87, 117, -55], [87, 121, -70], [89, 65, -50], [89, 79, -15], [89, 233, -15], [89, 97, -92], [89, 58, -65], [89, 44, -92], [89, 101, -92], [89, 45, -74], [89, 105, -74], [89, 111, -92], [89, 249, -92], [89, 46, -92], [89, 59, -65], [89, 117, -92], [97, 103, -10], [98, 46, -40], [98, 117, -20], [99, 104, -15], [99, 107, -20], [44, 186, -140], [44, 39, -140], [101, 44, -10], [101, 103, -40], [101, 46, -15], [101, 118, -15], [101, 119, -15], [101, 120, -20], [101, 121, -30], [102, 44, -10], [102, 245, -60], [102, 102, -18], [102, 105, -20], [102, 46, -15], [102, 39, 92], [103, 44, -10], [103, 101, -10], [103, 103, -10], [103, 46, -15], [107, 101, -10], [107, 111, -10], [107, 249, -10], [107, 121, -10], [110, 118, -40], [111, 103, -10], [111, 118, -10], [249, 103, -10], [249, 118, -10], [46, 186, -140], [46, 39, -140], [96, 96, -111], [39, 100, -25], [39, 39, -111], [39, 114, -25], [39, 115, -40], [39, 32, -111], [39, 116, -30], [39, 118, -10], [114, 97, -15], [114, 99, -37], [114, 44, -111], [114, 100, -37], [114, 101, -37], [114, 103, -37], [114, 45, -20], [114, 111, -45], [114, 249, -45], [114, 46, -111], [114, 113, -37], [114, 115, -10], [32, 65, -18], [32, 84, -18], [32, 86, -35], [32, 87, -40], [32, 89, -75], [118, 44, -74], [118, 46, -74], [119, 44, -74], [119, 46, -74], [121, 44, -55], [121, 46, -55]] },
    "Symbol": { widths: [250, 333, 713, 500, 549, 833, 778, 439, 333, 333, 500, 549, 250, 549, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 549, 549, 549, 444, 549, 722, 667, 722, 612, 611, 763, 603, 722, 333, 631, 722, 686, 889, 722, 722, 768, 741, 556, 592, 611, 690, 439, 768, 645, 795, 611, 333, 863, 333, 658, 500, 500, 631, 549, 549, 494, 439, 521, 411, 603, 329, 603, 549, 549, 576, 521, 549, 549, 521, 549, 603, 439, 576, 713, 686, 493, 686, 494, 480, 200, 480, 549, 750, 620, 247, 549, 167, 713, 500, 753, 753, 753, 753, 1042, 987, 603, 987, 603, 400, 549, 411, 549, 549, 713, 494, 460, 549, 549, 549, 549, 1000, 603, 1000, 658, 823, 686, 795, 987, 768, 768, 823, 768, 768, 713, 713, 713, 713, 713, 713, 713, 768, 713, 790, 790, 890, 823, 549, 250, 713, 603, 603, 1042, 987, 603, 987, 603, 494, 329, 790, 790, 786, 713, 384, 384, 384, 384, 384, 384, 494, 494, 494, 494, 329, 274, 686, 686, 686, 384, 384, 384, 384, 384, 384, 494, 494, 494, 790], firstChar: 32, lastChar: 254, familyName: "Symbol", fontWeight: "Medium", italicAngle: 0, fontBBox: [-180, -293, 1090, 1010], stemH: 92, stemV: 85, flag: 4, kernings: [] },
    "Courier-Bold": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: "Courier", fontWeight: "Bold", italicAngle: 0, fontBBox: [-113, -250, 749, 801], capHeight: 562, xHeight: 439, ascent: 629, descent: -157, stemH: 84, stemV: 106, flag: 35, kernings: [] },
    "Helvetica-Oblique": { widths: [278, 278, 355, 556, 556, 889, 667, 222, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 222, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 167, 556, 556, 556, 556, 191, 333, 556, 333, 333, 500, 500, 556, 556, 556, 278, 537, 350, 222, 333, 333, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 556, 778, 1000, 365, 889, 278, 222, 611, 944, 611, 278, 556, 556, 556, 556, 667, 584, 667, 667, 556, 722, 500, 500, 556, 722, 722, 556, 722, 556, 667, 722, 250, 737, 667, 500, 556, 722, 222, 556, 611, 722, 556, 667, 500, 500, 278, 471, 722, 778, 556, 556, 667, 333, 500, 611, 667, 778, 722, 667, 643, 722, 556, 333, 778, 667, 667, 584, 556, 611, 476, 500, 722, 278, 667, 556, 556, 500, 556, 556, 722, 278, 584, 260, 737, 778, 278, 600, 667, 333, 556, 611, 611, 549, 722, 722, 222, 317, 556, 722, 667, 667, 556, 500, 222, 778, 556, 556, 500, 278, 778, 722, 612, 556, 333, 778, 556, 278, 556, 667, 556, 834, 667, 299, 667, 556, 1000, 556, 278, 278, 556, 834, 549, 556, 556, 722, 667, 556, 556, 834, 667, 667, 778, 400, 556, 722, 556, 453, 722, 333, 722, 556, 722, 556, 667, 667, 667, 778, 500, 667, 278, 500, 584, 278, 556, 278, 584, 556, 556, 549, 556, 556, 500, 556, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: "Helvetica", fontWeight: "Medium", italicAngle: -12, fontBBox: [-170, -225, 1116, 931], capHeight: 718, xHeight: 523, ascent: 718, descent: -207, stemH: 76, stemV: 88, flag: 32, kernings: [[65, 67, -30], [65, 71, -30], [65, 79, -30], [65, 233, -30], [65, 81, -30], [65, 84, -120], [65, 85, -50], [65, 86, -70], [65, 87, -50], [65, 89, -100], [65, 117, -30], [65, 118, -40], [65, 119, -40], [65, 121, -40], [66, 85, -10], [66, 44, -20], [66, 46, -20], [67, 44, -30], [67, 46, -30], [68, 65, -40], [68, 86, -70], [68, 87, -40], [68, 89, -90], [68, 44, -70], [68, 46, -70], [70, 65, -80], [70, 97, -50], [70, 44, -150], [70, 101, -30], [70, 111, -30], [70, 249, -30], [70, 46, -150], [70, 114, -45], [74, 65, -20], [74, 97, -20], [74, 44, -30], [74, 46, -30], [74, 117, -20], [75, 79, -50], [75, 233, -50], [75, 101, -40], [75, 111, -40], [75, 249, -40], [75, 117, -30], [75, 121, -50], [76, 84, -110], [76, 86, -110], [76, 87, -70], [76, 89, -140], [76, 186, -140], [76, 39, -160], [76, 121, -30], [232, 84, -110], [232, 86, -110], [232, 87, -70], [232, 89, -140], [232, 186, -140], [232, 39, -160], [232, 121, -30], [79, 65, -20], [79, 84, -40], [79, 86, -50], [79, 87, -30], [79, 88, -60], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -20], [233, 84, -40], [233, 86, -50], [233, 87, -30], [233, 88, -60], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -120], [80, 97, -40], [80, 44, -180], [80, 101, -50], [80, 111, -50], [80, 249, -50], [80, 46, -180], [81, 85, -10], [82, 79, -20], [82, 233, -20], [82, 84, -30], [82, 85, -40], [82, 86, -50], [82, 87, -30], [82, 89, -50], [83, 44, -20], [83, 46, -20], [84, 65, -120], [84, 79, -40], [84, 233, -40], [84, 97, -120], [84, 58, -20], [84, 44, -120], [84, 101, -120], [84, 45, -140], [84, 111, -120], [84, 249, -120], [84, 46, -120], [84, 114, -120], [84, 59, -20], [84, 117, -120], [84, 119, -120], [84, 121, -120], [85, 65, -40], [85, 44, -40], [85, 46, -40], [86, 65, -80], [86, 71, -40], [86, 79, -40], [86, 233, -40], [86, 97, -70], [86, 58, -40], [86, 44, -125], [86, 101, -80], [86, 45, -80], [86, 111, -80], [86, 249, -80], [86, 46, -125], [86, 59, -40], [86, 117, -70], [87, 65, -50], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 44, -80], [87, 101, -30], [87, 45, -40], [87, 111, -30], [87, 249, -30], [87, 46, -80], [87, 117, -30], [87, 121, -20], [89, 65, -110], [89, 79, -85], [89, 233, -85], [89, 97, -140], [89, 58, -60], [89, 44, -140], [89, 101, -140], [89, 45, -140], [89, 105, -20], [89, 111, -140], [89, 249, -140], [89, 46, -140], [89, 59, -60], [89, 117, -110], [97, 118, -20], [97, 119, -20], [97, 121, -30], [98, 98, -10], [98, 44, -40], [98, 108, -20], [98, 248, -20], [98, 46, -40], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 44, -15], [99, 107, -20], [58, 32, -50], [44, 186, -100], [44, 39, -100], [101, 44, -15], [101, 46, -15], [101, 118, -30], [101, 119, -20], [101, 120, -30], [101, 121, -20], [102, 97, -30], [102, 44, -30], [102, 245, -28], [102, 101, -30], [102, 111, -30], [102, 249, -30], [102, 46, -30], [102, 186, 60], [102, 39, 50], [103, 114, -10], [104, 121, -30], [107, 101, -20], [107, 111, -20], [107, 249, -20], [109, 117, -10], [109, 121, -15], [110, 117, -10], [110, 118, -20], [110, 121, -15], [111, 44, -40], [111, 46, -40], [111, 118, -15], [111, 119, -15], [111, 120, -30], [111, 121, -30], [249, 97, -55], [249, 98, -55], [249, 99, -55], [249, 44, -95], [249, 100, -55], [249, 101, -55], [249, 102, -55], [249, 103, -55], [249, 104, -55], [249, 105, -55], [249, 106, -55], [249, 107, -55], [249, 108, -55], [249, 248, -55], [249, 109, -55], [249, 110, -55], [249, 111, -55], [249, 249, -55], [249, 112, -55], [249, 46, -95], [249, 113, -55], [249, 114, -55], [249, 115, -55], [249, 116, -55], [249, 117, -55], [249, 118, -70], [249, 119, -70], [249, 120, -85], [249, 121, -70], [249, 122, -55], [112, 44, -35], [112, 46, -35], [112, 121, -30], [46, 186, -100], [46, 39, -100], [46, 32, -60], [186, 32, -40], [96, 96, -57], [39, 100, -50], [39, 39, -57], [39, 114, -50], [39, 115, -50], [39, 32, -70], [114, 97, -10], [114, 58, 30], [114, 44, -50], [114, 105, 15], [114, 107, 15], [114, 108, 15], [114, 248, 15], [114, 109, 25], [114, 110, 25], [114, 112, 30], [114, 46, -50], [114, 59, 30], [114, 116, 40], [114, 117, 15], [114, 118, 30], [114, 121, 30], [115, 44, -15], [115, 46, -15], [115, 119, -30], [59, 32, -50], [32, 84, -50], [32, 86, -50], [32, 87, -40], [32, 89, -90], [32, 170, -30], [32, 96, -60], [118, 97, -25], [118, 44, -80], [118, 101, -25], [118, 111, -25], [118, 249, -25], [118, 46, -80], [119, 97, -15], [119, 44, -60], [119, 101, -10], [119, 111, -10], [119, 249, -10], [119, 46, -60], [120, 101, -30], [121, 97, -20], [121, 44, -100], [121, 101, -20], [121, 111, -20], [121, 249, -20], [121, 46, -100], [122, 101, -15], [122, 111, -15], [122, 249, -15]] }
};


/***/ }),

/***/ "./src/annotate/fonts.ts":
/*!*******************************!*\
  !*** ./src/annotate/fonts.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.FontManager = exports.Font = exports.FontType = void 0;
var font_data_1 = __webpack_require__(/*! ./font-data */ "./src/annotate/font-data.ts");
var writer_util_1 = __webpack_require__(/*! ./writer-util */ "./src/annotate/writer-util.ts");
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var FontType;
(function (FontType) {
    FontType[FontType["Type0"] = 0] = "Type0";
    FontType[FontType["Type1"] = 1] = "Type1";
    FontType[FontType["Type3"] = 2] = "Type3";
    FontType[FontType["MMType1"] = 3] = "MMType1";
    FontType[FontType["TrueType"] = 4] = "TrueType";
    FontType[FontType["CIDFontType0"] = 5] = "CIDFontType0";
    FontType[FontType["CIDFontType2"] = 6] = "CIDFontType2";
})(FontType = exports.FontType || (exports.FontType = {}));
var Font = /** @class */ (function () {
    function Font(fontType, name, baseFont) {
        if (fontType === void 0) { fontType = undefined; }
        if (name === void 0) { name = undefined; }
        if (baseFont === void 0) { baseFont = undefined; }
        this.object_id = undefined;
        /**
         * Determines if the font must be written to the PDF document, since it is not yet defined
         * */
        this.is_new = false;
        this.fontType = undefined;
        this.name = undefined;
        this.baseFont = undefined;
        this.firstChar = undefined;
        this.lastChar = undefined;
        this.widths = undefined;
        this.fontDescriptor = undefined;
        this.encoding = undefined;
        this.kernings = undefined;
        this.fontType = fontType;
        this.name = name;
        this.baseFont = baseFont;
        if (this.name && !this.name.startsWith("/")) {
            this.name = "/".concat(this.name);
        }
        if (this.baseFont && !this.baseFont.startsWith("/")) {
            this.baseFont = "/".concat(this.baseFont);
        }
        if (this.baseFont && Font.isStandardFont(this.baseFont)) {
            this.populateStandardFontData(this.baseFont);
            if (!this.widths) {
                throw Error("No widths found for standard font \"".concat(this.baseFont, "\""));
            }
        }
    }
    /**
     * Calculates the dimensions of the text using this font
     *
     * It also proposes linebreak positions for the provided width
     * */
    Font.prototype.proposeLinebreaks = function (text, fontSize, width) {
        if (!this.widths) {
            return [];
        }
        if (!this.firstChar) {
            this.firstChar = 0;
        }
        var ascii = this.getTextWidthArray(text, fontSize);
        var positions = [];
        var line_width = 0, last_space = -1, last_pos = 0;
        for (var l = 0; l < ascii.length; ++l) {
            if (text.charAt(l) === " ") {
                last_space = l;
            }
            if (line_width + ascii[l] > width) {
                // backtrack to last space in the same line and move remainder in the next line
                if (last_space !== -1) {
                    positions.push({ start: last_pos, end: last_space - 1, width: ascii.slice(last_pos, last_space).reduce(function (x, y) { return x + y; }, 0) });
                    l = last_space + 1;
                    last_pos = l;
                    last_space = -1;
                }
                else { // if no such last space is in the line return line_width - last letter width
                    positions.push({ start: last_pos, end: l - 1, width: ascii.slice(last_pos, l).reduce(function (x, y) { return x + y; }, 0) });
                    last_pos = l;
                }
                line_width = 0;
            }
            line_width += ascii[l];
        }
        if (last_pos !== ascii.length) {
            positions.push({ start: last_pos, end: ascii.length - 1, width: ascii.slice(last_pos, ascii.length).reduce(function (x, y) { return x + y; }, 0) });
        }
        return positions;
    };
    /**
     * Calculates the dimensions of the text using this font
     *
     * Returns [width, height]
     * */
    Font.prototype.calculateTextDimensions = function (text, fontSize) {
        var widths = this.getTextWidthArray(text, fontSize);
        // calculate the sum of the widths array
        return [widths.reduce(function (pv, cv) { return pv + cv; }, 0), fontSize];
    };
    /**
     * Calculates the dimensions of the text using this font in mm
     *
     * Returns [width, height]
     * */
    Font.prototype.calculateTextDimensionsInMM = function (text, fontSize) {
        var values = this.calculateTextDimensions(text, fontSize);
        return [values[0] * 25.4 / 72, values[1]];
    };
    /**
     * Helper method to lookup the kerning value
     * */
    Font.prototype.getKerningValue = function (previousChar, currentChar) {
        if (!this.kernings)
            return 0;
        var list = this.kernings.get(previousChar);
        if (!list)
            return 0;
        list = list.filter(function (x) { return x[0] === currentChar; });
        if (list.length === 1) {
            return list[0][1];
        }
        return 0;
    };
    /**
     * Returns the array of letter widths that are contained in the string
     * */
    Font.prototype.getTextWidthArray = function (text, fontSize) {
        if (!this.widths) {
            return [];
        }
        if (!this.firstChar) {
            this.firstChar = 0;
        }
        var ascii = util_1.Util.convertStringToAscii(text);
        var ret_val = [];
        var previous_char = -1;
        for (var _i = 0, ascii_1 = ascii; _i < ascii_1.length; _i++) {
            var letter = ascii_1[_i];
            var kerning_value = 0;
            if (previous_char != -1 && this.kernings) {
                kerning_value = this.getKerningValue(previous_char, letter);
            }
            ret_val.push((this.widths[letter - this.firstChar] + kerning_value) / 1000 * fontSize);
            previous_char = letter;
        }
        return ret_val;
    };
    /**
     * Returns the widths array of a standard font
     * */
    Font.prototype.populateStandardFontData = function (font_name) {
        if (font_name.startsWith("/")) {
            font_name = font_name.substring(1);
        }
        var key = Object.keys(font_data_1.STANDARD_FONT_DATA).filter(function (name) { return font_name.localeCompare(name) === 0; });
        if (!key || key.length === 0 || key.length > 1) {
            throw Error("No font widths for standard font ".concat(font_name));
        }
        var font_data = font_data_1.STANDARD_FONT_DATA[key[0]];
        if (!font_data) {
            throw Error("No font data for standard font ".concat(font_name));
        }
        this.widths = font_data.widths;
        this.firstChar = font_data.firstChar;
        this.lastChar = font_data.lastChar;
        this.fontDescriptor = {
            fontName: this.baseFont,
            fontFamily: font_data.familyName,
            fontWeight: font_data.fontWeight,
            italicAngle: font_data.italicAngle,
            fontBBox: font_data.fontBBox,
            capHeight: font_data.capHeight,
            xHeight: font_data.xHeight,
            ascent: font_data.ascent,
            descent: font_data.descent,
            stemH: font_data.stemH,
            stemV: font_data.stemV,
            flags: font_data.flag
        };
        // setup hash map that contains the kerning data
        if (font_data.kernings) {
            this.kernings = new Map();
            for (var _i = 0, _a = font_data.kernings; _i < _a.length; _i++) {
                var value = _a[_i];
                var _list = [];
                if (this.kernings.has(value[0])) {
                    _list = this.kernings.get(value[0]);
                }
                _list.push(value.slice(1));
                this.kernings.set(value[0], _list);
            }
        }
    };
    /**
     * Returns a standard font
     * fontName the name reference the font name
     * baseFont the standard font
     * */
    Font.createStandardFont = function (object_id, fontName, baseFont) {
        var font = new Font(FontType.Type1, fontName, baseFont);
        font.object_id = object_id;
        return font;
    };
    /**
     * True, if the name is a standard font name
     * */
    Font.isStandardFont = function (name) {
        if (name.startsWith("/")) {
            name = name.substring(1);
        }
        switch (name) {
            case "Times-Roman":
                return true;
            case "Times-Bold":
                return true;
            case "Times-Italic":
                return true;
            case "Times-BoldItalic":
                return true;
            case "Helvetica":
                return true;
            case "Helvetica-Bold":
                return true;
            case "Helvetica-Oblique":
                return true;
            case "Helvetica-BoldOblique":
                return true;
            case "Courier":
                return true;
            case "Courier-Oblique":
                return true;
            case "Courier-BoldOblique":
                return true;
            case "Courier-Bold":
                return true;
            case "Symbol":
                return true;
            case "ZapfDingbats":
                return true;
            default:
                return false;
        }
    };
    Font.prototype.typeToNumberArray = function (fontType) {
        switch (fontType) {
            case FontType.Type0:
                return writer_util_1.WriterUtil.TYPE0;
                break;
            case FontType.Type1:
                return writer_util_1.WriterUtil.TYPE1;
                break;
            case FontType.Type3:
                return writer_util_1.WriterUtil.TYPE3;
                break;
            case FontType.MMType1:
                return writer_util_1.WriterUtil.MMTYPE1;
                break;
            case FontType.TrueType:
                return writer_util_1.WriterUtil.TRUETYPE;
                break;
            case FontType.CIDFontType0:
                return writer_util_1.WriterUtil.CIDFONTTYPE0;
                break;
            case FontType.CIDFontType2:
                return writer_util_1.WriterUtil.CIDFONTTYPE2;
                break;
        }
        return [];
    };
    Font.prototype.writeFontDescriptor = function () {
        if (!this.fontDescriptor)
            return [];
        var ret = [];
        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.TYPE_FONTDESCRIPTOR);
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (this.baseFont) {
            ret = ret.concat(writer_util_1.WriterUtil.FONTNAME);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertStringToAscii(this.baseFont));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.fontFamily) {
            ret = ret.concat(writer_util_1.WriterUtil.FONTFAMILY);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertStringToByteString(this.fontDescriptor.fontFamily));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.fontStretch) {
            ret = ret.concat(writer_util_1.WriterUtil.FONTSTRETCH);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertStringToAscii(this.fontDescriptor.fontStretch));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.flags) {
            ret = ret.concat(writer_util_1.WriterUtil.FLAGS);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.flags));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.fontBBox) {
            ret = ret.concat(writer_util_1.WriterUtil.FONTBBOX);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.fontDescriptor.fontBBox));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.italicAngle) {
            ret = ret.concat(writer_util_1.WriterUtil.ITALICANGLE);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.italicAngle));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.ascent) {
            ret = ret.concat(writer_util_1.WriterUtil.ASCENT);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.ascent));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.descent) {
            ret = ret.concat(writer_util_1.WriterUtil.DESCENT);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.descent));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.leading) {
            ret = ret.concat(writer_util_1.WriterUtil.LEADING);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.leading));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.capHeight) {
            ret = ret.concat(writer_util_1.WriterUtil.CAPHEIGHT);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.capHeight));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.xHeight) {
            ret = ret.concat(writer_util_1.WriterUtil.XHEIGHT);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.xHeight));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.stemV) {
            ret = ret.concat(writer_util_1.WriterUtil.STEMV);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.stemV));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.stemH) {
            ret = ret.concat(writer_util_1.WriterUtil.STEMH);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.stemH));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.avgWidth) {
            ret = ret.concat(writer_util_1.WriterUtil.AVGWIDTH);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.avgWidth));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.maxWidth) {
            ret = ret.concat(writer_util_1.WriterUtil.MAXWIDTH);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.maxWidth));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor.missingWidth) {
            ret = ret.concat(writer_util_1.WriterUtil.MISSINGWIDTH);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.missingWidth));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);
        ret.push(writer_util_1.WriterUtil.SPACE);
        return ret;
    };
    Font.prototype.writeFont = function () {
        if (!this.object_id)
            throw Error("object_id of font not set");
        var ret = writer_util_1.WriterUtil.writeReferencePointer(this.object_id);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.OBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.TYPE_FONT);
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (!this.fontType) {
            throw Error("Font Type not set");
        }
        ret = ret.concat(writer_util_1.WriterUtil.SUBTYPE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(this.typeToNumberArray(this.fontType));
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (this.baseFont) {
            ret = ret.concat(writer_util_1.WriterUtil.BASEFONT);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertStringToAscii(this.baseFont));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.firstChar) {
            ret = ret.concat(writer_util_1.WriterUtil.FIRSTCHAR);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.firstChar));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.lastChar) {
            ret = ret.concat(writer_util_1.WriterUtil.LASTCHAR);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.lastChar));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.widths) {
            ret = ret.concat(writer_util_1.WriterUtil.WIDTHS);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.widths));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.fontDescriptor) {
            ret = ret.concat(writer_util_1.WriterUtil.FONTDESCRIPTOR);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(this.writeFontDescriptor());
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.encoding) {
            ret = ret.concat(writer_util_1.WriterUtil.ENCODING);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertStringToAscii(this.encoding));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        return ret;
    };
    return Font;
}());
exports.Font = Font;
var FontManager = /** @class */ (function () {
    function FontManager(parser) {
        this.parser = parser;
        /**
         * The fonts in the document
         * */
        this.fonts = [];
    }
    /**
     * Returns the font with the corresponding reference pointer or name or basefont
     *
     * If there is no such font it returns undefined
     * */
    FontManager.prototype.getFont = function (font) {
        for (var _i = 0, _a = this.fonts; _i < _a.length; _i++) {
            var f = _a[_i];
            if (typeof font === 'string') {
                if (f.name === font || f.baseFont === font)
                    return f;
            }
            else if (font instanceof Font) {
                if (font.object_id && f.object_id) {
                    if (f.object_id.obj === font.object_id.obj && f.object_id.generation === font.object_id.generation)
                        return f;
                }
                else if (font.name && f.name) {
                    if (f.name === font.name)
                        return f;
                }
                else if (font.baseFont && f.baseFont) {
                    if (f.baseFont === font.baseFont)
                        return f;
                }
            }
            else {
                if (f.object_id.obj === font.obj && f.object_id.generation === font.generation)
                    return f;
            }
        }
        return undefined;
    };
    /**
     * Adds a font, if it does not already exists.
     * */
    FontManager.prototype.addFont = function (font) {
        if (this.hasFont(font)) {
            return undefined;
        }
        if (typeof font === "string") {
            if (Font.isStandardFont(font)) {
                font = Font.createStandardFont(this.parser.getFreeObjectId(), this.getUnusedFontName(), font);
                font.is_new = true;
            }
        }
        if (!(font instanceof Font)) {
            throw Error('Could not add font');
        }
        this.fonts.push(font);
        return font;
    };
    /**
     * Returns a font name that is not used yet
     * */
    FontManager.prototype.getUnusedFontName = function () {
        var font_name = "/F".concat(this.fonts.length);
        var i = 1;
        while (this.hasFont(font_name)) {
            font_name = "/F".concat(this.fonts.length + i++);
        }
        return font_name;
    };
    /**
     * Retutrns true, if the font is already part of the font manager
     *
     * Font can be a Font object, a reference pointer of a font object a font name or a base font
     * */
    FontManager.prototype.hasFont = function (font_ptr) {
        if (font_ptr instanceof Font && font_ptr.object_id) {
            font_ptr = font_ptr.object_id;
        }
        else if (typeof font_ptr === "string") {
            return this.fonts.filter(function (f) { return f.name === font_ptr ||
                f.baseFont === font_ptr; }).length > 0;
        }
        return this.fonts.filter(function (f) { return f.object_id && f.object_id.obj === font_ptr.obj &&
            f.object_id.generation === font_ptr.generation; }).length > 0;
    };
    /**
     * Returns true, if the font with the given name is registered, or if it is the name of a standard font.
     * */
    FontManager.prototype.isRegisteredFont = function (font) {
        if (typeof font === 'string') {
            if (Font.isStandardFont(font))
                return true;
            for (var _i = 0, _a = this.fonts; _i < _a.length; _i++) {
                var _font = _a[_i];
                if (_font.name === font) {
                    return true;
                }
            }
        }
        else if (font instanceof Font) {
            for (var _b = 0, _c = this.fonts; _b < _c.length; _b++) {
                var _font = _c[_b];
                if (_font.name === font.name) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Returns the new fonts that must be appended to the document
     * */
    FontManager.prototype.getFontsToWrite = function () {
        return this.fonts.filter(function (x) { return x.is_new; });
    };
    return FontManager;
}());
exports.FontManager = FontManager;


/***/ }),

/***/ "./src/annotate/index.ts":
/*!*******************************!*\
  !*** ./src/annotate/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
exports.__esModule = true;
exports.AnnotationFactory = exports.Util = exports.FreeTextType = exports.TextJustification = exports.AnnotationStateModel = exports.AnnotationState = exports.AnnotationIcon = exports.LineEndingStyle = exports.PDFDocumentParser = void 0;
var parser_1 = __webpack_require__(/*! ./parser */ "./src/annotate/parser.ts");
__createBinding(exports, parser_1, "PDFDocumentParser");
var annotation_types_1 = __webpack_require__(/*! ./annotations/annotation_types */ "./src/annotate/annotations/annotation_types.ts");
__createBinding(exports, annotation_types_1, "LineEndingStyle");
var text_annotation_1 = __webpack_require__(/*! ./annotations/text_annotation */ "./src/annotate/annotations/text_annotation.ts");
__createBinding(exports, text_annotation_1, "AnnotationIcon");
__createBinding(exports, text_annotation_1, "AnnotationState");
__createBinding(exports, text_annotation_1, "AnnotationStateModel");
var freetext_annotation_1 = __webpack_require__(/*! ./annotations/freetext_annotation */ "./src/annotate/annotations/freetext_annotation.ts");
__createBinding(exports, freetext_annotation_1, "TextJustification");
__createBinding(exports, freetext_annotation_1, "FreeTextType");
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
__createBinding(exports, util_1, "Util");
var annotation_1 = __webpack_require__(/*! ./annotation */ "./src/annotate/annotation.ts");
__createBinding(exports, annotation_1, "AnnotationFactory");


/***/ }),

/***/ "./src/annotate/object-util.ts":
/*!*************************************!*\
  !*** ./src/annotate/object-util.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.ObjectUtil = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var array_util_1 = __webpack_require__(/*! ./array-util */ "./src/annotate/array-util.ts");
var stream_1 = __webpack_require__(/*! ./stream */ "./src/annotate/stream.ts");
/**
 * While the general Util class holds low level methods to navigate through the pdf data, the ObjectUtil
 * is purposefully build to extract complete objects. It returns those as json dictionaries.
 * */
var ObjectUtil = /** @class */ (function () {
    function ObjectUtil() {
    }
    ObjectUtil.extractDictKeyRec = function (data, ptr, dict) {
        var next = util_1.Util.readNextWord(data, ptr);
        var next_string = next.result;
        if (!next_string)
            return ptr;
        var _ptr = util_1.Util.skipDelimiter(next_string, 0);
        if (next_string[0] && util_1.Util.DICT_END[0] === next_string[0]) {
            var wordLookup = util_1.Util.readNextWord(data, next.end_index + 1);
            if (wordLookup.result && util_1.Util.DICT_END[0] === wordLookup.result[0]) {
                return wordLookup.end_index;
            }
        }
        return ObjectUtil.extractDictValueRec(data, next.end_index + 1, dict, util_1.Util.convertAsciiToString(next_string));
    };
    ObjectUtil.extractDictValueRec = function (data, ptr, dict, current_key) {
        if (current_key === void 0) { current_key = undefined; }
        var next = util_1.Util.readNextWord(data, ptr);
        var next_string = next.result || new Uint8Array([]);
        ptr = next.end_index - next_string.length + 1;
        if (next_string[0] === util_1.Util.ARRAY_START[0]) {
            if (!current_key)
                throw Error("Invalid anonymous array definition");
            // handle array
            var extracted_array = array_util_1.ArrayUtil.extractArray(data, ptr);
            dict[current_key] = extracted_array.result;
            return ObjectUtil.extractDictKeyRec(data, extracted_array.end_index + 1, dict);
        }
        else if (next_string[0] === util_1.Util.DICT_START[0] && data[next.end_index + 1] === util_1.Util.DICT_START[0]) {
            if (current_key) {
                var sup_dict = {};
                var end_sub_dict = ObjectUtil.extractDictKeyRec(data, next.end_index + 2, sup_dict);
                dict[current_key] = sup_dict;
                return ObjectUtil.extractDictKeyRec(data, end_sub_dict + 1, dict);
            }
            else {
                return ObjectUtil.extractDictKeyRec(data, next.end_index + 2, dict);
            }
        }
        else if (next_string[0] === util_1.Util.HEX_STRING_START[0]) {
            if (!current_key)
                throw Error("Invalid anonymous string definition");
            var extracted_string = util_1.Util.extractHexString(data, ptr);
            dict[current_key] = extracted_string.result;
            return ObjectUtil.extractDictKeyRec(data, extracted_string.end_index + 1, dict);
        }
        else if (next_string[0] === util_1.Util.LITERAL_STRING_START[0]) {
            if (!current_key)
                throw Error("Invalid anonymous string definition");
            var extracted_string = util_1.Util.extractString(data, ptr);
            dict[current_key] = extracted_string.result;
            return ObjectUtil.extractDictKeyRec(data, extracted_string.end_index + 1, dict);
        }
        else if (next_string[0] === 47) { // /
            if (!current_key)
                throw Error("Invalid anonymous property definition");
            var opt_value = util_1.Util.extractOptionValue(data, ptr);
            dict[current_key] = "/" + opt_value.result;
            return ObjectUtil.extractDictKeyRec(data, opt_value.end_index + 1, dict);
        }
        else { // It is a number, but this number might be part of a Reference
            var lookupNext = util_1.Util.readNextWord(data, next.end_index + 1);
            var lookupNextWord = lookupNext.result || new Uint8Array([]);
            if (!current_key)
                throw Error("Invalid anonymous reference/number definition");
            var value_end_ptr = next.end_index + 1;
            if (lookupNextWord[0] === 47 || lookupNextWord[0] === util_1.Util.DICT_END[0]) { // is a number
                dict[current_key] = util_1.Util.extractNumber(data, ptr).result;
            }
            else { // is a rereference
                var extracted_reference = util_1.Util.extractReferenceTyped(data, ptr);
                dict[current_key] = extracted_reference.result;
                value_end_ptr = extracted_reference.end_index + 1;
            }
            // handle Reference
            return ObjectUtil.extractDictKeyRec(data, value_end_ptr, dict);
        }
    };
    /**
     * Locates the object start in case the ptr does not point correctly
     * */
    ObjectUtil.locateObjectStart = function (data, ptr) {
        var obj_ptr = util_1.Util.locateSequence(util_1.Util.OBJ, data, ptr);
        var endobj_ptr = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, ptr);
        var consumeGenerationAndNumberRevere = function (ptr) {
            // <id> <generation> obj ... endobj
            //                   ^
            // being somewhere here
            var new_ptr = util_1.Util.skipSpacesReverse(data, ptr - 1);
            // <id> <generation> obj ... endobj
            //                 ^
            // being somewhere here
            while (new_ptr > 0 && !util_1.Util.isDelimiter(data[new_ptr]))
                --new_ptr;
            // <id> <generation> obj ... endobj
            //      ^
            // being somewhere here
            new_ptr = util_1.Util.skipSpacesReverse(data, new_ptr - 1);
            // <id> <generation> obj ... endobj
            // ^
            // being somewhere here
            while (new_ptr > 0 && !util_1.Util.isDelimiter(data[new_ptr]))
                --new_ptr;
            return new_ptr;
        };
        if (obj_ptr !== -1 && obj_ptr < endobj_ptr) {
            return consumeGenerationAndNumberRevere(obj_ptr);
        }
        else if (obj_ptr > endobj_ptr || (obj_ptr === -1 && endobj_ptr > -1)) {
            // <id> <generation> obj ... endobj
            //                        ^
            // being somewhere here
            var new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.OBJ, data, ptr);
            return consumeGenerationAndNumberRevere(new_ptr);
        }
        else {
            throw Error("Could not correct object start");
        }
    };
    /**
     * Parses a PDF object and returns a dictionary containing its fields
     * */
    ObjectUtil.extractObject = function (data, xref, objectLookupTable) {
        if (objectLookupTable === void 0) { objectLookupTable = undefined; }
        if (typeof xref !== 'number' && xref.compressed) {
            if (!objectLookupTable)
                throw Error("Provide ObjectLookupTable to extract stream object");
            return ObjectUtil.extractStreamObject(data, xref.id, xref.generation, objectLookupTable[xref.pointer]);
        }
        var ret_obj = {};
        var ptr = typeof xref === 'number' ? xref : xref.pointer;
        var object_id = util_1.Util.extractObjectId(data, ptr);
        if (isNaN(object_id.obj) || isNaN(object_id.generation)) {
            return ObjectUtil.extractObject(data, ObjectUtil.locateObjectStart(data, ptr), objectLookupTable);
        }
        ret_obj.id = object_id;
        ptr = util_1.Util.locateSequence(util_1.Util.OBJ, data, ptr);
        if (ptr === -1)
            throw { message: "Object missing 'obj' sequence", name: "MissingObjSequenceError" };
        ptr += util_1.Util.OBJ.length;
        var ptr_obj_end = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, ptr);
        data = data.slice(ptr, ptr_obj_end);
        // determine the type of the object:
        var next = util_1.Util.readNextWord(data, 0);
        if (next.result && next.result[0] === util_1.Util.DICT_START[0]) { // object contains a dict
            var result_dict = {};
            ObjectUtil.extractDictValueRec(data, 0, result_dict);
            ret_obj.value = result_dict;
        }
        else if (next.result && next.result[0] === util_1.Util.ARRAY_START[0]) { // object contains an array
            var lst = array_util_1.ArrayUtil.extractArray(data, 0);
            ret_obj.value = lst.result;
        }
        else {
            throw Error("Invalid object type - starting with: ".concat(next.result));
        }
        // check if the object has a stream part
        ptr = util_1.Util.locateSequence(util_1.Util.STREAM, data, 0);
        if (-1 !== ptr) {
            // extract stream part
            var ptr_stream_data_start = ptr + util_1.Util.STREAM.length;
            ptr_stream_data_start = util_1.Util.skipDelimiter(data, ptr_stream_data_start);
            var ptr_stream_data_end = ptr_stream_data_start + ret_obj.value["/Length"];
            ret_obj.stream = ObjectUtil.extractStreamData(data.slice(ptr_stream_data_start, ptr_stream_data_end), ret_obj.value["/Filter"], ObjectUtil.translateDecodeParams(ret_obj));
        }
        return ret_obj;
    };
    ObjectUtil.extractStreamObject = function (data, object_id_to_extract, offset, streamObj_xref) {
        var ptr = streamObj_xref.pointer;
        var ret_obj = {};
        // extract object id
        var object_id = util_1.Util.extractObjectId(data, ptr);
        ret_obj.id = object_id;
        ptr = util_1.Util.locateSequence(util_1.Util.OBJ, data, ptr) + util_1.Util.OBJ.length;
        var ptr_obj_end = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, ptr);
        data = data.slice(ptr, ptr_obj_end);
        // extract dict part
        var next = util_1.Util.readNextWord(data, 0);
        if (!next.result || next.result[0] !== util_1.Util.DICT_START[0]) {
            throw Error("Invalid stream object -- no dict");
        }
        var result_dict = {};
        ObjectUtil.extractDictValueRec(data, 0, result_dict);
        ret_obj.value = result_dict;
        if (result_dict["/Filter"] && Array.isArray(result_dict["/Filter"]) && result_dict["/Filter"].length > 0)
            result_dict["/Filter"] = result_dict["/Filter"][0];
        // check if filter is supported
        if (!result_dict["/Filter"] || result_dict["/Filter"] !== "/FlateDecode")
            throw Error("Unsupported stream filter: ".concat(result_dict["/Filter"], " - Only supported filter is FlateDecode"));
        if (!result_dict["/Type"] || result_dict["/Type"] !== "/ObjStm")
            throw Error("Invalid stream object type: ".concat(result_dict["/Type"]));
        // extract the stream length
        var streamLength = result_dict["/Length"];
        // extract stream part
        var ptr_stream_data_start = util_1.Util.locateSequence(util_1.Util.STREAM, data) + util_1.Util.STREAM.length;
        ptr_stream_data_start = util_1.Util.skipDelimiter(data, ptr_stream_data_start);
        var ptr_stream_data_end = ptr_stream_data_start + streamLength;
        var stream = ObjectUtil.extractStreamData(data.slice(ptr_stream_data_start, ptr_stream_data_end), result_dict["/Filter"], ObjectUtil.translateDecodeParams(result_dict));
        if (!result_dict["/N"])
            throw Error("Invalid stream object -- no number of objects specified");
        if (!result_dict["/First"])
            throw Error("Invalid stream object -- no offset to the first objct specified");
        var streamReferences = ObjectUtil.extractStreamObjectTable(stream, result_dict["/N"], result_dict["/First"]);
        if (!streamReferences[object_id_to_extract])
            throw Error("Object ".concat(object_id_to_extract, " not in stream object"));
        var result_obj = { id: { obj: object_id_to_extract, generation: 0 } };
        var stream_data = stream.getData();
        next = util_1.Util.readNextWord(stream_data, streamReferences[object_id_to_extract]);
        if (next.result && next.result[0] === util_1.Util.DICT_START[0]) { // object contains a dict
            var value = {};
            result_obj.pointer_stream_end = ObjectUtil.extractDictValueRec(stream_data, streamReferences[object_id_to_extract], value);
            result_obj.value = value;
            result_obj.stream = stream;
            result_obj.pointer_stream_start = streamReferences[object_id_to_extract];
        }
        else if (next.result && next.result[0] === util_1.Util.ARRAY_START[0]) { // object contains an array
            var lst = array_util_1.ArrayUtil.extractArray(stream_data, streamReferences[object_id_to_extract]);
            result_obj.value = lst.result;
            result_obj.stream = stream;
            result_obj.pointer_stream_start = streamReferences[object_id_to_extract];
        }
        else {
            throw Error("Invalid stream object type - starting with: ".concat(next.result));
        }
        return result_obj;
    };
    ObjectUtil.translateDecodeParams = function (dict) {
        if (!dict.value)
            return undefined;
        if (!dict.value["/DecodeParms"])
            return undefined;
        if (!dict.value["/DecodeParms"]["/Columns"])
            return undefined;
        if (!dict.value["/DecodeParms"]["/Predictor"])
            return undefined;
        return { columns: dict.value["/DecodeParms"]["/Columns"], predictor: dict.value["/DecodeParms"]["/Predictor"] };
    };
    ObjectUtil.extractStreamObjectTable = function (stream, number_of_obj, offset_first_obj) {
        var references = {};
        for (var i = 0; i < number_of_obj; ++i) {
            var obj_id = stream.getNumber();
            var pointer = stream.getNumber() + offset_first_obj;
            references[obj_id] = pointer;
        }
        return references;
    };
    ObjectUtil.extractStreamData = function (streamData, compression, decodeParameters) {
        if (decodeParameters === void 0) { decodeParameters = undefined; }
        var stream = undefined;
        if (compression === '/FlateDecode') {
            stream = new stream_1.FlateStream(streamData, decodeParameters);
        }
        else {
            throw Error("Unsupported stream filter: ".concat(compression, " - Only supported filter is FlateDecode (right now)"));
        }
        if (!stream)
            throw Error("Could not derive stream");
        return stream;
    };
    ObjectUtil.i = 0;
    return ObjectUtil;
}());
exports.ObjectUtil = ObjectUtil;


/***/ }),

/***/ "./src/annotate/parser.ts":
/*!********************************!*\
  !*** ./src/annotate/parser.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.PDFDocumentParser = exports.CryptoInterface = exports.Page = exports.Pages = exports.PageTree = exports.CatalogObject = exports.AnnotationParser = exports.FontParser = exports.AppearanceStreamParser = exports.XObjectParser = exports.ContentStreamParser = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var object_util_1 = __webpack_require__(/*! ./object-util */ "./src/annotate/object-util.ts");
var document_history_1 = __webpack_require__(/*! ./document-history */ "./src/annotate/document-history.ts");
var crypto_1 = __webpack_require__(/*! ./crypto */ "./src/annotate/crypto.ts");
var annotation_types_1 = __webpack_require__(/*! ./annotations/annotation_types */ "./src/annotate/annotations/annotation_types.ts");
var text_annotation_1 = __webpack_require__(/*! ./annotations/text_annotation */ "./src/annotate/annotations/text_annotation.ts");
var text_markup_annotation_1 = __webpack_require__(/*! ./annotations/text_markup_annotation */ "./src/annotate/annotations/text_markup_annotation.ts");
var freetext_annotation_1 = __webpack_require__(/*! ./annotations/freetext_annotation */ "./src/annotate/annotations/freetext_annotation.ts");
var circle_square_annotation_1 = __webpack_require__(/*! ./annotations/circle_square_annotation */ "./src/annotate/annotations/circle_square_annotation.ts");
var polygon_polyline_annotation_1 = __webpack_require__(/*! ./annotations/polygon_polyline_annotation */ "./src/annotate/annotations/polygon_polyline_annotation.ts");
var ink_annotation_1 = __webpack_require__(/*! ./annotations/ink_annotation */ "./src/annotate/annotations/ink_annotation.ts");
var content_stream_1 = __webpack_require__(/*! ./content-stream */ "./src/annotate/content-stream.ts");
var appearance_stream_1 = __webpack_require__(/*! ./appearance-stream */ "./src/annotate/appearance-stream.ts");
var fonts_1 = __webpack_require__(/*! ./fonts */ "./src/annotate/fonts.ts");
var resources_1 = __webpack_require__(/*! ./resources */ "./src/annotate/resources.ts");
/**
 * Parses the content stream of an XObject.
 * */
var ContentStreamParser = /** @class */ (function () {
    function ContentStreamParser() {
    }
    ContentStreamParser.extract = function (data) {
        var ret_val = new content_stream_1.ContentStream();
        var grouping_object = [ret_val];
        var index = 0;
        var parameters = [];
        while (index < data.length) {
            var word = util_1.Util.readNextWord(data, index);
            var skipped_index = util_1.Util.skipSymbol(data, util_1.Util.SPACE, word.end_index + 1); // make it robust against traling spaces
            if ((data[skipped_index] === util_1.Util.LF || data[skipped_index] === util_1.Util.COMMENT_START[0]) && word.result !== "") {
                var op_name = util_1.Util.convertUnicodeToString(word.result);
                if (op_name === ContentStreamParser.TEXT_OBJECT_START) {
                    grouping_object.push([parameters]);
                }
                else if (op_name === ContentStreamParser.TEXT_OBJECT_END) {
                    var new_ops = grouping_object.pop();
                    var to = new content_stream_1.TextObject();
                    to.parameters = __spreadArray([], new_ops[0], true);
                    to.operators = new_ops.slice(1);
                    if (Array.isArray(grouping_object[grouping_object.length - 1])) {
                        grouping_object[grouping_object.length - 1].push(to);
                    }
                    else {
                        grouping_object[grouping_object.length - 1].addOperator(to);
                    }
                }
                else if (op_name === ContentStreamParser.MARKED_CONTENT_START) {
                    grouping_object.push([parameters]);
                }
                else if (op_name === ContentStreamParser.MARKED_CONTENT_END) {
                    var new_ops = grouping_object.pop();
                    var to = new content_stream_1.MarkedContent();
                    to.parameters = __spreadArray([], new_ops[0], true);
                    to.operators = new_ops.slice(1);
                    if (Array.isArray(grouping_object[grouping_object.length - 1])) {
                        grouping_object[grouping_object.length - 1].push(to);
                    }
                    else {
                        grouping_object[grouping_object.length - 1].addOperator(to);
                    }
                }
                else {
                    if (grouping_object[grouping_object.length - 1] instanceof content_stream_1.ContentStream) {
                        grouping_object[grouping_object.length - 1].addOperator(new content_stream_1.Operator(op_name, __spreadArray([], parameters, true)));
                    }
                    else {
                        grouping_object[grouping_object.length - 1].push(new content_stream_1.Operator(op_name, __spreadArray([], parameters, true)));
                    }
                }
                parameters = [];
                index = word.end_index + 1;
            }
            else {
                if (!word.result) {
                    index = word.end_index + 1;
                }
                else if (word.result[0] === util_1.Util.LITERAL_STRING_START[0]) {
                    var res = util_1.Util.extractString(data, word.start_index);
                    parameters.push(util_1.Util.convertUnicodeToString(res.result));
                    index = res.end_index + 1;
                }
                else if (word.result[0] === util_1.Util.HEX_STRING_START[0]) {
                    var res = util_1.Util.extractHexString(data, word.start_index);
                    parameters.push(res.result);
                    index = res.end_index + 1;
                }
                else if (word.result[0] === 47) {
                    var res = util_1.Util.extractOptionValue(data, word.start_index);
                    parameters.push("/" + res.result);
                    index = res.end_index + 1;
                }
                else if (word.result[0] === util_1.Util.R[0]) {
                    var ref_ptr = { obj: parameters[parameters.length - 2], generation: parameters[parameters.length - 1] };
                    parameters = parameters.slice(0, parameters.length - 2);
                    parameters.push(ref_ptr);
                    index = word.end_index + 1;
                }
                else { // number
                    var res = util_1.Util.extractNumber(data, word.start_index);
                    parameters.push(res.result);
                    index = res.end_index + 1;
                }
            }
        }
        return ret_val;
    };
    ContentStreamParser.TEXT_OBJECT_START = "BT";
    ContentStreamParser.TEXT_OBJECT_END = "ET";
    ContentStreamParser.MARKED_CONTENT_START = "BMC";
    ContentStreamParser.MARKED_CONTENT_END = "EMC";
    return ContentStreamParser;
}());
exports.ContentStreamParser = ContentStreamParser;
var XObjectParser = /** @class */ (function () {
    function XObjectParser() {
    }
    XObjectParser.extract = function (data, xref, objectLookupTable, cryptoInterface) {
        var res = object_util_1.ObjectUtil.extractObject(data, xref, objectLookupTable);
        if (res.value["/Type"] !== "/XObject" || res.value["/Subtype"] !== "/Form") {
            throw Error("Xref {xref} is no valid XObject");
        }
        var ret_obj = new appearance_stream_1.XObjectObj();
        if (res.value["/Name"])
            ret_obj.name = res.value["/Name"];
        if (res.value["/Matrix"])
            ret_obj.matrix = res.value["/Matrix"];
        if (res.value["/FormType"])
            ret_obj.formType = res.value["/FormType"];
        if (res.value["/BBox"])
            ret_obj.bBox = res.value["/BBox"];
        if (res.value["/Resources"])
            ret_obj.resources = res.value["/Resources"];
        // parse content stream
        if (res.stream && res.stream.data && res.stream.data.length > 0) {
            ret_obj.contentStream = ContentStreamParser.extract(res.stream.data);
        }
        return ret_obj;
    };
    return XObjectParser;
}());
exports.XObjectParser = XObjectParser;
/**
 * Parses the appearance stream object. But if it is a reference it will not resolve the object and just provide
 * the reference.
 * */
var AppearanceStreamParser = /** @class */ (function () {
    function AppearanceStreamParser() {
    }
    AppearanceStreamParser.parseXObject = function (to_parse) {
        return new appearance_stream_1.XObjectObj();
    };
    AppearanceStreamParser.parseAppearanceStream = function (key, to_parse) {
        if (util_1.Util.isReferencePointer(to_parse[key])) {
            return to_parse[key];
        }
        else if (to_parse[key]["/Off"] && to_parse[key]["/ON"]) {
            if (util_1.Util.isReferencePointer(to_parse[key]["/Off"])) {
                return to_parse[key]["/Off"];
            }
            else {
                return AppearanceStreamParser.parseXObject(to_parse[key]["/Off"]);
            }
            if (util_1.Util.isReferencePointer(to_parse[key]["/On"])) {
                return to_parse[key]["/On"];
            }
            else {
                return AppearanceStreamParser.parseXObject(to_parse[key]["/On"]);
            }
        }
        else {
            return AppearanceStreamParser.parseXObject(to_parse[key]);
        }
    };
    AppearanceStreamParser.parse = function (annot, to_parse) {
        if (!to_parse["/N"]) {
            throw Error("/N flag is required in appearance stream");
        }
        var appStream = new appearance_stream_1.AppStream(annot);
        appStream.N = AppearanceStreamParser.parseAppearanceStream("/N", to_parse);
        if (to_parse["/R"]) {
            appStream.R = AppearanceStreamParser.parseAppearanceStream("/R", to_parse);
        }
        if (to_parse["/D"]) {
            appStream.D = AppearanceStreamParser.parseAppearanceStream("/D", to_parse);
        }
        return appStream;
    };
    return AppearanceStreamParser;
}());
exports.AppearanceStreamParser = AppearanceStreamParser;
/**
 * Parses a font object
 * */
var FontParser = /** @class */ (function () {
    function FontParser() {
    }
    /**
     * Extract the font dictionary
     * */
    FontParser.extract = function (data, xref, objectLookupTable, name) {
        var res = object_util_1.ObjectUtil.extractObject(data, xref, objectLookupTable);
        var ftype = fonts_1.FontType.Type1;
        switch (res.value["/Subtype"]) {
            case "/Type0":
                ftype = fonts_1.FontType.Type0;
                break;
            case "/Type1":
                ftype = fonts_1.FontType.Type1;
                break;
            case "/Type3":
                ftype = fonts_1.FontType.Type3;
                break;
            case "/MMType1":
                ftype = fonts_1.FontType.MMType1;
                break;
            case "/TrueType":
                ftype = fonts_1.FontType.TrueType;
                break;
            case "/CIDFontType0":
                ftype = fonts_1.FontType.CIDFontType0;
                break;
            case "/CIDFontType2":
                ftype = fonts_1.FontType.CIDFontType2;
                break;
            default:
                ftype = undefined;
        }
        var font = new fonts_1.Font(ftype, name, res.value["/BaseFont"]);
        return font;
    };
    return FontParser;
}());
exports.FontParser = FontParser;
/**
 * Parses an annotation from the document and translates this into the pdfAnnotate datastructure
 * */
var AnnotationParser = /** @class */ (function () {
    function AnnotationParser() {
    }
    /**
     * Extract the annotation object it also assigns the raw data, i.e., potentially unknown/ additional attributes
     * */
    AnnotationParser.extract = function (factory, data, xref, page, objectLookupTable, cryptoInterface) {
        var annot_obj = object_util_1.ObjectUtil.extractObject(data, xref, objectLookupTable);
        annot_obj = annot_obj.value;
        var ret_obj;
        switch (annot_obj["/Subtype"]) {
            case "/Circle":
                ret_obj = new circle_square_annotation_1.CircleAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/Square":
                ret_obj = new circle_square_annotation_1.SquareAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/FreeText":
                ret_obj = new freetext_annotation_1.FreeTextAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/Ink":
                ret_obj = new ink_annotation_1.InkAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/PolyLine":
                ret_obj = new polygon_polyline_annotation_1.PolyLineAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/Polygon":
                ret_obj = new polygon_polyline_annotation_1.PolygonAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/Text":
                ret_obj = new text_annotation_1.TextAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/Highlight":
                ret_obj = new text_markup_annotation_1.HighlightAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/Underline":
                ret_obj = new text_markup_annotation_1.UnderlineAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/Squiggly":
                ret_obj = new text_markup_annotation_1.SquigglyAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            case "/StrikeOut":
                ret_obj = new text_markup_annotation_1.StrikeOutAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
                break;
            default:
                ret_obj = new annotation_types_1.RawAnnotationObj();
                ret_obj.object_id = { obj: xref.id, generation: xref.generation };
                ret_obj.extract(annot_obj, page, cryptoInterface);
        }
        ret_obj.factory = factory;
        return ret_obj;
    };
    return AnnotationParser;
}());
exports.AnnotationParser = AnnotationParser;
/**
 * Represents the Catalog object of the PDF document
 * */
var CatalogObject = /** @class */ (function () {
    /**
     * Extracts the data representing the object.
     * */
    function CatalogObject(data, xref, objectLookupTable) {
        this.data = data;
        this.xref = xref;
        this.objectLookupTable = objectLookupTable;
        this.pagesObjectId = { obj: -1, generation: -1 };
        this.data = data;
        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable).value;
        if (page_obj["/Type"] !== "/Catalog")
            throw Error("Invalid catalog object at position ".concat(xref.pointer));
        this.pagesObjectId = page_obj["/Pages"];
    }
    CatalogObject.prototype.getPagesObjectId = function () {
        return this.pagesObjectId;
    };
    return CatalogObject;
}());
exports.CatalogObject = CatalogObject;
/**
 * Represents the PageTree object of the PDF document
 * This is the object with /Type /Pages
 * */
var PageTree = /** @class */ (function () {
    function PageTree(data, objectLookupTable) {
        this.data = data;
        this.objectLookupTable = objectLookupTable;
        this.pageCount = -1;
        /**
         * References to page objects
         * */
        this.pageReferences = [];
        /**
         * References to pages objects
         * */
        this.visitedPages = [];
        this.data = data;
    }
    /**
     * Extracts the kids references recursively.
     * For every kid it checks if the referenced object type is:
     * - a /Pages object then it recursively lookups its children
     * - a /Page object then it adds the references
     * */
    PageTree.prototype.extractPageReferences = function (references) {
        var _loop_1 = function (reference) {
            if (this_1.visitedPages.some(function (el) { return el.obj === reference.obj &&
                el.generation === reference.generation; })) {
                return "continue";
            }
            var xref = this_1.objectLookupTable[reference.obj];
            var kid_page_obj = object_util_1.ObjectUtil.extractObject(this_1.data, xref, this_1.objectLookupTable).value;
            if (kid_page_obj["/Type"] === "/Page") {
                this_1.pageReferences.push(reference);
            }
            else if (kid_page_obj["/Type"] === "/Pages") {
                this_1.visitedPages.push(reference);
                this_1.extractPageReferences(kid_page_obj["/Kids"]);
            }
            else {
                throw Error("Invalid object type ".concat(kid_page_obj["/Type"]));
            }
        };
        var this_1 = this;
        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
            var reference = references_1[_i];
            _loop_1(reference);
        }
    };
    /**
     * Extract the object data at the given pointer
     * */
    PageTree.prototype.extract = function (xref, objectLookupTable) {
        var page_tree_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable).value;
        if (!page_tree_obj["/Kids"])
            throw Error("Could not find index of /Kids in /Pages object");
        var refs = page_tree_obj["/Kids"];
        this.pageReferences = [];
        this.extractPageReferences(refs);
        this.pageCount = this.pageReferences.length;
    };
    /**
     * Returns the number of pages the page tree comprises
     * */
    PageTree.prototype.getPageCount = function () {
        return this.pageCount;
    };
    /**
     * Returns the reference to the page objects
     * */
    PageTree.prototype.getPageReferences = function () {
        return this.pageReferences;
    };
    /**
     * Returns the references to the pages objects
     * */
    PageTree.prototype.getPagesReferences = function () {
        return this.visitedPages;
    };
    return PageTree;
}());
exports.PageTree = PageTree;
/**
 * Represent a pages object in the PDF document
 * */
var Pages = /** @class */ (function () {
    function Pages(data, documentHistory) {
        this.data = data;
        this.documentHistory = documentHistory;
        /**
         * Holds the resource dictionary that might be associated with the object
         * */
        this.resources = undefined;
        this.data = data;
    }
    /**
     * Extracts the page object starting at position ptr
     * */
    Pages.prototype.extract = function (xref, objectLookupTable) {
        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable);
        this.object_id = page_obj.id;
        var resources = page_obj.value["/Resources"];
        if (resources) {
            this.resources = new resources_1.Resource();
            this.resources.associatedWith = this.object_id;
            this.resources.extract(resources);
        }
    };
    return Pages;
}());
exports.Pages = Pages;
/**
 * Represents a page object in the PDF document
 * */
var Page = /** @class */ (function () {
    function Page(data, documentHistory) {
        this.data = data;
        this.documentHistory = documentHistory;
        /**
         * Holds the resource dictionary that might be associated with the object
         * */
        this.resources = undefined;
        this.annots = [];
        this.hasAnnotsField = false;
        this.data = data;
    }
    /**
     * Extracts the references in the linked annotations array
     * */
    Page.prototype.extractAnnotationArray = function () {
        var obj_table = this.documentHistory.createObjectLookupTable();
        if (!this.annotsPointer)
            throw Error("Annotations pointer not set");
        var ref_annot_table = obj_table[this.annotsPointer.obj];
        var annotations_obj = object_util_1.ObjectUtil.extractObject(this.data, ref_annot_table, obj_table);
        this.annots = annotations_obj.value;
    };
    /**
     * Extracts the page object starting at position ptr
     * */
    Page.prototype.extract = function (xref, objectLookupTable) {
        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable);
        this.object_id = page_obj.id;
        var annots = page_obj.value["/Annots"];
        if (annots) {
            this.hasAnnotsField = true;
            if (Array.isArray(annots)) {
                this.annots = annots.filter(function (x) { return x !== 'null'; });
            }
            else {
                this.annotsPointer = annots;
                this.extractAnnotationArray();
            }
        }
        var resources = page_obj.value["/Resources"];
        if (resources) {
            this.resources = new resources_1.Resource();
            this.resources.associatedWith = this.object_id;
            this.resources.extract(resources);
        }
    };
    return Page;
}());
exports.Page = Page;
/**
 * Provides a configured interface to handle the encryption and decryption of PDFs
 * */
var CryptoInterface = /** @class */ (function () {
    function CryptoInterface(data, documentHistory, ref_ptr, user_pwd, owner_pwd) {
        this.data = data;
        this.documentHistory = documentHistory;
        this.ref_ptr = ref_ptr;
        this.cryptoConfiguration = { version: undefined, revision: undefined, filter: undefined, user_pwd: "", owner_pwd: "", length: undefined, permissions: undefined, owner_pwd_c: undefined, user_pwd_c: undefined };
        this.cryptoEngine = new crypto_1.IdentityEngine();
        this.data = data;
        this.documentHistory = documentHistory;
        this.cryptoConfiguration.user_pwd = user_pwd ? user_pwd : "";
        this.cryptoConfiguration.owner_pwd = owner_pwd ? owner_pwd : "";
        if (this.ref_ptr && this.documentHistory) {
            this.extractEncryptionDictionary(this.ref_ptr);
            // setup crypto-engine
            if (this.cryptoConfiguration.version === 1) {
                this.cryptoEngine = new crypto_1.RC4CryptoEngine(this.cryptoConfiguration, this.documentHistory.getRecentUpdate().id, crypto_1.RC4_40_BIT);
            }
            else if (this.cryptoConfiguration.version === 2) {
                this.cryptoEngine = new crypto_1.RC4CryptoEngine(this.cryptoConfiguration, this.documentHistory.getRecentUpdate().id);
            }
            else if (this.cryptoConfiguration.version === 4) {
                console.log("Some fancy AES encryption");
            }
            else {
                throw Error("Unsupported Encryption ".concat(this.cryptoConfiguration.version));
            }
        }
    }
    /**
     * Returns the reference pointer
     * */
    CryptoInterface.prototype.getEncryptionDictReference = function () {
        if (!this.ref_ptr)
            return undefined;
        return { obj: this.ref_ptr.id, generation: this.ref_ptr.generation };
    };
    CryptoInterface.prototype.encrypt = function (data, reference) {
        return this.cryptoEngine.encrypt(data, reference);
    };
    CryptoInterface.prototype.decrypt = function (data, reference) {
        return this.cryptoEngine.decrypt(data, reference);
    };
    CryptoInterface.prototype.isUserPasswordCorrect = function () {
        if (!this.cryptoEngine) {
            throw Error("Crypto engine not configured");
        }
        return this.cryptoEngine.isUserPasswordCorrect();
    };
    CryptoInterface.prototype.isOwnerPasswordCorrect = function () {
        if (!this.cryptoEngine) {
            throw Error("Crypto engine not configured");
        }
        return this.cryptoEngine.isOwnerPasswordCorrect();
    };
    /**
     * Extracts the enrcyption dictionary
     * */
    CryptoInterface.prototype.extractEncryptionDictionary = function (ptr) {
        if (!this.documentHistory) {
            throw Error("Documenthistory not configured");
        }
        if (!this.data) {
            throw Error("Data not configured");
        }
        var obj_table = this.documentHistory.createObjectLookupTable();
        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, ptr, obj_table);
        this.cryptoConfiguration.version = page_obj.value["/V"];
        this.cryptoConfiguration.revision = page_obj.value["/R"];
        this.cryptoConfiguration.filter = page_obj.value["/Filter"];
        this.cryptoConfiguration.user_pwd_c = page_obj.value["/U"];
        this.cryptoConfiguration.owner_pwd_c = page_obj.value["/O"];
        this.cryptoConfiguration.length = page_obj.value["/Length"];
        this.cryptoConfiguration.permissions = page_obj.value["/P"];
    };
    return CryptoInterface;
}());
exports.CryptoInterface = CryptoInterface;
var ObjectCache = /** @class */ (function () {
    function ObjectCache() {
        this.cache = {};
    }
    ObjectCache.prototype.set = function (key, value) {
        this.cache["".concat(key.obj, "_").concat(key.generation)] = value;
    };
    ObjectCache.prototype.get = function (key, otherwise) {
        if (otherwise === void 0) { otherwise = undefined; }
        return this.cache["".concat(key.obj, "_").concat(key.generation)] || otherwise;
    };
    ObjectCache.prototype.has = function (key) {
        return typeof this.cache["".concat(key.obj, "_").concat(key.generation)] !== 'undefined';
    };
    return ObjectCache;
}());
/**
 * Parses the relevant parts of the PDF document and provides functionality to extract the necessary information for
 * adding annotations
 * */
var PDFDocumentParser = /** @class */ (function () {
    /**
     * Parses a PDF document and allows access to the cross reference table and individual PDF objects.
     *
     * Note that this class heavily relies on caching to prevent expensive lookup operations.
     * */
    function PDFDocumentParser(data, userpwd, ownerpwd) {
        if (userpwd === void 0) { userpwd = ""; }
        if (ownerpwd === void 0) { ownerpwd = ""; }
        this.data = data;
        this.version = undefined;
        this.documentHistory = new document_history_1.DocumentHistory(new Uint8Array([]));
        this.catalogObject = undefined;
        this.pageTree = undefined;
        this.objectCache = new ObjectCache();
        this.cryptoInterface = new CryptoInterface();
        this.fontManager = undefined;
        this.data = new Uint8Array(data);
        this.documentHistory = new document_history_1.DocumentHistory(this.data);
        this.documentHistory.extractDocumentHistory();
        if (this.documentHistory.isEncrypted()) {
            // extract encryption dictionary
            var obj_table = this.documentHistory.createObjectLookupTable();
            var enc_obj = this.documentHistory.getRecentUpdate().encrypt;
            if (!enc_obj)
                throw Error("Invalid encryption indication");
            var enc_obj_ptr = obj_table[enc_obj.obj];
            this.cryptoInterface = new CryptoInterface(this.data, this.documentHistory, enc_obj_ptr, userpwd, ownerpwd);
            // verify keys
            if (!this.cryptoInterface.isUserPasswordCorrect()) {
                if (!this.cryptoInterface.isOwnerPasswordCorrect()) {
                    throw Error("No valid user credentials");
                }
            }
        }
    }
    /**
     * Returns the crypto interface
     * */
    PDFDocumentParser.prototype.getCryptoInterface = function () {
        return this.cryptoInterface;
    };
    /**
     * Returns the major and minor version of the pdf document
     * */
    PDFDocumentParser.prototype.getPDFVersion = function () {
        if (this.version)
            return this.version;
        this.version = util_1.Util.extractVersion(this.data, 0);
        return this.version;
    };
    /**
     * Returns a free object id. It first checks wether there can be an freed object id reused. If that is not the case
     * it creates a new one
     * */
    PDFDocumentParser.prototype.getFreeObjectId = function () {
        return this.documentHistory.getFreeObjectId();
    };
    /**
     * Returns the catalog object of the PDF file
     * */
    PDFDocumentParser.prototype.getCatalog = function () {
        var recent_update = this.documentHistory.getRecentUpdate();
        if (recent_update.root) {
            var root_obj = recent_update.root;
            var obj_table = this.documentHistory.createObjectLookupTable();
            return new CatalogObject(this.data, obj_table[root_obj.obj], obj_table);
        }
        else { // If we do not know the catalogue object we need to look it up
            // In cross reference stream objects no /ROOT field is required, however often it is provided anyway
            // otherwise run this routine, but buffer the catalog object
            if (this.catalogObject)
                return this.catalogObject;
            throw Error("Does not work for compressed data");
        }
    };
    /**
     * Returns the latest version of the page tree object of the document
     * */
    PDFDocumentParser.prototype.getPageTree = function () {
        if (this.pageTree)
            return this.pageTree;
        var obj_table = this.documentHistory.createObjectLookupTable();
        var catalog_object = this.getCatalog();
        var pages_id = catalog_object.getPagesObjectId();
        var pages_ref = obj_table[pages_id.obj];
        var pageTree = new PageTree(this.data, obj_table);
        pageTree.extract(pages_ref, obj_table);
        this.pageTree = pageTree;
        return pageTree;
    };
    /**
     * Returns the latest version of the page with the given pageNumber
     * */
    PDFDocumentParser.prototype.getPage = function (pageNumber) {
        var pageId = undefined;
        if (typeof pageNumber === 'number') {
            var pageTree = this.getPageTree();
            pageId = pageTree.getPageReferences()[pageNumber];
        }
        else if (util_1.Util.isReferencePointer(pageNumber)) {
            pageId = pageNumber;
        }
        if (!pageId)
            throw Error("Could not determine reference pointer from page number");
        if (this.objectCache.has(pageId)) {
            var cached = this.objectCache.get(pageId);
            if (!(cached instanceof Page))
                throw Error("Invalid cached Page object");
            return cached;
        }
        var obj_table = this.documentHistory.createObjectLookupTable();
        var obj_ptr = obj_table[pageId.obj];
        var page = new Page(this.data, this.documentHistory);
        page.extract(obj_ptr, obj_table);
        this.objectCache.set(pageId, page);
        return page;
    };
    /**
     * Returns the pages object with the given reference pointer
     * */
    PDFDocumentParser.prototype.getPages = function (refPtr) {
        if (this.objectCache.has(refPtr)) {
            var cached = this.objectCache.get(refPtr);
            if (!(cached instanceof Pages))
                throw Error("Invalid cached Pages object");
            return cached;
        }
        var obj_table = this.documentHistory.createObjectLookupTable();
        var obj_ptr = obj_table[refPtr.obj];
        var page = new Pages(this.data, this.documentHistory);
        page.extract(obj_ptr, obj_table);
        this.objectCache.set(refPtr, page);
        return page;
    };
    /**
     * Returns the annotations that exist in the document
     * */
    PDFDocumentParser.prototype.extractAnnotations = function (factory) {
        var annots = [];
        var pt = this.getPageTree();
        var obj_table = this.documentHistory.createObjectLookupTable();
        var pageCount = pt.getPageCount();
        for (var i = 0; i < pageCount; ++i) {
            var page = this.getPage(i);
            var annotationReferences = page.annots;
            var pageAnnots = [];
            for (var _i = 0, annotationReferences_1 = annotationReferences; _i < annotationReferences_1.length; _i++) {
                var refPtr = annotationReferences_1[_i];
                var a = AnnotationParser.extract(factory, this.data, obj_table[refPtr.obj], page, obj_table, this.cryptoInterface);
                a.page = i;
                pageAnnots.push(a);
            }
            annots.push(pageAnnots);
        }
        return annots;
    };
    /**
     * Extracts the fonts, hat are available in the document and setups the font manager
     * */
    PDFDocumentParser.prototype.extractFonts = function () {
        var pageTree = this.getPageTree();
        var pageReferences = pageTree.getPageReferences();
        var obj_table = this.documentHistory.createObjectLookupTable();
        if (!this.fontManager) {
            throw Error("FontManager not set");
        }
        for (var _i = 0, pageReferences_1 = pageReferences; _i < pageReferences_1.length; _i++) {
            var reference = pageReferences_1[_i];
            var page = this.getPage(reference);
            if (page.resources) {
                for (var _a = 0, _b = page.resources.font; _a < _b.length; _a++) {
                    var resDef = _b[_a];
                    if (!resDef.refPtr) {
                        throw Error("Reference pointer not set in resource definition");
                    }
                    if (!this.fontManager.hasFont(resDef.refPtr)) {
                        var font = FontParser.extract(this.data, obj_table[resDef.refPtr.obj], obj_table, resDef.name);
                        font.object_id = resDef.refPtr;
                        this.fontManager.addFont(font);
                    }
                }
            }
        }
        var pagesReferences = pageTree.getPagesReferences();
        for (var _c = 0, pagesReferences_1 = pagesReferences; _c < pagesReferences_1.length; _c++) {
            var reference = pagesReferences_1[_c];
            var pages = this.getPages(reference);
            if (pages.resources) {
                for (var _d = 0, _e = pages.resources.font; _d < _e.length; _d++) {
                    var resDef = _e[_d];
                    if (!resDef.refPtr) {
                        throw Error("Reference pointer not set in resource definition");
                    }
                    if (!this.fontManager.hasFont(resDef.refPtr)) {
                        var font = FontParser.extract(this.data, obj_table[resDef.refPtr.obj], obj_table, resDef.name);
                        font.object_id = resDef.refPtr;
                        this.fontManager.addFont(font);
                    }
                }
            }
        }
    };
    /**
     * Returns the font manager, that manages the available fonts in the document
     * */
    PDFDocumentParser.prototype.getFonts = function () {
        if (this.fontManager)
            return this.fontManager;
        this.fontManager = new fonts_1.FontManager(this);
        this.extractFonts();
        return this.fontManager;
    };
    /**
     * Extracts the XObject with the provided reference pointer
     * */
    PDFDocumentParser.prototype.extractXObject = function (p) {
        var obj_table = this.documentHistory.createObjectLookupTable();
        return XObjectParser.extract(this.data, obj_table[p.obj], obj_table, this.cryptoInterface);
    };
    return PDFDocumentParser;
}());
exports.PDFDocumentParser = PDFDocumentParser;


/***/ }),

/***/ "./src/annotate/resources.ts":
/*!***********************************!*\
  !*** ./src/annotate/resources.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
exports.Resource = void 0;
var writer_util_1 = __webpack_require__(/*! ./writer-util */ "./src/annotate/writer-util.ts");
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var Resource = /** @class */ (function () {
    function Resource() {
        this.object_id = undefined;
        this.new_object = false; // indicates to the factory that this object must be created when writing the document
        /**
         * Hoelds the reference pointer of the object to which the resource dictionary is related
         * */
        this.associatedWith = undefined;
        this.extGState = [];
        this.colorSpace = [];
        this.pattern = [];
        this.shading = [];
        this.xObject = [];
        this.font = [];
        this.procSet = [];
        this.properties = [];
    }
    Resource.prototype.containsResourceDef = function (def, list) {
        return list.filter(function (d) { return d.name === def.name && def.refPtr && d.refPtr && def.refPtr.obj === d.refPtr.obj && def.refPtr.generation === d.refPtr.generation; }).length > 0;
    };
    Resource.prototype.addGStateDef = function (def) {
        if (!this.containsResourceDef(def, this.extGState)) {
            this.extGState.push(def);
        }
    };
    Resource.prototype.addColorSpaceDef = function (def) {
        if (!this.containsResourceDef(def, this.colorSpace)) {
            this.colorSpace.push(def);
        }
    };
    Resource.prototype.addPatternDef = function (def) {
        if (!this.containsResourceDef(def, this.pattern)) {
            this.pattern.push(def);
        }
    };
    Resource.prototype.addShadingDef = function (def) {
        if (!this.containsResourceDef(def, this.shading)) {
            this.shading.push(def);
        }
    };
    Resource.prototype.addXObjectDef = function (def) {
        if (!this.containsResourceDef(def, this.xObject)) {
            this.xObject.push(def);
        }
    };
    Resource.prototype.addFontDef = function (def) {
        if (!this.containsResourceDef(def, this.font)) {
            this.font.push(def);
        }
    };
    Resource.prototype.addProcSetDef = function (def) {
        if (!this.containsResourceDef(def, this.procSet)) {
            this.procSet.push(def);
        }
    };
    Resource.prototype.addProperty = function (def) {
        if (!this.containsResourceDef(def, this.properties)) {
            this.properties.push(def);
        }
    };
    Resource.prototype.writeDictAttribute = function (defs) {
        var ret_val = [];
        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_START);
        ret_val.push(writer_util_1.WriterUtil.SPACE);
        for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {
            var def = defs_1[_i];
            def.name = def.name.trim();
            if (def.name.charAt(0) !== "/")
                def.name = "/".concat(def.name);
            ret_val = ret_val.concat(util_1.Util.convertStringToAscii(def.name));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            if (!def.refPtr)
                throw Error("Missing reference pointer in resource definition");
            ret_val = ret_val.concat(writer_util_1.WriterUtil.writeReferencePointer(def.refPtr, true));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_END);
        return ret_val;
    };
    Resource.prototype.writeArrayAttribute = function (defs) {
        var ret_val = [];
        ret_val = ret_val.concat(writer_util_1.WriterUtil.ARRAY_START);
        for (var _i = 0, defs_2 = defs; _i < defs_2.length; _i++) {
            var def = defs_2[_i];
            def.name = def.name.trim();
            if (def.name.charAt(0) !== "/")
                def.name = "/".concat(def.name);
            ret_val = ret_val.concat(util_1.Util.convertStringToAscii(def.name));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        ret_val = ret_val.concat(writer_util_1.WriterUtil.ARRAY_END);
        return ret_val;
    };
    Resource.prototype.writeResource = function () {
        var ret_val = [];
        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_START);
        ret_val.push(writer_util_1.WriterUtil.SPACE);
        if (this.extGState.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.EXTGSTATE);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeDictAttribute(this.extGState));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.colorSpace.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.COLORSPACE);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeDictAttribute(this.colorSpace));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.pattern.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.PATTERN);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeDictAttribute(this.pattern));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.shading.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.SHADING);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeDictAttribute(this.shading));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.xObject.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.XOBJECT);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeDictAttribute(this.xObject));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.font.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.FONT);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeDictAttribute(this.font));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.procSet.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.PROCSET);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeArrayAttribute(this.procSet));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        if (this.properties.length > 0) {
            ret_val = ret_val.concat(writer_util_1.WriterUtil.PROPERTIES);
            ret_val.push(writer_util_1.WriterUtil.SPACE);
            ret_val = ret_val.concat(this.writeDictAttribute(this.properties));
            ret_val.push(writer_util_1.WriterUtil.SPACE);
        }
        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_END);
        return ret_val;
    };
    /**
     * Extract the resource mappings from a dictionary
     * */
    Resource.prototype.extract = function (value) {
        if (value["/ExtGState"]) {
            for (var _i = 0, _a = Object.keys(value["/ExtGState"]); _i < _a.length; _i++) {
                var key = _a[_i];
                this.addGStateDef({ name: key, refPtr: value["/ExtGState"][key] });
            }
        }
        if (value["/ColorSpace"]) {
            for (var _b = 0, _c = Object.keys(value["/ColorSpace"]); _b < _c.length; _b++) {
                var key = _c[_b];
                this.addColorSpaceDef({ name: key, refPtr: value["/ColorSpace"][key] });
            }
        }
        if (value["/Pattern"]) {
            for (var _d = 0, _e = Object.keys(value["/Pattern"]); _d < _e.length; _d++) {
                var key = _e[_d];
                this.addPatternDef({ name: key, refPtr: value["/Pattern"][key] });
            }
        }
        if (value["/Shading"]) {
            for (var _f = 0, _g = Object.keys(value["/Shading"]); _f < _g.length; _f++) {
                var key = _g[_f];
                this.addShadingDef({ name: key, refPtr: value["/Shading"][key] });
            }
        }
        if (value["/XObject"]) {
            for (var _h = 0, _j = Object.keys(value["/XObject"]); _h < _j.length; _h++) {
                var key = _j[_h];
                this.addXObjectDef({ name: key, refPtr: value["/XObject"][key] });
            }
        }
        if (value["/Font"]) {
            for (var _k = 0, _l = Object.keys(value["/Font"]); _k < _l.length; _k++) {
                var key = _l[_k];
                this.addFontDef({ name: key, refPtr: value["/Font"][key] });
            }
        }
        if (value["/ProcSet"]) {
            for (var _m = 0, _o = Object.keys(value["/ProcSet"]); _m < _o.length; _m++) {
                var key = _o[_m];
                this.addProcSetDef({ name: key, refPtr: value["/ProcSet"][key] });
            }
        }
        if (value["/Properties"]) {
            for (var _p = 0, _q = Object.keys(value["/Properties"]); _p < _q.length; _p++) {
                var key = _q[_p];
                this.addProperty({ name: key, refPtr: value["/Properties"][key] });
            }
        }
    };
    return Resource;
}());
exports.Resource = Resource;


/***/ }),

/***/ "./src/annotate/stream.ts":
/*!********************************!*\
  !*** ./src/annotate/stream.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.FlateStream = exports.Stream = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var Pako = __webpack_require__(/*! pako */ "./node_modules/pako/index.js");
var Stream = /** @class */ (function () {
    function Stream(data) {
        this.data = data;
        this._ptr = 0;
    }
    Stream.prototype.getData = function () {
        return this.data;
    };
    /**
     * Returns the data encoded
     * */
    Stream.prototype.encode = function () {
        throw Error("abstract method");
    };
    Stream.prototype.getLength = function () {
        return this.data.length;
    };
    Stream.prototype.peekNBytes = function (n, ptr) {
        if (n === void 0) { n = 1; }
        if (ptr === void 0) { ptr = 0; }
        return this.data.slice(ptr, ptr + n);
    };
    Stream.prototype.peekNBytesAsNumber = function (n, ptr) {
        if (n === void 0) { n = 1; }
        if (ptr === void 0) { ptr = 0; }
        var res = 0;
        for (var i = 0; i < n; ++i) {
            res += (this.data[i + ptr] << 8 * (n - i - 1));
        }
        return res;
    };
    /**
     * reads the next 'n' bytes of position 'ptr' and returns its content as a number
     * */
    Stream.prototype.getNBytesAsNumber = function (n) {
        if (n === void 0) { n = 1; }
        var res = this.peekNBytesAsNumber(n, this._ptr);
        this._ptr += n;
        return res;
    };
    /**
     * Reads the next byte from the stream
     * */
    Stream.prototype.getByte = function () {
        return this.data[this._ptr++];
    };
    /**
     * Skips spaces and than adds as many bytes to the number until another space is reached
     * */
    Stream.prototype.getNumber = function () {
        var nbr = util_1.Util.extractNumber(this.data, this._ptr);
        this._ptr = nbr.end_index + 1;
        return nbr.result;
    };
    return Stream;
}());
exports.Stream = Stream;
var FlateStream = /** @class */ (function (_super) {
    __extends(FlateStream, _super);
    /**
     * rawData : if true, the provided data is not compressed yet.
     * */
    function FlateStream(data, decodeParameters, rawData, cryptoInterface, object_id) {
        if (decodeParameters === void 0) { decodeParameters = undefined; }
        if (rawData === void 0) { rawData = false; }
        if (cryptoInterface === void 0) { cryptoInterface = undefined; }
        if (object_id === void 0) { object_id = undefined; }
        var _this = _super.call(this, data) || this;
        _this.data = data;
        _this.decodeParameters = decodeParameters;
        _this.rawData = rawData;
        _this.cryptoInterface = cryptoInterface;
        _this.object_id = object_id;
        if (_this.data.length > 0 && !rawData) {
            _this.data = Pako.inflate(data);
        }
        if (decodeParameters && !rawData) {
            _this.data = _this.applyDecoding(_this.data, decodeParameters);
        }
        return _this;
    }
    /**
     * Returns the data encoded
     * */
    FlateStream.prototype.encode = function () {
        if (!this.data || this.data.length === 0)
            return new Uint8Array();
        var int_data = this.data;
        if (this.decodeParameters && this.rawData) {
            int_data = this.applyEncoding(int_data, this.decodeParameters);
        }
        var compressed_data = Pako.deflate(int_data);
        if (this.cryptoInterface && this.object_id) {
            return this.cryptoInterface.encrypt(compressed_data, this.object_id);
        }
        return compressed_data;
    };
    FlateStream.prototype.applyEncoding = function (data, decodeParameters) {
        if (decodeParameters.predictor >= 10) {
            return this.encodePNGFilter(data, decodeParameters);
        }
        else if (decodeParameters.predictor === 2) {
            throw Error("Unsupported filter -- file feature request");
        }
        return data;
    };
    FlateStream.prototype.applyDecoding = function (data, decodeParameters) {
        if (decodeParameters.predictor >= 10) {
            return this.decodePNGFilter(data, decodeParameters);
        }
        else if (decodeParameters.predictor === 2) {
            throw Error("Unsupported filter -- file feature request");
        }
        return data;
    };
    /**
     * Applies PNG filter for encoding the data stream
     * */
    FlateStream.prototype.encodePNGFilter = function (data, decodeParameters) {
        if (data.length % (decodeParameters.columns) !== 0)
            throw Error("Invalid decode parameters");
        if ((typeof decodeParameters.encoding == 'undefined') || decodeParameters.encoding < 0 || decodeParameters.encoding > 4)
            throw Error("Invalid PNG filter encoding");
        var total_columns = decodeParameters.columns;
        var encoded_data = [];
        var encoding = 0;
        var offset = 0;
        var index_upper_value = 0;
        var upper_value = 0;
        var left_value = 0;
        var left_upper_value = 0;
        for (var i = 0; i < data.length; ++i) {
            if (i % total_columns === 0) {
                encoded_data.push(decodeParameters.encoding);
            }
            switch (decodeParameters.encoding) {
                case 0:
                    encoded_data.push(data[i]);
                    break;
                case 1:
                    offset = Math.floor(i / total_columns) * total_columns;
                    encoded_data.push(((i % total_columns) === 0) ? data[(i % total_columns) + offset] : (data[(i % total_columns) + offset] - data[(i % total_columns) + offset - 1]) % 256);
                    break;
                case 2:
                    index_upper_value = i - total_columns;
                    upper_value = (index_upper_value < 0) ? 0 : data[index_upper_value];
                    encoded_data.push((data[i] - upper_value) % 256);
                    break;
                case 3:
                    index_upper_value = i - total_columns;
                    upper_value = (index_upper_value < 0) ? 0 : data[index_upper_value];
                    left_value = ((i % total_columns) - 1 < 0) ? 0 : data[i - 1];
                    encoded_data.push((data[i] - Math.floor((upper_value + left_value) / 2)) % 256);
                    break;
                case 4: // Paeth -- uses three neighbouring bytes (left, upper and upper left) to compute a linear function
                    index_upper_value = i - total_columns;
                    upper_value = (index_upper_value < 0) ? 0 : data[index_upper_value];
                    left_value = ((i % total_columns) - 1 < 0) ? 0 : data[i - 1];
                    left_upper_value = (index_upper_value - 1 < 0) ? 0 : data[index_upper_value - 1];
                    encoded_data.push((data[i] - this.paethPredictor(left_value, upper_value, left_upper_value)) % 256);
                    break;
                default:
                    throw Error("Invalid PNG filter encoding");
            }
        }
        return new Uint8Array(encoded_data);
    };
    /**
     * Applies PNG Filter for decoding the data stream
     * */
    FlateStream.prototype.decodePNGFilter = function (data, decodeParameters) {
        if (data.length % (decodeParameters.columns + 1) !== 0)
            throw Error("Invalid decode parameters");
        var total_columns = decodeParameters.columns + 1;
        var unfiltered_data = [];
        var encoding = 0;
        for (var i = 0; i < data.length; ++i) {
            var left_value = 0;
            var upper_value = 0;
            var index_upper_value = 0;
            var left_upper_value = 0;
            if (i % total_columns === 0) {
                encoding = data[i];
            }
            else {
                switch (encoding) {
                    case 0: // no encoding
                        unfiltered_data.push(data[i]);
                        break;
                    case 1: // Sub filter -- the difference of the current pixel and the pixel before
                        // add the left already decoded pixel and 0 at the start of a row
                        left_value = ((i % total_columns) - 2 < 0) ? 0 : unfiltered_data[((i - 2) % decodeParameters.columns) + Math.floor(i / total_columns) * (decodeParameters.columns - 1)];
                        unfiltered_data.push((data[i] + left_value) % 256);
                        break;
                    case 2: // Up filter -- the difference of the current prixel and the pixel above
                        index_upper_value = i - (total_columns + Math.floor(i / total_columns));
                        upper_value = (index_upper_value < 0) ? 0 : unfiltered_data[index_upper_value];
                        unfiltered_data.push((data[i] + upper_value) % 256);
                        break;
                    case 3: // Average filter -- considers the average of the upper and the left pixel
                        index_upper_value = i - (total_columns + Math.floor(i / total_columns));
                        upper_value = (index_upper_value < 0) ? 0 : unfiltered_data[index_upper_value];
                        left_value = ((i % total_columns) - 2 < 0) ? 0 : unfiltered_data[((i - 2) % decodeParameters.columns) + Math.floor(i / total_columns) * (decodeParameters.columns - 1)];
                        unfiltered_data.push((data[i] + Math.floor((upper_value + left_value) / 2)) % 256);
                        break;
                    case 4: // Paeth -- uses three neighbouring bytes (left, upper and upper left) to compute a linear function
                        index_upper_value = i - (total_columns + Math.floor(i / total_columns));
                        upper_value = (index_upper_value < 0) ? 0 : unfiltered_data[index_upper_value];
                        left_value = ((i % total_columns) - 2 < 0) ? 0 : unfiltered_data[((i - 2) % decodeParameters.columns) + Math.floor(i / total_columns) * (decodeParameters.columns - 1)];
                        left_upper_value = (index_upper_value - 1 < 0) ? 0 : unfiltered_data[index_upper_value - 1];
                        unfiltered_data.push((data[i] + this.paethPredictor(left_value, upper_value, left_upper_value)) % 256);
                        break;
                }
            }
        }
        return new Uint8Array(unfiltered_data);
    };
    /**
     * Computes the path predictor of the given bytes
     * */
    FlateStream.prototype.paethPredictor = function (left_byte, upper_byte, upper_left_byte) {
        var p = left_byte + upper_byte - upper_left_byte;
        var pa = Math.abs(p - left_byte);
        var pb = Math.abs(p - upper_byte);
        var pc = Math.abs(p - upper_left_byte);
        if (pa <= pb && pa <= pc) {
            return left_byte;
        }
        else if (pb <= pc) {
            return upper_byte;
        }
        else {
            return upper_left_byte;
        }
    };
    return FlateStream;
}(Stream));
exports.FlateStream = FlateStream;


/***/ }),

/***/ "./src/annotate/util.ts":
/*!******************************!*\
  !*** ./src/annotate/util.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.Util = void 0;
/**
 * This class provides methods to navigate through the byte array representing the PDF document
 * */
var Util = /** @class */ (function () {
    function Util() {
    }
    /**
     * Extracts the version information of a PDF file
     * */
    Util.extractVersion = function (data, index) {
        if (index === void 0) { index = 0; }
        var ptr_version_start = Util.locateSequence(Util.VERSION, data, index) + Util.VERSION.length;
        var ptr_delimiter = Util.locateSequence([Util.DOT], data, ptr_version_start);
        var major_version = Util.extractNumber(data, ptr_version_start, ptr_delimiter).result;
        var ptr_end = Util.locateDelimiter(data, ptr_delimiter);
        var minor_version = Util.extractNumber(data, ptr_delimiter + 1, ptr_end).result;
        return { major: major_version, minor: minor_version };
    };
    /**
     * Consumes comments that is
     *  '%.................. EOL'
     *
     *  Also handles mulitple line comments
     * */
    Util.consumeComment = function (data, index) {
        while (data[index] !== 13 && data[index] != 10 && index < data.length)
            ++index;
        index = Util.skipSpaces(data, index);
        if (data[index] == 37) //%
            return Util.consumeComment(data, index);
        return index;
    };
    /**
     * Returns the next word. These are bytes that are not separated by a delimiter and a ptr to the position where the word ends
     * It ignores/skips comments.
     * */
    Util.readNextWord = function (data, index) {
        if (index === void 0) { index = 0; }
        if (index >= data.length) {
            return { result: undefined, start_index: index, end_index: data.length - 1 };
        }
        index = Util.skipSpaces(data, index);
        if (data[index] === 37) { //%
            index = Util.consumeComment(data, index);
        }
        var start_index = index;
        index++;
        while (!Util.isDelimiter(data[index]) && index < data.length)
            ++index;
        if (index <= data.length)
            return { result: data.slice(start_index, index), start_index: start_index, end_index: index - 1 };
        return { result: undefined, start_index: start_index, end_index: index - 1 };
    };
    /**
     * Assumes that at position index is a delimiter and than runs as long forward until it finds
     * another delimiter or reaches the end of the document
     * */
    Util.skipDelimiter = function (data, index) {
        if (index === void 0) { index = 0; }
        while (index < data.length && this.isDelimiter(data[index]))
            ++index;
        return index;
    };
    /**
     * Skips only spaces
     * */
    Util.skipSpaces = function (data, index) {
        if (index === void 0) { index = 0; }
        while (index < data.length && (data[index] === 10 || data[index] === 9 || data[index] === 13 || data[index] === 32))
            ++index;
        return index;
    };
    /**
     * Skips the symbol specified by _symbol
     * */
    Util.skipSymbol = function (data, _symbol, index) {
        if (index === void 0) { index = 0; }
        while (index < data.length && (data[index] === _symbol))
            ++index;
        return index;
    };
    /**
     * Skips only spaces
     * */
    Util.skipSpacesReverse = function (data, index) {
        if (index === void 0) { index = 0; }
        while (index > 0 && (data[index] === 10 || data[index] === 9 || data[index] === 13 || data[index] === 32))
            --index;
        return index;
    };
    /**
     * Assumes that at position index is a delimiter and than runs as long backwards until it finds
     * another delimiter or reaches the end of the document
     * */
    Util.skipDelimiterReverse = function (data, index) {
        if (index === void 0) { index = 0; }
        while (index > 0 && this.isDelimiter(data[index]))
            --index;
        return index;
    };
    /**
     * Transforms a string into an array of the corresponding ascii values
     * */
    Util.convertStringToAscii = function (toConvert) {
        var asciis = [];
        for (var i = 0; i < toConvert.length; ++i) {
            asciis.push(+toConvert.charCodeAt(i));
        }
        return asciis;
    };
    Util.isSpace = function (value) {
        return value === Util.LF ||
            value === Util.CR ||
            value === Util.SPACE;
    };
    Util.isDelimiter = function (value) {
        return Util.isSpace(value) ||
            value === 47 || // /
            value === 37 || // %
            value === 60 || // <
            value === 62 || // >
            value === 91 || // [
            value === 93 || // ]
            value === 40 || // (
            value === 41; // )
    };
    Util.isNumber = function (value) {
        return value >= 48 && value <= 57; // 0 <= value <=  9
    };
    /**
     * Search the sequence in data starting at the offset
     *
     * Set the 'closed' flag to check if the suceeding char after the sequence is a line feed (10), a carriage return (13), the end
     * of the whole sequence or a space (32)
     * */
    Util.locateSequence = function (sequence, data, offset, closed) {
        if (offset === void 0) { offset = 0; }
        if (closed === void 0) { closed = false; }
        var i = offset;
        for (var j = 0; i < data.length; ++i) {
            if (data[i] == sequence[j]) {
                if (j == sequence.length - 1) {
                    if (!closed || data.length == i + 1 || this.isDelimiter(data[i + 1])) {
                        return i - (sequence.length - 1);
                    }
                    else {
                        j = -1;
                    }
                }
                ++j;
            }
            else {
                j = 0;
            }
        }
        return -1;
    };
    /**
     * Search the sequence in data starting at the offset in reverse direction
     *
     * Set the 'closed' flag to check if the preceding char before the sequence is a line feed (10), a carriage return (13), the start
     * of the whole data sequence or a space (32)
     * */
    Util.locateSequenceReversed = function (sequence, data, offset, closed) {
        if (offset === void 0) { offset = data.length - 1; }
        if (closed === void 0) { closed = false; }
        var i = offset;
        for (var j = sequence.length - 1; i >= 0; --i) {
            if (data[i] == sequence[j]) {
                if (j == 0) {
                    if (!closed || i - 1 < 0 || this.isDelimiter(data[i - 1])) {
                        return i;
                    }
                    else {
                        j = sequence.length;
                    }
                }
                --j;
            }
            else {
                j = sequence.length - 1;
            }
        }
        return -1;
    };
    /**
     * Locates the index before the next delimiter. Delimiters can be a line feed (10), a carriage return (13), the end of the whole sequence
     * or a space (32)
     * */
    Util.locateDelimiter = function (data, offset) {
        if (offset === void 0) { offset = 0; }
        while (offset < data.length && !this.isDelimiter(data[offset]))
            ++offset;
        return offset - 1;
    };
    /**
     * Locates the index after the last delimiter. Delimiters can be a line feed (10), a carriage return (13), the end of the whole sequence
     * or a space (32)
     * */
    Util.locateDelimiterReversed = function (data, offset) {
        if (offset === void 0) { offset = data.length - 1; }
        while (offset > 0 && !this.isDelimiter(data[offset]))
            --offset;
        if (offset <= 0)
            return offset;
        return offset - 1;
    };
    /**
     * Extract an object identifier
     * <ID> <GEN> obj
     * */
    Util.extractObjectId = function (data, index) {
        index = Util.skipDelimiter(data, index);
        var end_obj_ptr = Util.locateDelimiter(data, index + 1);
        var obj = Util.extractNumber(data, index, end_obj_ptr).result;
        var start_gen_ptr = Util.skipDelimiter(data, end_obj_ptr + 1);
        var end_gen_ptr = Util.locateDelimiter(data, start_gen_ptr + 1);
        var gen = Util.extractNumber(data, start_gen_ptr, end_gen_ptr).result;
        return { obj: obj, generation: gen };
    };
    /**
     * Extract the reference starting at position 'index'
     * */
    Util.extractReference = function (data, index) {
        index = Util.skipDelimiter(data, index);
        var r_index = this.locateSequence(this.convertStringToAscii(" R"), data, index, true);
        return data.slice(index, r_index);
    };
    /**
     * Returns a reference as typed object
     * */
    Util.extractReferenceTyped = function (data, index) {
        var ref_data = this.extractReference(data, index);
        var del_index = this.locateDelimiter(ref_data, 0);
        var id = this.extractNumber(ref_data, 0, del_index).result;
        var gen = this.extractNumber(ref_data, del_index + 2).result;
        return { result: { obj: id, generation: gen }, start_index: index, end_index: index + ref_data.length + 1 }; // + _R
    };
    /**
     * Extracts a string in Hex notation <...>
     * */
    Util.extractHexString = function (data, index) {
        var string_start = Util.locateSequence(Util.HEX_STRING_START, data, index);
        var string_end = Util.locateSequence(Util.HEX_STRING_END, data, index);
        data = data.slice(string_start + 1, string_end);
        return { result: new Uint8Array(Util.convertHexStringToByteArray(data)), start_index: string_start, end_index: string_end };
    };
    /**
     * Extratcs a string (...)
     * */
    Util.extractString = function (data, index) {
        var string_start = Util.locateSequence(Util.LITERAL_STRING_START, data, index);
        var string_end = Util.locateSequence(Util.LITERAL_STRING_END, data, index);
        while (data[string_end - 1] === 92) { // "\" escape
            string_end = Util.locateSequence(Util.LITERAL_STRING_END, data, string_end + 1);
        }
        data = data.slice(string_start + 1, string_end);
        return { result: Util.unescapeString(data), start_index: string_start, end_index: string_end };
    };
    /**
     * Returns the value of an option
     * /<option>
     *
     * so for instance for /Highlight it would return 'Highlight'
     *
     * The index must point to the "/"
     * */
    Util.extractOptionValue = function (data, index) {
        if (index === void 0) { index = 0; }
        if (data[index] !== 47)
            throw Error("misplaced option value pointer");
        var end = Util.locateDelimiter(data, index + 1);
        return { result: Util.convertAsciiToString(Array.from(data.slice(index + 1, end + 1))), start_index: index, end_index: end };
    };
    /**
     * Parses the ascii encoded number of the PDF file
     * */
    Util.extractNumber = function (data, start, end) {
        if (end === void 0) { end = -1; }
        start = Util.skipDelimiter(data, start);
        if (-1 == end) {
            end = Util.locateDelimiter(data, start);
        }
        if (end < start) {
            throw Error("Could not identify number bounds: [".concat(start, ",").concat(end, "]"));
        }
        var str_id = "";
        for (var i = start; i <= end; ++i) {
            str_id += String.fromCharCode(data[i]);
        }
        if ("" === str_id) {
            throw Error("Could not parse number at position ".concat(start));
        }
        return { result: +str_id, start_index: start, end_index: end };
    };
    /**
     * Converts the given date into PDF formatting
     * */
    Util.convertDateToPDFDate = function (date) {
        var date_str = "D:";
        date_str += date.getFullYear();
        var month = String(date.getMonth() + 1);
        date_str += (month.length == 1 ? "0" : "") + month;
        var day = String(date.getDate());
        date_str += (day.length == 1 ? "0" : "") + day;
        var hours = String(date.getHours());
        date_str += (hours.length == 1 ? "0" : "") + hours;
        var minutes = String(date.getMinutes());
        date_str += (minutes.length == 1 ? "0" : "") + minutes;
        var seconds = String(date.getSeconds());
        date_str += (seconds.length == 1 ? "0" : "") + seconds;
        return date_str;
    };
    /**
     * Converts a unicode sequence into a string
     * */
    Util.convertUnicodeToString = function (val) {
        if (val instanceof Uint8Array)
            val = new Uint8Array(val);
        if (val[0] === 254 && val[1] === 255) {
            val = val.slice(2, val.length);
            var uintToString = function (uintArray) {
                var ret = "";
                for (var i = 0; i < uintArray.length - 1; i += 2) {
                    ret += String.fromCharCode((uintArray[i] << 8) | uintArray[i + 1] & 0xFF);
                }
                return ret;
            };
            var ret_1 = uintToString(val);
            return ret_1;
        }
        // handle utf-8 compression
        var Utf8ArrayToStr = function (array) {
            var ret = "";
            var i = 0;
            while (i < array.length) {
                var char1 = array[i++];
                var char2 = void 0;
                switch (char1 >> 4) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        // one byte
                        ret += String.fromCharCode(char1);
                        break;
                    case 12:
                    case 13:
                        // two byte sequence
                        char2 = array[i++];
                        ret += String.fromCharCode(((char1 & 0x1F) << 6) | (char2 & 0x3F));
                        break;
                    case 14:
                        // three byte sequence
                        char2 = array[i++];
                        var char3 = array[i++];
                        ret += String.fromCharCode(((char1 & 0x0F) << 12) |
                            ((char2 & 0x3F) << 6) |
                            ((char3 & 0x3F) << 0));
                        break;
                }
            }
            return ret;
        };
        var ret = Utf8ArrayToStr(Array.from(val));
        return ret;
    };
    Util.convertAsciiToString = function (val) {
        var ret = "";
        for (var i = 0; i < val.length; ++i) {
            ret += String.fromCharCode(val[i]);
        }
        return ret;
    };
    /**
     * takes a number and returns an array of its char representations
     * */
    Util.convertNumberToCharArray = function (nbr) {
        return Util.convertStringToAscii(String(nbr));
    };
    /**
     * Converts a hex string into a byte array
     * That means two consecutive hex values are merged into one byte that is appended to the array
     * */
    Util.convertHexStringToByteArray = function (hex_string) {
        var ret_val = [];
        if (typeof hex_string !== "string") {
            hex_string = Util.convertAsciiToString(hex_string);
        }
        for (var i = 0; i < hex_string.length - 1; i += 2) {
            ret_val.push((parseInt(hex_string.charAt(i), 16) << 4) + parseInt(hex_string.charAt(i + 1), 16));
        }
        if (hex_string.length % 2 !== 0) {
            ret_val.push(parseInt(hex_string.charAt(hex_string.length - 1), 16));
        }
        return ret_val;
    };
    /**
     * Converts an array of byte values into a hex string
     * */
    Util.convertByteArrayToHexString = function (values) {
        var ret_val = "";
        var HEX_VALUES = "0123456789ABCDEF";
        for (var i_1 = 0; i_1 < values.length; ++i_1) {
            ret_val += HEX_VALUES.charAt(values[i_1] >> 4);
            ret_val += HEX_VALUES.charAt(values[i_1] & 15);
        }
        // remove leading zeros
        var i = 0;
        while ('0' === ret_val.charAt(i) && i < ret_val.length)
            ++i;
        return ret_val.slice(i, ret_val.length);
    };
    /**
     * takes two arrays and checks their equality
     * */
    Util.areArraysEqual = function (array_one, array_two) {
        if (array_one.length !== array_two.length)
            return false;
        for (var i = 0; i < array_one.length; ++i) {
            if (array_one[i] !== array_two[i])
                return false;
        }
        return true;
    };
    /**
     * Prints the array with leading indexes 10 bytes in a row
     * Delimiter are substituted by '.'
     * */
    Util.debug_printIndexed = function (array) {
        var outp = "";
        for (var i = 0; i < array.length; ++i) {
            if (i % 10 === 0) {
                outp += "\n" + i + ":";
            }
            if (Util.isSpace(array[i]))
                outp += " .";
            else
                outp += " " + String.fromCharCode(array[i]);
        }
        console.log(outp);
    };
    /**
     * Converts a list of 8 bit integers into a list of 32 bit integers
     * */
    Util.convertUint8ArrayToInt32Array = function (a) {
        var ret_val = new Int32Array(Math.ceil(a.length / 4));
        var i = 0;
        var index = 0;
        while (i < a.length) {
            if (a[i] > 255 || a[i + 1] > 255 || a[i + 2] >> 255 || a[i + 3] > 255)
                throw Error("Invalid byte size");
            ret_val[index++] = (a[i++] << 24) + (a[i++] << 16) + (a[i++] << 8) + (a[i++] << 0);
        }
        return ret_val;
    };
    /**
     * Converts a list of 32 bit integers into a list of 8 bit UNSIGNED integers
     * */
    Util.convertInt32ArrayToUint8Array = function (a) {
        var ret_val = new Uint8Array(a.length * 4);
        for (var i = 0; i < a.length; ++i) {
            for (var j = 0; j < 4; ++j) {
                ret_val[i * 4 + j] = (a[i] >> 8 * (4 - j - 1)) & 0xFF;
            }
        }
        return ret_val;
    };
    /**
     * Adds escape symbols to specific elements of the provided string
     *
     * Symbols that needs to be escaped are: \ ) (
     * */
    Util.escapeString = function (array) {
        var ret_val = [];
        for (var i = 0; i < array.length; ++i) {
            switch (array[i]) {
                case Util.LITERAL_STRING_START[0]:
                case Util.LITERAL_STRING_END[0]:
                case 92: // 92 = '\'
                    ret_val.push(92);
                    ret_val.push(array[i]);
                    break;
                case 9: // 9 = TAB
                    ret_val.push(92);
                    ret_val.push(116); // \t
                    break;
                case 10: // 10 = LINE FEED
                    ret_val.push(92);
                    ret_val.push(110); // \n
                    break;
                case 13: // 13 = CARRIAGE RETURN
                    ret_val.push(92);
                    ret_val.push(114); // \r
                    break;
                case 8: // 8 = BACKSPACE
                    ret_val.push(92);
                    ret_val.push(98); // \b
                    break;
                case 12: // 255 = FORM FEED
                    ret_val.push(92);
                    ret_val.push(102); // \f
                    break;
                default:
                    ret_val.push(array[i]);
            }
        }
        return new Uint8Array(ret_val);
    };
    /**
     * Removes escape symbols from the given string
     *
     * Symbols that needs to be escaped are: \ ) (
     * */
    Util.unescapeString = function (array) {
        var ret_val = [];
        var in_escape = false;
        for (var i = 0; i < array.length; ++i) {
            if (in_escape) {
                in_escape = false;
                switch (array[i]) {
                    case 92: // \
                        ret_val.push(92);
                        break;
                    case Util.LITERAL_STRING_START[0]:
                        ret_val.push(Util.LITERAL_STRING_START[0]);
                        break;
                    case Util.LITERAL_STRING_END[0]:
                        ret_val.push(Util.LITERAL_STRING_END[0]);
                        break;
                    case 116: // \t
                        ret_val.push(9);
                        break;
                    case 110: // \n
                        ret_val.push(10);
                        break;
                    case 114: // \r
                        ret_val.push(13);
                        break;
                    case 98: // \b
                        ret_val.push(8);
                        break;
                    case 102: // \f
                        ret_val.push(12);
                        break;
                    default:
                        ret_val.push(array[i]);
                }
            }
            else {
                if (array[i] === 92) {
                    in_escape = true;
                }
                else {
                    ret_val.push(array[i]);
                }
            }
        }
        return new Uint8Array(ret_val);
    };
    /**
     * Returns true, if the object corresponds to the interface of a reference pointer.
     * */
    Util.isReferencePointer = function (obj) {
        return ("obj" in obj && "generation" in obj && Object.keys(obj).length == 2);
    };
    /**
     * If color is provided in range [0,1) it will map these values in the color range [0, 255]
     * */
    Util.colorToRange255 = function (color) {
        if (color.r <= 1) {
            color.r = Math.round(color.r * 255);
        }
        if (color.g <= 1) {
            color.g = Math.round(color.g * 255);
        }
        if (color.b <= 1) {
            color.b = Math.round(color.b * 255);
        }
        return color;
    };
    /**
     * If color is provided in range [0,255] it will map these values in the color range [0, 1]
     * */
    Util.colorToRange01 = function (color) {
        if (color.r > 1) {
            color.r = +(color.r / 255).toFixed(3);
        }
        if (color.g > 1) {
            color.g = +(color.g / 255).toFixed(3);
        }
        if (color.b > 1) {
            color.b = +(color.b / 255).toFixed(3);
        }
        return color;
    };
    /**
     * Returns the HTML color hex code of the provided color
     * */
    Util.colorToHex = function (color) {
        if (color.r <= 1 || color.g <= 1 || color.b <= 1) {
            color = Util.colorToRange255(color);
        }
        var r = color.r.toString(16);
        r = r.length === 1 ? "0" + r : r;
        var g = color.g.toString(16);
        g = g.length === 1 ? "0" + g : g;
        var b = color.b.toString(16);
        b = b.length === 1 ? "0" + b : b;
        return "#".concat(r.toUpperCase()).concat(g.toUpperCase()).concat(b.toUpperCase());
    };
    /**
     * Converts a string into a byte string / hex string <12AFA3>
     * */
    Util.convertStringToByteString = function (value) {
        var ret_value = __spreadArray([], Util.HEX_STRING_START, true);
        var hex_val = Util.convertByteArrayToHexString(Util.convertStringToAscii(value));
        ret_value = ret_value.concat(Util.convertStringToAscii(hex_val));
        ret_value = ret_value.concat(Util.HEX_STRING_END);
        return ret_value;
    };
    /**
     * Converts a string into a byte string / hex string <12AFA3>
     * */
    Util.convertStringToHexString = function (value) {
        return Util.convertStringToByteString(value);
    };
    Util.VERSION = [37, 80, 68, 70, 45]; // %PDF-
    Util.COMMENT_START = [37]; // '%'
    Util.NULL = [110, 117, 108, 108]; // null
    Util.DOT = 46;
    Util.CR = 13;
    Util.LF = 10;
    Util.TYPE = "/Type ";
    Util.SPACE = 32;
    Util.OBJ = [111, 98, 106]; // 'obj'
    Util.ENDOBJ = [101, 110, 100, 111, 98, 106]; // 'endobj'
    Util.ARRAY_START = [91]; // '['
    Util.ARRAY_END = [93]; // ']'
    Util.LITERAL_STRING_START = [40]; // '('
    Util.HEX_STRING_START = [60]; // '<'
    Util.LITERAL_STRING_END = [41]; // ')'
    Util.HEX_STRING_END = [62]; // '>'
    Util.R = [82]; // 'R'
    Util.ANNOTS = [47, 65, 110, 110, 111, 116, 115]; // '/Annot'
    Util.DICT_START = [60, 60]; // '<<'
    Util.DICT_END = [62, 62]; // '>>'
    Util.PAGE = [47, 80, 97, 103, 101];
    Util.SIZE = [47, 83, 105, 122, 101]; // /Size
    Util.ROOT = [47, 82, 111, 111, 116]; // /Root
    Util.PREV = [47, 80, 114, 101, 118]; // /Prev
    Util.STARTXREF = [115, 116, 97, 114, 116, 120, 114, 101, 102]; // = 'startxref'
    Util.XREF = [120, 114, 101, 102]; // = 'xref'
    Util.STREAM = [115, 116, 114, 101, 97, 109]; // = 'stream'
    Util.TRAILER = [116, 114, 97, 105, 108, 101, 114]; // = 'trailer'
    return Util;
}());
exports.Util = Util;


/***/ }),

/***/ "./src/annotate/writer-util.ts":
/*!*************************************!*\
  !*** ./src/annotate/writer-util.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.WriterUtil = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var stream_1 = __webpack_require__(/*! ./stream */ "./src/annotate/stream.ts");
var WriterUtil = /** @class */ (function () {
    function WriterUtil() {
    }
    /**
     * Writes a reference pointer
     *
     * <obj_id> <generation> R
     *
     * The 'R' and the preceding space is only written in case 'referenced' is true
     * */
    WriterUtil.writeReferencePointer = function (ref, referenced) {
        if (referenced === void 0) { referenced = false; }
        var ret = util_1.Util.convertNumberToCharArray(ref.obj);
        ret.push(util_1.Util.SPACE);
        ret = ret.concat(util_1.Util.convertNumberToCharArray(ref.generation));
        if (referenced) {
            ret.push(util_1.Util.SPACE);
            ret.push.apply(ret, util_1.Util.R);
        }
        return ret;
    };
    /**
     * Adds preceding zeros (0) in front of the 'value' to match the length
     * */
    WriterUtil.pad = function (length, value) {
        value = String(value);
        var ret = [];
        for (var i = 0; i < length - value.length; ++i) {
            ret.push(48);
        }
        ret = ret.concat(util_1.Util.convertNumberToCharArray(value));
        return ret;
    };
    /**
     * Writes a nested number array
     * */
    WriterUtil.writeNestedNumberArray = function (array) {
        var ret = __spreadArray([], util_1.Util.ARRAY_START, true);
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var subArray = array_1[_i];
            ret = ret.concat(WriterUtil.writeNumberArray(subArray));
            ret.push(util_1.Util.SPACE);
        }
        ret.push.apply(ret, util_1.Util.ARRAY_END);
        return ret;
    };
    /**
     * Writes a javascript number array to a PDF number array
     * */
    WriterUtil.writeNumberArray = function (array) {
        var ret = __spreadArray([], util_1.Util.ARRAY_START, true);
        for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
            var i = array_2[_i];
            ret = ret.concat(util_1.Util.convertNumberToCharArray(i));
            ret.push(util_1.Util.SPACE);
        }
        ret.push.apply(ret, util_1.Util.ARRAY_END);
        return ret;
    };
    /**
     * Replaces the /Annots field in an page object
     *
     * ptr : Pointer to the page object
     * annot_array_reference : The reference to the annotation array
     * */
    WriterUtil.replaceAnnotsFieldInPageObject = function (data, page, page_ptr, annot_array_reference) {
        var ptr_objend = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, page_ptr, true);
        var complete_page_object_data = data.slice(page_ptr, ptr_objend + util_1.Util.ENDOBJ.length);
        var ret = [];
        if (page.hasAnnotsField) {
            // in this case the page object directly contains an array of references and
            // does not point to an array array object -- we replace the array of references with a pointer
            // to the reference array
            var ptr_annots = util_1.Util.locateSequence(util_1.Util.ANNOTS, complete_page_object_data, 0, true);
            ret = Array.from(complete_page_object_data.slice(0, ptr_annots + util_1.Util.ANNOTS.length));
            ret.push(util_1.Util.SPACE);
            ret = ret.concat(WriterUtil.writeReferencePointer(annot_array_reference, true));
            ret.push(util_1.Util.SPACE);
            var ptr_annots_array_end = util_1.Util.locateSequence(util_1.Util.ARRAY_END, complete_page_object_data, ptr_annots, true) + util_1.Util.ARRAY_END.length;
            ret = ret.concat(Array.from(complete_page_object_data.slice(ptr_annots_array_end, complete_page_object_data.length)));
        }
        else {
            var ptr_dict_end = util_1.Util.locateSequenceReversed(util_1.Util.DICT_END, complete_page_object_data, complete_page_object_data.length - 1);
            if (-1 === ptr_dict_end)
                throw Error("Could not identify dictionary end");
            ret = Array.from(complete_page_object_data.slice(0, ptr_dict_end));
            ret = ret.concat(util_1.Util.ANNOTS);
            ret.push(util_1.Util.SPACE);
            ret = ret.concat(WriterUtil.writeReferencePointer(annot_array_reference, true));
            ret.push(util_1.Util.SPACE);
            ret = ret.concat(Array.from(complete_page_object_data.slice(ptr_dict_end, complete_page_object_data.length)));
        }
        ret.push(util_1.Util.CR);
        ret.push(util_1.Util.LF);
        return ret;
    };
    /**
     * Writes the given object as stream object. Handels all the necessary stuff
     * object_id: The reference pointer id and generation
     * dict: dictionary fields that must be added to the stream object. Must be already encoded in bytes
     * stream: The stream content. Note, that the stream output will be only compressed if you provide a stream object. Number arrays will be processed unaltered.
     * */
    WriterUtil.writeStreamObject = function (object_id, dict, stream) {
        var streamData = stream;
        var compressed = false;
        if (stream instanceof stream_1.Stream) {
            streamData = Array.from(stream.encode());
            compressed = true;
        }
        var ret = WriterUtil.writeReferencePointer(object_id);
        ret.push(WriterUtil.SPACE);
        ret = ret.concat(WriterUtil.OBJ);
        ret.push(WriterUtil.CR);
        ret.push(WriterUtil.LF);
        ret = ret.concat(WriterUtil.DICT_START);
        ret.push(WriterUtil.SPACE);
        if (compressed) {
            ret = ret.concat(WriterUtil.FILTER);
            ret.push(WriterUtil.SPACE);
            ret = ret.concat(WriterUtil.FLATEDECODE);
            ret.push(WriterUtil.SPACE);
        }
        ret = ret.concat(WriterUtil.LENGTH);
        ret.push(WriterUtil.SPACE);
        ret = ret.concat(util_1.Util.convertNumberToCharArray(streamData.length));
        ret.push(WriterUtil.SPACE);
        ret = ret.concat(dict);
        ret = ret.concat(WriterUtil.DICT_END);
        ret = ret.concat(WriterUtil.STREAM);
        ret.push(WriterUtil.CR);
        ret.push(WriterUtil.LF);
        ret = ret.concat(streamData);
        ret.push(WriterUtil.CR);
        ret.push(WriterUtil.LF);
        ret = ret.concat(WriterUtil.ENDSTREAM);
        ret.push(WriterUtil.CR);
        ret.push(WriterUtil.LF);
        ret = ret.concat(WriterUtil.ENDOBJ);
        ret.push(WriterUtil.CR);
        ret.push(WriterUtil.LF);
        return ret;
    };
    WriterUtil.N = 110;
    WriterUtil.F = 102;
    WriterUtil.q = 113;
    WriterUtil.Q = 81;
    WriterUtil.BT = [66, 84]; // = 'BT'
    WriterUtil.ET = [69, 84]; // = 'ET'
    WriterUtil.BMC = [66, 77, 67]; // = 'BMC'
    WriterUtil.EMC = [69, 77, 67]; // = 'EMC'
    WriterUtil.AP_N = [47, 78]; // = '/N'
    WriterUtil.AP_D = [47, 68]; // = '/D'
    WriterUtil.AP_R = [47, 82]; // = '/R'
    WriterUtil.SPACE = 32;
    WriterUtil.CR = 13;
    WriterUtil.LF = 10;
    WriterUtil.AP = [47, 65, 80]; // = '/AP'
    WriterUtil.OBJ = [111, 98, 106];
    WriterUtil.ENDOBJ = [101, 110, 100, 111, 98, 106];
    WriterUtil.ENCRYPT = [47, 69, 110, 99, 114, 121, 112, 116];
    WriterUtil.ARRAY_START = 91;
    WriterUtil.OPEN = [47, 79, 112, 101, 110];
    WriterUtil.ARRAY_END = 93;
    WriterUtil.DICT_START = [60, 60];
    WriterUtil.HEX_STRING_START = [60];
    WriterUtil.HEX_STRING_END = [62];
    WriterUtil.DICT_END = [62, 62];
    WriterUtil.TYPE0 = [47, 84, 121, 112, 101, 48]; // /Type0
    WriterUtil.TYPE1 = [47, 84, 121, 112, 101, 49]; // /Type1
    WriterUtil.TYPE3 = [47, 84, 121, 112, 101, 51]; // /Type3
    WriterUtil.MMTYPE1 = [47, 77, 77, 84, 121, 112, 101, 49]; // /MMType1
    WriterUtil.TRUETYPE = [47, 84, 114, 117, 101, 84, 121, 112, 101]; // /TrueType
    WriterUtil.CIDFONTTYPE0 = [47, 67, 73, 68, 70, 111, 110, 116, 84, 121, 112, 101, 48]; // /CIDFontType0
    WriterUtil.CIDFONTTYPE2 = [47, 67, 73, 68, 70, 111, 110, 116, 84, 121, 112, 101, 50]; // /CIDFontType2
    WriterUtil.TYPE_ANNOT = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 65, 110, 110, 111, 116];
    WriterUtil.TYPE_XOBJECT = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 88, 79, 98, 106, 101, 99, 116];
    WriterUtil.TYPE_EXTGSTATE = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 69, 120, 116, 71, 83, 116, 97, 116, 101];
    WriterUtil.TYPE_FONTDESCRIPTOR = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 70, 111, 110, 116, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114];
    WriterUtil.TYPE_FONT = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 70, 111, 110, 116];
    WriterUtil.FONTNAME = [47, 70, 111, 110, 116, 78, 97, 109, 101]; // = '/FontName'
    WriterUtil.FONTFAMILY = [47, 70, 111, 110, 116, 70, 97, 109, 105, 108, 121]; // = '/FontFamily'
    WriterUtil.FONTSTRETCH = [47, 70, 111, 110, 116, 83, 116, 114, 101, 116, 99, 104]; // = '/FontStretch'
    WriterUtil.FLAGS = [47, 70, 108, 97, 103, 115]; // = '/Flags'
    WriterUtil.FONTBBOX = [47, 70, 111, 110, 116, 66, 66, 111, 120]; // = '/FontBBox'
    WriterUtil.ITALICANGLE = [47, 73, 116, 97, 108, 105, 99, 65, 110, 103, 108, 101]; // = '/ItalicAngle'
    WriterUtil.ASCENT = [47, 65, 115, 99, 101, 110, 116]; // = '/Ascent'
    WriterUtil.DESCENT = [47, 68, 101, 115, 99, 101, 110, 116]; // = '/Descent'
    WriterUtil.LEADING = [47, 76, 101, 97, 100, 105, 110, 103]; // = '/Leading'
    WriterUtil.CAPHEIGHT = [47, 67, 97, 112, 72, 101, 105, 103, 104, 116]; // = '/CapHeight'
    WriterUtil.XHEIGHT = [47, 88, 72, 101, 105, 103, 104, 116]; // = '/XHeight'
    WriterUtil.STEMV = [47, 83, 116, 101, 109, 86]; // = '/StemV'
    WriterUtil.ENCODING = [47, 69, 110, 99, 111, 100, 105, 110, 103]; // = '/Encoding'
    WriterUtil.STEMH = [47, 83, 116, 101, 109, 2]; // = '/StemH'
    WriterUtil.AVGWIDTH = [47, 65, 118, 103, 87, 105, 100, 116, 104]; // = '/AvgWidth'
    WriterUtil.MAXWIDTH = [47, 77, 97, 120, 87, 105, 100, 116, 104]; // = '/MaxWidth'
    WriterUtil.MISSINGWIDTH = [47, 77, 105, 115, 115, 105, 110, 103, 87, 105, 100, 116, 104]; // = '/MissingWidth'
    WriterUtil.FIRSTCHAR = [47, 70, 105, 114, 115, 116, 67, 104, 97, 114]; // = '/FirstChar'
    WriterUtil.LASTCHAR = [47, 76, 97, 115, 116, 67, 104, 97, 114]; // = '/LastChar'
    WriterUtil.BASEFONT = [47, 66, 97, 115, 101, 70, 111, 110, 116]; // = '/BaseFont'
    WriterUtil.WIDTHS = [47, 87, 105, 100, 116, 104, 115]; // = '/Widths'
    WriterUtil.FONTDESCRIPTOR = [47, 70, 111, 110, 116, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114]; // = '/FontDescriptor'
    WriterUtil.XOBJECT = [47, 88, 79, 98, 106, 101, 99, 116]; // = '/XObject'
    WriterUtil.EXTGSTATE = [47, 69, 120, 116, 71, 83, 116, 97, 116, 101]; // = '/ExtGState'
    WriterUtil.COLORSPACE = [47, 67, 111, 108, 111, 114, 83, 112, 97, 99, 101]; // = '/ColorSpace'
    WriterUtil.PATTERN = [47, 80, 97, 116, 116, 101, 114, 110]; // = '/Pattern'
    WriterUtil.SHADING = [47, 83, 104, 97, 100, 105, 110, 103]; // = '/Shading'
    WriterUtil.FONT = [47, 70, 111, 110, 116]; // = '/Font'
    WriterUtil.PROCSET = [47, 80, 114, 111, 99, 83, 101, 116]; // = '/ProcSet'
    WriterUtil.PROPERTIES = [47, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115]; // = '/Properties'
    WriterUtil.RECT = [47, 82, 101, 99, 116];
    WriterUtil.RESOURCES = [47, 82, 101, 115, 111, 117, 114, 99, 101, 115]; // = '/Resources'
    WriterUtil.SUBTYPE = [47, 83, 117, 98, 116, 121, 112, 101];
    WriterUtil.FORM = [47, 70, 111, 114, 109]; // = '/Form'
    WriterUtil.UPDATE_DATE = [47, 77]; // = '/M'
    WriterUtil.AUTHOR = [47, 84]; // = '/T'
    WriterUtil.CONTENTS = [47, 67, 111, 110, 116, 101, 110, 116, 115]; // = '/Contents'
    WriterUtil.BRACKET_START = 40;
    WriterUtil.BRACKET_END = 41;
    WriterUtil.FLAG = [47, 70]; // = '/F'
    WriterUtil.ID = [47, 78, 77]; // = '/NM'
    WriterUtil.DOCUMENT_ID = [47, 73, 68]; // = '/ID'
    WriterUtil.COLOR = [47, 67]; // = '/C'
    WriterUtil.FILL = [47, 73, 67]; // = '/IC'
    WriterUtil.STATE = [47, 83, 116, 97, 116, 101]; // = '/State'
    WriterUtil.STATEMODEL = [47, 83, 116, 97, 116, 101, 77, 111, 100, 101, 108]; // = '/StateModel'
    WriterUtil.OPACITY = [47, 67, 65]; // = '/CA'
    WriterUtil._OPACITY = [47, 99, 97]; // = '/ca'
    WriterUtil.BORDER = [47, 66, 111, 114, 100, 101, 114]; // = '/Border'
    WriterUtil.PAGE_REFERENCE = [47, 80]; // = '/P'
    WriterUtil.DEFAULT_APPEARANCE = [47, 68, 65]; // = '/DA'
    WriterUtil.INKLIST = [47, 73, 110, 107, 76, 105, 115, 116]; // = '/InkList'
    WriterUtil.FILTER = [47, 70, 105, 108, 116, 101, 114]; // = '/Filter'
    WriterUtil.FLATEDECODE = [47, 70, 108, 97, 116, 101, 68, 101, 99, 111, 100, 101]; // = '/FlateDecode'
    WriterUtil.LENGTH = [47, 76, 101, 110, 103, 116, 104]; // = '/Length'
    WriterUtil.STREAM = [115, 116, 114, 101, 97, 109]; // = 'stream'
    WriterUtil.ENDSTREAM = [101, 110, 100, 115, 116, 114, 101, 97, 109]; // = 'endstream'
    WriterUtil.FORMTYPE = [47, 70, 111, 114, 109, 84, 121, 112, 101]; // = '/FormType'
    WriterUtil.MATRIX = [47, 77, 97, 116, 114, 105, 120]; // = '/Matrix'
    WriterUtil.BBOX = [47, 66, 66, 111, 120]; // = '/BBox'
    WriterUtil.RC = [47, 82, 67]; // = '/RC'
    WriterUtil.CREATION_DATE = [47, 67, 114, 101, 97, 116, 105, 111, 110, 68, 97, 116, 101]; // = '/CreationDate'
    WriterUtil.SUBJ = [47, 83, 117, 98, 106]; // = '/Subj'
    WriterUtil.TRAILER = [116, 114, 97, 105, 108, 101, 114]; // = 'trailer'
    WriterUtil.SIZE = [47, 83, 105, 122, 101]; // = '/Size'
    WriterUtil.ROOT = [47, 82, 111, 111, 116]; // = '/Root'
    WriterUtil.PREV = [47, 80, 114, 101, 118]; // ='/Prev'
    WriterUtil.STARTXREF = [115, 116, 97, 114, 116, 120, 114, 101, 102]; // = 'startxref'
    WriterUtil.EOF = [37, 37, 69, 79, 70]; // = '%%EOF'
    WriterUtil.TRUE = [116, 114, 117, 101]; // = 'true'
    WriterUtil.XREF = [120, 114, 101, 102]; // = 'xref'
    WriterUtil.TEXT_JUSTIFICATION = [47, 81]; // = '/Q'
    WriterUtil.DEFAULT_STYLE_STRING = [47, 68, 83]; // = '/DS'
    WriterUtil.DIFFERENCE_RECTANGLE = [47, 82, 68]; // = '/RD'
    WriterUtil.IT = [47, 73, 84]; // = '/IT'
    WriterUtil.LINE_ENDING = [47, 76, 69]; // = '/LE'
    WriterUtil.CALLOUT_LINE = [47, 67, 76]; // = '/CL'
    WriterUtil.QUADPOINTS = [47, 81, 117, 97, 100, 80, 111, 105, 110, 116, 115]; // = '/QuadPoints'
    WriterUtil.VERTICES = [47, 86, 101, 114, 116, 105, 99, 101, 115]; // = '/Vertices'
    WriterUtil.NAME = [47, 78, 97, 109, 101]; // = '/Name'
    WriterUtil.DRAFT = [47, 68, 114, 97, 102, 116]; // = '/Draft'
    WriterUtil.SY = [47, 83, 121]; // = '/Sy'
    WriterUtil.P = 80;
    return WriterUtil;
}());
exports.WriterUtil = WriterUtil;


/***/ }),

/***/ "./src/annotate/writer.ts":
/*!********************************!*\
  !*** ./src/annotate/writer.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.Writer = void 0;
var util_1 = __webpack_require__(/*! ./util */ "./src/annotate/util.ts");
var object_util_1 = __webpack_require__(/*! ./object-util */ "./src/annotate/object-util.ts");
var writer_util_1 = __webpack_require__(/*! ./writer-util */ "./src/annotate/writer-util.ts");
/**
 * Creats the byte array that must be attached to the end of the document
 * */
var Writer = /** @class */ (function () {
    /**
     * data : The data representing the original PDF document
     * aannotations : The annotations to add to the document
     * */
    function Writer(data, annotations, toDelete, parser) {
        this.data = data;
        this.annotations = annotations;
        this.toDelete = toDelete;
        this.parser = parser;
        /**
         * Holds the crossite reference table
         * */
        this.xrefs = [];
        this.data = new Uint8Array(data);
        this.cryptoInterface = parser.getCryptoInterface();
    }
    /**
     * Sorts the annotations pagewise.
     *
     * This is necessary since the annotation arrays of the sites must be extended
     * and it makes sense to do this update in one step.
     * */
    Writer.prototype.sortPageWise = function (annotations) {
        var pageAnnots = {};
        for (var _i = 0, annotations_1 = annotations; _i < annotations_1.length; _i++) {
            var annot = annotations_1[_i];
            if (!pageAnnots[annot.page])
                pageAnnots[annot.page] = [];
            pageAnnots[annot.page].push(annot);
        }
        return pageAnnots;
    };
    /**
     * It returns the page object either extended by a /Annots field, if this did not exist yet or with the annots field replaced by a rerference pointer
     * to an array if the page object contains the list of annotations directly
     *
     * ptr : Pointer to the page object
     * annot_array_reference : The reference to the annotation array
     * */
    Writer.prototype.adaptPageObject = function (page, annot_array_reference) {
        if (!page.object_id)
            throw Error("Page without object id");
        var ret = [];
        var lookupTable = this.parser.documentHistory.createObjectLookupTable();
        var page_ptr = lookupTable[page.object_id.obj];
        if (page_ptr.compressed) {
            var obj = object_util_1.ObjectUtil.extractObject(this.data, page_ptr, lookupTable);
            var obj_data = obj.stream.getData().slice(obj.pointer_stream_start, obj.pointer_stream_end + 1);
            var ref_ptr = writer_util_1.WriterUtil.writeReferencePointer(obj.id, false).concat(32);
            var new_data = new Uint8Array(ref_ptr.length + writer_util_1.WriterUtil.OBJ.length + obj_data.length + writer_util_1.WriterUtil.ENDOBJ.length);
            new_data.set(ref_ptr);
            new_data.set(writer_util_1.WriterUtil.OBJ, ref_ptr.length);
            new_data.set(obj_data, writer_util_1.WriterUtil.OBJ.length + ref_ptr.length);
            new_data.set(writer_util_1.WriterUtil.ENDOBJ, writer_util_1.WriterUtil.OBJ.length + obj_data.length + ref_ptr.length);
            return writer_util_1.WriterUtil.replaceAnnotsFieldInPageObject(new_data, page, 0, annot_array_reference);
        }
        return writer_util_1.WriterUtil.replaceAnnotsFieldInPageObject(this.data, page, page_ptr.pointer, annot_array_reference);
    };
    /**
     * Takes the annotations of >>one<< page and derives the annotations array from it.
     * Thereby it also considers the potentially existing annotation array.
     *
     * toDelete := contains those annotations that must be deleted. It removes them from the reference array
     * and marks them as removed
     * */
    Writer.prototype.writeAnnotArray = function (annots, toDelete) {
        var page = annots[0].pageReference;
        if (!page)
            throw Error("Missing page reference");
        if (!page.object_id)
            throw Error("Page without object id");
        var references = page.annots;
        references = references.concat(annots.map(function (x) {
            if (!x.object_id)
                throw Error("Annotation with object_id null");
            return x.object_id;
        }));
        // remove annotation references from the array that must be deleted and mark them as deleted
        references = references.filter(function (a) {
            var toDel = toDelete.find(function (t) { return t.object_id.obj === a.obj && t.object_id.generation === a.generation; });
            if (toDel) {
                toDel.is_deleted = true;
                return false;
            }
            return true;
        });
        var refArray_id = page.annotsPointer;
        var page_data = [];
        if (!refArray_id) {
            refArray_id = this.parser.getFreeObjectId();
            page_data = this.adaptPageObject(page, refArray_id);
        }
        var ret = writer_util_1.WriterUtil.writeReferencePointer(refArray_id);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.OBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret.push(writer_util_1.WriterUtil.ARRAY_START);
        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
            var an = references_1[_i];
            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(an, true));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret.push(writer_util_1.WriterUtil.ARRAY_END);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        return { ptr: refArray_id, data: ret, pageReference: page.object_id, pageData: page_data };
    };
    /**
     * Writes an annotation object
     * */
    Writer.prototype.writeAnnotationObject = function (annot) {
        //if ((annot as _Annotation).stampType) {
        //    ret = ret.concat(Writer.NAME)
        //    ret.push(Writer.SPACE)
        //    ret = ret.concat(Writer.DRAFT)
        //    ret.push(Writer.SPACE)
        //}
        //if ((annot as _Annotation).caretSymbol) {
        //    ret = ret.concat(Writer.SY)
        //    ret.push(Writer.SPACE)
        //    ret.push(Writer.P)
        //    ret.push(Writer.SPACE)
        //}
        var ret = annot.writeAnnotationPreamble();
        ret = ret.concat(annot.writeAnnotationObject(this.cryptoInterface));
        ret = ret.concat(annot.writeAnnotationPostamble());
        return { ptr: annot.object_id, data: ret };
    };
    /**
     * Takes all the cross site reference table entries and extracts the consecutive sequences
     * */
    Writer.prototype.computeXrefSequences = function () {
        var seqs = [];
        var ordered_xrefs = this.xrefs.sort(function (a, b) {
            if (a.id < b.id)
                return -1;
            if (a.id > b.id)
                return 1;
            return 0;
        });
        var seq = [ordered_xrefs[0]];
        var last_id = ordered_xrefs[0].id;
        seqs.push(seq);
        for (var i = 1; i < ordered_xrefs.length; ++i) {
            if (ordered_xrefs[i].id === last_id + 1) {
                seq.push(ordered_xrefs[i]);
            }
            else {
                seq = [ordered_xrefs[i]];
                seqs.push(seq);
            }
            last_id = ordered_xrefs[i].id;
        }
        return seqs;
    };
    /**
     * Constructs the pointers of the linked list that contains the ids of freed objects
     * */
    Writer.prototype.applyObjectFreeing = function (refs) {
        // write free object head
        var head = this.parser.documentHistory.createObjectLookupTable()[0];
        var last_freed_object_id = head.id;
        var freed_objs = refs.filter(function (r) { return r.free; });
        freed_objs = freed_objs.sort(function (a, b) {
            if (a.id < b.id)
                return -1;
            if (a.id > b.id)
                return 1;
            return 0;
        });
        var lastobj = undefined;
        for (var _i = 0, freed_objs_1 = freed_objs; _i < freed_objs_1.length; _i++) {
            var obj = freed_objs_1[_i];
            if (!lastobj) {
                // set first object as list header
                head.pointer = obj.id;
            }
            if (lastobj) {
                lastobj.pointer = obj.id;
            }
            lastobj = obj;
        }
        if (freed_objs.length > 0)
            freed_objs[freed_objs.length - 1].pointer = last_freed_object_id;
        refs.push(head);
        return refs;
    };
    /**
     * Writes the crossite reference table
     * */
    Writer.prototype.writeCrossSiteReferenceTable = function () {
        var ret = __spreadArray([], writer_util_1.WriterUtil.XREF, true);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        this.xrefs = this.applyObjectFreeing(this.xrefs);
        var ordered_sequences = this.computeXrefSequences();
        for (var _i = 0, ordered_sequences_1 = ordered_sequences; _i < ordered_sequences_1.length; _i++) {
            var sequence = ordered_sequences_1[_i];
            var head = sequence[0];
            ret = ret.concat(util_1.Util.convertNumberToCharArray(head.id));
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret = ret.concat(util_1.Util.convertNumberToCharArray(sequence.length));
            ret.push(writer_util_1.WriterUtil.CR);
            ret.push(writer_util_1.WriterUtil.LF);
            for (var i = 0; i < sequence.length; ++i) {
                var _ret = [];
                _ret = _ret.concat(writer_util_1.WriterUtil.pad(10, sequence[i].pointer));
                _ret.push(writer_util_1.WriterUtil.SPACE);
                _ret = _ret.concat(writer_util_1.WriterUtil.pad(5, sequence[i].generation));
                _ret.push(writer_util_1.WriterUtil.SPACE);
                if (sequence[i].free)
                    _ret.push(writer_util_1.WriterUtil.F);
                if (sequence[i].update)
                    _ret.push(writer_util_1.WriterUtil.N);
                _ret.push(writer_util_1.WriterUtil.CR);
                _ret.push(writer_util_1.WriterUtil.LF);
                if (_ret.length < 20)
                    throw Error("XRef entry < 20 bytes");
                ret = ret.concat(_ret);
            }
        }
        return ret;
    };
    /**
     * Writes the trailer
     * */
    Writer.prototype.writeTrailer = function (posXref) {
        var ret = __spreadArray([], writer_util_1.WriterUtil.TRAILER, true);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);
        ret = ret.concat(writer_util_1.WriterUtil.SIZE);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.parser.documentHistory.trailerSize));
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (this.parser.documentHistory.isEncrypted()) {
            ret = ret.concat(writer_util_1.WriterUtil.ENCRYPT);
            ret.push(writer_util_1.WriterUtil.SPACE);
            var enc_ref = this.parser.getCryptoInterface().getEncryptionDictReference();
            if (!enc_ref)
                throw Error("No reference pointer to encryption dictionary");
            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(enc_ref, true));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        var trailer = this.parser.documentHistory.getRecentUpdate();
        if (trailer.id) {
            ret = ret.concat(writer_util_1.WriterUtil.DOCUMENT_ID);
            ret.push(writer_util_1.WriterUtil.SPACE);
            ret.push(writer_util_1.WriterUtil.ARRAY_START);
            for (var _i = 0, _a = trailer.id; _i < _a.length; _i++) {
                var val = _a[_i];
                ret.push(writer_util_1.WriterUtil.SPACE);
                ret = ret.concat(writer_util_1.WriterUtil.HEX_STRING_START);
                ret = ret.concat(util_1.Util.convertStringToAscii(util_1.Util.convertByteArrayToHexString(val)));
                ret = ret.concat(writer_util_1.WriterUtil.HEX_STRING_END);
                ret.push(writer_util_1.WriterUtil.SPACE);
            }
            ret.push(writer_util_1.WriterUtil.ARRAY_END);
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret = ret.concat(writer_util_1.WriterUtil.ROOT);
        ret.push(writer_util_1.WriterUtil.SPACE);
        if (!trailer.root)
            throw Error("No root object in trailer, although this is an cross reference table document");
        ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(trailer.root, true));
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.PREV);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.parser.documentHistory.getRecentUpdate().start_pointer));
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.STARTXREF);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(util_1.Util.convertNumberToCharArray(posXref));
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.EOF);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        return ret;
    };
    /**
     * Writes the annations at the end of the PDF byte representation and returns
     * the byte array
     * */
    Writer.prototype.write = function () {
        var pageWiseSorted = this.sortPageWise(this.annotations);
        var ptr = this.data.length;
        var new_data = [];
        // Fix case that there is no linebreak after the end of the file
        if (this.data[ptr - 1] === 70) { // 70 = 'F' (from [%%EO]F
            new_data.push(writer_util_1.WriterUtil.CR);
            new_data.push(writer_util_1.WriterUtil.LF);
            ptr += 2;
        }
        for (var key in pageWiseSorted) {
            var pageAnnots = pageWiseSorted[key];
            // write the array referencing to annotations of a certain page
            // it also removes references of annotations that must be deleted
            var annot_array = this.writeAnnotArray(pageAnnots, this.toDelete);
            this.xrefs.push({
                id: annot_array.ptr.obj,
                pointer: ptr,
                generation: annot_array.ptr.generation,
                free: false,
                update: true
            });
            new_data = new_data.concat(annot_array.data);
            ptr += annot_array.data.length;
            // add adapted page object if it exists -- In the case the page had no annotation yet there exists
            // no such array referring to its annotations. A pointer to such an array must be added to the
            // page object. If this was done the `pageData` paramater is set and contains the adapted page object
            if (annot_array.pageData.length > 0) {
                this.xrefs.push({
                    id: annot_array.pageReference.obj,
                    pointer: ptr,
                    generation: annot_array.pageReference.generation,
                    free: false,
                    update: true
                });
                new_data = new_data.concat(annot_array.pageData);
                ptr += annot_array.pageData.length;
            }
            // writes the actual annotation object
            for (var _i = 0, pageAnnots_1 = pageAnnots; _i < pageAnnots_1.length; _i++) {
                var annot = pageAnnots_1[_i];
                /**
                 * write additional objects, that are related to the newly created or adapted annotation
                 * */
                for (var _a = 0, _b = annot.additional_objects_to_write; _a < _b.length; _a++) {
                    var add_obj = _b[_a];
                    var data = add_obj.func(add_obj.obj, this.cryptoInterface);
                    this.xrefs.push({
                        id: add_obj.obj.object_id.obj,
                        pointer: ptr,
                        generation: add_obj.obj.object_id.generation,
                        free: false,
                        update: true
                    });
                    new_data = new_data.concat(data);
                    ptr += data.length;
                }
                var annot_obj = this.writeAnnotationObject(annot);
                this.xrefs.push({
                    id: annot_obj.ptr.obj,
                    pointer: ptr,
                    generation: annot_obj.ptr.generation,
                    free: false,
                    update: true
                });
                new_data = new_data.concat(annot_obj.data);
                ptr += annot_obj.data.length;
            }
        }
        // take all annotations that are not deleted yet
        var _toDelete = this.toDelete.filter(function (t) { return !t.is_deleted; });
        var pageWiseSortedToDelete = this.sortPageWise(_toDelete);
        // adapt the remaining annotation reference tables
        for (var key in pageWiseSortedToDelete) {
            var del_data = this.updatePageAnnotationReferenceArray(pageWiseSortedToDelete[key]);
            this.xrefs.push({
                id: del_data.ptr.obj,
                pointer: ptr,
                generation: del_data.ptr.generation,
                free: false,
                update: true
            });
            new_data = new_data.concat(del_data.data);
            ptr += del_data.data.length;
        }
        // write new fonts
        var fonts = this.parser.getFonts().getFontsToWrite();
        for (var _c = 0, fonts_1 = fonts; _c < fonts_1.length; _c++) {
            var font = fonts_1[_c];
            if (!font.object_id)
                throw Error("Font has no object id");
            var font_data = font.writeFont();
            this.xrefs.push({
                id: font.object_id.obj,
                pointer: ptr,
                generation: font.object_id.generation,
                free: false,
                update: true
            });
            new_data = new_data.concat(font_data);
            ptr += font_data.length;
        }
        // at this point all references to annotation objects in pages should be removed and we can free
        // the annotation object ids
        for (var _d = 0, _e = this.toDelete; _d < _e.length; _d++) {
            var toDel = _e[_d];
            if (!toDel.object_id)
                continue;
            this.xrefs.push({
                id: toDel.object_id.obj,
                pointer: -1,
                generation: toDel.object_id.generation + 1,
                free: true,
                update: false
            });
        }
        var crtable = this.writeCrossSiteReferenceTable();
        new_data = new_data.concat(crtable);
        var trailer = this.writeTrailer(ptr);
        new_data = new_data.concat(trailer);
        var new_data_array = new Uint8Array(new_data);
        var ret_array = new Uint8Array(this.data.length + new_data_array.length);
        ret_array.set(this.data);
        ret_array.set(new_data, this.data.length);
        return ret_array;
    };
    /**
     * Removes the given annotation
     * */
    Writer.prototype.updatePageAnnotationReferenceArray = function (toDelete) {
        var page = toDelete[0].pageReference;
        if (!page)
            throw Error("Missing page reference");
        if (!page.object_id) {
            throw Error("Page without object id");
        }
        var references = page.annots;
        // remove annotation references from the array that must be deleted and mark them as deleted
        references = references.filter(function (a) {
            var toDel = toDelete.find(function (t) { return t.object_id.obj === a.obj && t.object_id.generation === a.generation; });
            if (toDel) {
                toDel.is_deleted = true;
                return false;
            }
            return true;
        });
        var refArray_id = page.annotsPointer;
        var ret = writer_util_1.WriterUtil.writeReferencePointer(refArray_id);
        ret.push(writer_util_1.WriterUtil.SPACE);
        ret = ret.concat(writer_util_1.WriterUtil.OBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret.push(writer_util_1.WriterUtil.ARRAY_START);
        for (var _i = 0, references_2 = references; _i < references_2.length; _i++) {
            var an = references_2[_i];
            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(an, true));
            ret.push(writer_util_1.WriterUtil.SPACE);
        }
        ret.push(writer_util_1.WriterUtil.ARRAY_END);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);
        ret.push(writer_util_1.WriterUtil.CR);
        ret.push(writer_util_1.WriterUtil.LF);
        return { ptr: refArray_id, data: ret };
    };
    return Writer;
}());
exports.Writer = Writer;


/***/ }),

/***/ "./src/annotate_controller.js":
/*!************************************!*\
  !*** ./src/annotate_controller.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotateController": function() { return /* binding */ AnnotateController; }
/* harmony export */ });
const {AnnotationFactory} = __webpack_require__(/*! ./annotate/index.ts */ "./src/annotate/index.ts");
class AnnotateController{
    constructor(PDFViewerApplication,data,up="",op=""){
        this.PDFViewerApplication = PDFViewerApplication;
        this.pdfViewer = PDFViewerApplication.pdfViewer;

        this.AnnotationFactory = new AnnotationFactory(data,up,op);
        PDFViewerApplication.pdfAnnotator = this.AnnotationFactory;
        // 暂时禁用这部分代码，专注于onlineAnnotation
        // this._init();
    }
    getSelectionObject(r){
        const outBounding = JSON.parse(JSON.stringify(r.getRangeAt(0).getBoundingClientRect())); // deep copy
        let innerBounding=[];
        const contentNode = r.getRangeAt(0).cloneContents().children;
        if(contentNode.length==1){
            return {
                outBounding,
                innerBounding:null
            }
        }
        //console.log('Select Node',contentNode)
        for(let nodeIndex in contentNode){
            if(contentNode[nodeIndex].tagName!='SPAN') continue;
            let basePos = JSON.parse(JSON.stringify(document.querySelector(`span[style='${contentNode[nodeIndex].getAttribute('style')}']`).getBoundingClientRect()));
            if(nodeIndex==0){
                if(this._lastMouseDown.x>outBounding.left||this._lastMouseUp.x>outBounding.left){
                     // 选区在元素内，要减掉 但是要分情况(可以再化简，懒得弄了。。)
                    if(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y<this._lastMouseUp.y){
                        // 右上到左下
                        basePos.x=this._lastMouseDown.x
                        basePos.width = basePos.width-(this._lastMouseDown.x-outBounding.left)
                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y<this._lastMouseDown.y){
                        // 左下到右上
                        basePos.x=this._lastMouseUp.x
                        basePos.width = basePos.width-(this._lastMouseUp.x-outBounding.left)
                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y>this._lastMouseDown.y){
                        // 左上到右下
                        basePos.x=this._lastMouseDown.x
                        basePos.width = basePos.width-(this._lastMouseDown.x-outBounding.left)
                    }else{
                        // 右下到左上(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y>this._lastMouseUp.y)
                        basePos.x=this._lastMouseUp.x
                        basePos.width = basePos.width-(this._lastMouseUp.x-outBounding.left)
                    }
                    innerBounding.push(
                        this.selectionCoordinates(basePos,true)
                    );
                }
            }else if(nodeIndex == contentNode.length-1){
              
                     // 选区在元素内，要减掉 但是要分情况(可以再化简，懒得弄了。。)
                     if(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y<this._lastMouseUp.y){
                        // 右上到左下
                        //basePos.x=this._lastMouseUp.x
                        basePos.width = basePos.width - (outBounding.right-this._lastMouseUp.x)
                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y<this._lastMouseDown.y){
                        // 左下到右上
                        //basePos.x=this._lastMouseDown.x
                        basePos.width = basePos.width - (outBounding.right-this._lastMouseDown.x)
                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y>this._lastMouseDown.y){
                        // 左上到右下
                        //basePos.x=this._lastMouseUp.x
                        basePos.width = basePos.width - (outBounding.right-this._lastMouseUp.x)
                    }else{
                        // 右下到左上(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y>this._lastMouseUp.y)
                        //basePos.x=this._lastMouseDown.x
                        basePos.width = basePos.width - (outBounding.right-this._lastMouseDown.x)
                    }
                    innerBounding.push(
                        this.selectionCoordinates(basePos,true)
                    );
              
            }else{
                innerBounding.push(this.selectionCoordinates(basePos,true));
            }
        }
        // console.log(`Results `,{
        //     outBounding,
        //     innerBounding
        // })
        return {
            outBounding,
            innerBounding
        }
    }
    _init(){
        const that=this;
        this.fn = function (e){

            that._lastMouseUp = {x:e.x,y:e.y};
            const isOnTextLayer = e.path.some(elem=>{return elem.className=='textLayer'})
            if(!isOnTextLayer){
                return;
            }
            // 防止已经出了tooltip在上面点不了
            if(e.path.some((x)=>{
                return x.id=='annotateTooltip'
            })) return;
            var r = "";
            if (document.selection) {
                r = document.selection.createRange().text;
            }
            else if (window.getSelection()) {
                r = window.getSelection();
            }
            if (r!= "") {
                that._lastSelection = that.getSelectionObject(r);
                if(that.annotateTip){
                    that._removeAnnotateTip();
                }

                    that._buildAnnotateTip(e);
            }else{
                if(that.annotateTip) that._removeAnnotateTip();
            }
        }
        document.addEventListener("mouseup",this.fn);
        document.addEventListener("mousedown",(e)=>{
            that._lastMouseDown = {x:e.x,y:e.y};
        })
        const {annotationButton} = this.PDFViewerApplication.appConfig;
        //console.log(annotationButton);
        if(annotationButton.highLightAnnotation){
            annotationButton.highLightAnnotation.addEventListener('click',this._doHighLightAnnotation)
        }
    }
    _removeAnnotateTip(){
        document.body.removeChild(this.annotateTip);
        this.annotateTip=null;
        //document.addEventListener("mouseup",this.fn);
        this._lastSelection=null;
    }
    _buildAnnotateTip(e){
        //document.removeEventListener("mouseup",this.fn);
        var x=10;
        var y=10;
        const outer = document.createElement('div');
        outer.id="annotateTooltip";
        outer.style.backgroundColor="gray"
        outer.style.top=(e.pageY - y)+'px';
        outer.style.left=(e.pageX + x)+'px';
        outer.style.position="absolute";
        outer.class='annotateTooltip';
        outer.innerHTML=`<span id="highLightHere" style="color:red">高亮此处</span>`;
        this.annotateTip=outer;
        document.body.appendChild(outer);
        document.getElementById('highLightHere').addEventListener('click',()=>{
            //console.log("highLight!",this._lastSelection);
            this._doHighLightAnnotation(this._lastSelection);
            this._removeAnnotateTip();
        },true);
        return outer;
    }
    computePageOffset() {
        //console.log("compute Offset Page",this.pdfViewer.currentPageNumber);
        
        // 获取相对坐标
        let pg = document.querySelector(`.page[data-page-number="${this.pdfViewer.currentPageNumber}"]`).getElementsByTagName('canvas')[0];

        var rect = pg.getBoundingClientRect(), bodyElt = document.body;
        return {
                top: rect.top + bodyElt .scrollTop,
                left: rect.left + bodyElt .scrollLeft
        }
    }
    selectionCoordinates(selection,fourPoint=false) {
        let rec = selection
        let ost = this.computePageOffset()
        let x_1 = rec.x - ost.left
        let y_1 = rec.y - ost.top
        let x_2 = x_1 + rec.width
        let y_2 = y_1
        let x_3 = x_1 + rec.width
        let y_3 = y_1 + rec.height
        let x_4 = x_1
        let y_4 = y_3

        let x_1_y_1 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_1, y_1)
        x_1 = x_1_y_1[0]
        y_1 = x_1_y_1[1]
        let x_2_y_2 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_2, y_2)
        x_2 = x_2_y_2[0]
        y_2 = x_2_y_2[1]
        let x_3_y_3 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_3, y_3)
        x_3 = x_3_y_3[0]
        y_3 = x_3_y_3[1]
        let x_4_y_4 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_4, y_4)
        x_4 = x_4_y_4[0]
        y_4 = x_4_y_4[1]
        if(!fourPoint){
            return [x_1, y_1, x_3, y_3]
        }else{
            return [x_4, y_4, x_3, y_3,x_1, y_1, x_2, y_2]
        }
        
}
    _doHighLightAnnotation(selection){
        //console.log("Request HighLight",selection);

        this.AnnotationFactory.createHighlightAnnotation({
            page: this.pdfViewer.currentPageNumber - 1,
            rect:this.selectionCoordinates(selection.outBounding),
            quadPoints: selection.innerBounding?selection.innerBounding.flat():null,
            contents: "HighLight Text",
            author: "SaltDog",
            color: {r: 128, g: 0, b: 0},
            opacity: 0.3
    }
    );
}

    getAnnotatedPDFBlob(){
        return this.AnnotationFactory.write();
    }
}


/***/ }),

/***/ "./src/annotation_layer_builder.js":
/*!*****************************************!*\
  !*** ./src/annotation_layer_builder.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationLayerBuilder": function() { return /* binding */ AnnotationLayerBuilder; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {AnnotationLayer} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const {NullL10n} = __webpack_require__(/*! ./l10n_utils.js */ "./src/l10n_utils.js");
class AnnotationLayerBuilder {
 constructor({pageDiv, pdfPage, linkService, downloadManager, annotationStorage = null, imageResourcesPath = "", renderForms = true, l10n = NullL10n, enableScripting = false, hasJSActionsPromise = null, fieldObjectsPromise = null, mouseState = null, annotationCanvasMap = null}) {
  this.pageDiv = pageDiv;
  this.pdfPage = pdfPage;
  this.linkService = linkService;
  this.downloadManager = downloadManager;
  this.imageResourcesPath = imageResourcesPath;
  this.renderForms = renderForms;
  this.l10n = l10n;
  this.annotationStorage = annotationStorage;
  this.enableScripting = enableScripting;
  this._hasJSActionsPromise = hasJSActionsPromise;
  this._fieldObjectsPromise = fieldObjectsPromise;
  this._mouseState = mouseState;
  this._annotationCanvasMap = annotationCanvasMap;
  this.div = null;
  this.onlineSvg =null;
  this._cancelled = false;
 }
 async render(viewport, intent = "display") {
  const [annotations, hasJSActions = false, fieldObjects = null] = await Promise.all([
   this.pdfPage.getAnnotations({ intent }),
   this._hasJSActionsPromise,
   this._fieldObjectsPromise
  ]);
  if (this._cancelled){//|| annotations.length === 0) {
   return;
  }
  const parameters = {
   viewport: viewport.clone({ dontFlip: true }),
   div: this.div,
   annotations,
   page: this.pdfPage,
   imageResourcesPath: this.imageResourcesPath,
   renderForms: this.renderForms,
   linkService: this.linkService,
   downloadManager: this.downloadManager,
   annotationStorage: this.annotationStorage,
   enableScripting: this.enableScripting,
   hasJSActions,
   fieldObjects,
   mouseState: this._mouseState,
   annotationCanvasMap: this._annotationCanvasMap
  };
  if (this.div) {
   AnnotationLayer.update(parameters);
  } else {
   this.div = document.createElement("div");
   this.div.className = "annotationLayer";
   this.pageDiv.appendChild(this.div);
   parameters.div = this.div;
   AnnotationLayer.render(parameters);
   this.l10n.translate(this.div);
  }
       // 巨坑SVG要用NS创建
    this.onlineSvg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    this.onlineSvg.setAttribute("class","onlineAnnotationLayer");
    this.onlineSvg.setAttribute("version","1.1");
    this.onlineSvg.setAttribute("x","0");
    this.onlineSvg.setAttribute("y","0");
    this.onlineSvg.style.position = 'absolute';
    this.onlineSvg.style.top = '0';
    this.onlineSvg.style.display = 'block';
    this.pageDiv.insertBefore(this.onlineSvg,this.pageDiv.children[1]);
 }
 cancel() {
  this._cancelled = true;
 }
 hide() {
  if (!this.div) {
   return;
  }
  this.div.hidden = true;
 }
}



/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultExternalServices": function() { return /* binding */ DefaultExternalServices; },
/* harmony export */   "PDFPrintServiceFactory": function() { return /* binding */ PDFPrintServiceFactory; },
/* harmony export */   "PDFViewerApplication": function() { return /* binding */ PDFViewerApplication; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {animationStarted, apiPageLayoutToViewerModes, /*apiPageModeToSidebarView,*/ AutoPrintRegExp, DEFAULT_SCALE_VALUE, getActiveOrFocusedElement, isValidRotation, isValidScrollMode, isValidSpreadMode, noContextMenuHandler, normalizeWheelEventDirection, parseQueryString, ProgressBar, RendererType, RenderingStates, ScrollMode,/* SidebarView,*/ SpreadMode, TextLayerMode} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const {AppOptions, OptionKind} = __webpack_require__(/*! ./app_options.js */ "./src/app_options.js");
const {AutomationEventBus, EventBus} = __webpack_require__(/*! ./event_utils.js */ "./src/event_utils.js");
const {build, createPromiseCapability, getDocument, getFilenameFromUrl, getPdfFilenameFromUrl, GlobalWorkerOptions, InvalidPDFException, isPdfFile, loadScript, MissingPDFException, OPS, PDFWorker, shadow, UnexpectedResponseException, UNSUPPORTED_FEATURES, version} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const {CursorTool, PDFCursorTools} = __webpack_require__(/*! ./pdf_cursor_tools.js */ "./src/pdf_cursor_tools.js");
const {LinkTarget, PDFLinkService} = __webpack_require__(/*! ./pdf_link_service.js */ "./src/pdf_link_service.js");
const {OverlayManager} = __webpack_require__(/*! ./overlay_manager.js */ "./src/overlay_manager.js");
const {PasswordPrompt} = __webpack_require__(/*! ./password_prompt.js */ "./src/password_prompt.js");
// sdpdfcore disable sidebar
// const {PDFAttachmentViewer} = require("./pdf_attachment_viewer.js");
// saltdog disable documentProperties
// const {PDFDocumentProperties} = require("./pdf_document_properties.js");
const {PDFFindBar} = __webpack_require__(/*! ./pdf_find_bar.js */ "./src/pdf_find_bar.js");
const {PDFFindController} = __webpack_require__(/*! ./pdf_find_controller.js */ "./src/pdf_find_controller.js");
const {PDFHistory} = __webpack_require__(/*! ./pdf_history.js */ "./src/pdf_history.js");
// const {PDFLayerViewer} = require("./pdf_layer_viewer.js");
// sdpdfcore disable sidebar
// const {PDFOutlineViewer} = require("./pdf_outline_viewer.js");
// saltdog disable presentation
// const {PDFPresentationMode} = require("./pdf_presentation_mode.js");
const {PDFRenderingQueue} = __webpack_require__(/*! ./pdf_rendering_queue.js */ "./src/pdf_rendering_queue.js");
const {PDFScriptingManager} = __webpack_require__(/*! ./pdf_scripting_manager.js */ "./src/pdf_scripting_manager.js");
// sdpdfcore disable sidebar
// const {PDFSidebar} = require("./pdf_sidebar.js");
// const {PDFSidebarResizer} = require("./pdf_sidebar_resizer.js");
// const {PDFThumbnailViewer} = require("./pdf_thumbnail_viewer.js");
const {PDFViewer} = __webpack_require__(/*! ./pdf_viewer.js */ "./src/pdf_viewer.js");
const {SecondaryToolbar} = __webpack_require__(/*! ./secondary_toolbar.js */ "./src/secondary_toolbar.js");
const {Toolbar} = __webpack_require__(/*! ./toolbar.js */ "./src/toolbar.js");
const {ViewHistory} = __webpack_require__(/*! ./view_history.js */ "./src/view_history.js");
const {AnnotateController} = __webpack_require__(/*! ./annotate_controller.js */ "./src/annotate_controller.js");
const DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000;
const FORCE_PAGES_LOADED_TIMEOUT = 10000;
const WHEEL_ZOOM_DISABLED_TIMEOUT = 1000;
const ViewOnLoad = {
 UNKNOWN: -1,
 PREVIOUS: 0,
 INITIAL: 1
};
const ViewerCssTheme = {
 AUTOMATIC: 0,
 LIGHT: 1,
 DARK: 2
};
const KNOWN_VERSIONS = [
 "1.0",
 "1.1",
 "1.2",
 "1.3",
 "1.4",
 "1.5",
 "1.6",
 "1.7",
 "1.8",
 "1.9",
 "2.0",
 "2.1",
 "2.2",
 "2.3"
];
const KNOWN_GENERATORS = [
 "acrobat distiller",
 "acrobat pdfwriter",
 "adobe livecycle",
 "adobe pdf library",
 "adobe photoshop",
 "ghostscript",
 "tcpdf",
 "cairo",
 "dvipdfm",
 "dvips",
 "pdftex",
 "pdfkit",
 "itext",
 "prince",
 "quarkxpress",
 "mac os x",
 "microsoft",
 "openoffice",
 "oracle",
 "luradocument",
 "pdf-xchange",
 "antenna house",
 "aspose.cells",
 "fpdf"
];
class DefaultExternalServices {
 constructor() {
  throw new Error("Cannot initialize DefaultExternalServices.");
 }
 static updateFindControlState(data) {
 }
 static updateFindMatchesCount(data) {
 }
 static initPassiveLoading(callbacks) {
 }
 static async fallback(data) {
 }
 static reportTelemetry(data) {
 }
 static createDownloadManager(options) {
  throw new Error("Not implemented: createDownloadManager");
 }
 static createPreferences() {
  throw new Error("Not implemented: createPreferences");
 }
 static createL10n(options) {
  throw new Error("Not implemented: createL10n");
 }
 static createScripting(options) {
  throw new Error("Not implemented: createScripting");
 }
 static get supportsIntegratedFind() {
   // sdpdfcore disable intergrated find
  return shadow(this, "supportsIntegratedFind", true);
 }
 static get supportsDocumentFonts() {
  return shadow(this, "supportsDocumentFonts", true);
 }
 static get supportedMouseWheelZoomModifierKeys() {
  return shadow(this, "supportedMouseWheelZoomModifierKeys", {
   ctrlKey: true,
   metaKey: true
  });
 }
 static get isInAutomation() {
  return shadow(this, "isInAutomation", false);
 }
}
const PDFViewerApplication = {
 initialBookmark: document.location.hash.substring(1),
 _initializedCapability: createPromiseCapability(),
 _fellback: false,
 appConfig: null,
 pdfDocument: null,
 pdfLoadingTask: null,
 printService: null,
 pdfViewer: null,
//  pdfThumbnailViewer: null,
 pdfRenderingQueue: null,
 // saltdog disable presentation
//  pdfPresentationMode: null,
 // saltdog disable documentProperties
//  pdfDocumentProperties: null,
 pdfLinkService: null,
 pdfHistory: null,
// sdpdfcore disable sidebar
//  pdfSidebar: null,
//  pdfSidebarResizer: null,
//  pdfOutlineViewer: null,
//  pdfAttachmentViewer: null,
//  pdfLayerViewer: null,
 pdfCursorTools: null,
 pdfScriptingManager: null,
 store: null,
 downloadManager: null,
 overlayManager: null,
 preferences: null,
 toolbar: null,
 secondaryToolbar: null,
 eventBus: null,
 l10n: null,
 isInitialViewSet: false,
 downloadComplete: false,
 isViewerEmbedded: window.parent !== window,
 url: "",
 baseUrl: "",
 _downloadUrl: "",
 externalServices: DefaultExternalServices,
 _boundEvents: Object.create(null),
 documentInfo: null,
 metadata: null,
 _contentDispositionFilename: null,
 _contentLength: null,
 _saveInProgress: false,
 _docStats: null,
 _wheelUnusedTicks: 0,
 _idleCallbacks: new Set(),
 async initialize(appConfig) {
  this.preferences = this.externalServices.createPreferences();
  this.appConfig = appConfig;
  await this._readPreferences();
  await this._parseHashParameters();
  this._forceCssTheme();
  await this._initializeL10n();
  if (this.isViewerEmbedded && AppOptions.get("externalLinkTarget") === LinkTarget.NONE) {
   AppOptions.set("externalLinkTarget", LinkTarget.TOP);
  }
  await this._initializeViewerComponents();
  this.bindEvents();
  this.bindWindowEvents();
  const appContainer = appConfig.appContainer || document.documentElement;
  this.l10n.translate(appContainer).then(() => {
   this.eventBus.dispatch("localized", { source: this });
  });
  this._initializedCapability.resolve();
 },
 async _readPreferences() {
  if (AppOptions.get("disablePreferences")) {
   return;
  }
  if (AppOptions._hasUserOptions()) {
   console.warn("_readPreferences: The Preferences may override manually set AppOptions; " + 'please use the "disablePreferences"-option in order to prevent that.');
  }
  try {
   AppOptions.setAll(await this.preferences.getAll());
  } catch (reason) {
   console.error(`_readPreferences: "${ reason?.message }".`);
  }
 },
 async _parseHashParameters() {
  if (!AppOptions.get("pdfBugEnabled")) {
   return;
  }
  const hash = document.location.hash.substring(1);
  if (!hash) {
   return;
  }
  const params = parseQueryString(hash), waitOn = [];
  if (params.get("disableworker") === "true") {
   waitOn.push(loadFakeWorker());
  }
  if (params.has("disablerange")) {
   AppOptions.set("disableRange", params.get("disablerange") === "true");
  }
  if (params.has("disablestream")) {
   AppOptions.set("disableStream", params.get("disablestream") === "true");
  }
  if (params.has("disableautofetch")) {
   AppOptions.set("disableAutoFetch", params.get("disableautofetch") === "true");
  }
  if (params.has("disablefontface")) {
   AppOptions.set("disableFontFace", params.get("disablefontface") === "true");
  }
  if (params.has("disablehistory")) {
   AppOptions.set("disableHistory", params.get("disablehistory") === "true");
  }
  if (params.has("verbosity")) {
   AppOptions.set("verbosity", params.get("verbosity") | 0);
  }
  if (params.has("textlayer")) {
   switch (params.get("textlayer")) {
   case "off":
    AppOptions.set("textLayerMode", TextLayerMode.DISABLE);
    break;
   case "visible":
   case "shadow":
   case "hover":
    const viewer = this.appConfig.viewerContainer;
    viewer.classList.add(`textLayer-${ params.get("textlayer") }`);
    break;
   }
  }
  if (params.has("pdfbug")) {
   AppOptions.set("pdfBug", true);
   AppOptions.set("fontExtraProperties", true);
   const enabled = params.get("pdfbug").split(",");
   waitOn.push(initPDFBug(enabled));
  }
  if (params.has("locale")) {
   AppOptions.set("locale", params.get("locale"));
  }
  if (waitOn.length === 0) {
   return;
  }
  try {
   await Promise.all(waitOn);
  } catch (reason) {
   console.error(`_parseHashParameters: "${ reason.message }".`);
  }
 },
 async _initializeL10n() {
  this.l10n = this.externalServices.createL10n({ locale: AppOptions.get("locale") });
  const dir = await this.l10n.getDirection();
  document.getElementsByTagName("html")[0].dir = dir;
 },
 _forceCssTheme() {
  const cssTheme = AppOptions.get("viewerCssTheme");
  if (cssTheme === ViewerCssTheme.AUTOMATIC || !Object.values(ViewerCssTheme).includes(cssTheme)) {
   return;
  }
  try {
   const styleSheet = document.styleSheets[0];
   const cssRules = styleSheet?.cssRules || [];
   for (let i = 0, ii = cssRules.length; i < ii; i++) {
    const rule = cssRules[i];
    if (rule instanceof CSSMediaRule && rule.media?.[0] === "(prefers-color-scheme: dark)") {
     if (cssTheme === ViewerCssTheme.LIGHT) {
      styleSheet.deleteRule(i);
      return;
     }
     const darkRules = /^@media \(prefers-color-scheme: dark\) {\n\s*([\w\s-.,:;/\\{}()]+)\n}$/.exec(rule.cssText);
     if (darkRules?.[1]) {
      styleSheet.deleteRule(i);
      styleSheet.insertRule(darkRules[1], i);
     }
     return;
    }
   }
  } catch (reason) {
   console.error(`_forceCssTheme: "${ reason?.message }".`);
  }
 },
 async _initializeViewerComponents() {
  const {appConfig, externalServices} = this;
  const eventBus = externalServices.isInAutomation ? new AutomationEventBus() : new EventBus();
  this.eventBus = eventBus;
  this.overlayManager = new OverlayManager();
  const pdfRenderingQueue = new PDFRenderingQueue();
  pdfRenderingQueue.onIdle = this._cleanup.bind(this);
  this.pdfRenderingQueue = pdfRenderingQueue;
  const pdfLinkService = new PDFLinkService({
   eventBus,
   externalLinkTarget: AppOptions.get("externalLinkTarget"),
   externalLinkRel: AppOptions.get("externalLinkRel"),
   ignoreDestinationZoom: AppOptions.get("ignoreDestinationZoom")
  });
  this.pdfLinkService = pdfLinkService;
  const downloadManager = externalServices.createDownloadManager();
  this.downloadManager = downloadManager;
  const findController = new PDFFindController({
   linkService: pdfLinkService,
   eventBus
  });
  this.findController = findController;
  const pdfScriptingManager = new PDFScriptingManager({
   eventBus,
   sandboxBundleSrc: AppOptions.get("sandboxBundleSrc"),
   scriptingFactory: externalServices,
   docPropertiesLookup: this._scriptingDocProperties.bind(this)
  });
  this.pdfScriptingManager = pdfScriptingManager;
  const container = appConfig.mainContainer;
  const viewer = appConfig.viewerContainer;
  // 新增pdfAnnotator PDF加载后赋值
  this.pdfAnnotator = {status:"Not Loaded"};
  this.pdfViewer = new PDFViewer({
   container,
   viewer,
   eventBus,
   renderingQueue: pdfRenderingQueue,
   linkService: pdfLinkService,
   downloadManager,
   findController,
   scriptingManager: AppOptions.get("enableScripting") && pdfScriptingManager,
   renderer: AppOptions.get("renderer"),
   l10n: this.l10n,
   textLayerMode: AppOptions.get("textLayerMode"),
   annotationMode: AppOptions.get("annotationMode"),
   imageResourcesPath: AppOptions.get("imageResourcesPath"),
   enablePrintAutoRotate: AppOptions.get("enablePrintAutoRotate"),
   useOnlyCssZoom: AppOptions.get("useOnlyCssZoom"),
   maxCanvasPixels: AppOptions.get("maxCanvasPixels"),
   enablePermissions: AppOptions.get("enablePermissions")
  });
  pdfRenderingQueue.setViewer(this.pdfViewer);
  pdfLinkService.setViewer(this.pdfViewer);
  pdfScriptingManager.setViewer(this.pdfViewer);
  // sdpdfcore disable sidebar
  // this.pdfThumbnailViewer = new PDFThumbnailViewer({
  //  container: appConfig.sidebar.thumbnailView,
  //  eventBus,
  //  renderingQueue: pdfRenderingQueue,
  //  linkService: pdfLinkService,
  //  l10n: this.l10n
  // });
  // pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);
  if (!this.isViewerEmbedded && !AppOptions.get("disableHistory")) {
   this.pdfHistory = new PDFHistory({
    linkService: pdfLinkService,
    eventBus
   });
   pdfLinkService.setHistory(this.pdfHistory);
  }
  if (!this.supportsIntegratedFind) {
   this.findBar = new PDFFindBar(appConfig.findBar, eventBus, this.l10n);
  }
  // saltdog disable documentProperties
  // this.pdfDocumentProperties = new PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n);
  this.pdfCursorTools = new PDFCursorTools({
   container,
   eventBus,
   cursorToolOnLoad: AppOptions.get("cursorToolOnLoad")
  });
  this.toolbar = new Toolbar(appConfig.toolbar, eventBus, this.l10n);
  this.secondaryToolbar = new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);
  // saltdog disable presenation
  // if (this.supportsFullscreen) {
  //  this.pdfPresentationMode = new PDFPresentationMode({
  //   container,
  //   pdfViewer: this.pdfViewer,
  //   eventBus
  //  });
  // }
  this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n, this.isViewerEmbedded);
  // sdpdfcore disable sidebar
  // this.pdfOutlineViewer = new PDFOutlineViewer({
  //  container: appConfig.sidebar.outlineView,
  //  eventBus,
  //  linkService: pdfLinkService
  // });
  // this.pdfAttachmentViewer = new PDFAttachmentViewer({
  //  container: appConfig.sidebar.attachmentsView,
  //  eventBus,
  //  downloadManager
  // });
  // this.pdfLayerViewer = new PDFLayerViewer({
  //  container: appConfig.sidebar.layersView,
  //  eventBus,
  //  l10n: this.l10n
  // });
  // sdpdfcore disable sidebar
  // this.pdfSidebar = new PDFSidebar({
  //  elements: appConfig.sidebar,
  //  pdfViewer: this.pdfViewer,
  //  pdfThumbnailViewer: this.pdfThumbnailViewer,
  //  eventBus,
  //  l10n: this.l10n
  // });
  // this.pdfSidebar.onToggled = this.forceRendering.bind(this);
  // this.pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);
 },
 run(config) {
  this.initialize(config).then(()=>{
    window.__sdJSBridge?'':webViewerInitialized();
    // debuglgy
    window.__sdJSBridge&&window.__sdJSBridge.publish(`SDPDFCore_Ready`);
    this.eventBus.on('SDPDFCore_loadPDF',()=>{
      webViewerInitialized();
    })
  });
 },
 get initialized() {
  return this._initializedCapability.settled;
 },
 get initializedPromise() {
  return this._initializedCapability.promise;
 },
 zoomIn(steps) {
  // saltdog disable presentation
  // if (this.pdfViewer.isInPresentationMode) {
  //  return;
  // }
  this.pdfViewer.increaseScale(steps);
 },
 zoomOut(steps) {
   // saltdog disable presentation
  // if (this.pdfViewer.isInPresentationMode) {
  //  return;
  // }
  this.pdfViewer.decreaseScale(steps);
 },
 zoomReset() {
   // saltdog disable presentation
  // if (this.pdfViewer.isInPresentationMode) {
  //  return;
  // }
  this.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE;
 },
 get pagesCount() {
  return this.pdfDocument ? this.pdfDocument.numPages : 0;
 },
 get page() {
  return this.pdfViewer.currentPageNumber;
 },
 set page(val) {
  this.pdfViewer.currentPageNumber = val;
 },
 get supportsPrinting() {
  return PDFPrintServiceFactory.instance.supportsPrinting;
 },
// saltdog disable presenation
//  get supportsFullscreen() {
//   return shadow(this, "supportsFullscreen", document.fullscreenEnabled || document.webkitFullscreenEnabled);
//  },
 get supportsIntegratedFind() {
  return this.externalServices.supportsIntegratedFind;
 },
 get supportsDocumentFonts() {
  return this.externalServices.supportsDocumentFonts;
 },
 get loadingBar() {
  const bar = new ProgressBar("#loadingBar");
  return shadow(this, "loadingBar", bar);
 },
 get supportedMouseWheelZoomModifierKeys() {
  return this.externalServices.supportedMouseWheelZoomModifierKeys;
 },
 initPassiveLoading() {
  throw new Error("Not implemented: initPassiveLoading");
 },
 setTitleUsingUrl(url = "", downloadUrl = null) {
  this.url = url;
  this.baseUrl = url.split("#")[0];
  if (downloadUrl) {
   this._downloadUrl = downloadUrl === url ? this.baseUrl : downloadUrl.split("#")[0];
  }
  let title = getPdfFilenameFromUrl(url, "");
  if (!title) {
   try {
    title = decodeURIComponent(getFilenameFromUrl(url)) || url;
   } catch (ex) {
    title = url;
   }
  }
  this.setTitle(title);
 },
 setTitle(title) {
  if (this.isViewerEmbedded) {
   return;
  }
  document.title = title;
 },
 get _docFilename() {
  return this._contentDispositionFilename || getPdfFilenameFromUrl(this.url);
 },
 _hideViewBookmark() {
  const {toolbar, secondaryToolbar} = this.appConfig;
  toolbar.viewBookmark.hidden = true;
  secondaryToolbar.viewBookmarkButton.hidden = true;
 },
 _cancelIdleCallbacks() {
  if (!this._idleCallbacks.size) {
   return;
  }
  for (const callback of this._idleCallbacks) {
   window.cancelIdleCallback(callback);
  }
  this._idleCallbacks.clear();
 },
 async close() {
  this._unblockDocumentLoadEvent();
  this._hideViewBookmark();
  const {container} = this.appConfig.errorWrapper;
  container.hidden = true;
  if (!this.pdfLoadingTask) {
   return;
  }
  if (this.pdfDocument?.annotationStorage.size > 0 && this._annotationStorageModified) {
   try {
    await this.save({ sourceEventType: "save" });
   } catch (reason) {
   }
  }
  const promises = [];
  promises.push(this.pdfLoadingTask.destroy());
  this.pdfLoadingTask = null;
  if (this.pdfDocument) {
   this.pdfDocument = null;
   // sdpdfcore disable sidebar
  //  this.pdfThumbnailViewer.setDocument(null);
   this.pdfViewer.setDocument(null);
   this.pdfLinkService.setDocument(null);
   // saltdog disable documentProperties
  //  this.pdfDocumentProperties.setDocument(null);
  }
  this.pdfLinkService.externalLinkEnabled = true;
  this._fellback = false;
  this.store = null;
  this.isInitialViewSet = false;
  this.downloadComplete = false;
  this.url = "";
  this.baseUrl = "";
  this._downloadUrl = "";
  this.documentInfo = null;
  this.metadata = null;
  this._contentDispositionFilename = null;
  this._contentLength = null;
  this._saveInProgress = false;
  this._docStats = null;
  this._cancelIdleCallbacks();
  promises.push(this.pdfScriptingManager.destroyPromise);
  // sdpdfcore disable sidebar
  // this.pdfSidebar.reset();
  // this.pdfOutlineViewer.reset();
  // this.pdfAttachmentViewer.reset();
  // this.pdfLayerViewer.reset();
  this.pdfHistory?.reset();
  this.findBar?.reset();
  this.toolbar.reset();
  this.secondaryToolbar.reset();
  if (typeof PDFBug !== "undefined") {
   PDFBug.cleanup();
  }
  await Promise.all(promises);
 },
 async open(file, args) {
  if (this.pdfLoadingTask) {
   await this.close();
  }
  const workerParameters = AppOptions.getAll(OptionKind.WORKER);
  for (const key in workerParameters) {
   GlobalWorkerOptions[key] = workerParameters[key];
  }
  const parameters = Object.create(null);
  if (typeof file === "string") {
   this.setTitleUsingUrl(file, file);
   parameters.url = file;
  } else if (file && "byteLength" in file) {
   parameters.data = file;
  } else if (file.url && file.originalUrl) {
   this.setTitleUsingUrl(file.originalUrl, file.url);
   parameters.url = file.url;
  }
  const apiParameters = AppOptions.getAll(OptionKind.API);
  for (const key in apiParameters) {
   let value = apiParameters[key];
   if (key === "docBaseUrl" && !value) {
    value = document.URL.split("#")[0];
   }
   parameters[key] = value;
  }
  if (args) {
   for (const key in args) {
    parameters[key] = args[key];
   }
  }
  const loadingTask = getDocument(parameters);
  this.pdfLoadingTask = loadingTask;
  loadingTask.onPassword = (updateCallback, reason) => {
   this.pdfLinkService.externalLinkEnabled = false;
   this.passwordPrompt.setUpdateCallback(updateCallback, reason);
   this.passwordPrompt.open();
  };
  loadingTask.onProgress = ({loaded, total}) => {
   this.progress(loaded / total);
  };
  loadingTask.onUnsupportedFeature = this.fallback.bind(this);
  return loadingTask.promise.then(pdfDocument => {
   this.load(pdfDocument);
   // 注入在线批注模块
   window.__initPDFJSAnnotate&&window.__initPDFJSAnnotate(pdfDocument);
   // sdpdfcore 加入实例化批注模块 TODO: 密码
   pdfDocument.getData().then( (data) => {
    PDFViewerApplication.pdfAnnotateController = new AnnotateController(PDFViewerApplication,data);
  })
   
  }, reason => {
   if (loadingTask !== this.pdfLoadingTask) {
    return undefined;
   }
   let key = "loading_error";
   if (reason instanceof InvalidPDFException) {
    key = "invalid_file_error";
   } else if (reason instanceof MissingPDFException) {
    key = "missing_file_error";
   } else if (reason instanceof UnexpectedResponseException) {
    key = "unexpected_response_error";
   }
   return this.l10n.get(key).then(msg => {
    this._documentError(msg, { message: reason?.message });
    throw reason;
   });
  });
 },
 _ensureDownloadComplete() {
  if (this.pdfDocument && this.downloadComplete) {
   return;
  }
  throw new Error("PDF document not downloaded.");
 },
 async download({
  sourceEventType = "download"
 } = {}) {
  const url = this._downloadUrl, filename = this._docFilename;
  try {
   this._ensureDownloadComplete();
   // sdpdfcore 批注后下载
  //  const data = await this.pdfDocument.getData();
  //  const blob = new Blob([data], { type: "application/pdf" });
  //  await this.downloadManager.download(blob, url, filename, sourceEventType);
  const blob = new Blob([this.pdfAnnotateController.getAnnotatedPDFBlob()], { type: "application/pdf" });
  await this.downloadManager.download(blob, url, filename, sourceEventType);
  } catch (reason) {
    console.error("Download Failed, reason:",reason);
  //  await this.downloadManager.downloadUrl(url, filename);
  }
 },
 async save({
  sourceEventType = "download"
 } = {}) {
  if (this._saveInProgress) {
   return;
  }
  this._saveInProgress = true;
  await this.pdfScriptingManager.dispatchWillSave();
  const url = this._downloadUrl, filename = this._docFilename;
  try {
   this._ensureDownloadComplete();
   const data = await this.pdfDocument.saveDocument();
   const blob = new Blob([data], { type: "application/pdf" });
   await this.downloadManager.download(blob, url, filename, sourceEventType);
  } catch (reason) {
   console.error(`Error when saving the document: ${ reason.message }`);
   await this.download({ sourceEventType });
  } finally {
   await this.pdfScriptingManager.dispatchDidSave();
   this._saveInProgress = false;
  }
 },
 downloadOrSave(options) {
  if (this.pdfDocument?.annotationStorage.size > 0) {
   this.save(options);
  } else {
   this.download(options);
  }
 },
 fallback(featureId) {
  this.externalServices.reportTelemetry({
   type: "unsupportedFeature",
   featureId
  });
  if (this._fellback) {
   return;
  }
  this._fellback = true;
  this.externalServices.fallback({
   featureId,
   url: this.baseUrl
  }).then(download => {
   if (!download) {
    return;
   }
   this.download({ sourceEventType: "download" });
  });
 },
 _documentError(message, moreInfo = null) {
  this._unblockDocumentLoadEvent();
  this._otherError(message, moreInfo);
  this.eventBus.dispatch("documenterror", {
   source: this,
   message,
   reason: moreInfo?.message ?? null
  });
 },
 _otherError(message, moreInfo = null) {
  const moreInfoText = [this.l10n.get("error_version_info", {
    version: version || "?",
    build: build || "?"
   })];
  if (moreInfo) {
   moreInfoText.push(this.l10n.get("error_message", { message: moreInfo.message }));
   if (moreInfo.stack) {
    moreInfoText.push(this.l10n.get("error_stack", { stack: moreInfo.stack }));
   } else {
    if (moreInfo.filename) {
     moreInfoText.push(this.l10n.get("error_file", { file: moreInfo.filename }));
    }
    if (moreInfo.lineNumber) {
     moreInfoText.push(this.l10n.get("error_line", { line: moreInfo.lineNumber }));
    }
   }
  }
  const errorWrapperConfig = this.appConfig.errorWrapper;
  const errorWrapper = errorWrapperConfig.container;
  errorWrapper.hidden = false;
  const errorMessage = errorWrapperConfig.errorMessage;
  errorMessage.textContent = message;
  const closeButton = errorWrapperConfig.closeButton;
  closeButton.onclick = function () {
   errorWrapper.hidden = true;
  };


  
  closeButton.oncontextmenu = noContextMenuHandler;

 },
 progress(level) {
  if (this.downloadComplete) {
   return;
  }
  const percent = Math.round(level * 100);
  if (percent > this.loadingBar.percent || isNaN(percent)) {
   this.loadingBar.percent = percent;
   const disableAutoFetch = this.pdfDocument ? this.pdfDocument.loadingParams.disableAutoFetch : AppOptions.get("disableAutoFetch");
   if (disableAutoFetch && percent) {
    if (this.disableAutoFetchLoadingBarTimeout) {
     clearTimeout(this.disableAutoFetchLoadingBarTimeout);
     this.disableAutoFetchLoadingBarTimeout = null;
    }
    this.loadingBar.show();
    this.disableAutoFetchLoadingBarTimeout = setTimeout(() => {
     this.loadingBar.hide();
     this.disableAutoFetchLoadingBarTimeout = null;
    }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);
   }
  }
 },
 load(pdfDocument) {
  this.pdfDocument = pdfDocument;
  pdfDocument.getDownloadInfo().then(({length}) => {
   this._contentLength = length;
   this.downloadComplete = true;
   this.loadingBar.hide();
   firstPagePromise.then(() => {
    this.eventBus.dispatch("documentloaded", { source: this });
   });
  });
  const pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {
  });
  const pageModePromise = pdfDocument.getPageMode().catch(function () {
  });
  const openActionPromise = pdfDocument.getOpenAction().catch(function () {
  });
  this.toolbar.setPagesCount(pdfDocument.numPages, false);
  this.secondaryToolbar.setPagesCount(pdfDocument.numPages);
  let baseDocumentUrl;
  baseDocumentUrl = null;
  this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);
  // saltdog disable documentProperties
  // this.pdfDocumentProperties.setDocument(pdfDocument, this.url);
  const pdfViewer = this.pdfViewer;
  pdfViewer.setDocument(pdfDocument);
  const {firstPagePromise, onePageRendered, pagesPromise} = pdfViewer;
  // sdpdfcore disable sidebar
  // const pdfThumbnailViewer = this.pdfThumbnailViewer;
  // pdfThumbnailViewer.setDocument(pdfDocument);
  const storedPromise = (this.store = new ViewHistory(pdfDocument.fingerprints[0])).getMultiple({
   page: null,
   zoom: DEFAULT_SCALE_VALUE,
   scrollLeft: "0",
   scrollTop: "0",
   rotation: null,
   // sdpdfcore disable sidebar
  //  sidebarView: SidebarView.UNKNOWN,
   scrollMode: ScrollMode.UNKNOWN,
   spreadMode: SpreadMode.UNKNOWN
  }).catch(() => {
   return Object.create(null);
  });
  firstPagePromise.then(pdfPage => {
   this.loadingBar.setWidth(this.appConfig.viewerContainer);
   this._initializeAnnotationStorageCallbacks(pdfDocument);
   Promise.all([
    animationStarted,
    storedPromise,
    pageLayoutPromise,
    pageModePromise,
    openActionPromise
   ]).then(async ([timeStamp, stored, pageLayout, pageMode, openAction]) => {
    const viewOnLoad = AppOptions.get("viewOnLoad");
    this._initializePdfHistory({
     fingerprint: pdfDocument.fingerprints[0],
     viewOnLoad,
     initialDest: openAction?.dest
    });
    const initialBookmark = this.initialBookmark;
    const zoom = AppOptions.get("defaultZoomValue");
    let hash = zoom ? `zoom=${ zoom }` : null;
    let rotation = null;
    // sdpdfcore disable sidebar
    // let sidebarView = AppOptions.get("sidebarViewOnLoad");
    let scrollMode = AppOptions.get("scrollModeOnLoad");
    let spreadMode = AppOptions.get("spreadModeOnLoad");
    if (stored.page && viewOnLoad !== ViewOnLoad.INITIAL) {
     hash = `page=${ stored.page }&zoom=${ zoom || stored.zoom },` + `${ stored.scrollLeft },${ stored.scrollTop }`;
     rotation = parseInt(stored.rotation, 10);
     // sdpdfcore disable sidebar
    //  if (sidebarView === SidebarView.UNKNOWN) {
    //   sidebarView = stored.sidebarView | 0;
    //  }
     if (scrollMode === ScrollMode.UNKNOWN) {
      scrollMode = stored.scrollMode | 0;
     }
     if (spreadMode === SpreadMode.UNKNOWN) {
      spreadMode = stored.spreadMode | 0;
     }
    }
    // sdpdfcore disable sidebar
    // if (pageMode && sidebarView === SidebarView.UNKNOWN) {
    //  sidebarView = apiPageModeToSidebarView(pageMode);
    // }
    if (pageLayout && scrollMode === ScrollMode.UNKNOWN && spreadMode === SpreadMode.UNKNOWN) {
     const modes = apiPageLayoutToViewerModes(pageLayout);
     spreadMode = modes.spreadMode;
    }
    this.setInitialView(hash, {
     rotation,
     // sdpdfcore disable sidebar
    //  sidebarView,
     scrollMode,
     spreadMode
    });
    this.eventBus.dispatch("documentinit", { source: this });
    if (!this.isViewerEmbedded) {
     pdfViewer.focus();
    }
    await Promise.race([
     pagesPromise,
     new Promise(resolve => {
      setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT);
     })
    ]);
    if (!initialBookmark && !hash) {
     return;
    }
    if (pdfViewer.hasEqualPageSizes) {
     return;
    }
    this.initialBookmark = initialBookmark;
    pdfViewer.currentScaleValue = pdfViewer.currentScaleValue;
    this.setInitialView(hash);
   }).catch(() => {
    this.setInitialView();
   }).then(function () {
    pdfViewer.update();
   });
  });
  pagesPromise.then(() => {
   this._unblockDocumentLoadEvent();
   this._initializeAutoPrint(pdfDocument, openActionPromise);
  }, reason => {
   this.l10n.get("loading_error").then(msg => {
    this._documentError(msg, { message: reason?.message });
   });
  });
  onePageRendered.then(data => {
   this.externalServices.reportTelemetry({
    type: "pageInfo",
    timestamp: data.timestamp
   });
   // sdpdfcore disable sidebar
  //  pdfDocument.getOutline().then(outline => {
  //   if (pdfDocument !== this.pdfDocument) {
  //    return;
  //   }
  //   this.pdfOutlineViewer.render({
  //    outline,
  //    pdfDocument
  //   });
  //  });
  //  pdfDocument.getAttachments().then(attachments => {
  //   if (pdfDocument !== this.pdfDocument) {
  //    return;
  //   }
  //   this.pdfAttachmentViewer.render({ attachments });
  //  });
  //  pdfViewer.optionalContentConfigPromise.then(optionalContentConfig => {
  //   if (pdfDocument !== this.pdfDocument) {
  //    return;
  //   }
  //   this.pdfLayerViewer.render({
  //    optionalContentConfig,
  //    pdfDocument
  //   });
  //  });
   if ("requestIdleCallback" in window) {
    const callback = window.requestIdleCallback(() => {
     this._collectTelemetry(pdfDocument);
     this._idleCallbacks.delete(callback);
    }, { timeout: 1000 });
    this._idleCallbacks.add(callback);
   }
  });
  this._initializePageLabels(pdfDocument);
  this._initializeMetadata(pdfDocument);
 },
 async _scriptingDocProperties(pdfDocument) {
  if (!this.documentInfo) {
   await new Promise(resolve => {
    this.eventBus._on("metadataloaded", resolve, { once: true });
   });
   if (pdfDocument !== this.pdfDocument) {
    return null;
   }
  }
  if (!this._contentLength) {
   await new Promise(resolve => {
    this.eventBus._on("documentloaded", resolve, { once: true });
   });
   if (pdfDocument !== this.pdfDocument) {
    return null;
   }
  }
  return {
   ...this.documentInfo,
   baseURL: this.baseUrl,
   filesize: this._contentLength,
   filename: this._docFilename,
   metadata: this.metadata?.getRaw(),
   authors: this.metadata?.get("dc:creator"),
   numPages: this.pagesCount,
   URL: this.url
  };
 },
 async _collectTelemetry(pdfDocument) {
  const markInfo = await this.pdfDocument.getMarkInfo();
  if (pdfDocument !== this.pdfDocument) {
   return;
  }
  const tagged = markInfo?.Marked || false;
  this.externalServices.reportTelemetry({
   type: "tagged",
   tagged
  });
 },
 async _initializeAutoPrint(pdfDocument, openActionPromise) {
  const [openAction, javaScript] = await Promise.all([
   openActionPromise,
   !this.pdfViewer.enableScripting ? pdfDocument.getJavaScript() : null
  ]);
  if (pdfDocument !== this.pdfDocument) {
   return;
  }
  let triggerAutoPrint = false;
  if (openAction?.action === "Print") {
   triggerAutoPrint = true;
  }
  if (javaScript) {
   javaScript.some(js => {
    if (!js) {
     return false;
    }
    console.warn("Warning: JavaScript support is not enabled");
    this.fallback(UNSUPPORTED_FEATURES.javaScript);
    return true;
   });
   if (!triggerAutoPrint) {
    for (const js of javaScript) {
     if (js && AutoPrintRegExp.test(js)) {
      triggerAutoPrint = true;
      break;
     }
    }
   }
  }
  if (triggerAutoPrint) {
   this.triggerPrinting();
  }
 },
 async _initializeMetadata(pdfDocument) {
  const {info, metadata, contentDispositionFilename, contentLength} = await pdfDocument.getMetadata();
  if (pdfDocument !== this.pdfDocument) {
   return;
  }
  this.documentInfo = info;
  this.metadata = metadata;
  this._contentDispositionFilename ??= contentDispositionFilename;
  this._contentLength ??= contentLength;
  console.log(`PDF ${ pdfDocument.fingerprints[0] } [${ info.PDFFormatVersion } ` + `${ (info.Producer || "-").trim() } / ${ (info.Creator || "-").trim() }] ` + `(PDF.js: ${ version || "-" })`);
  let pdfTitle = info?.Title;
  const metadataTitle = metadata?.get("dc:title");
  if (metadataTitle) {
   if (metadataTitle !== "Untitled" && !/[\uFFF0-\uFFFF]/g.test(metadataTitle)) {
    pdfTitle = metadataTitle;
   }
  }
  if (pdfTitle) {
   this.setTitle(`${ pdfTitle } - ${ contentDispositionFilename || document.title }`);
  } else if (contentDispositionFilename) {
   this.setTitle(contentDispositionFilename);
  }
  if (info.IsXFAPresent && !info.IsAcroFormPresent && !pdfDocument.isPureXfa) {
   if (pdfDocument.loadingParams.enableXfa) {
    console.warn("Warning: XFA Foreground documents are not supported");
   } else {
    console.warn("Warning: XFA support is not enabled");
   }
   this.fallback(UNSUPPORTED_FEATURES.forms);
  } else if ((info.IsAcroFormPresent || info.IsXFAPresent) && !this.pdfViewer.renderForms) {
   console.warn("Warning: Interactive form support is not enabled");
   this.fallback(UNSUPPORTED_FEATURES.forms);
  }
  if (info.IsSignaturesPresent) {
   console.warn("Warning: Digital signatures validation is not supported");
   this.fallback(UNSUPPORTED_FEATURES.signatures);
  }
  let versionId = "other";
  if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {
   versionId = `v${ info.PDFFormatVersion.replace(".", "_") }`;
  }
  let generatorId = "other";
  if (info.Producer) {
   const producer = info.Producer.toLowerCase();
   KNOWN_GENERATORS.some(function (generator) {
    if (!producer.includes(generator)) {
     return false;
    }
    generatorId = generator.replace(/[ .-]/g, "_");
    return true;
   });
  }
  let formType = null;
  if (info.IsXFAPresent) {
   formType = "xfa";
  } else if (info.IsAcroFormPresent) {
   formType = "acroform";
  }
  this.externalServices.reportTelemetry({
   type: "documentInfo",
   version: versionId,
   generator: generatorId,
   formType
  });
  this.eventBus.dispatch("metadataloaded", { source: this });
 },
 async _initializePageLabels(pdfDocument) {
  const labels = await pdfDocument.getPageLabels();
  if (pdfDocument !== this.pdfDocument) {
   return;
  }
  if (!labels || AppOptions.get("disablePageLabels")) {
   return;
  }
  const numLabels = labels.length;
  let standardLabels = 0, emptyLabels = 0;
  for (let i = 0; i < numLabels; i++) {
   const label = labels[i];
   if (label === (i + 1).toString()) {
    standardLabels++;
   } else if (label === "") {
    emptyLabels++;
   } else {
    break;
   }
  }
  if (standardLabels >= numLabels || emptyLabels >= numLabels) {
   return;
  }
  // sdpdfcore disable sidebar
  const {pdfViewer, /*pdfThumbnailViewer,*/ toolbar} = this;
  pdfViewer.setPageLabels(labels);
  // pdfThumbnailViewer.setPageLabels(labels);
  toolbar.setPagesCount(numLabels, true);
  toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
 },
 _initializePdfHistory({fingerprint, viewOnLoad, initialDest = null}) {
  if (!this.pdfHistory) {
   return;
  }
  this.pdfHistory.initialize({
   fingerprint,
   resetHistory: viewOnLoad === ViewOnLoad.INITIAL,
   updateUrl: AppOptions.get("historyUpdateUrl")
  });
  if (this.pdfHistory.initialBookmark) {
   this.initialBookmark = this.pdfHistory.initialBookmark;
   this.initialRotation = this.pdfHistory.initialRotation;
  }
  if (initialDest && !this.initialBookmark && viewOnLoad === ViewOnLoad.UNKNOWN) {
   this.initialBookmark = JSON.stringify(initialDest);
   this.pdfHistory.push({
    explicitDest: initialDest,
    pageNumber: null
   });
  }
 },
 _initializeAnnotationStorageCallbacks(pdfDocument) {
  if (pdfDocument !== this.pdfDocument) {
   return;
  }
  const {annotationStorage} = pdfDocument;
  annotationStorage.onSetModified = () => {
   window.addEventListener("beforeunload", beforeUnload);
   this._annotationStorageModified = true;
  };
  annotationStorage.onResetModified = () => {
   window.removeEventListener("beforeunload", beforeUnload);
   delete this._annotationStorageModified;
  };
 },
 // sdpdfcore disable sidebar
 setInitialView(storedHash, {rotation, /*sidebarView,*/ scrollMode, spreadMode} = {}) {
  const setRotation = angle => {
   if (isValidRotation(angle)) {
    this.pdfViewer.pagesRotation = angle;
   }
  };
  const setViewerModes = (scroll, spread) => {
   if (isValidScrollMode(scroll)) {
    this.pdfViewer.scrollMode = scroll;
   }
   if (isValidSpreadMode(spread)) {
    this.pdfViewer.spreadMode = spread;
   }
  };
  this.isInitialViewSet = true;
  // sdpdfcore disable sidebar
  // this.pdfSidebar.setInitialView(sidebarView);
  setViewerModes(scrollMode, spreadMode);
  if (this.initialBookmark) {
   setRotation(this.initialRotation);
   delete this.initialRotation;
   this.pdfLinkService.setHash(this.initialBookmark);
   this.initialBookmark = null;
  } else if (storedHash) {
   setRotation(rotation);
   this.pdfLinkService.setHash(storedHash);
  }
  this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel);
  this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);
  if (!this.pdfViewer.currentScaleValue) {
   this.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE;
  }
 },
 _cleanup() {
  if (!this.pdfDocument) {
   return;
  }
  this.pdfViewer.cleanup();
  // sdpdfcore disable sidebar
  // this.pdfThumbnailViewer.cleanup();
  this.pdfDocument.cleanup(this.pdfViewer.renderer === RendererType.SVG);
 },
 forceRendering() {
  this.pdfRenderingQueue.printing = !!this.printService;
  // sdpdfcore disable sidebar
  // this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;
  this.pdfRenderingQueue.renderHighestPriority();
 },
 beforePrint() {
  this.pdfScriptingManager.dispatchWillPrint();
  if (this.printService) {
   return;
  }
  if (!this.supportsPrinting) {
   this.l10n.get("printing_not_supported").then(msg => {
    this._otherError(msg);
   });
   return;
  }
  if (!this.pdfViewer.pageViewsReady) {
   this.l10n.get("printing_not_ready").then(msg => {
    window.alert(msg);
   });
   return;
  }
  const pagesOverview = this.pdfViewer.getPagesOverview();
  const printContainer = this.appConfig.printContainer;
  const printResolution = AppOptions.get("printResolution");
  const optionalContentConfigPromise = this.pdfViewer.optionalContentConfigPromise;
  const printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, this.l10n);
  this.printService = printService;
  this.forceRendering();
  printService.layout();
  this.externalServices.reportTelemetry({ type: "print" });
 },
 afterPrint() {
  this.pdfScriptingManager.dispatchDidPrint();
  if (this.printService) {
   this.printService.destroy();
   this.printService = null;
   this.pdfDocument?.annotationStorage.resetModified();
  }
  this.forceRendering();
 },
 rotatePages(delta) {
  this.pdfViewer.pagesRotation += delta;
 },
 // saltdog disable presentation
//  requestPresentationMode() {
//   this.pdfPresentationMode?.request();
//  },
 triggerPrinting() {
  if (!this.supportsPrinting) {
   return;
  }
  window.print();
 },
 bindEvents() {
  const {eventBus, _boundEvents} = this;
  _boundEvents.beforePrint = this.beforePrint.bind(this);
  _boundEvents.afterPrint = this.afterPrint.bind(this);
  eventBus._on("resize", webViewerResize);
  eventBus._on("hashchange", webViewerHashchange);
  eventBus._on("beforeprint", _boundEvents.beforePrint);
  eventBus._on("afterprint", _boundEvents.afterPrint);
  eventBus._on("pagerendered", webViewerPageRendered);
  eventBus._on("updateviewarea", webViewerUpdateViewarea);
  eventBus._on("pagechanging", webViewerPageChanging);
  eventBus._on("scalechanging", webViewerScaleChanging);
  eventBus._on("rotationchanging", webViewerRotationChanging);
  // eventBus._on("sidebarviewchanged", webViewerSidebarViewChanged);
  // sdpdfcore disable sidebar
  // eventBus._on("pagemode", webViewerPageMode);
  eventBus._on("namedaction", webViewerNamedAction);
  // saltdog disable presentation
  // eventBus._on("presentationmodechanged", webViewerPresentationModeChanged);
  // eventBus._on("presentationmode", webViewerPresentationMode);
  eventBus._on("print", webViewerPrint);
  eventBus._on("download", webViewerDownload);
  eventBus._on("save", webViewerSave);
  eventBus._on("firstpage", webViewerFirstPage);
  eventBus._on("lastpage", webViewerLastPage);
  eventBus._on("nextpage", webViewerNextPage);
  eventBus._on("previouspage", webViewerPreviousPage);
  eventBus._on("zoomin", webViewerZoomIn);
  eventBus._on("zoomout", webViewerZoomOut);
  eventBus._on("zoomreset", webViewerZoomReset);
  eventBus._on("pagenumberchanged", webViewerPageNumberChanged);
  eventBus._on("scalechanged", webViewerScaleChanged);
  eventBus._on("rotatecw", webViewerRotateCw);
  eventBus._on("rotateccw", webViewerRotateCcw);
  eventBus._on("optionalcontentconfig", webViewerOptionalContentConfig);
  eventBus._on("switchscrollmode", webViewerSwitchScrollMode);
  eventBus._on("scrollmodechanged", webViewerScrollModeChanged);
  eventBus._on("switchspreadmode", webViewerSwitchSpreadMode);
  eventBus._on("spreadmodechanged", webViewerSpreadModeChanged);
  // saltdog disable documentProperties
  // eventBus._on("documentproperties", webViewerDocumentProperties);
  eventBus._on("findfromurlhash", webViewerFindFromUrlHash);
  eventBus._on("updatefindmatchescount", webViewerUpdateFindMatchesCount);
  eventBus._on("updatefindcontrolstate", webViewerUpdateFindControlState);
  if (AppOptions.get("pdfBug")) {
   _boundEvents.reportPageStatsPDFBug = reportPageStatsPDFBug;
   eventBus._on("pagerendered", _boundEvents.reportPageStatsPDFBug);
   eventBus._on("pagechanging", _boundEvents.reportPageStatsPDFBug);
  }
  eventBus._on("fileinputchange", webViewerFileInputChange);
  eventBus._on("openfile", webViewerOpenFile);
 },
 bindWindowEvents() {
  const {eventBus, _boundEvents} = this;
  _boundEvents.windowResize = () => {
   eventBus.dispatch("resize", { source: window });
  };
  _boundEvents.windowHashChange = () => {
   eventBus.dispatch("hashchange", {
    source: window,
    hash: document.location.hash.substring(1)
   });
  };
  _boundEvents.windowBeforePrint = () => {
   eventBus.dispatch("beforeprint", { source: window });
  };
  _boundEvents.windowAfterPrint = () => {
   eventBus.dispatch("afterprint", { source: window });
  };
  _boundEvents.windowUpdateFromSandbox = event => {
   eventBus.dispatch("updatefromsandbox", {
    source: window,
    detail: event.detail
   });
  };
  window.addEventListener("visibilitychange", webViewerVisibilityChange);
  window.addEventListener("wheel", webViewerWheel, { passive: false });
  window.addEventListener("touchstart", webViewerTouchStart, { passive: false });
  window.addEventListener("click", webViewerClick);
  window.addEventListener("keydown", webViewerKeyDown);
  window.addEventListener("resize", _boundEvents.windowResize);
  window.addEventListener("hashchange", _boundEvents.windowHashChange);
  window.addEventListener("beforeprint", _boundEvents.windowBeforePrint);
  window.addEventListener("afterprint", _boundEvents.windowAfterPrint);
  window.addEventListener("updatefromsandbox", _boundEvents.windowUpdateFromSandbox);
 },
 unbindEvents() {
  const {eventBus, _boundEvents} = this;
  eventBus._off("resize", webViewerResize);
  eventBus._off("hashchange", webViewerHashchange);
  eventBus._off("beforeprint", _boundEvents.beforePrint);
  eventBus._off("afterprint", _boundEvents.afterPrint);
  eventBus._off("pagerendered", webViewerPageRendered);
  eventBus._off("updateviewarea", webViewerUpdateViewarea);
  eventBus._off("pagechanging", webViewerPageChanging);
  eventBus._off("scalechanging", webViewerScaleChanging);
  eventBus._off("rotationchanging", webViewerRotationChanging);
  // eventBus._off("sidebarviewchanged", webViewerSidebarViewChanged);
  // sdpdfcore disable sidebar
  // eventBus._off("pagemode", webViewerPageMode);
  eventBus._off("namedaction", webViewerNamedAction);
  // saltdog disable presentation
  // eventBus._off("presentationmodechanged", webViewerPresentationModeChanged);
  // eventBus._off("presentationmode", webViewerPresentationMode);
  eventBus._off("print", webViewerPrint);
  eventBus._off("download", webViewerDownload);
  eventBus._off("save", webViewerSave);
  eventBus._off("firstpage", webViewerFirstPage);
  eventBus._off("lastpage", webViewerLastPage);
  eventBus._off("nextpage", webViewerNextPage);
  eventBus._off("previouspage", webViewerPreviousPage);
  eventBus._off("zoomin", webViewerZoomIn);
  eventBus._off("zoomout", webViewerZoomOut);
  eventBus._off("zoomreset", webViewerZoomReset);
  eventBus._off("pagenumberchanged", webViewerPageNumberChanged);
  eventBus._off("scalechanged", webViewerScaleChanged);
  eventBus._off("rotatecw", webViewerRotateCw);
  eventBus._off("rotateccw", webViewerRotateCcw);
  eventBus._off("optionalcontentconfig", webViewerOptionalContentConfig);
  eventBus._off("switchscrollmode", webViewerSwitchScrollMode);
  eventBus._off("scrollmodechanged", webViewerScrollModeChanged);
  eventBus._off("switchspreadmode", webViewerSwitchSpreadMode);
  eventBus._off("spreadmodechanged", webViewerSpreadModeChanged);
  // saltdog disable documentProperties
  // eventBus._off("documentproperties", webViewerDocumentProperties);
  eventBus._off("findfromurlhash", webViewerFindFromUrlHash);
  eventBus._off("updatefindmatchescount", webViewerUpdateFindMatchesCount);
  eventBus._off("updatefindcontrolstate", webViewerUpdateFindControlState);
  if (_boundEvents.reportPageStatsPDFBug) {
   eventBus._off("pagerendered", _boundEvents.reportPageStatsPDFBug);
   eventBus._off("pagechanging", _boundEvents.reportPageStatsPDFBug);
   _boundEvents.reportPageStatsPDFBug = null;
  }
  eventBus._off("fileinputchange", webViewerFileInputChange);
  eventBus._off("openfile", webViewerOpenFile);
  _boundEvents.beforePrint = null;
  _boundEvents.afterPrint = null;
 },
 unbindWindowEvents() {
  const {_boundEvents} = this;
  window.removeEventListener("visibilitychange", webViewerVisibilityChange);
  window.removeEventListener("wheel", webViewerWheel, { passive: false });
  window.removeEventListener("touchstart", webViewerTouchStart, { passive: false });
  window.removeEventListener("click", webViewerClick);
  window.removeEventListener("keydown", webViewerKeyDown);
  window.removeEventListener("resize", _boundEvents.windowResize);
  window.removeEventListener("hashchange", _boundEvents.windowHashChange);
  window.removeEventListener("beforeprint", _boundEvents.windowBeforePrint);
  window.removeEventListener("afterprint", _boundEvents.windowAfterPrint);
  window.removeEventListener("updatefromsandbox", _boundEvents.windowUpdateFromSandbox);
  _boundEvents.windowResize = null;
  _boundEvents.windowHashChange = null;
  _boundEvents.windowBeforePrint = null;
  _boundEvents.windowAfterPrint = null;
  _boundEvents.windowUpdateFromSandbox = null;
 },
 accumulateWheelTicks(ticks) {
  if (this._wheelUnusedTicks > 0 && ticks < 0 || this._wheelUnusedTicks < 0 && ticks > 0) {
   this._wheelUnusedTicks = 0;
  }
  this._wheelUnusedTicks += ticks;
  const wholeTicks = Math.sign(this._wheelUnusedTicks) * Math.floor(Math.abs(this._wheelUnusedTicks));
  this._wheelUnusedTicks -= wholeTicks;
  return wholeTicks;
 },
 _unblockDocumentLoadEvent() {
  if (document.blockUnblockOnload) {
   document.blockUnblockOnload(false);
  }
  this._unblockDocumentLoadEvent = () => {
  };
 },
 _reportDocumentStatsTelemetry() {
  const {stats} = this.pdfDocument;
  if (stats !== this._docStats) {
   this._docStats = stats;
   this.externalServices.reportTelemetry({
    type: "documentStats",
    stats
   });
  }
 },
 get scriptingReady() {
  return this.pdfScriptingManager.ready;
 }
};
let validateFileURL;
{
 const HOSTED_VIEWER_ORIGINS = [
  "null",
  "http://mozilla.github.io",
  "https://mozilla.github.io"
 ];
 validateFileURL = function (file) {
  if (file === undefined) {
   return;
  }
  try {
   const viewerOrigin = new URL(window.location.href).origin || "null";
   if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) {
    return;
   }
   const {origin, protocol} = new URL(file, window.location.href);
   if (origin !== viewerOrigin && protocol !== "blob:") {
    throw new Error("file origin does not match viewer's");
   }
  } catch (ex) {
   PDFViewerApplication.l10n.get("loading_error").then(msg => {
    PDFViewerApplication._documentError(msg, { message: ex?.message });
   });
   throw ex;
  }
 };
}
async function loadFakeWorker() {
 if (!GlobalWorkerOptions.workerSrc) {
  GlobalWorkerOptions.workerSrc = AppOptions.get("workerSrc");
 }
 window.pdfjsWorker = await __webpack_require__.e(/*! import() */ "vendors-node_modules_pdfjs-dist_build_pdf_worker_js").then(__webpack_require__.t.bind(__webpack_require__, /*! pdfjs-dist/build/pdf.worker */ "./node_modules/pdfjs-dist/build/pdf.worker.js", 23));
}
async function initPDFBug(enabledTabs) {
 const {debuggerScriptPath, mainContainer} = PDFViewerApplication.appConfig;
 await loadScript(debuggerScriptPath);
 PDFBug.init({ OPS }, mainContainer, enabledTabs);
}
function reportPageStatsPDFBug({pageNumber}) {
 if (typeof Stats === "undefined" || !Stats.enabled) {
  return;
 }
 const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1);
 const pageStats = pageView?.pdfPage?.stats;
 if (!pageStats) {
  return;
 }
 Stats.add(pageNumber, pageStats);
}

function webViewerInitialized() {
 const appConfig = PDFViewerApplication.appConfig;
 let file;
 const queryString = document.location.search.substring(1);
 const params = parseQueryString(queryString);
 // sdpdfcore loadFile
 file = params.get("file") ?? AppOptions.get("fileBlob");
 //validateFileURL(file);
 const fileInput = document.createElement("input");
 fileInput.id = appConfig.openFileInputName;
 fileInput.className = "fileInput";
 fileInput.setAttribute("type", "file");
 fileInput.oncontextmenu = noContextMenuHandler;
 document.body.appendChild(fileInput);
 if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
  appConfig.toolbar.openFile.hidden = true;
  appConfig.secondaryToolbar.openFileButton.hidden = true;
 } else {
  fileInput.value = null;
 }
 fileInput.addEventListener("change", function (evt) {
  const files = evt.target.files;
  if (!files || files.length === 0) {
   return;
  }
  PDFViewerApplication.eventBus.dispatch("fileinputchange", {
   source: this,
   fileInput: evt.target
  });
 });
 appConfig.mainContainer.addEventListener("dragover", function (evt) {
  evt.preventDefault();
  evt.dataTransfer.dropEffect = "move";
 });
 appConfig.mainContainer.addEventListener("drop", function (evt) {
  evt.preventDefault();
  const files = evt.dataTransfer.files;
  if (!files || files.length === 0) {
   return;
  }
  PDFViewerApplication.eventBus.dispatch("fileinputchange", {
   source: this,
   fileInput: evt.dataTransfer
  });
 });
 if (!PDFViewerApplication.supportsDocumentFonts) {
  AppOptions.set("disableFontFace", true);
  PDFViewerApplication.l10n.get("web_fonts_disabled").then(msg => {
   console.warn(msg);
  });
 }
 if (!PDFViewerApplication.supportsPrinting) {
  appConfig.toolbar.print.classList.add("hidden");
  appConfig.secondaryToolbar.printButton.classList.add("hidden");
 }
 // saltdog disable presenation
//  if (!PDFViewerApplication.supportsFullscreen) {
//   appConfig.toolbar.presentationModeButton.classList.add("hidden");
//   appConfig.secondaryToolbar.presentationModeButton.classList.add("hidden");
//  }
 if (PDFViewerApplication.supportsIntegratedFind) {
  appConfig.toolbar.viewFind.classList.add("hidden");
 }
 appConfig.mainContainer.addEventListener("transitionend", function (evt) {
  if (evt.target === this) {
   PDFViewerApplication.eventBus.dispatch("resize", { source: this });
  }
 }, true);
 try {
  webViewerOpenFileViaURL(file);
 } catch (reason) {
  PDFViewerApplication.l10n.get("loading_error").then(msg => {
   PDFViewerApplication._documentError(msg, reason);
  });
 }
}
function webViewerOpenFileViaURL(file) {
 if (file) {
  PDFViewerApplication.open(file);
 } else {
  PDFViewerApplication._hideViewBookmark();
 }
}
function webViewerPageRendered({pageNumber, error}) {
 if (pageNumber === PDFViewerApplication.page) {
  PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);
 }
 // sdpdfcore disable sidebar
//  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
//   const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1);
//   const thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageNumber - 1);
//   if (pageView && thumbnailView) {
//    thumbnailView.setImage(pageView);
//   }
//  }
 if (error) {
  PDFViewerApplication.l10n.get("rendering_error").then(msg => {
   PDFViewerApplication._otherError(msg, error);
  });
 }
 PDFViewerApplication._reportDocumentStatsTelemetry();
}
// function webViewerPageMode({mode}) {
//  let view;
//  switch (mode) {
//  case "thumbs":
//   view = SidebarView.THUMBS;
//   break;
//  case "bookmarks":
//  case "outline":
//   view = SidebarView.OUTLINE;
//   break;
//  case "attachments":
//   view = SidebarView.ATTACHMENTS;
//   break;
//  case "layers":
//   view = SidebarView.LAYERS;
//   break;
//  case "none":
//   view = SidebarView.NONE;
//   break;
//  default:
//   console.error('Invalid "pagemode" hash parameter: ' + mode);
//   return;
//  }
//  PDFViewerApplication.pdfSidebar.switchView(view, true);
// }
function webViewerNamedAction(evt) {
 switch (evt.action) {
 case "GoToPage":
  PDFViewerApplication.appConfig.toolbar.pageNumber.select();
  break;
 case "Find":
  if (!PDFViewerApplication.supportsIntegratedFind) {
   PDFViewerApplication.findBar.toggle();
  }
  break;
 case "Print":
  PDFViewerApplication.triggerPrinting();
  break;
 case "SaveAs":
  webViewerSave();
  break;
 }
}
// saltdog disable presentation
// function webViewerPresentationModeChanged(evt) {
//  PDFViewerApplication.pdfViewer.presentationModeState = evt.state;
// }
// sdpdfcore disable sidebar
// function webViewerSidebarViewChanged(evt) {
//  PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;
//  if (PDFViewerApplication.isInitialViewSet) {
//   PDFViewerApplication.store?.set("sidebarView", evt.view).catch(() => {
//   });
//  }
// }
function webViewerUpdateViewarea(evt) {
 const location = evt.location;
 if (PDFViewerApplication.isInitialViewSet) {
  PDFViewerApplication.store?.setMultiple({
   page: location.pageNumber,
   zoom: location.scale,
   scrollLeft: location.left,
   scrollTop: location.top,
   rotation: location.rotation
  }).catch(() => {
  });
 }
 const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams);
 PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;
 PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href;
 const currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1);
 const loading = currentPage?.renderingState !== RenderingStates.FINISHED;
 PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);
}
function webViewerScrollModeChanged(evt) {
 if (PDFViewerApplication.isInitialViewSet) {
  PDFViewerApplication.store?.set("scrollMode", evt.mode).catch(() => {
  });
 }
}
function webViewerSpreadModeChanged(evt) {
 if (PDFViewerApplication.isInitialViewSet) {
  PDFViewerApplication.store?.set("spreadMode", evt.mode).catch(() => {
  });
 }
}
function webViewerResize() {
 const {pdfDocument, pdfViewer} = PDFViewerApplication;
 if (!pdfDocument) {
  return;
 }
 const currentScaleValue = pdfViewer.currentScaleValue;
 if (currentScaleValue === "auto" || currentScaleValue === "page-fit" || currentScaleValue === "page-width") {
  pdfViewer.currentScaleValue = currentScaleValue;
 }
 pdfViewer.update();
}
function webViewerHashchange(evt) {
 const hash = evt.hash;
 if (!hash) {
  return;
 }
 if (!PDFViewerApplication.isInitialViewSet) {
  PDFViewerApplication.initialBookmark = hash;
 } else if (!PDFViewerApplication.pdfHistory?.popStateInProgress) {
  PDFViewerApplication.pdfLinkService.setHash(hash);
 }
}
let webViewerFileInputChange, webViewerOpenFile;
{
 webViewerFileInputChange = function (evt) {
   // saltdog disable presentation
  // if (PDFViewerApplication.pdfViewer?.isInPresentationMode) {
  //  return;
  // }
  const file = evt.fileInput.files[0];
  let url = URL.createObjectURL(file);
  if (file.name) {
   url = {
    url,
    originalUrl: file.name
   };
  }
  PDFViewerApplication.open(url);
 };
 webViewerOpenFile = function (evt) {
  const openFileInputName = PDFViewerApplication.appConfig.openFileInputName;
  document.getElementById(openFileInputName).click();
 };
}
// saltdog disable presentation
// function webViewerPresentationMode() {
//  PDFViewerApplication.requestPresentationMode();
// }
function webViewerPrint() {
 PDFViewerApplication.triggerPrinting();
}
function webViewerDownload() {
 PDFViewerApplication.downloadOrSave({ sourceEventType: "download" });
}
function webViewerSave() {
 PDFViewerApplication.downloadOrSave({ sourceEventType: "save" });
}
function webViewerFirstPage() {
 if (PDFViewerApplication.pdfDocument) {
  PDFViewerApplication.page = 1;
 }
}
function webViewerLastPage() {
 if (PDFViewerApplication.pdfDocument) {
  PDFViewerApplication.page = PDFViewerApplication.pagesCount;
 }
}
function webViewerNextPage() {
 PDFViewerApplication.pdfViewer.nextPage();
}
function webViewerPreviousPage() {
 PDFViewerApplication.pdfViewer.previousPage();
}
function webViewerZoomIn() {
 PDFViewerApplication.zoomIn();
}
function webViewerZoomOut() {
 PDFViewerApplication.zoomOut();
}
function webViewerZoomReset() {
 PDFViewerApplication.zoomReset();
}
// lgylgylgy20220309
function webViewerPageNumberChanged(evt) {
  console.log('webViewerPageNumberChanged',evt);
  // __sdJSBridge&&__sdJSBridge.publish(`pageNumberChanged`,evt.value);
 const pdfViewer = PDFViewerApplication.pdfViewer;
    // sdpdfcore parseInt
 if (evt.value !== "") {
  PDFViewerApplication.pdfLinkService.goToPage(evt.value);
 }
 if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) {
  PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
 }
}
function webViewerScaleChanged(evt) {
  console.log('webViewerScaleChanged',evt);
  window.__sdJSBridge&&__sdJSBridge.publish(`scaleChanged`,evt.value);
 PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;
}
function webViewerRotateCw() {
 PDFViewerApplication.rotatePages(90);
}
function webViewerRotateCcw() {
 PDFViewerApplication.rotatePages(-90);
}
// ???
function webViewerOptionalContentConfig(evt) {
 PDFViewerApplication.pdfViewer.optionalContentConfigPromise = evt.promise;
}

function webViewerSwitchScrollMode(evt) {
 PDFViewerApplication.pdfViewer.scrollMode = evt.mode;
}
function webViewerSwitchSpreadMode(evt) {
 PDFViewerApplication.pdfViewer.spreadMode = evt.mode;
}
// saltdog disable documentProperties
// function webViewerDocumentProperties() {
//  PDFViewerApplication.pdfDocumentProperties.open();
// }
function webViewerFindFromUrlHash(evt) {
 PDFViewerApplication.eventBus.dispatch("find", {
  source: evt.source,
  type: "",
  query: evt.query,
  phraseSearch: evt.phraseSearch,
  caseSensitive: false,
  entireWord: false,
  highlightAll: true,
  findPrevious: false,
  matchDiacritics: true
 });
}
function webViewerUpdateFindMatchesCount({matchesCount}) {
 if (PDFViewerApplication.supportsIntegratedFind) {
  PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount);
 } else {
  PDFViewerApplication.findBar.updateResultsCount(matchesCount);
 }
}
function webViewerUpdateFindControlState({state, previous, matchesCount, rawQuery}) {
 if (PDFViewerApplication.supportsIntegratedFind) {
  PDFViewerApplication.externalServices.updateFindControlState({
   result: state,
   findPrevious: previous,
   matchesCount,
   rawQuery
  });
 } else {
  PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount);
 }
}
function webViewerScaleChanging(evt) {
 PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);
 PDFViewerApplication.pdfViewer.update();
}
function webViewerRotationChanging(evt) {
  // sdpdfcore disable sidebar
//  PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;
 PDFViewerApplication.forceRendering();
 PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;
}
function webViewerPageChanging({pageNumber, pageLabel}) {
 PDFViewerApplication.toolbar.setPageNumber(pageNumber, pageLabel);
 PDFViewerApplication.secondaryToolbar.setPageNumber(pageNumber);
 // sdpdfcore disable sidebar
//  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
//   PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(pageNumber);
//  }
}
function webViewerVisibilityChange(evt) {
 if (document.visibilityState === "visible") {
  setZoomDisabledTimeout();
 }
}
let zoomDisabledTimeout = null;
function setZoomDisabledTimeout() {
 if (zoomDisabledTimeout) {
  clearTimeout(zoomDisabledTimeout);
 }
 zoomDisabledTimeout = setTimeout(function () {
  zoomDisabledTimeout = null;
 }, WHEEL_ZOOM_DISABLED_TIMEOUT);
}
function webViewerWheel(evt) {
 const {pdfViewer, supportedMouseWheelZoomModifierKeys} = PDFViewerApplication;
 // saltdog disable presentation
//  if (pdfViewer.isInPresentationMode) {
//   return;
//  }
 if (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey) {
  evt.preventDefault();
  if (zoomDisabledTimeout || document.visibilityState === "hidden") {
   return;
  }
  const deltaMode = evt.deltaMode;
  const delta = normalizeWheelEventDirection(evt);
  const previousScale = pdfViewer.currentScale;
  let ticks = 0;
  if (deltaMode === WheelEvent.DOM_DELTA_LINE || deltaMode === WheelEvent.DOM_DELTA_PAGE) {
   if (Math.abs(delta) >= 1) {
    ticks = Math.sign(delta);
   } else {
    ticks = PDFViewerApplication.accumulateWheelTicks(delta);
   }
  } else {
   const PIXELS_PER_LINE_SCALE = 30;
   ticks = PDFViewerApplication.accumulateWheelTicks(delta / PIXELS_PER_LINE_SCALE);
  }
  if (ticks < 0) {
   PDFViewerApplication.zoomOut(-ticks);
  } else if (ticks > 0) {
   PDFViewerApplication.zoomIn(ticks);
  }
  const currentScale = pdfViewer.currentScale;
  if (previousScale !== currentScale) {
   const scaleCorrectionFactor = currentScale / previousScale - 1;
   const rect = pdfViewer.container.getBoundingClientRect();
   const dx = evt.clientX - rect.left;
   const dy = evt.clientY - rect.top;
   pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;
   pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;
  }
 } else {
  setZoomDisabledTimeout();
 }
}
function webViewerTouchStart(evt) {
 if (evt.touches.length > 1) {
  evt.preventDefault();
 }
}
function webViewerClick(evt) {
 if (!PDFViewerApplication.secondaryToolbar.isOpen) {
  return;
 }
 const appConfig = PDFViewerApplication.appConfig;
 if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar.toggleButton) {
  PDFViewerApplication.secondaryToolbar.close();
 }
}
function webViewerKeyDown(evt) {
 if (PDFViewerApplication.overlayManager.active) {
  return;
 }
 const {eventBus, pdfViewer} = PDFViewerApplication;
 // saltdog disable presentation
//  const isViewerInPresentationMode = pdfViewer.isInPresentationMode;
 let handled = false, ensureViewerFocused = false;
 const cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0);
 if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {
  switch (evt.keyCode) {
  case 70:
   if (!PDFViewerApplication.supportsIntegratedFind && !evt.shiftKey) {
    PDFViewerApplication.findBar.open();
    handled = true;
   }
   break;
  case 71:
   if (!PDFViewerApplication.supportsIntegratedFind) {
    const {state} = PDFViewerApplication.findController;
    if (state) {
     const eventState = Object.assign(Object.create(null), state, {
      source: window,
      type: "again",
      findPrevious: cmd === 5 || cmd === 12
     });
     eventBus.dispatch("find", eventState);
    }
    handled = true;
   }
   break;
  case 61:
  case 107:
  case 187:
  case 171:
  //  if (!isViewerInPresentationMode) {
    PDFViewerApplication.zoomIn();
  //  }
   handled = true;
   break;
  case 173:
  case 109:
  case 189:
  //  if (!isViewerInPresentationMode) {
    PDFViewerApplication.zoomOut();
  //  }
   handled = true;
   break;
  case 48:
  case 96:
  //  if (!isViewerInPresentationMode) {
    setTimeout(function () {
     PDFViewerApplication.zoomReset();
    });
    handled = false;
  //  }
   break;
  case 38:
   if (PDFViewerApplication.page > 1) {
    PDFViewerApplication.page = 1;
    handled = true;
    ensureViewerFocused = true;
   }
   break;
  case 40:
   if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
    PDFViewerApplication.page = PDFViewerApplication.pagesCount;
    handled = true;
    ensureViewerFocused = true;
   }
   break;
  }
 }
 if (cmd === 1 || cmd === 8) {
  switch (evt.keyCode) {
  case 83:
   eventBus.dispatch("download", { source: window });
   handled = true;
   break;
  case 79: {
    eventBus.dispatch("openfile", { source: window });
    handled = true;
   }
   break;
  }
 }
 if (cmd === 3 || cmd === 10) {
  switch (evt.keyCode) {
  case 80:
   
   handled = true;
   break;
  case 71:
   PDFViewerApplication.appConfig.toolbar.pageNumber.select();
   handled = true;
   break;
  }
 }
 if (handled) {
  if (ensureViewerFocused ) {
   pdfViewer.focus();
  }
  evt.preventDefault();
  return;
 }
 const curElement = getActiveOrFocusedElement();
 const curElementTagName = curElement?.tagName.toUpperCase();
 if (curElementTagName === "INPUT" || curElementTagName === "TEXTAREA" || curElementTagName === "SELECT" || curElement?.isContentEditable) {
  if (evt.keyCode !== 27) {
   return;
  }
 }
 if (cmd === 0) {
  let turnPage = 0, turnOnlyIfPageFit = false;
  switch (evt.keyCode) {
  case 38:
  case 33:
   if (pdfViewer.isVerticalScrollbarEnabled) {
    turnOnlyIfPageFit = true;
   }
   turnPage = -1;
   break;
  case 8:
    turnOnlyIfPageFit = true;
   turnPage = -1;
   break;
  case 37:
   if (pdfViewer.isHorizontalScrollbarEnabled) {
    turnOnlyIfPageFit = true;
   }
  case 75:
  case 80:
   turnPage = -1;
   break;
  case 27:
   if (PDFViewerApplication.secondaryToolbar.isOpen) {
    PDFViewerApplication.secondaryToolbar.close();
    handled = true;
   }
   if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened) {
    PDFViewerApplication.findBar.close();
    handled = true;
   }
   break;
  case 40:
  case 34:
   if (pdfViewer.isVerticalScrollbarEnabled) {
    turnOnlyIfPageFit = true;
   }
   turnPage = 1;
   break;
  case 13:
  case 32:
    turnOnlyIfPageFit = true;
  
   turnPage = 1;
   break;
  case 39:
   if (pdfViewer.isHorizontalScrollbarEnabled) {
    turnOnlyIfPageFit = true;
   }
  case 74:
  case 78:
   turnPage = 1;
   break;
  case 36:
   if (PDFViewerApplication.page > 1) {
    PDFViewerApplication.page = 1;
    handled = true;
    ensureViewerFocused = true;
   }
   break;
  case 35:
   if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
    PDFViewerApplication.page = PDFViewerApplication.pagesCount;
    handled = true;
    ensureViewerFocused = true;
   }
   break;
  case 83:
   PDFViewerApplication.pdfCursorTools.switchTool(CursorTool.SELECT);
   break;
  case 72:
   PDFViewerApplication.pdfCursorTools.switchTool(CursorTool.HAND);
   break;
  case 82:
   PDFViewerApplication.rotatePages(90);
   break;
  case 115:
    // sdpdfcore disable sidebar
  //  PDFViewerApplication.pdfSidebar.toggle();
   break;
  }
  if (turnPage !== 0 && (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === "page-fit")) {
   if (turnPage > 0) {
    pdfViewer.nextPage();
   } else {
    pdfViewer.previousPage();
   }
   handled = true;
  }
 }
 if (cmd === 4) {
  switch (evt.keyCode) {
  case 13:
  case 32:
   if (pdfViewer.currentScaleValue !== "page-fit") {
    break;
   }
   pdfViewer.previousPage();
   handled = true;
   break;
  case 82:
   PDFViewerApplication.rotatePages(-90);
   break;
  }
 }
 if (!handled ) {
  if (evt.keyCode >= 33 && evt.keyCode <= 40 || evt.keyCode === 32 && curElementTagName !== "BUTTON") {
   ensureViewerFocused = true;
  }
 }
 if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {
  pdfViewer.focus();
 }
 if (handled) {
  evt.preventDefault();
 }
}
function beforeUnload(evt) {
 evt.preventDefault();
 evt.returnValue = "";
 return false;
}
const PDFPrintServiceFactory = {
 instance: {
  supportsPrinting: false,
  createPrintService() {
   throw new Error("Not implemented: createPrintService");
  }
 }
};



/***/ }),

/***/ "./src/app_options.js":
/*!****************************!*\
  !*** ./src/app_options.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppOptions": function() { return /* binding */ AppOptions; },
/* harmony export */   "compatibilityParams": function() { return /* binding */ compatibilityParams; },
/* harmony export */   "OptionKind": function() { return /* binding */ OptionKind; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const compatibilityParams = Object.create(null);
{
 const userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
 const platform = typeof navigator !== "undefined" && navigator.platform || "";
 const maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1;
 const isAndroid = /Android/.test(userAgent);
 const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
 (function checkCanvasSizeLimitation() {
  if (isIOS || isAndroid) {
   compatibilityParams.maxCanvasPixels = 5242880;
  }
 }());
}
const OptionKind = {
 VIEWER: 0x02,
 API: 0x04,
 WORKER: 0x08,
 PREFERENCE: 0x80
};
const defaultOptions = {
 annotationMode: {
  value: 2,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 cursorToolOnLoad: {
  value: 0,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 findBlob: {
  value: null,
  kind: OptionKind.VIEWER
 },
 defaultZoomValue: {
  value: "",
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 disableHistory: {
  value: false,
  kind: OptionKind.VIEWER
 },
 disablePageLabels: {
  value: true, //sdpdfcore
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 enablePermissions: {
  value: false,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 enablePrintAutoRotate: {
  value: true,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 enableScripting: {
  value: true,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 externalLinkRel: {
  value: "noopener noreferrer nofollow",
  kind: OptionKind.VIEWER
 },
 externalLinkTarget: {
  value: 0,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 historyUpdateUrl: {
  value: false,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 ignoreDestinationZoom: {
  value: false,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 imageResourcesPath: {
  value: "./images/",
  kind: OptionKind.VIEWER
 },
 maxCanvasPixels: {
  value: 16777216,
  compatibility: compatibilityParams.maxCanvasPixels,
  kind: OptionKind.VIEWER
 },
 pdfBugEnabled: {
  value: true,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 printResolution: {
  value: 150,
  kind: OptionKind.VIEWER
 },
 renderer: {
  value: "canvas", // sdpdfcore pdfjsannotation
  kind: OptionKind.VIEWER
 },
 sidebarViewOnLoad: {
  value: -1,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 scrollModeOnLoad: {
  value: -1,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 spreadModeOnLoad: {
  value: -1,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 textLayerMode: {
  value: 1,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 useOnlyCssZoom: {
  value: false,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 viewerCssTheme: {
  value: 0,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 viewOnLoad: {
  value: 0,
  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
 },
 cMapPacked: {
  value: true,
  kind: OptionKind.API
 },
 cMapUrl: {
  value: "../external/bcmaps/",
  kind: OptionKind.API
 },
 disableAutoFetch: {
  value: false,
  kind: OptionKind.API + OptionKind.PREFERENCE
 },
 disableFontFace: {
  value: false,
  kind: OptionKind.API + OptionKind.PREFERENCE
 },
 disableRange: {
  value: false,
  kind: OptionKind.API + OptionKind.PREFERENCE
 },
 disableStream: {
  value: false,
  kind: OptionKind.API + OptionKind.PREFERENCE
 },
 docBaseUrl: {
  value: "",
  kind: OptionKind.API
 },
 enableXfa: {
  value: true,
  kind: OptionKind.API + OptionKind.PREFERENCE
 },
 fontExtraProperties: {
  value: false,
  kind: OptionKind.API
 },
 isEvalSupported: {
  value: true,
  kind: OptionKind.API
 },
 maxImageSize: {
  value: -1,
  kind: OptionKind.API
 },
 pdfBug: {
  value: false,
  kind: OptionKind.API
 },
 standardFontDataUrl: {
  value: "../external/standard_fonts/",
  kind: OptionKind.API
 },
 verbosity: {
  value: 1,
  kind: OptionKind.API
 },
 workerPort: {
  value: null,
  kind: OptionKind.WORKER
 },
 workerSrc: {
  value: "./pdf.worker.js",
  kind: OptionKind.WORKER
 }
};
{
 defaultOptions.disablePreferences = {
  value: false,
  kind: OptionKind.VIEWER
 };
 defaultOptions.locale = {
  value: typeof navigator !== "undefined" ? navigator.language : "en-US",
  kind: OptionKind.VIEWER
 };
 defaultOptions.sandboxBundleSrc = {
  value: "../build/dev-sandbox/pdf.sandbox.js",
  kind: OptionKind.VIEWER
 };
 defaultOptions.renderer.kind += OptionKind.PREFERENCE;
}
const userOptions = Object.create(null);
class AppOptions {
 constructor() {
  throw new Error("Cannot initialize AppOptions.");
 }
 static get(name) {
  const userOption = userOptions[name];
  if (userOption !== undefined) {
   return userOption;
  }
  const defaultOption = defaultOptions[name];
  if (defaultOption !== undefined) {
   return defaultOption.compatibility ?? defaultOption.value;
  }
  return undefined;
 }
 static getAll(kind = null) {
  const options = Object.create(null);
  for (const name in defaultOptions) {
   const defaultOption = defaultOptions[name];
   if (kind) {
    if ((kind & defaultOption.kind) === 0) {
     continue;
    }
    if (kind === OptionKind.PREFERENCE) {
     const value = defaultOption.value, valueType = typeof value;
     if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
      options[name] = value;
      continue;
     }
     throw new Error(`Invalid type for preference: ${ name }`);
    }
   }
   const userOption = userOptions[name];
   options[name] = userOption !== undefined ? userOption : defaultOption.compatibility ?? defaultOption.value;
  }
  return options;
 }
 static set(name, value) {
  userOptions[name] = value;
 }
 static setAll(options) {
  for (const name in options) {
   userOptions[name] = options[name];
  }
 }
 static remove(name) {
  delete userOptions[name];
 }
 static _hasUserOptions() {
  return Object.keys(userOptions).length > 0;
 }
}



/***/ }),

/***/ "./src/base_viewer.js":
/*!****************************!*\
  !*** ./src/base_viewer.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseViewer": function() { return /* binding */ BaseViewer; },
/* harmony export */   "PagesCountLimit": function() { return /* binding */ PagesCountLimit; },
/* harmony export */   "PDFPageViewBuffer": function() { return /* binding */ PDFPageViewBuffer; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {AnnotationMode, createPromiseCapability, PermissionFlag, PixelsPerInch, version} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const {DEFAULT_SCALE, DEFAULT_SCALE_DELTA, DEFAULT_SCALE_VALUE, getVisibleElements, isPortraitOrientation, isValidRotation, isValidScrollMode, isValidSpreadMode, MAX_AUTO_SCALE, MAX_SCALE, MIN_SCALE, RendererType, RenderingStates, SCROLLBAR_PADDING, scrollIntoView, ScrollMode, SpreadMode, TextLayerMode, UNKNOWN_SCALE, VERTICAL_PADDING, watchScroll} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const {AnnotationLayerBuilder} = __webpack_require__(/*! ./annotation_layer_builder.js */ "./src/annotation_layer_builder.js");
const {NullL10n} = __webpack_require__(/*! ./l10n_utils.js */ "./src/l10n_utils.js");
const {PDFPageView} = __webpack_require__(/*! ./pdf_page_view.js */ "./src/pdf_page_view.js");
const {PDFRenderingQueue} = __webpack_require__(/*! ./pdf_rendering_queue.js */ "./src/pdf_rendering_queue.js");
const {SimpleLinkService} = __webpack_require__(/*! ./pdf_link_service.js */ "./src/pdf_link_service.js");
const {StructTreeLayerBuilder} = __webpack_require__(/*! ./struct_tree_layer_builder.js */ "./src/struct_tree_layer_builder.js");
const {TextHighlighter} = __webpack_require__(/*! ./text_highlighter.js */ "./src/text_highlighter.js");
const {TextLayerBuilder} = __webpack_require__(/*! ./text_layer_builder.js */ "./src/text_layer_builder.js");
const {XfaLayerBuilder} = __webpack_require__(/*! ./xfa_layer_builder.js */ "./src/xfa_layer_builder.js");
const DEFAULT_CACHE_SIZE = 10;
const ENABLE_PERMISSIONS_CLASS = "enablePermissions";
const PagesCountLimit = {
 FORCE_SCROLL_MODE_PAGE: 15000,
 FORCE_LAZY_PAGE_INIT: 7500,
 PAUSE_EAGER_PAGE_INIT: 250
};
class PDFPageViewBuffer {
 #buf = new Set();
 #size = 0;
 constructor(size) {
  this.#size = size;
 }
 push(view) {
  const buf = this.#buf;
  if (buf.has(view)) {
   buf.delete(view);
  }
  buf.add(view);
  if (buf.size > this.#size) {
   this.#destroyFirstView();
  }
 }
 resize(newSize, idsToKeep = null) {
  this.#size = newSize;
  const buf = this.#buf;
  if (idsToKeep) {
   const ii = buf.size;
   let i = 1;
   for (const view of buf) {
    if (idsToKeep.has(view.id)) {
     buf.delete(view);
     buf.add(view);
    }
    if (++i > ii) {
     break;
    }
   }
  }
  while (buf.size > this.#size) {
   this.#destroyFirstView();
  }
 }
 has(view) {
  return this.#buf.has(view);
 }
 [Symbol.iterator]() {
  return this.#buf.keys();
 }
 #destroyFirstView() {
  const firstView = this.#buf.keys().next().value;
  firstView?.destroy();
  this.#buf.delete(firstView);
 }
}
class BaseViewer {
 #buffer = null;
 #annotationMode = AnnotationMode.ENABLE_FORMS;
 #previousAnnotationMode = null;
 #enablePermissions = false;
 #previousContainerHeight = 0;
 #scrollModePageState = null;
 #onVisibilityChange = null;
 constructor(options) {
  if (this.constructor === BaseViewer) {
   throw new Error("Cannot initialize BaseViewer.");
  }
  const viewerVersion = '2.12.313';
  if (version !== viewerVersion) {
   throw new Error(`The API version "${ version }" does not match the Viewer version "${ viewerVersion }".`);
  }
  this.container = options.container;
  this.viewer = options.viewer || options.container.firstElementChild;
  if (!(this.container?.tagName.toUpperCase() === "DIV" && this.viewer?.tagName.toUpperCase() === "DIV")) {
   throw new Error("Invalid `container` and/or `viewer` option.");
  }
  if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute") {
   throw new Error("The `container` must be absolutely positioned.");
  }
  this.eventBus = options.eventBus;
  this.linkService = options.linkService || new SimpleLinkService();
  this.downloadManager = options.downloadManager || null;
  this.findController = options.findController || null;
  this._scriptingManager = options.scriptingManager || null;
  this.removePageBorders = options.removePageBorders || false;
  this.textLayerMode = options.textLayerMode ?? TextLayerMode.ENABLE;
  this.#annotationMode = options.annotationMode ?? AnnotationMode.ENABLE_FORMS;
  this.imageResourcesPath = options.imageResourcesPath || "";
  this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
  this.renderer = options.renderer || RendererType.CANVAS;
  this.useOnlyCssZoom = options.useOnlyCssZoom || false;
  this.maxCanvasPixels = options.maxCanvasPixels;
  this.l10n = options.l10n || NullL10n;
  this.#enablePermissions = options.enablePermissions || false;
  this.defaultRenderingQueue = !options.renderingQueue;
  if (this.defaultRenderingQueue) {
   this.renderingQueue = new PDFRenderingQueue();
   this.renderingQueue.setViewer(this);
  } else {
   this.renderingQueue = options.renderingQueue;
  }
  this._doc = document.documentElement;
  this.scroll = watchScroll(this.container, this._scrollUpdate.bind(this));
  this._onBeforeDraw = this._onAfterDraw = null;
  this._resetView();
  if (this.removePageBorders) {
   this.viewer.classList.add("removePageBorders");
  }
  Promise.resolve().then(() => {
   this.eventBus.dispatch("baseviewerinit", { source: this });
  });
 }
 get pagesCount() {
  return this._pages.length;
 }
 getPageView(index) {
  return this._pages[index];
 }
 get pageViewsReady() {
  if (!this._pagesCapability.settled) {
   return false;
  }
  return this._pages.every(function (pageView) {
   return pageView?.pdfPage;
  });
 }
 get renderForms() {
  return this.#annotationMode === AnnotationMode.ENABLE_FORMS;
 }
 get enableScripting() {
  return !!this._scriptingManager;
 }
 get currentPageNumber() {
  return this._currentPageNumber;
 }
 set currentPageNumber(val) {
  if (!Number.isInteger(val)) {
   throw new Error("Invalid page number.");
  }
  if (!this.pdfDocument) {
   return;
  }
  if (!this._setCurrentPageNumber(val, true)) {
   console.error(`currentPageNumber: "${ val }" is not a valid page.`);
  }
 }
 _setCurrentPageNumber(val, resetCurrentPageView = false) {
  if (this._currentPageNumber === val) {
   if (resetCurrentPageView) {
    this._resetCurrentPageView();
   }
   return true;
  }
  if (!(0 < val && val <= this.pagesCount)) {
   return false;
  }
  const previous = this._currentPageNumber;
  this._currentPageNumber = val;
  this.eventBus.dispatch("pagechanging", {
   source: this,
   pageNumber: val,
   pageLabel: this._pageLabels?.[val - 1] ?? null,
   previous
  });
  if (resetCurrentPageView) {
   this._resetCurrentPageView();
  }
  return true;
 }
 get currentPageLabel() {
  return this._pageLabels?.[this._currentPageNumber - 1] ?? null;
 }
 set currentPageLabel(val) {
  if (!this.pdfDocument) {
   return;
  }
  let page = val | 0;
  if (this._pageLabels) {
   const i = this._pageLabels.indexOf(val);
   if (i >= 0) {
    page = i + 1;
   }
  }
  if (!this._setCurrentPageNumber(page, true)) {
   console.error(`currentPageLabel: "${ val }" is not a valid page.`);
  }
 }
 get currentScale() {
  return this._currentScale !== UNKNOWN_SCALE ? this._currentScale : DEFAULT_SCALE;
 }
 set currentScale(val) {
  if (isNaN(val)) {
   throw new Error("Invalid numeric scale.");
  }
  if (!this.pdfDocument) {
   return;
  }
  this._setScale(val, false);
 }
 get currentScaleValue() {
  return this._currentScaleValue;
 }
 set currentScaleValue(val) {
  if (!this.pdfDocument) {
   return;
  }
  this._setScale(val, false);
 }
 get pagesRotation() {
  return this._pagesRotation;
 }
 set pagesRotation(rotation) {
  if (!isValidRotation(rotation)) {
   throw new Error("Invalid pages rotation angle.");
  }
  if (!this.pdfDocument) {
   return;
  }
  rotation %= 360;
  if (rotation < 0) {
   rotation += 360;
  }
  if (this._pagesRotation === rotation) {
   return;
  }
  this._pagesRotation = rotation;
  const pageNumber = this._currentPageNumber;
  const updateArgs = { rotation };
  for (const pageView of this._pages) {
   pageView.update(updateArgs);
  }
  if (this._currentScaleValue) {
   this._setScale(this._currentScaleValue, true);
  }
  this.eventBus.dispatch("rotationchanging", {
   source: this,
   pagesRotation: rotation,
   pageNumber
  });
  if (this.defaultRenderingQueue) {
   this.update();
  }
 }
 get firstPagePromise() {
  return this.pdfDocument ? this._firstPageCapability.promise : null;
 }
 get onePageRendered() {
  return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
 }
 get pagesPromise() {
  return this.pdfDocument ? this._pagesCapability.promise : null;
 }
 #initializePermissions(permissions) {
  if (!permissions) {
   return;
  }
  if (!permissions.includes(PermissionFlag.COPY)) {
   this.viewer.classList.add(ENABLE_PERMISSIONS_CLASS);
  }
  if (!permissions.includes(PermissionFlag.MODIFY_ANNOTATIONS) && !permissions.includes(PermissionFlag.FILL_INTERACTIVE_FORMS)) {
   if (this.#annotationMode === AnnotationMode.ENABLE_FORMS) {
    this.#previousAnnotationMode = this.#annotationMode;
    this.#annotationMode = AnnotationMode.ENABLE;
   }
  }
 }
 #onePageRenderedOrForceFetch() {
  if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0) {
   return Promise.resolve();
  }
  const visibilityChangePromise = new Promise(resolve => {
   this.#onVisibilityChange = () => {
    if (document.visibilityState !== "hidden") {
     return;
    }
    resolve();
    document.removeEventListener("visibilitychange", this.#onVisibilityChange);
    this.#onVisibilityChange = null;
   };
   document.addEventListener("visibilitychange", this.#onVisibilityChange);
  });
  return Promise.race([
   this._onePageRenderedCapability.promise,
   visibilityChangePromise
  ]);
 }
 setDocument(pdfDocument) {
  if (this.pdfDocument) {
   this.eventBus.dispatch("pagesdestroy", { source: this });
   this._cancelRendering();
   this._resetView();
   if (this.findController) {
    this.findController.setDocument(null);
   }
   if (this._scriptingManager) {
    this._scriptingManager.setDocument(null);
   }
  }
  this.pdfDocument = pdfDocument;
  if (!pdfDocument) {
   return;
  }
  const isPureXfa = pdfDocument.isPureXfa;
  const pagesCount = pdfDocument.numPages;
  const firstPagePromise = pdfDocument.getPage(1);
  const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();
  const permissionsPromise = this.#enablePermissions ? pdfDocument.getPermissions() : Promise.resolve();
  if (pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
   console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
   const mode = this._scrollMode = ScrollMode.PAGE;
   this.eventBus.dispatch("scrollmodechanged", {
    source: this,
    mode
   });
  }
  this._pagesCapability.promise.then(() => {
   this.eventBus.dispatch("pagesloaded", {
    source: this,
    pagesCount
   });
  }, () => {
  });
  this._onBeforeDraw = evt => {
   const pageView = this._pages[evt.pageNumber - 1];
   if (!pageView) {
    return;
   }
   this.#buffer.push(pageView);
  };
  this.eventBus._on("pagerender", this._onBeforeDraw);
  this._onAfterDraw = evt => {
   if (evt.cssTransform || this._onePageRenderedCapability.settled) {
    return;
   }
   this._onePageRenderedCapability.resolve({ timestamp: evt.timestamp });
   this.eventBus._off("pagerendered", this._onAfterDraw);
   this._onAfterDraw = null;
   if (this.#onVisibilityChange) {
    document.removeEventListener("visibilitychange", this.#onVisibilityChange);
    this.#onVisibilityChange = null;
   }
  };
  this.eventBus._on("pagerendered", this._onAfterDraw);
  Promise.all([
   firstPagePromise,
   permissionsPromise
  ]).then(([firstPdfPage, permissions]) => {
   if (pdfDocument !== this.pdfDocument) {
    return;
   }
   this._firstPageCapability.resolve(firstPdfPage);
   this._optionalContentConfigPromise = optionalContentConfigPromise;
   this.#initializePermissions(permissions);
   const viewerElement = this._scrollMode === ScrollMode.PAGE ? null : this.viewer;
   const scale = this.currentScale;
   const viewport = firstPdfPage.getViewport({ scale: scale * PixelsPerInch.PDF_TO_CSS_UNITS });
   const textLayerFactory = this.textLayerMode !== TextLayerMode.DISABLE && !isPureXfa ? this : null;
   const annotationLayerFactory = this.#annotationMode !== AnnotationMode.DISABLE ? this : null;
   const xfaLayerFactory = isPureXfa ? this : null;
   for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
    const pageView = new PDFPageView({
     container: viewerElement,
     eventBus: this.eventBus,
     id: pageNum,
     scale,
     defaultViewport: viewport.clone(),
     optionalContentConfigPromise,
     renderingQueue: this.renderingQueue,
     textLayerFactory,
     textLayerMode: this.textLayerMode,
     annotationLayerFactory,
     annotationMode: this.#annotationMode,
     xfaLayerFactory,
     textHighlighterFactory: this,
     structTreeLayerFactory: this,
     imageResourcesPath: this.imageResourcesPath,
     renderer: this.renderer,
     useOnlyCssZoom: this.useOnlyCssZoom,
     maxCanvasPixels: this.maxCanvasPixels,
     l10n: this.l10n
    });
    this._pages.push(pageView);
   }
   const firstPageView = this._pages[0];
   if (firstPageView) {
    firstPageView.setPdfPage(firstPdfPage);
    this.linkService.cachePageRef(1, firstPdfPage.ref);
   }
   if (this._scrollMode === ScrollMode.PAGE) {
    this.#ensurePageViewVisible();
   } else if (this._spreadMode !== SpreadMode.NONE) {
    this._updateSpreadMode();
   }
   this.#onePageRenderedOrForceFetch().then(async () => {
    if (this.findController) {
     this.findController.setDocument(pdfDocument);
    }
    if (this._scriptingManager) {
     this._scriptingManager.setDocument(pdfDocument);
    }
    if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > PagesCountLimit.FORCE_LAZY_PAGE_INIT) {
     this._pagesCapability.resolve();
     return;
    }
    let getPagesLeft = pagesCount - 1;
    if (getPagesLeft <= 0) {
     this._pagesCapability.resolve();
     return;
    }
    for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
     const promise = pdfDocument.getPage(pageNum).then(pdfPage => {
      const pageView = this._pages[pageNum - 1];
      if (!pageView.pdfPage) {
       pageView.setPdfPage(pdfPage);
      }
      this.linkService.cachePageRef(pageNum, pdfPage.ref);
      if (--getPagesLeft === 0) {
       this._pagesCapability.resolve();
      }
     }, reason => {
      console.error(`Unable to get page ${ pageNum } to initialize viewer`, reason);
      if (--getPagesLeft === 0) {
       this._pagesCapability.resolve();
      }
     });
     if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) {
      await promise;
     }
    }
   });
   this.eventBus.dispatch("pagesinit", { source: this });
   pdfDocument.getMetadata().then(({info}) => {
    if (pdfDocument !== this.pdfDocument) {
     return;
    }
    if (info.Language) {
     this.viewer.lang = info.Language;
    }
   });
   if (this.defaultRenderingQueue) {
    this.update();
   }
  }).catch(reason => {
   console.error("Unable to initialize viewer", reason);
   this._pagesCapability.reject(reason);
  });
 }
 setPageLabels(labels) {
  if (!this.pdfDocument) {
   return;
  }
  if (!labels) {
   this._pageLabels = null;
  } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
   this._pageLabels = null;
   console.error(`setPageLabels: Invalid page labels.`);
  } else {
   this._pageLabels = labels;
  }
  for (let i = 0, ii = this._pages.length; i < ii; i++) {
   this._pages[i].setPageLabel(this._pageLabels?.[i] ?? null);
  }
 }
 _resetView() {
  this._pages = [];
  this._currentPageNumber = 1;
  this._currentScale = UNKNOWN_SCALE;
  this._currentScaleValue = null;
  this._pageLabels = null;
  this.#buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
  this._location = null;
  this._pagesRotation = 0;
  this._optionalContentConfigPromise = null;
  this._firstPageCapability = createPromiseCapability();
  this._onePageRenderedCapability = createPromiseCapability();
  this._pagesCapability = createPromiseCapability();
  this._scrollMode = ScrollMode.VERTICAL;
  this._previousScrollMode = ScrollMode.UNKNOWN;
  this._spreadMode = SpreadMode.NONE;
  this.#scrollModePageState = {
   previousPageNumber: 1,
   scrollDown: true,
   pages: []
  };
  if (this._onBeforeDraw) {
   this.eventBus._off("pagerender", this._onBeforeDraw);
   this._onBeforeDraw = null;
  }
  if (this._onAfterDraw) {
   this.eventBus._off("pagerendered", this._onAfterDraw);
   this._onAfterDraw = null;
  }
  if (this.#onVisibilityChange) {
   document.removeEventListener("visibilitychange", this.#onVisibilityChange);
   this.#onVisibilityChange = null;
  }
  this.viewer.textContent = "";
  this._updateScrollMode();
  this.viewer.removeAttribute("lang");
  this.viewer.classList.remove(ENABLE_PERMISSIONS_CLASS);
  if (this.#previousAnnotationMode !== null) {
   this.#annotationMode = this.#previousAnnotationMode;
   this.#previousAnnotationMode = null;
  }
 }
 #ensurePageViewVisible() {
  if (this._scrollMode !== ScrollMode.PAGE) {
   throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
  }
  const pageNumber = this._currentPageNumber, state = this.#scrollModePageState, viewer = this.viewer;
  viewer.textContent = "";
  state.pages.length = 0;
  if (this._spreadMode === SpreadMode.NONE) {
   const pageView = this._pages[pageNumber - 1];

    viewer.appendChild(pageView.div);
   
   state.pages.push(pageView);
  } else {
   const pageIndexSet = new Set(), parity = this._spreadMode - 1;
   if (pageNumber % 2 !== parity) {
    pageIndexSet.add(pageNumber - 1);
    pageIndexSet.add(pageNumber);
   } else {
    pageIndexSet.add(pageNumber - 2);
    pageIndexSet.add(pageNumber - 1);
   }
   let spread = null;
   for (const i of pageIndexSet) {
    const pageView = this._pages[i];
    if (!pageView) {
     continue;
    }
    if (spread === null) {
     spread = document.createElement("div");
     spread.className = "spread";
     viewer.appendChild(spread);
    } else if (i % 2 === parity) {
     spread = spread.cloneNode(false);
     viewer.appendChild(spread);
    }
    spread.appendChild(pageView.div);
    state.pages.push(pageView);
   }
  }
  state.scrollDown = pageNumber >= state.previousPageNumber;
  state.previousPageNumber = pageNumber;
 }
 _scrollUpdate() {
  if (this.pagesCount === 0) {
   return;
  }
  this.update();
 }
 _scrollIntoView({pageDiv, pageSpot = null, pageNumber = null}) {
  if (this._scrollMode === ScrollMode.PAGE) {
   if (pageNumber) {
    this._setCurrentPageNumber(pageNumber);
   }
   this.#ensurePageViewVisible();
   this.update();
  }
  if (!pageSpot) {
   const left = pageDiv.offsetLeft + pageDiv.clientLeft;
   const right = left + pageDiv.clientWidth;
   const {scrollLeft, clientWidth} = this.container;
   if (this._scrollMode === ScrollMode.HORIZONTAL || left < scrollLeft || right > scrollLeft + clientWidth) {
    pageSpot = {
     left: 0,
     top: 0
    };
   }
  }
  scrollIntoView(pageDiv, pageSpot);
 }
 #isSameScale(newScale) {
  return newScale === this._currentScale || Math.abs(newScale - this._currentScale) < 1e-15;
 }
 _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {
  this._currentScaleValue = newValue.toString();
  if (this.#isSameScale(newScale)) {
   if (preset) {
    this.eventBus.dispatch("scalechanging", {
     source: this,
     scale: newScale,
     presetValue: newValue
    });
   }
   return;
  }
  this._doc.style.setProperty("--zoom-factor", newScale);
  this._doc.style.setProperty("--viewport-scale-factor", newScale * PixelsPerInch.PDF_TO_CSS_UNITS);
  const updateArgs = { scale: newScale };
  for (const pageView of this._pages) {
   pageView.update(updateArgs);
  }
  this._currentScale = newScale;
  if (!noScroll) {
   let page = this._currentPageNumber, dest;
   if (this._location) {
    page = this._location.pageNumber;
    dest = [
     null,
     { name: "XYZ" },
     this._location.left,
     this._location.top,
     null
    ];
   }
   this.scrollPageIntoView({
    pageNumber: page,
    destArray: dest,
    allowNegativeOffset: true
   });
  }
  this.eventBus.dispatch("scalechanging", {
   source: this,
   scale: newScale,
   presetValue: preset ? newValue : undefined
  });
  if (this.defaultRenderingQueue) {
   this.update();
  }
  this.#previousContainerHeight = this.container.clientHeight;
 }
 get _pageWidthScaleFactor() {
  if (this._spreadMode !== SpreadMode.NONE && this._scrollMode !== ScrollMode.HORIZONTAL) {
   return 2;
  }
  return 1;
 }
 _setScale(value, noScroll = false) {
  let scale = parseFloat(value);
  if (scale > 0) {
   this._setScaleUpdatePages(scale, value, noScroll, false);
  } else {
   const currentPage = this._pages[this._currentPageNumber - 1];
   if (!currentPage) {
    return;
   }
   let hPadding = SCROLLBAR_PADDING, vPadding = VERTICAL_PADDING;
  if (this.removePageBorders) {
    hPadding = vPadding = 0;
   }
   if (this._scrollMode === ScrollMode.HORIZONTAL) {
    [hPadding, vPadding] = [
     vPadding,
     hPadding
    ];
   }
   const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor;
   const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;
   switch (value) {
   case "page-actual":
    scale = 1;
    break;
   case "page-width":
    scale = pageWidthScale;
    break;
   case "page-height":
    scale = pageHeightScale;
    break;
   case "page-fit":
    scale = Math.min(pageWidthScale, pageHeightScale);
    break;
   case "auto":
    const horizontalScale = isPortraitOrientation(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
    scale = Math.min(MAX_AUTO_SCALE, horizontalScale);
    break;
   default:
    console.error(`_setScale: "${ value }" is an unknown zoom value.`);
    return;
   }
   this._setScaleUpdatePages(scale, value, noScroll, true);
  }
 }
 _resetCurrentPageView() {

  const pageView = this._pages[this._currentPageNumber - 1];
  this._scrollIntoView({ pageDiv: pageView.div });
 }
 pageLabelToPageNumber(label) {
  if (!this._pageLabels) {
   return null;
  }
  const i = this._pageLabels.indexOf(label);
  if (i < 0) {
   return null;
  }
  return i + 1;
 }
 scrollPageIntoView({pageNumber, destArray = null, allowNegativeOffset = false, ignoreDestinationZoom = false}) {
  if (!this.pdfDocument) {
   return;
  }
  const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];
  if (!pageView) {
   console.error(`scrollPageIntoView: "${ pageNumber }" is not a valid pageNumber parameter.`);
   return;
  }
  if (!destArray) {
    this._setCurrentPageNumber(pageNumber, true);
    return;
   }
  let x = 0, y = 0;
  let width = 0, height = 0, widthScale, heightScale;
  const changeOrientation = pageView.rotation % 180 !== 0;
  const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / PixelsPerInch.PDF_TO_CSS_UNITS;
  const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / PixelsPerInch.PDF_TO_CSS_UNITS;
  let scale = 0;
  switch (destArray[1].name) {
  case "XYZ":
   x = destArray[2];
   y = destArray[3];
   scale = destArray[4];
   x = x !== null ? x : 0;
   y = y !== null ? y : pageHeight;
   break;
  case "Fit":
  case "FitB":
   scale = "page-fit";
   break;
  case "FitH":
  case "FitBH":
   y = destArray[2];
   scale = "page-width";
   if (y === null && this._location) {
    x = this._location.left;
    y = this._location.top;
   } else if (typeof y !== "number" || y < 0) {
    y = pageHeight;
   }
   break;
  case "FitV":
  case "FitBV":
   x = destArray[2];
   width = pageWidth;
   height = pageHeight;
   scale = "page-height";
   break;
  case "FitR":
   x = destArray[2];
   y = destArray[3];
   width = destArray[4] - x;
   height = destArray[5] - y;
   const hPadding = this.removePageBorders ? 0 : SCROLLBAR_PADDING;
   const vPadding = this.removePageBorders ? 0 : VERTICAL_PADDING;
   widthScale = (this.container.clientWidth - hPadding) / width / PixelsPerInch.PDF_TO_CSS_UNITS;
   heightScale = (this.container.clientHeight - vPadding) / height / PixelsPerInch.PDF_TO_CSS_UNITS;
   scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
   break;
  default:
   console.error(`scrollPageIntoView: "${ destArray[1].name }" is not a valid destination type.`);
   return;
  }
  if (!ignoreDestinationZoom) {
   if (scale && scale !== this._currentScale) {
    this.currentScaleValue = scale;
   } else if (this._currentScale === UNKNOWN_SCALE) {
    this.currentScaleValue = DEFAULT_SCALE_VALUE;
   }
  }
  if (scale === "page-fit" && !destArray[4]) {
   this._scrollIntoView({
    pageDiv: pageView.div,
    pageNumber
   });
   return;
  }
  const boundingRect = [
   pageView.viewport.convertToViewportPoint(x, y),
   pageView.viewport.convertToViewportPoint(x + width, y + height)
  ];
  let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
  let top = Math.min(boundingRect[0][1], boundingRect[1][1]);
  if (!allowNegativeOffset) {
   left = Math.max(left, 0);
   top = Math.max(top, 0);
  }
  this._scrollIntoView({
   pageDiv: pageView.div,
   pageSpot: {
    left,
    top
   },
   pageNumber
  });
 }
 _updateLocation(firstPage) {
  const currentScale = this._currentScale;
  const currentScaleValue = this._currentScaleValue;
  const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;
  const pageNumber = firstPage.id;
  let pdfOpenParams = "#page=" + pageNumber;
  pdfOpenParams += "&zoom=" + normalizedScaleValue;
  const currentPageView = this._pages[pageNumber - 1];
  const container = this.container;
  const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
  const intLeft = Math.round(topLeft[0]);
  const intTop = Math.round(topLeft[1]);
  pdfOpenParams += "," + intLeft + "," + intTop;
  this._location = {
   pageNumber,
   scale: normalizedScaleValue,
   top: intTop,
   left: intLeft,
   rotation: this._pagesRotation,
   pdfOpenParams
  };
 }
 update() {
  const visible = this._getVisiblePages();
  const visiblePages = visible.views, numVisiblePages = visiblePages.length;
  if (numVisiblePages === 0) {
   return;
  }
  const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);
  this.#buffer.resize(newCacheSize, visible.ids);
  this.renderingQueue.renderHighestPriority(visible);

   const isSimpleLayout = this._spreadMode === SpreadMode.NONE && (this._scrollMode === ScrollMode.PAGE || this._scrollMode === ScrollMode.VERTICAL);
   let currentId = this._currentPageNumber;
   let stillFullyVisible = false;
   for (const page of visiblePages) {
    if (page.percent < 100) {
     break;
    }
    if (page.id === currentId && isSimpleLayout) {
     stillFullyVisible = true;
     break;
    }
   }
   if (!stillFullyVisible) {
    currentId = visiblePages[0].id;
   }
   this._setCurrentPageNumber(currentId);
  
  this._updateLocation(visible.first);
  this.eventBus.dispatch("updateviewarea", {
   source: this,
   location: this._location
  });
 }
 containsElement(element) {
  return this.container.contains(element);
 }
 focus() {
  this.container.focus();
 }
 get _isContainerRtl() {
  return getComputedStyle(this.container).direction === "rtl";
 }


 get isHorizontalScrollbarEnabled() {
  return this.container.scrollWidth > this.container.clientWidth;
 }
 get isVerticalScrollbarEnabled() {
  return this.container.scrollHeight > this.container.clientHeight;
 }
 _getCurrentVisiblePage() {
  if (!this.pagesCount) {
   return { views: [] };
  }
  const pageView = this._pages[this._currentPageNumber - 1];
  const element = pageView.div;
  const view = {
   id: pageView.id,
   x: element.offsetLeft + element.clientLeft,
   y: element.offsetTop + element.clientTop,
   view: pageView
  };
  const ids = new Set([pageView.id]);
  return {
   first: view,
   last: view,
   views: [view],
   ids
  };
 }
 _getVisiblePages() {

  const views = this._scrollMode === ScrollMode.PAGE ? this.#scrollModePageState.pages : this._pages, horizontal = this._scrollMode === ScrollMode.HORIZONTAL, rtl = horizontal && this._isContainerRtl;
  return getVisibleElements({
   scrollEl: this.container,
   views,
   sortByVisibility: true,
   horizontal,
   rtl
  });
 }
 isPageVisible(pageNumber) {
  if (!this.pdfDocument) {
   return false;
  }
  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
   console.error(`isPageVisible: "${ pageNumber }" is not a valid page.`);
   return false;
  }
  return this._getVisiblePages().ids.has(pageNumber);
 }
 isPageCached(pageNumber) {
  if (!this.pdfDocument) {
   return false;
  }
  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
   console.error(`isPageCached: "${ pageNumber }" is not a valid page.`);
   return false;
  }
  const pageView = this._pages[pageNumber - 1];
  return this.#buffer.has(pageView);
 }
 cleanup() {
  for (let i = 0, ii = this._pages.length; i < ii; i++) {
   if (this._pages[i] && this._pages[i].renderingState !== RenderingStates.FINISHED) {
    this._pages[i].reset();
   }
  }
 }
 _cancelRendering() {
  for (let i = 0, ii = this._pages.length; i < ii; i++) {
   if (this._pages[i]) {
    this._pages[i].cancelRendering();
   }
  }
 }
 async #ensurePdfPageLoaded(pageView) {
  if (pageView.pdfPage) {
   return pageView.pdfPage;
  }
  try {
   const pdfPage = await this.pdfDocument.getPage(pageView.id);
   if (!pageView.pdfPage) {
    pageView.setPdfPage(pdfPage);
   }
   if (!this.linkService._cachedPageNumber?.(pdfPage.ref)) {
    this.linkService.cachePageRef(pageView.id, pdfPage.ref);
   }
   return pdfPage;
  } catch (reason) {
   console.error("Unable to get page for page view", reason);
   return null;
  }
 }
 #getScrollAhead(visible) {
  if (visible.first?.id === 1) {
   return true;
  } else if (visible.last?.id === this.pagesCount) {
   return false;
  }
  switch (this._scrollMode) {
  case ScrollMode.PAGE:
   return this.#scrollModePageState.scrollDown;
  case ScrollMode.HORIZONTAL:
   return this.scroll.right;
  }
  return this.scroll.down;
 }
 #toggleLoadingIconSpinner(visibleIds) {
  for (const id of visibleIds) {
   const pageView = this._pages[id - 1];
   pageView?.toggleLoadingIconSpinner(true);
  }
  for (const pageView of this.#buffer) {
   if (visibleIds.has(pageView.id)) {
    continue;
   }
   pageView.toggleLoadingIconSpinner(false);
  }
 }
 forceRendering(currentlyVisiblePages) {
  const visiblePages = currentlyVisiblePages || this._getVisiblePages();
  const scrollAhead = this.#getScrollAhead(visiblePages);
  const preRenderExtra = this._spreadMode !== SpreadMode.NONE && this._scrollMode !== ScrollMode.HORIZONTAL;
  const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra);
  this.#toggleLoadingIconSpinner(visiblePages.ids);
  if (pageView) {
   this.#ensurePdfPageLoaded(pageView).then(() => {
    this.renderingQueue.renderView(pageView);
   });
   return true;
  }
  return false;
 }
 createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus, highlighter) {
  return new TextLayerBuilder({
   textLayerDiv,
   eventBus,
   pageIndex,
   viewport,
   enhanceTextSelection:  enhanceTextSelection,
   highlighter
  });
 }
 createTextHighlighter(pageIndex, eventBus) {
  return new TextHighlighter({
   eventBus,
   pageIndex,
   findController:  this.findController
  });
 }
 createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = "", renderForms = true, l10n = NullL10n, enableScripting = null, hasJSActionsPromise = null, mouseState = null, fieldObjectsPromise = null, annotationCanvasMap = null) {
  return new AnnotationLayerBuilder({
   pageDiv,
   pdfPage,
   annotationStorage: annotationStorage || this.pdfDocument?.annotationStorage,
   imageResourcesPath,
   renderForms,
   linkService: this.linkService,
   downloadManager: this.downloadManager,
   l10n,
   enableScripting: enableScripting ?? this.enableScripting,
   hasJSActionsPromise: hasJSActionsPromise || this.pdfDocument?.hasJSActions(),
   fieldObjectsPromise: fieldObjectsPromise || this.pdfDocument?.getFieldObjects(),
   mouseState: mouseState || this._scriptingManager?.mouseState,
   annotationCanvasMap
  });
 }
 createXfaLayerBuilder(pageDiv, pdfPage, annotationStorage = null) {
  return new XfaLayerBuilder({
   pageDiv,
   pdfPage,
   annotationStorage: annotationStorage || this.pdfDocument?.annotationStorage,
   linkService: this.linkService
  });
 }
 createStructTreeLayerBuilder(pdfPage) {
  return new StructTreeLayerBuilder({ pdfPage });
 }
 get hasEqualPageSizes() {
  const firstPageView = this._pages[0];
  for (let i = 1, ii = this._pages.length; i < ii; ++i) {
   const pageView = this._pages[i];
   if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
    return false;
   }
  }
  return true;
 }
 getPagesOverview() {
  return this._pages.map(pageView => {
   const viewport = pageView.pdfPage.getViewport({ scale: 1 });
   if (!this.enablePrintAutoRotate || isPortraitOrientation(viewport)) {
    return {
     width: viewport.width,
     height: viewport.height,
     rotation: viewport.rotation
    };
   }
   return {
    width: viewport.height,
    height: viewport.width,
    rotation: (viewport.rotation - 90) % 360
   };
  });
 }
 get optionalContentConfigPromise() {
  if (!this.pdfDocument) {
   return Promise.resolve(null);
  }
  if (!this._optionalContentConfigPromise) {
   return this.pdfDocument.getOptionalContentConfig();
  }
  return this._optionalContentConfigPromise;
 }
 set optionalContentConfigPromise(promise) {
  if (!(promise instanceof Promise)) {
   throw new Error(`Invalid optionalContentConfigPromise: ${ promise }`);
  }
  if (!this.pdfDocument) {
   return;
  }
  if (!this._optionalContentConfigPromise) {
   return;
  }
  this._optionalContentConfigPromise = promise;
  const updateArgs = { optionalContentConfigPromise: promise };
  for (const pageView of this._pages) {
   pageView.update(updateArgs);
  }
  this.update();
  this.eventBus.dispatch("optionalcontentconfigchanged", {
   source: this,
   promise
  });
 }
 get scrollMode() {
  return this._scrollMode;
 }
 set scrollMode(mode) {
  if (this._scrollMode === mode) {
   return;
  }
  if (!isValidScrollMode(mode)) {
   throw new Error(`Invalid scroll mode: ${ mode }`);
  }
  if (this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
   return;
  }
  this._previousScrollMode = this._scrollMode;
  this._scrollMode = mode;
  this.eventBus.dispatch("scrollmodechanged", {
   source: this,
   mode
  });
  this._updateScrollMode(this._currentPageNumber);
 }
 _updateScrollMode(pageNumber = null) {
  const scrollMode = this._scrollMode, viewer = this.viewer;
  viewer.classList.toggle("scrollHorizontal", scrollMode === ScrollMode.HORIZONTAL);
  viewer.classList.toggle("scrollWrapped", scrollMode === ScrollMode.WRAPPED);
  if (!this.pdfDocument || !pageNumber) {
   return;
  }
  if (scrollMode === ScrollMode.PAGE) {
   this.#ensurePageViewVisible();
  } else if (this._previousScrollMode === ScrollMode.PAGE) {
   this._updateSpreadMode();
  }
  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
   this._setScale(this._currentScaleValue, true);
  }
  this._setCurrentPageNumber(pageNumber, true);
  this.update();
 }
 get spreadMode() {
  return this._spreadMode;
 }
 set spreadMode(mode) {
  if (this._spreadMode === mode) {
   return;
  }
  if (!isValidSpreadMode(mode)) {
   throw new Error(`Invalid spread mode: ${ mode }`);
  }
  this._spreadMode = mode;
  this.eventBus.dispatch("spreadmodechanged", {
   source: this,
   mode
  });
  this._updateSpreadMode(this._currentPageNumber);
 }
 _updateSpreadMode(pageNumber = null) {
  if (!this.pdfDocument) {
   return;
  }
  const viewer = this.viewer, pages = this._pages;
  if (this._scrollMode === ScrollMode.PAGE) {
   this.#ensurePageViewVisible();
  } else {
   viewer.textContent = "";
   if (this._spreadMode === SpreadMode.NONE) {
    for (let i = 0, ii = pages.length; i < ii; ++i) {
     viewer.appendChild(pages[i].div);
    }
   } else {
    const parity = this._spreadMode - 1;
    let spread = null;
    for (let i = 0, ii = pages.length; i < ii; ++i) {
     if (spread === null) {
      spread = document.createElement("div");
      spread.className = "spread";
      viewer.appendChild(spread);
     } else if (i % 2 === parity) {
      spread = spread.cloneNode(false);
      viewer.appendChild(spread);
     }
     spread.appendChild(pages[i].div);
    }
   }
  }
  if (!pageNumber) {
   return;
  }
  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
   this._setScale(this._currentScaleValue, true);
  }
  this._setCurrentPageNumber(pageNumber, true);
  this.update();
 }
 _getPageAdvance(currentPageNumber, previous = false) {
  switch (this._scrollMode) {
  case ScrollMode.WRAPPED: {
    const {views} = this._getVisiblePages(), pageLayout = new Map();
    for (const {id, y, percent, widthPercent} of views) {
     if (percent === 0 || widthPercent < 100) {
      continue;
     }
     let yArray = pageLayout.get(y);
     if (!yArray) {
      pageLayout.set(y, yArray ||= []);
     }
     yArray.push(id);
    }
    for (const yArray of pageLayout.values()) {
     const currentIndex = yArray.indexOf(currentPageNumber);
     if (currentIndex === -1) {
      continue;
     }
     const numPages = yArray.length;
     if (numPages === 1) {
      break;
     }
     if (previous) {
      for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {
       const currentId = yArray[i], expectedId = yArray[i + 1] - 1;
       if (currentId < expectedId) {
        return currentPageNumber - expectedId;
       }
      }
     } else {
      for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {
       const currentId = yArray[i], expectedId = yArray[i - 1] + 1;
       if (currentId > expectedId) {
        return expectedId - currentPageNumber;
       }
      }
     }
     if (previous) {
      const firstId = yArray[0];
      if (firstId < currentPageNumber) {
       return currentPageNumber - firstId + 1;
      }
     } else {
      const lastId = yArray[numPages - 1];
      if (lastId > currentPageNumber) {
       return lastId - currentPageNumber + 1;
      }
     }
     break;
    }
    break;
   }
  case ScrollMode.HORIZONTAL: {
    break;
   }
  case ScrollMode.PAGE:
  case ScrollMode.VERTICAL: {
    if (this._spreadMode === SpreadMode.NONE) {
     break;
    }
    const parity = this._spreadMode - 1;
    if (previous && currentPageNumber % 2 !== parity) {
     break;
    } else if (!previous && currentPageNumber % 2 === parity) {
     break;
    }
    const {views} = this._getVisiblePages(), expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;
    for (const {id, percent, widthPercent} of views) {
     if (id !== expectedId) {
      continue;
     }
     if (percent > 0 && widthPercent === 100) {
      return 2;
     }
     break;
    }
    break;
   }
  }
  return 1;
 }
 nextPage() {
  const currentPageNumber = this._currentPageNumber, pagesCount = this.pagesCount;
  if (currentPageNumber >= pagesCount) {
   return false;
  }
  const advance = this._getPageAdvance(currentPageNumber, false) || 1;
  this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);
  return true;
 }
 previousPage() {
  const currentPageNumber = this._currentPageNumber;
  if (currentPageNumber <= 1) {
   return false;
  }
  const advance = this._getPageAdvance(currentPageNumber, true) || 1;
  this.currentPageNumber = Math.max(currentPageNumber - advance, 1);
  return true;
 }
 increaseScale(steps = 1) {
  let newScale = this._currentScale;
  do {
   newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);
   newScale = Math.ceil(newScale * 10) / 10;
   newScale = Math.min(MAX_SCALE, newScale);
  } while (--steps > 0 && newScale < MAX_SCALE);
  this.currentScaleValue = newScale;
 }
 decreaseScale(steps = 1) {
  let newScale = this._currentScale;
  do {
   newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);
   newScale = Math.floor(newScale * 10) / 10;
   newScale = Math.max(MIN_SCALE, newScale);
  } while (--steps > 0 && newScale > MIN_SCALE);
  this.currentScaleValue = newScale;
 }
}



/***/ }),

/***/ "./src/event_utils.js":
/*!****************************!*\
  !*** ./src/event_utils.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutomationEventBus": function() { return /* binding */ AutomationEventBus; },
/* harmony export */   "EventBus": function() { return /* binding */ EventBus; },
/* harmony export */   "waitOnEventOrTimeout": function() { return /* binding */ waitOnEventOrTimeout; },
/* harmony export */   "WaitOnType": function() { return /* binding */ WaitOnType; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const WaitOnType = {
 EVENT: "event",
 TIMEOUT: "timeout"
};
function waitOnEventOrTimeout({target, name, delay = 0}) {
 return new Promise(function (resolve, reject) {
  if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
   throw new Error("waitOnEventOrTimeout - invalid parameters.");
  }
  function handler(type) {
   if (target instanceof EventBus) {
    target._off(name, eventHandler);
   } else {
    target.removeEventListener(name, eventHandler);
   }
   if (timeout) {
    clearTimeout(timeout);
   }
   resolve(type);
  }
  const eventHandler = handler.bind(null, WaitOnType.EVENT);
  if (target instanceof EventBus) {
   target._on(name, eventHandler);
  } else {
   target.addEventListener(name, eventHandler);
  }
  const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
  const timeout = setTimeout(timeoutHandler, delay);
 });
}
class EventBus {
 constructor() {
  this._listeners = Object.create(null);
 }
 on(eventName, listener, options = null) {
  this._on(eventName, listener, {
   external: true,
   once: options?.once
  });
 }
 off(eventName, listener, options = null) {
  this._off(eventName, listener, {
   external: true,
   once: options?.once
  });
 }
 dispatch(eventName, data) {
  const eventListeners = this._listeners[eventName];
  if (!eventListeners || eventListeners.length === 0) {
   return;
  }
  let externalListeners;
  for (const {listener, external, once} of eventListeners.slice(0)) {
   if (once) {
    this._off(eventName, listener);
   }
   if (external) {
    (externalListeners ||= []).push(listener);
    continue;
   }
   listener(data);
  }
  if (externalListeners) {
   for (const listener of externalListeners) {
    listener(data);
   }
   externalListeners = null;
  }
 }
 _on(eventName, listener, options = null) {
  const eventListeners = this._listeners[eventName] ||= [];
  eventListeners.push({
   listener,
   external: options?.external === true,
   once: options?.once === true
  });
 }
 _off(eventName, listener, options = null) {
  const eventListeners = this._listeners[eventName];
  if (!eventListeners) {
   return;
  }
  for (let i = 0, ii = eventListeners.length; i < ii; i++) {
   if (eventListeners[i].listener === listener) {
    eventListeners.splice(i, 1);
    return;
   }
  }
 }
}
class AutomationEventBus extends EventBus {
 dispatch(eventName, data) {
  throw new Error("Not implemented: AutomationEventBus.dispatch");
 }
}



/***/ }),

/***/ "./src/grab_to_pan.js":
/*!****************************!*\
  !*** ./src/grab_to_pan.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GrabToPan": function() { return /* binding */ GrabToPan; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const CSS_CLASS_GRAB = "grab-to-pan-grab";
class GrabToPan {
 constructor(options) {
  this.element = options.element;
  this.document = options.element.ownerDocument;
  if (typeof options.ignoreTarget === "function") {
   this.ignoreTarget = options.ignoreTarget;
  }
  this.onActiveChanged = options.onActiveChanged;
  this.activate = this.activate.bind(this);
  this.deactivate = this.deactivate.bind(this);
  this.toggle = this.toggle.bind(this);
  this._onMouseDown = this.#onMouseDown.bind(this);
  this._onMouseMove = this.#onMouseMove.bind(this);
  this._endPan = this.#endPan.bind(this);
  const overlay = this.overlay = document.createElement("div");
  overlay.className = "grab-to-pan-grabbing";
 }
 activate() {
  if (!this.active) {
   this.active = true;
   this.element.addEventListener("mousedown", this._onMouseDown, true);
   this.element.classList.add(CSS_CLASS_GRAB);
   this.onActiveChanged?.(true);
  }
 }
 deactivate() {
  if (this.active) {
   this.active = false;
   this.element.removeEventListener("mousedown", this._onMouseDown, true);
   this._endPan();
   this.element.classList.remove(CSS_CLASS_GRAB);
   this.onActiveChanged?.(false);
  }
 }
 toggle() {
  if (this.active) {
   this.deactivate();
  } else {
   this.activate();
  }
 }
 ignoreTarget(node) {
  return node.matches("a[href], a[href] *, input, textarea, button, button *, select, option");
 }
 #onMouseDown(event) {
  if (event.button !== 0 || this.ignoreTarget(event.target)) {
   return;
  }
  if (event.originalTarget) {
   try {
    event.originalTarget.tagName;
   } catch (e) {
    return;
   }
  }
  this.scrollLeftStart = this.element.scrollLeft;
  this.scrollTopStart = this.element.scrollTop;
  this.clientXStart = event.clientX;
  this.clientYStart = event.clientY;
  this.document.addEventListener("mousemove", this._onMouseMove, true);
  this.document.addEventListener("mouseup", this._endPan, true);
  this.element.addEventListener("scroll", this._endPan, true);
  event.preventDefault();
  event.stopPropagation();
  const focusedElement = document.activeElement;
  if (focusedElement && !focusedElement.contains(event.target)) {
   focusedElement.blur();
  }
 }
 #onMouseMove(event) {
  this.element.removeEventListener("scroll", this._endPan, true);
  if (!(event.buttons & 1)) {
   this._endPan();
   return;
  }
  const xDiff = event.clientX - this.clientXStart;
  const yDiff = event.clientY - this.clientYStart;
  const scrollTop = this.scrollTopStart - yDiff;
  const scrollLeft = this.scrollLeftStart - xDiff;
  if (this.element.scrollTo) {
   this.element.scrollTo({
    top: scrollTop,
    left: scrollLeft,
    behavior: "instant"
   });
  } else {
   this.element.scrollTop = scrollTop;
   this.element.scrollLeft = scrollLeft;
  }
  if (!this.overlay.parentNode) {
   document.body.appendChild(this.overlay);
  }
 }
 #endPan() {
  this.element.removeEventListener("scroll", this._endPan, true);
  this.document.removeEventListener("mousemove", this._onMouseMove, true);
  this.document.removeEventListener("mouseup", this._endPan, true);
  this.overlay.remove();
 }
}



/***/ }),

/***/ "./src/l10n_utils.js":
/*!***************************!*\
  !*** ./src/l10n_utils.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fixupLangCode": function() { return /* binding */ fixupLangCode; },
/* harmony export */   "getL10nFallback": function() { return /* binding */ getL10nFallback; },
/* harmony export */   "NullL10n": function() { return /* binding */ NullL10n; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const DEFAULT_L10N_STRINGS = {
 of_pages: "of {{pagesCount}}",
 page_of_pages: "({{pageNumber}} of {{pagesCount}})",
 document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
 document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
 document_properties_date_string: "{{date}}, {{time}}",
 document_properties_page_size_unit_inches: "in",
 document_properties_page_size_unit_millimeters: "mm",
 document_properties_page_size_orientation_portrait: "portrait",
 document_properties_page_size_orientation_landscape: "landscape",
 document_properties_page_size_name_a3: "A3",
 document_properties_page_size_name_a4: "A4",
 document_properties_page_size_name_letter: "Letter",
 document_properties_page_size_name_legal: "Legal",
 document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
 document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
 document_properties_linearized_yes: "Yes",
 document_properties_linearized_no: "No",
 print_progress_percent: "{{progress}}%",
 "toggle_sidebar.title": "Toggle Sidebar",
 "toggle_sidebar_notification2.title": "Toggle Sidebar (document contains outline/attachments/layers)",
 additional_layers: "Additional Layers",
 page_landmark: "Page {{page}}",
 thumb_page_title: "Page {{page}}",
 thumb_page_canvas: "Thumbnail of Page {{page}}",
 find_reached_top: "Reached top of document, continued from bottom",
 find_reached_bottom: "Reached end of document, continued from top",
 "find_match_count[one]": "{{current}} of {{total}} match",
 "find_match_count[other]": "{{current}} of {{total}} matches",
 "find_match_count_limit[one]": "More than {{limit}} match",
 "find_match_count_limit[other]": "More than {{limit}} matches",
 find_not_found: "Phrase not found",
 error_version_info: "PDF.js v{{version}} (build: {{build}})",
 error_message: "Message: {{message}}",
 error_stack: "Stack: {{stack}}",
 error_file: "File: {{file}}",
 error_line: "Line: {{line}}",
 rendering_error: "An error occurred while rendering the page.",
 page_scale_width: "Page Width",
 page_scale_fit: "Page Fit",
 page_scale_auto: "Automatic Zoom",
 page_scale_actual: "Actual Size",
 page_scale_percent: "{{scale}}%",
 loading: "Loading…",
 loading_error: "An error occurred while loading the PDF.",
 invalid_file_error: "Invalid or corrupted PDF file.",
 missing_file_error: "Missing PDF file.",
 unexpected_response_error: "Unexpected server response.",
 printing_not_supported: "Warning: Printing is not fully supported by this browser.",
 printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
 web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts."
};
function getL10nFallback(key, args) {
 switch (key) {
 case "find_match_count":
  key = `find_match_count[${ args.total === 1 ? "one" : "other" }]`;
  break;
 case "find_match_count_limit":
  key = `find_match_count_limit[${ args.limit === 1 ? "one" : "other" }]`;
  break;
 }
 return DEFAULT_L10N_STRINGS[key] || "";
}
const PARTIAL_LANG_CODES = {
 en: "en-US",
 es: "es-ES",
 fy: "fy-NL",
 ga: "ga-IE",
 gu: "gu-IN",
 hi: "hi-IN",
 hy: "hy-AM",
 nb: "nb-NO",
 ne: "ne-NP",
 nn: "nn-NO",
 pa: "pa-IN",
 pt: "pt-PT",
 sv: "sv-SE",
 zh: "zh-CN"
};
function fixupLangCode(langCode) {
 return PARTIAL_LANG_CODES[langCode?.toLowerCase()] || langCode;
}
function formatL10nValue(text, args) {
 if (!args) {
  return text;
 }
 return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
  return name in args ? args[name] : "{{" + name + "}}";
 });
}
const NullL10n = {
 async getLanguage() {
  return "en-us";
 },
 async getDirection() {
  return "ltr";
 },
 async get(key, args = null, fallback = getL10nFallback(key, args)) {
  return formatL10nValue(fallback, args);
 },
 async translate(element) {
 }
};



/***/ }),

/***/ "./src/online_annotate.js":
/*!********************************!*\
  !*** ./src/online_annotate.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const PDFJSAnnotate = (__webpack_require__(/*! ./online_annotate/PDFJSAnnotate.js */ "./src/online_annotate/PDFJSAnnotate.js")["default"]);
const initColorPicker = (__webpack_require__(/*! ./online_annotate/initColorPicker */ "./src/online_annotate/initColorPicker.js")["default"]);

function initOnlineAnnotation(id, pref) {
    window.PDFJSAnnotate = PDFJSAnnotate;
    function htmlEscape(text) {
        return text.replace('&', '&amp;').replace('>', '&gt;').replace('<', '&lt;').replace('"', '&quot;').replace("'", '&#39;');
    }

    const { UI } = PDFJSAnnotate;
    // FIXME: docid;
    const documentId = id || 'UntitledDocument';
    window.user;
    window._PAGE_HEIGHT;
    window._RENDER_OPTIONS = {
        documentId: documentId,
        pdfDocument: null,
        scale: 1,
        rotate: 0,
    };
    window.currentAnnoteColor = '#000000';
    window.currentAnnoteSize = '2';
    window.currentOpacity = 0.5;
    window.colorPaletteOpen = false;
    window.userPresets = pref || {
        colors: {
            highlight: [
                {
                    color: '#ff0000',
                    // opacity: 0.5,
                },
                {
                    color: '#00ff00',
                    // opacity: 0.5,
                },
                {
                    color: '#0000ff',
                    // opacity: 0.5,
                },
                {
                    color: '#ff00ff',
                    // opacity: 0.5,
                },
            ],
            underline: [
                {
                    color: '#ff0000',
                    // opacity: 1,
                },
                {
                    color: '#00ff00',
                    // opacity: 1,
                },
                {
                    color: '#0000ff',
                    // opacity: 1,
                },
                {
                    color: '#ff00ff',
                    // opacity: 1,
                },
            ],
            strikeout: [
                {
                    color: '#ff0000',
                    // opacity: 1,
                },
                {
                    color: '#00ff00',
                    // opacity: 1,
                },
                {
                    color: '#0000ff',
                    // opacity: 1,
                },
                {
                    color: '#ff00ff',
                    // opacity: 1,
                },
            ],
            area: [
                {
                    color: '#ff0000',
                    // opacity: 1,
                },
                {
                    color: '#00ff00',
                    // opacity: 1,
                },
                {
                    color: '#0000ff',
                    // opacity: 1,
                },
                {
                    color: '#ff00ff',
                    // opacity: 1,
                },
            ],
            text: [
                {
                    color: '#000000',
                    size: 10,
                    // opacity: 1,
                },
                {
                    color: '#00ff00',
                    size: 10,
                    // opacity: 1,
                },
                {
                    color: '#0000ff',
                    size: 5,
                    // opacity: 1,
                },
                {
                    color: '#ff00ff',
                    size: 5,
                    // opacity: 1,
                },
            ],
            draw: [
                {
                    color: '#ff0000',
                    opacity: 1,
                    size: 2,
                },
                {
                    color: '#00ff00',
                    opacity: 1,
                    size: 2,
                },
                {
                    color: '#0000ff',
                    opacity: 1,
                    size: 2,
                },
                {
                    color: '#ff00ff',
                    opacity: 1,
                    size: 2,
                },
            ],
            freeHandHighlight: [
                {
                    color: '#ff0000',
                    opacity: 0.2,
                    size: 10,
                },
                {
                    color: '#00ff00',
                    opacity: 0.2,
                    size: 10,
                },
                {
                    color: '#0000ff',
                    opacity: 0.2,
                    size: 10,
                },
                {
                    color: '#ff00ff',
                    opacity: 0.2,
                    size: 10,
                },
            ],
        },
        activePresetIndex: {
            highlight: 0,
            underline: 0,
            strikeout: 0,
            text: 0,
            area: 0,
            draw: 0,
            freeHandHighlight: 0,
        },
    };
    console.log(`window.__sdJSBridge status:`, window.__sdJSBridge);
    PDFJSAnnotate.setStoreAdapter(window.__sdJSBridge ? new PDFJSAnnotate.SaltDogAdapter() : new PDFJSAnnotate.LocalStoreAdapter());
    // Render stuff
    let NUM_PAGES = 0;
    function setScaleRotate(scale, rotate) {
        scale = parseFloat(scale, 10);
        rotate = parseInt(rotate, 10);

        if (window._RENDER_OPTIONS.scale !== scale || window._RENDER_OPTIONS.rotate !== rotate) {
            window._RENDER_OPTIONS.scale = scale;
            window._RENDER_OPTIONS.rotate = rotate;
        }
    }

    function handleScaleChange(scale) {
        setScaleRotate(scale, window._RENDER_OPTIONS.rotate);
    }

    function handleRotateCWClick() {
        setScaleRotate(window._RENDER_OPTIONS.scale, window._RENDER_OPTIONS.rotate + 90);
    }

    function handleRotateCCWClick() {
        setScaleRotate(window._RENDER_OPTIONS.scale, window._RENDER_OPTIONS.rotate - 90);
    }

    window.__initPDFJSAnnotate = function (pdfDocument) {
        window._RENDER_OPTIONS.pdfDocument = pdfDocument;

        // window._RENDER_OPTIONS.scale = window.PDFViewerApplication.pdfViewer._currentScale || 1;
        // window._RENDER_OPTIONS.rotate = window.PDFViewerApplication.pdfViewer._pagesRotation || 0;
        window.PDFViewerApplication.eventBus._on('scalechanging', (e) => {
            handleScaleChange(e.scale);
        });
        window.PDFViewerApplication.eventBus._on('rotatecw', (e) => {
            handleRotateCWClick();
        });
        window.PDFViewerApplication.eventBus._on('rotateccw', (e) => {
            handleRotateCCWClick();
        });
        // let viewer = document.getElementById('viewer');
        // viewer.innerHTML = '';
        NUM_PAGES = pdfDocument.numPages;
        // for (let i = 0; i < NUM_PAGES; i++) {
        //   // let page = UI.createPage(i + 1);
        //   viewer.appendChild(page);
        // }
    };
    // Hotspot color stuff
    (function () {
        let hotspotColor = localStorage.getItem(`${window._RENDER_OPTIONS.documentId}/hotspot/color`) || 'darkgoldenrod';
        let currentTarget;

        function handleAnnotationClick(target) {
            let type = target.getAttribute('data-pdf-annotate-type');
            if (['fillcircle', 'arrow'].indexOf(type) === -1) {
                return; // nothing to do
            }
            currentTarget = target;
            hotspotColor = currentTarget.getAttribute('stroke');

            UI.setArrow(10, hotspotColor);
            UI.setCircle(10, hotspotColor);

            let a = document.querySelector('.hotspot-color .color');
            if (a) {
                a.setAttribute('data-color', hotspotColor);
                a.style.background = hotspotColor;
            }
        }

        function handleAnnotationBlur(target) {
            if (currentTarget === target) {
                currentTarget = undefined;
            }
        }
        UI.addEventListener('annotation:click', handleAnnotationClick);
        UI.addEventListener('annotation:blur', handleAnnotationBlur);
    })();

    // Toolbar buttons
    (function () {
        let tooltype = 'cursor';
        setActiveToolbarItem(tooltype, document.querySelector(`.AnnotationBtns button[data-tooltype=${tooltype}]`));

        function setActiveToolbarItem(type, button) {
            // 取消pdfjs的工具选择
            if (type != 'cursor') {
                document.getElementById(`cursorSelectTool`).classList.remove(`active`);
                document.getElementById(`cursorHandTool`).classList.remove(`active`);
            }
            let active = document.querySelector('.AnnotationBtns button.active');
            if (active) {
                active.classList.remove('active');
                active.children[0].removeAttribute('style');
                document.getElementById('presetsContainer').innerHTML = window.generatePresetsDom('');
                switch (tooltype) {
                    case 'cursor':
                        UI.disableEdit();
                        break;
                    case 'eraser':
                        UI.disableEraser();
                        break;
                    case 'draw':
                    case 'freeHandHighlight':
                        UI.disablePen();
                        break;
                    case 'arrow':
                        UI.disableArrow();
                        break;
                    case 'text':
                        UI.disableText();
                        break;
                    case 'point':
                        UI.disablePoint();
                        break;
                    case 'area':
                    case 'highlight':
                    case 'strikeout':
                    case 'underline':
                        UI.disableRect();
                        break;
                    case 'circle':
                    case 'emptycircle':
                    case 'fillcircle':
                        UI.disableCircle();
                        break;
                }
            }
            if (tooltype == type) {
                // 再次点击回归curser模式
                tooltype = 'cursor';
                UI.enableEdit();
                return;
            }
            if (button) {
                button.classList.add('active');
            }
            if (tooltype !== type) {
                localStorage.setItem(`${window._RENDER_OPTIONS.documentId}/tooltype`, type);
            }
            tooltype = type;
            dealPresetsDom(type);
            switch (type) {
                case 'cursor':
                    UI.enableEdit();
                    break;
                case 'eraser':
                    UI.enableEraser();
                    break;
                case 'draw':
                case 'freeHandHighlight':
                    UI.enablePen();
                    break;
                // case 'arrow':
                //     UI.enableArrow();
                //     break;
                case 'text':
                    UI.enableText();
                    break;
                // case 'point':
                //     UI.enablePoint();
                //     break;
                case 'area':
                case 'highlight':
                case 'strikeout':
                case 'underline':
                    UI.enableRect(type);
                    break;
                // case 'circle':
                // case 'emptycircle':
                // case 'fillcircle':
                //     UI.enableCircle(type);
                //     break;
            }
        }
        function dealPresetsDom(type) {
            document.getElementById('presetsContainer').innerHTML = window.generatePresetsDom(type);
            const activePresetIndex = window.userPresets['activePresetIndex'][type] || 0;
            setActivePresetItem(document.getElementById(`presets_${type}_${activePresetIndex}`), type, activePresetIndex);
        }
        window._setActiveToolbarItem = setActiveToolbarItem;
        function handleToolbarClick(e) {
            if (e.target.nodeName === 'BUTTON' && e.target.dataset.tooltype) {
                setActiveToolbarItem(e.target.getAttribute('data-tooltype'), e.target);
            }
        }
        window._activePresetItem = null;
        function setActivePresetItem(e, type, index) {
            if (!e) return;
            window._activePresetItem = e;
            for (let elem of document.getElementById('presetsContainer').children[0].children) {
                elem.children[0].classList.remove('active');
            }
            window.userPresets['activePresetIndex'][e.getAttribute('data-tooltype')] = Number(index);
            window.currentAnnoteColor = window.userPresets['colors'][e.getAttribute('data-tooltype')][index]['color'];
            window.currentOpacity = window.userPresets['colors'][e.getAttribute('data-tooltype')][index]['opacity'];
            window.currentAnnoteSize = window.userPresets['colors'][e.getAttribute('data-tooltype')][index]['size'];
            const mainbtn = document.querySelector(`button.active[data-tooltype="${type}"]`).children[0];
            mainbtn.style.color = window.parseRGBA(window.currentAnnoteColor, window.currentOpacity);
            // mainbtn.style.opacity=window.currentOpacity;
            e.classList.add('active');
        }
        function handlePresetsClick(e) {
            if (e.target.nodeName === 'BUTTON') {
                setActivePresetItem(e.target, e.target.getAttribute('data-tooltype'), e.target.getAttribute('data-index'));
            }
            e.stopPropagation();
        }
        document.getElementById('presetsContainer').addEventListener('click', handlePresetsClick);
        document.querySelector('.AnnotationBtns').addEventListener('click', handleToolbarClick);
    })();

    // Clear toolbar button
    (function () {
        function handleClearClick(e) {
            if (confirm('Are you sure you want to clear annotations?')) {
                for (let i = 0; i < NUM_PAGES; i++) {
                    document.querySelector(`div#page${i + 1} svg.onlineAnnotationLayer`).innerHTML = '';
                }

                localStorage.removeItem(`${window._RENDER_OPTIONS.documentId}/annotations`);
            }
        }
        //document.querySelector('a.clear').addEventListener('click', handleClearClick);
    })();

    // Comment stuff
    //   (function(window, document) {
    //     let commentList = document.querySelector('#comment-wrapper .comment-list-container');
    //     let commentForm = document.querySelector('#comment-wrapper .comment-list-form');
    //     let commentText = commentForm.querySelector('input[type="text"]');

    //     function supportsComments(target) {
    //       let type = target.getAttribute('data-pdf-annotate-type');
    //       return ['point', 'highlight', 'area'].indexOf(type) > -1;
    //     }

    //     function insertComment(comment) {
    //       let child = document.createElement('div');
    //       child.className = 'comment-list-item';
    //       child.innerHTML = htmlEscape(comment.content);

    //       commentList.appendChild(child);
    //     }

    //     function handleAnnotationClick(target) {
    //       if (supportsComments(target)) {
    //         let documentId = target.parentNode.getAttribute('data-pdf-annotate-document');
    //         let annotationId = target.getAttribute('data-pdf-annotate-id');

    //         PDFJSAnnotate.getStoreAdapter().getComments(documentId, annotationId).then((comments) => {
    //           commentList.innerHTML = '';
    //           commentForm.style.display = '';
    //           commentText.focus();

    //           commentForm.onsubmit = function() {
    //             PDFJSAnnotate.getStoreAdapter().addComment(documentId, annotationId, commentText.value.trim())
    //               .then(insertComment)
    //               .then(() => {
    //                 commentText.value = '';
    //                 commentText.focus();
    //               });

    //             return false;
    //           };

    //           comments.forEach(insertComment);
    //         });
    //       }
    //     }

    //     function handleAnnotationBlur(target) {
    //       if (supportsComments(target)) {
    //         commentList.innerHTML = '';
    //         commentForm.style.display = 'none';
    //         commentForm.onsubmit = null;

    //         insertComment({content: 'No comments'});
    //       }
    //     }

    //     UI.addEventListener('annotation:click', handleAnnotationClick);
    //     UI.addEventListener('annotation:blur', handleAnnotationBlur);

    //     UI.setArrow(10, 'darkgoldenrod');
    //     UI.setCircle(10, 'darkgoldenrod');
    //   })(window, document);
}
window.currentAnnoteColor = '#000000';
window.currentAnnoteSize = '2';
window.currentOpacity = 0.5;
window.colorPaletteOpen = false;
window.userPresets = {
    colors: {
        highlight: [
            {
                color: '#ff0000',
                // opacity: 0.5,
            },
            {
                color: '#00ff00',
                // opacity: 0.5,
            },
            {
                color: '#0000ff',
                // opacity: 0.5,
            },
            {
                color: '#ff00ff',
                // opacity: 0.5,
            },
        ],
        underline: [
            {
                color: '#ff0000',
                // opacity: 1,
            },
            {
                color: '#00ff00',
                // opacity: 1,
            },
            {
                color: '#0000ff',
                // opacity: 1,
            },
            {
                color: '#ff00ff',
                // opacity: 1,
            },
        ],
        strikeout: [
            {
                color: '#ff0000',
                // opacity: 1,
            },
            {
                color: '#00ff00',
                // opacity: 1,
            },
            {
                color: '#0000ff',
                // opacity: 1,
            },
            {
                color: '#ff00ff',
                // opacity: 1,
            },
        ],
        area: [
            {
                color: '#ff0000',
                // opacity: 1,
            },
            {
                color: '#00ff00',
                // opacity: 1,
            },
            {
                color: '#0000ff',
                // opacity: 1,
            },
            {
                color: '#ff00ff',
                // opacity: 1,
            },
        ],
        text: [
            {
                color: '#000000',
                size: 10,
                // opacity: 1,
            },
            {
                color: '#00ff00',
                size: 10,
                // opacity: 1,
            },
            {
                color: '#0000ff',
                size: 5,
                // opacity: 1,
            },
            {
                color: '#ff00ff',
                size: 5,
                // opacity: 1,
            },
        ],
        draw: [
            {
                color: '#ff0000',
                opacity: 1,
                size: 2,
            },
            {
                color: '#00ff00',
                opacity: 1,
                size: 2,
            },
            {
                color: '#0000ff',
                opacity: 1,
                size: 2,
            },
            {
                color: '#ff00ff',
                opacity: 1,
                size: 2,
            },
        ],
        freeHandHighlight: [
            {
                color: '#ff0000',
                opacity: 0.2,
                size: 10,
            },
            {
                color: '#00ff00',
                opacity: 0.2,
                size: 10,
            },
            {
                color: '#0000ff',
                opacity: 0.2,
                size: 10,
            },
            {
                color: '#ff00ff',
                opacity: 0.2,
                size: 10,
            },
        ],
    },
    activePresetIndex: {
        highlight: 0,
        underline: 0,
        strikeout: 0,
        text: 0,
        area: 0,
        draw: 0,
        freeHandHighlight: 0,
    },
};
window.generatePresetsDom = function (type) {
    function buildPresetsBtn(type, color, opacity, id, index) {
        function getSVG(type) {
            switch (type) {
                case 'highlight':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <title>icon - line - tool - highlight</title>
          <path fill="currentColor" d="M9.91,13.07h3.86L11.84,8.46Zm5.46,3.68L14.62,15H9.05L7.77,18H5.63L10.45,6.64a1,1,0,0,1,1-.64h1a1.23,1.23,0,0,1,1,.64l2,4.91V4H5.85A2.22,2.22,0,0,0,3.63,6.22V17.78A2.22,2.22,0,0,0,5.85,20h9.52Z"></path>
          <path fill="default" class="cls-1" d="M20.37,2V22h-2V2Z"></path>
          </svg>`;
                case 'underline':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <title>icon - tool - text manipulation - underline</title>
          <rect fill="currentColor" x="2.8" y="20.29" width="18.4" height="1.7"></rect>
          <path fill="default" class="cls-1" d="M8.53,13.2h6.94l1.6,3.74h2.66L13.87,2.8a1.54,1.54,0,0,0-1.2-.8h-1.2a1.27,1.27,0,0,0-1.2.8l-6,14.14H6.93ZM12,5.07l2.4,5.73H9.6Z"></path>
      </svg>`;
                case 'strikeout':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <title>icon - tool - text manipulation - strikethrough</title>
          <rect fill="currentColor" x="3.13" y="11.31" width="17.74" height="1.7"></rect>
          <path fill="default" class="cls-1" d="M12,5l2.4,5.77h2.68l-3.28-8A1.49,1.49,0,0,0,12.64,2H11.49a1.24,1.24,0,0,0-1.16.77L7,10.73H9.59Zm3.25,8.62,2,4.74h2.57l-2-4.74ZM4.17,18.32H6.74l2-4.74H6.18Z"></path>
      </svg>`;
                case 'area':
                    return `
          <svg version="1.1" id="icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 24 24" style="enable-background: new 0 0 24 24" xml:space="preserve">
              <path fill="currentColor" class="st0" d="M19.3,3.8H4.7c-1,0-1.8,0.8-1.8,1.8v12.8c0,1,0.8,1.8,1.8,1.8h14.7c1,0,1.8-0.8,1.8-1.8V5.6 C21.2,4.6,20.3,3.7,19.3,3.8z M5.1,18V6h13.8v12H5.1z"></path>
              <rect fill="none" x="5.1" y="6" width="13.8" height="12"></rect>
          </svg>`;
                case 'draw':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path fill="currentColor" d="M18.91,19.66a1.13,1.13,0,0,1-1.35,1.82,5.82,5.82,0,0,0-2.09-1c-3.22-.85-4.57-.29-6.82.63l-.55.23A7.42,7.42,0,0,1,5.42,22a3,3,0,0,1-2-.69,2.38,2.38,0,0,1-.87-1.66,1.81,1.81,0,0,1,.59-1.36,9.16,9.16,0,0,1,.93-.78,1.13,1.13,0,0,1,1.58.23,1.14,1.14,0,0,1-.23,1.59,2.93,2.93,0,0,0-.42.33c.27.13.84.17,2.25-.4L7.8,19a10.81,10.81,0,0,1,8.25-.72A7.89,7.89,0,0,1,18.91,19.66Z"></path>
          <path fill="default" class="cls-1" d="M21.45,5.77a2.09,2.09,0,0,1-.62,1.51l-9.16,9.16c-.09.08-.26.26-.44.26,0,0-4.18.9-4.42.89a1,1,0,0,1-.72-.13.67.67,0,0,1-.16-.73l.8-4.53c0-.18.08-.27.26-.45L13,5.8l3.2-3.2a2.2,2.2,0,0,1,3,0l1.66,1.66A2.34,2.34,0,0,1,21.45,5.77ZM16.21,9.06,14.37,7.22,8.59,13l1.84,1.84Zm3.2-3.2L17.57,4,15.88,5.71l1.84,1.84Z"></path>
      </svg>`;
                case 'freeHandHighlight':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <title>icon - tool - pen - highlight</title>
        <path fill="default" class="cls-1" d="M19.9658 6.91017H19.92L16.2992 3.25267C16.1376 3.0909 15.9183 3 15.6896 3C15.4609 3 15.2416 3.0909 15.08 3.25267L7.82917 10.4118C7.68847 10.5239 7.59386 10.6837 7.56334 10.861L6.56417 15.2518L4.8225 17.4427H7.6275L8.73667 16.3335L12.2567 15.5452C12.4386 15.5144 12.6023 15.4162 12.715 15.2702L19.92 8.12934C20.2428 7.7936 20.2625 7.2692 19.9658 6.91017V6.91017ZM11.9083 13.5377L9.54334 11.1727L15.7583 5.0585L18.1233 7.4235L11.9083 13.5377Z"></path>
        <path fill="currentColor" d="M18.4167 17.2685C18.744 18.2557 18.9773 19.2716 19.1133 20.3027C18.2719 19.3853 17.15 18.7728 15.9233 18.561C14.8314 18.4146 13.7204 18.5244 12.6783 18.8818C11.4047 19.3332 10.1589 19.8597 8.9475 20.4585C7.81125 21.1097 6.50296 21.3975 5.19833 21.2835C4.80235 21.1839 4.45663 20.9426 4.22666 20.6052C4.14173 20.4738 4.07395 20.3321 4.025 20.1835C4.01028 20.0885 3.98252 19.9959 3.9425 19.9085C3.80542 19.4227 3.84105 18.9043 4.04333 18.4418C4.15136 18.1403 4.32695 17.8675 4.55667 17.6443L4.905 19.4135C4.79615 19.4335 4.71381 19.5233 4.70333 19.6335C4.70333 19.8993 5.79417 19.7527 6.67417 19.4227C7.31069 19.1708 7.92412 18.8641 8.5075 18.506C9.77851 17.691 11.1416 17.0294 12.5683 16.5352C13.7125 16.1519 14.9299 16.0389 16.125 16.2052C16.6842 16.3049 17.2193 16.5102 17.7017 16.8102C17.8758 16.8927 18.4167 17.2685 18.4167 17.2685Z"></path>
    </svg>`;
                case 'text':
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <title>icon - tool - text - free text</title>
      <g><path fill="currentColor" d="M19.39,4.77V7.64A.43.43,0,0,1,19,8h-.82a.41.41,0,0,1-.4-.41V6.51H13.34V18h1.54a.41.41,0,0,1,.41.41v.81a.41.41,0,0,1-.41.41H9.14a.41.41,0,0,1-.41-.41v-.81A.41.41,0,0,1,9.14,18h1.54V6.51H6.27V7.64A.41.41,0,0,1,5.86,8H5A.43.43,0,0,1,4.6,7.6V4.77A.41.41,0,0,1,5,4.36H19A.39.39,0,0,1,19.39,4.77Z"></path></g>
  </svg>`;
            }
        }
        let html = `<div class="tool-button-container">
    <button class="Button tool-button hasStyles" id="${id}" data-index="${index}" style="color:${window.parseRGBA(color, opacity)};" data-tooltype="${type}" data-color="${color}" data-opacity="${opacity}" data-element="${type}ToolPresetButton" aria-label="${type}" type="button">
                                                        <div class="Icon" style="color:inherit">
                                                            ${getSVG(type)}
                                                        </div>
                                                    </button>
                                                    <div onclick="setCustomColor('${type}','${id}',${index})" class="tool-button-arrow-container">
                                                        <div class="tool-button-arrow-inner-container">
                                                            <div class="Icon tool-button-arrow-down">
                                                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12">
                                                                    <defs>
                                                                        <style>
                                                                            .cls-1 {
                                                                                fill: #abb0c4;
                                                                            }
                                                                        </style>
                                                                    </defs>
                                                                    <title>icon - chevron - down</title>
                                                                    <path class="cls-1" d="M9,3.5l-3,3-3-3-1,1,4,4,4-4Z"></path>
                                                                </svg>
                                                            </div>
                                                        </div>
                                                    </div>

    </div>`;
        return html;
    }
    let html = '<div class="tool-buttons-container">';
    let curr_preset;
    switch (type) {
        case 'underline':
        case 'highlight':
        case 'strikeout':
        case 'area':
        case 'draw':
        case 'freeHandHighlight':
        case 'text':
            curr_preset = window.userPresets['colors'][type];
            for (let i = 0; i < curr_preset.length; i++) {
                html += buildPresetsBtn(type, curr_preset[i].color, curr_preset[i].opacity, `presets_${type}_${i}`, i);
            }
            break;
        default:
            return `<div class="no-presets">无可用选项</div>`;
    }
    html += '</div>';
    return html;
};

window.setCustomColor = function (type, id, index) {
    const color = ['rgb(241, 160, 153)', 'rgb(255, 198, 123)', 'rgb(255, 230, 162)', 'rgb(128, 229, 177)', 'rgb(146, 232, 232)', 'rgb(166, 161, 230)', 'rgb(228, 66, 52)', 'rgb(255, 141, 0)', 'rgb(255, 205, 69)', 'rgb(0, 204, 99)', 'rgb(37, 210, 209)', 'rgb(78, 125, 233)', 'rgb(197, 68, 206)', 'rgb(136, 39, 31)', 'rgb(181, 72, 0)', 'rgb(246, 154, 0)', 'rgb(0, 122, 59)', 'rgb(22, 126, 125)', 'rgb(46, 75, 139)', 'rgb(118, 40, 123)', 'rgb(255, 255, 255)', 'rgb(205, 205, 205)', 'rgb(156, 156, 156)', 'rgb(105, 105, 105)', 'rgb(39, 39, 39)', 'rgb(0, 0, 0)'];
    function buildColorHtml(color) {
        const div = document.createElement('div');
        div.classList.add('ToolStylePopup');
        div.id = 'colorPanel';
        let html = `
    <div class="Popup StylePopup" data-element="stylePopup">
        <div class="divider-container"><div class="divider-horizontal"></div></div>
        <div id="colorPalette" class="ColorPalette">`;
        for (let i in color) {
            html += `<button class="cell-container" aria-label="Color ${i}" data-color="${color[i]}">
              <div class="cell-outer"><div class="cell" data-color="${color[i]}" style="background-color: ${color[i]}"></div></div>
          </button>`;
        }
        html += `</div><div class="sliders-container">`;
        if (type == 'draw')
            html += `
        
                                                    <div class="slider" data-element="opacitySlider">
                                                        <div class="slider-property">不透明度</div>
                                                        <div class="slider-svg-container">
                                                            <input id="colorPalette_slider_opacity" type="range" min="10" max="100"
                                                             />
                                                            <div class="slider-value" id="colorPalette_slider_opacity_value"></div>
                                                        </div>
                                                    </div>`;
        if (type == 'draw' || type == 'text')
            html += `<div class="slider" data-element="opacitySlider">
          <div class="slider-property">大小</div>
          <div class="slider-svg-container">
              <input id="colorPalette_slider_size" type="range" min="1" max="50"
               />
              <div class="slider-value" id="colorPalette_slider_size_value"></div>
          </div>
      </div>`;
        html += `</div>`;

        div.innerHTML = html;
        return div;
    }
    /**
   
   */

    const oc = document.getElementById('presetOuterContainer');
    function closeColorPalette() {
        window.colorPaletteOpen = false;
        oc.classList.remove('shadow');
        oc.removeChild(window._colorPanel);
        window._colorPanel = null;
    }
    if (oc.classList.contains('shadow') && window._colorPanel) {
        closeColorPalette();
    } else {
        oc.classList.add('shadow');
        window._colorPanel = oc.appendChild(buildColorHtml(color));
        window.colorPaletteOpen = true;
        const presetbtn = document.getElementById(id);
        window._colorPanel.addEventListener('click', function (e) {
            if (e.target.classList.contains('cell')) {
                for (let ele of document.getElementById('colorPalette').children) {
                    ele.children[0].classList.remove('active');
                }
                e.target.parentNode.classList.add('active');
                presetbtn.style.color = window.parseRGBA(e.target.dataset.color, window.userPresets['colors'][type][Number(index)].opacity);
                presetbtn.dataset.color = e.target.dataset.color;
                window.userPresets['colors'][type][Number(index)].color = e.target.dataset.color;
                if (window._activePresetItem.id == id) {
                    window.currentAnnoteColor = e.target.dataset.color;
                    window.currentOpacity = window.userPresets['colors'][type][Number(index)].opacity;
                    const primBtn = document.querySelector(`button.active[data-tooltype="${type}"]`);
                    if (primBtn) {
                        primBtn.children[0].style.color = presetbtn.style.color;
                    }
                }
                // console.log(e.target.dataset.color);
            }
            e.stopPropagation();
        });

        const opacitySlider = document.getElementById('colorPalette_slider_opacity');
        const opacitySliderValue = document.getElementById('colorPalette_slider_opacity_value');
        if (opacitySlider && opacitySliderValue) {
            opacitySlider.value = window.userPresets['colors'][type][Number(index)].opacity * 100;
            opacitySliderValue.innerText = opacitySlider.value + ' %';

            opacitySlider.addEventListener('pointermove', (e) => {
                opacitySliderValue.innerText = e.target.value + ' %';
            });

            opacitySlider.addEventListener('change', (e) => {
                window.userPresets['colors'][type][Number(index)].opacity = e.target.value / 100;
                presetbtn.dataset.opacity = e.target.value / 100;
                presetbtn.style.color = window.parseRGBA(window.userPresets['colors'][type][Number(index)].color, e.target.value / 100);
                presetbtn.dataset.color = window.userPresets['colors'][type][Number(index)].color;
                if (window._activePresetItem.id == id) {
                    window.currentOpacity = e.target.value / 100;
                    window.currentAnnoteColor = window.userPresets['colors'][type][Number(index)].color;
                    const primBtn = document.querySelector(`button.active[data-tooltype="${type}"]`);
                    if (primBtn) {
                        primBtn.children[0].style.color = window.parseRGBA(window.userPresets['colors'][type][Number(index)].color, e.target.value / 100);
                    }
                }
            });
        }

        const sizeSlider = document.getElementById('colorPalette_slider_size');
        const sizeSliderValue = document.getElementById('colorPalette_slider_size_value');
        if (sizeSlider && sizeSliderValue) {
            sizeSlider.value = window.userPresets['colors'][type][Number(index)].size;
            sizeSliderValue.innerText = sizeSlider.value + ' px';

            sizeSlider.addEventListener('pointermove', (e) => {
                sizeSliderValue.innerText = e.target.value + ' px';
            });

            sizeSlider.addEventListener('change', (e) => {
                window.userPresets['colors'][type][Number(index)].size = e.target.value;
                presetbtn.dataset.size = e.target.value;
                if (window._activePresetItem.id == id) {
                    window.currentAnnoteSize = e.target.value;
                    window.currentAnnoteColor = window.userPresets['colors'][type][Number(index)].color;
                }
            });
        }

        window._colorPanel.addEventListener('mouseleave', function () {
            closeColorPalette();
        });
    }
    console.log(type, id);
};

window.parseRGBA = function (color, opacity) {
    if (!color) return;
    let r, g, b;
    if (color.startsWith('rgba')) {
        const rgb = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
        r = rgb[1];
        g = rgb[2];
        b = rgb[3];
    }
    if (color.startsWith('rgb')) {
        const rgb = color.match(/^rgb?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
        r = rgb[1];
        g = rgb[2];
        b = rgb[3];
    } else {
        // 16进制颜色值的正则
        const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
        // 把颜色值变成小写
        let colord = color.toLowerCase();
        if (reg.test(colord)) {
            // 如果只有三位的值，需变成六位，如：#fff => #ffffff
            if (colord.length === 4) {
                let colorNew = '#';
                for (let i = 1; i < 4; i += 1) {
                    colorNew += colord.slice(i, i + 1).concat(colord.slice(i, i + 1));
                }
                colord = colorNew;
            }
            // 处理六位的颜色值，转为RGB
            let colorChange = [];
            for (let i = 1; i < 7; i += 2) {
                colorChange.push(parseInt('0x' + colord.slice(i, i + 2)));
            }
            r = colorChange[0];
            g = colorChange[1];
            b = colorChange[2];
        }
    }
    return `rgba(${r},${g},${b},${opacity || 1})`;
};

module.exports = { initOnlineAnnotation };


/***/ }),

/***/ "./src/online_annotate/PDFJSAnnotate.js":
/*!**********************************************!*\
  !*** ./src/online_annotate/PDFJSAnnotate.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adapter_StoreAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter/StoreAdapter */ "./src/online_annotate/adapter/StoreAdapter.js");
/* harmony import */ var _adapter_SaltDogAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapter/SaltDogAdapter */ "./src/online_annotate/adapter/SaltDogAdapter.js");
/* harmony import */ var _adapter_LocalStoreAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adapter/LocalStoreAdapter */ "./src/online_annotate/adapter/LocalStoreAdapter.js");
/* harmony import */ var _adapter_LocalUserStoreAdapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./adapter/LocalUserStoreAdapter */ "./src/online_annotate/adapter/LocalUserStoreAdapter.js");
/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./render */ "./src/online_annotate/render/index.js");
/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UI */ "./src/online_annotate/UI/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config */ "./src/online_annotate/config.js");
/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/uuid */ "./src/online_annotate/utils/uuid.js");
/* harmony import */ var _UI_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./UI/utils */ "./src/online_annotate/UI/utils.js");










/* harmony default export */ __webpack_exports__["default"] = ({
    findAnnotationAtPoint: _UI_utils__WEBPACK_IMPORTED_MODULE_8__.findAnnotationAtPoint,
    findSVGContainer: _UI_utils__WEBPACK_IMPORTED_MODULE_8__.findSVGContainer,
    convertToScreenPoint: _UI_utils__WEBPACK_IMPORTED_MODULE_8__.convertToScreenPoint,

    /**
     * Abstract class that needs to be defined so PDFJSAnnotate
     * knows how to communicate with your server.
     */
    StoreAdapter: _adapter_StoreAdapter__WEBPACK_IMPORTED_MODULE_0__["default"],

    /**
     * Implementation of StoreAdapter that stores annotation data to localStorage.
     */
    LocalStoreAdapter: _adapter_LocalStoreAdapter__WEBPACK_IMPORTED_MODULE_2__["default"],

    /**
     * Implementation of StoreAdapter that stores annotation data to localStorage particular
     * to a specific user
     */
    LocalUserStoreAdapter: _adapter_LocalUserStoreAdapter__WEBPACK_IMPORTED_MODULE_3__["default"],
    /**
     * Implementation of StoreAdapter that stores annotation data to Saltdog particular
     * to a specific user
     */
    SaltDogAdapter: _adapter_SaltDogAdapter__WEBPACK_IMPORTED_MODULE_1__["default"],

    /**
     * Abstract instance of StoreAdapter
     */
    __storeAdapter: new _adapter_StoreAdapter__WEBPACK_IMPORTED_MODULE_0__["default"](),

    /**
     * Getter for the underlying StoreAdapter property
     *
     * @return {StoreAdapter}
     */
    getStoreAdapter() {
        return this.__storeAdapter;
    },

    /**
     * Setter for the underlying StoreAdapter property
     *
     * @param {StoreAdapter} adapter The StoreAdapter implementation to be used.
     */
    setStoreAdapter(adapter) {
        // TODO this throws an error when bundled
        // if (!(adapter instanceof StoreAdapter)) {
        //   throw new Error('adapter must be an instance of StoreAdapter');
        // }

        this.__storeAdapter = adapter;
    },

    /**
     * UI is a helper for instrumenting UI interactions for creating,
     * editing, and deleting annotations in the browser.
     */
    UI: _UI__WEBPACK_IMPORTED_MODULE_5__["default"],

    /**
     * Render the annotations for a page in the PDF Document
     *
     * @param {SVGElement} svg The SVG element that annotations should be rendered to
     * @param {PageViewport} viewport The PDFPage.getViewport data
     * @param {Object} data The StoreAdapter.getAnnotations data
     * @return {Promise}
     */
    render: _render__WEBPACK_IMPORTED_MODULE_4__["default"],

    /**
     * Convenience method for getting annotation data
     *
     * @alias StoreAdapter.getAnnotations
     * @param {String} documentId The ID of the document
     * @param {String} pageNumber The page number
     * @return {Promise}
     */
    getAnnotations(documentId, pageNumber) {
        return this.getStoreAdapter().getAnnotations(...arguments);
    },

    config: _config__WEBPACK_IMPORTED_MODULE_6__["default"],

    uuid: _utils_uuid__WEBPACK_IMPORTED_MODULE_7__["default"],
});


/***/ }),

/***/ "./src/online_annotate/UI/arrow.js":
/*!*****************************************!*\
  !*** ./src/online_annotate/UI/arrow.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setArrow": function() { return /* binding */ setArrow; },
/* harmony export */   "enableArrow": function() { return /* binding */ enableArrow; },
/* harmony export */   "disableArrow": function() { return /* binding */ disableArrow; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ "./src/online_annotate/render/appendChild.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");




let _enabled = false;
let _penSize;
let _penColor;
let path;
let lines;
let originY;
let originX;

/**
 * Handle document.mousedown event
 */
function handleDocumentMousedown(e) {
  if((0,_utils__WEBPACK_IMPORTED_MODULE_2__.hasButton)(e)) return;
  let target = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findAnnotationAtPoint)(e.clientX, e.clientY);
  if (target === null) {
    return;
  }

  let type = target.getAttribute('data-pdf-annotate-type');
  if (type !== 'circle' && type !== 'fillcircle' && type !== 'emptycircle') {
    return;
  }

  let svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGContainer)(target);
  let { documentId } = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getMetadata)(svg);
  let annotationId = target.getAttribute('data-pdf-annotate-id');

  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().getAnnotation(documentId, annotationId).then((annotation) => {
    if (annotation) {
      path = null;
      lines = [];

      let point = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.convertToScreenPoint)([
        annotation.cx,
        annotation.cy
      ], svg);

      let rect = svg.getBoundingClientRect();

      originX = point[0] + rect.left;
      originY = point[1] + rect.top;

      document.addEventListener('mousemove', handleDocumentMousemove);
      document.addEventListener('mouseup', handleDocumentMouseup);
    }
  });
}

/**
 * Handle document.mouseup event
 *
 * @param {Event} e The DOM event to be handled
 */
function handleDocumentMouseup(e) {
  if((0,_utils__WEBPACK_IMPORTED_MODULE_2__.hasButton)(e)) return;
  let svg;
  if (lines.length > 1 && (svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(e.clientX, e.clientY))) {
    let { documentId, pageNumber } = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getMetadata)(svg);

    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().addAnnotation(documentId, pageNumber, {
      type: 'arrow',
      width: _penSize,
      color: _penColor,
      lines
    }).then((annotation) => {
      if (path) {
        svg.removeChild(path);
      }

      (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_1__.appendChild)(svg, annotation);
    });
  }

  document.removeEventListener('mousemove', handleDocumentMousemove);
  document.removeEventListener('mouseup', handleDocumentMouseup);
}

/**
 * Handle document.mousemove event
 *
 * @param {Event} e The DOM event to be handled
 */
function handleDocumentMousemove(e) {
  
  let x = lines.length === 0 ? originX : e.clientX;
  let y = lines.length === 0 ? originY : e.clientY;

  savePoint(x, y);
}

/**
 * Handle document.keyup event
 *
 * @param {Event} e The DOM event to be handled
 */
function handleDocumentKeyup(e) {
  // Cancel rect if Esc is pressed
  if (e.keyCode === 27) {
    lines = null;
    path.parentNode.removeChild(path);
    document.removeEventListener('mousemove', handleDocumentMousemove);
    document.removeEventListener('mouseup', handleDocumentMouseup);
  }
}

/**
 * Save a point to the line being drawn.
 *
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 */
function savePoint(x, y) {
  let svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(x, y);
  if (!svg) {
    return;
  }

  let rect = svg.getBoundingClientRect();
  let point = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.convertToSvgPoint)([
    x - rect.left,
    y - rect.top
  ], svg);

  if (lines.length < 2) {
    lines.push(point);
    return;
  }
  else {
    lines[1] = point; // update end point
  }

  if (path) {
    svg.removeChild(path);
  }

  path = (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_1__.appendChild)(svg, {
    type: 'arrow',
    color: _penColor,
    width: _penSize,
    lines
  });
}

/**
 * Set the attributes of the pen.
 *
 * @param {Number} penSize The size of the lines drawn by the pen
 * @param {String} penColor The color of the lines drawn by the pen
 */
function setArrow(penSize = 10, penColor = '0000FF') {
  _penSize = parseInt(penSize, 10);
  _penColor = penColor;
}

/**
 * Enable the pen behavior
 */
function enableArrow() {
  if (_enabled) { return; }

  _enabled = true;
  document.addEventListener('mousedown', handleDocumentMousedown);
  document.addEventListener('keyup', handleDocumentKeyup);
  (0,_utils__WEBPACK_IMPORTED_MODULE_2__.disableUserSelect)();
}

/**
 * Disable the pen behavior
 */
function disableArrow() {
  if (!_enabled) { return; }

  _enabled = false;
  document.removeEventListener('mousedown', handleDocumentMousedown);
  document.removeEventListener('keyup', handleDocumentKeyup);
  (0,_utils__WEBPACK_IMPORTED_MODULE_2__.enableUserSelect)();
}



/***/ }),

/***/ "./src/online_annotate/UI/circle.js":
/*!******************************************!*\
  !*** ./src/online_annotate/UI/circle.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setCircle": function() { return /* binding */ setCircle; },
/* harmony export */   "enableCircle": function() { return /* binding */ enableCircle; },
/* harmony export */   "disableCircle": function() { return /* binding */ disableCircle; },
/* harmony export */   "addCircle": function() { return /* binding */ addCircle; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ "./src/online_annotate/render/appendChild.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");




let _enabled = false;
let _type;
let _circleRadius = 10;
let _circleColor = '0000FF';

/**
 * Set the attributes of the pen.
 *
 * @param {Number} circleRadius The radius of the circle
 * @param {String} circleColor The color of the circle
 */
function setCircle(circleRadius = 10, circleColor = '0000FF') {
  _circleRadius = parseInt(circleRadius, 10);
  _circleColor = circleColor;
}

/**
 * Handle document.mouseup event
 *
 * @param {Event} e The DOM event to handle
 */
function handleDocumentMouseup(e) {
  let svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(e.clientX, e.clientY);
  if (!svg) {
    return;
  }
  let rect = svg.getBoundingClientRect();
  saveCircle(svg, _type, {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  }, _circleRadius, _circleColor);
}

/**
 * Save a circle annotation
 *
 * @param {SVGElement} svg
 * @param {String} type The type of circle (circle, emptycircle, fillcircle)
 * @param {Object} pt The point to use for annotation
 * @param {float} radius
 * @param {String} color The color of the rects
 */
function saveCircle(svg, type, pt, radius, color) {
  // Initialize the annotation
  let svg_pt = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.convertToSvgPoint)([ pt.x, pt.y ], svg);
  let annotation = {
    type,
    color,
    cx: svg_pt[0],
    cy: svg_pt[1],
    r: radius
  };

  let { documentId, pageNumber } = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getMetadata)(svg);

  // Add the annotation
  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)
    .then((annotation) => {
      (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_1__.appendChild)(svg, annotation);
    });
}

/**
 * Enable circle behavior
 */
function enableCircle(type) {
  _type = type;

  if (_enabled) { return; }

  _enabled = true;
  document.addEventListener('mouseup', handleDocumentMouseup);
}

/**
 * Disable circle behavior
 */
function disableCircle() {
  if (!_enabled) { return; }

  _enabled = false;
  document.removeEventListener('mouseup', handleDocumentMouseup);
}

function addCircle(type, e) {
  let oldType = _type;
  _type = type;
  handleDocumentMouseup(e);
  _type = oldType;
}


/***/ }),

/***/ "./src/online_annotate/UI/edit.js":
/*!****************************************!*\
  !*** ./src/online_annotate/UI/edit.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableEdit": function() { return /* binding */ enableEdit; },
/* harmony export */   "disableEdit": function() { return /* binding */ disableEdit; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./src/online_annotate/config.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event */ "./src/online_annotate/UI/event.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");
/* harmony import */ var _render_renderPath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/renderPath */ "./src/online_annotate/render/renderPath.js");






let _enabled = false;
let isDragging = false;
let overlay;
let dragOffsetX, dragOffsetY, dragStartX, dragStartY;
const OVERLAY_BORDER_SIZE = 3;

/**
 * Create an overlay for editing an annotation.
 *
 * @param {Element} target The annotation element to apply overlay for
 */
function createEditOverlay(target) {
  destroyEditOverlay();

  overlay = document.createElement('div');
  let anchor = document.createElement('a');
  let parentNode = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.findSVGContainer)(target).parentNode;
  let id = target.getAttribute('data-pdf-annotate-id');
  let rect = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getOffsetAnnotationRect)(target);
  let styleLeft = rect.left - OVERLAY_BORDER_SIZE;
  let styleTop = rect.top - OVERLAY_BORDER_SIZE;

  overlay.setAttribute('id', 'pdf-annotate-edit-overlay');
  overlay.setAttribute('data-target-id', id);
  overlay.style.boxSizing = 'content-box';
  overlay.style.position = 'absolute';
  overlay.style.top = `${styleTop}px`;
  overlay.style.left = `${styleLeft}px`;
  overlay.style.width = `${rect.width}px`;
  overlay.style.height = `${rect.height}px`;
  overlay.style.border = `${OVERLAY_BORDER_SIZE}px solid ${_utils__WEBPACK_IMPORTED_MODULE_3__.BORDER_COLOR}`;
  overlay.style.borderRadius = `${OVERLAY_BORDER_SIZE}px`;
  overlay.style.zIndex = 20100;
  // overlay.style.transform =  `scale(${window._RENDER_OPTIONS.scale})`

  anchor.innerHTML = '×';
  anchor.setAttribute('href', 'javascript://');
  anchor.style.background = '#fff';
  anchor.style.borderRadius = '20px';
  anchor.style.border = '1px solid #bbb';
  anchor.style.color = '#bbb';
  anchor.style.fontSize = '16px';
  anchor.style.padding = '2px';
  anchor.style.textAlign = 'center';
  anchor.style.textDecoration = 'none';
  anchor.style.position = 'absolute';
  anchor.style.top = '-13px';
  anchor.style.right = '-13px';
  anchor.style.width = '25px';
  anchor.style.height = '25px';
  anchor.style.transform = `scale(0.5)`;

  overlay.appendChild(anchor);
  parentNode.appendChild(overlay);
  document.addEventListener('click', handleDocumentClick);
  document.addEventListener('keyup', handleDocumentKeyup);
  document.addEventListener('mousedown', handleDocumentMousedown);
  anchor.addEventListener('click', deleteAnnotation);
  anchor.addEventListener('mouseover', () => {
    anchor.style.color = '#35A4DC';
    anchor.style.borderColor = '#999';
    anchor.style.boxShadow = '0 1px 1px #ccc';
  });
  anchor.addEventListener('mouseout', () => {
    anchor.style.color = '#bbb';
    anchor.style.borderColor = '#bbb';
    anchor.style.boxShadow = '';
  });
  overlay.addEventListener('mouseover', () => {
    if (!isDragging) { anchor.style.display = ''; }
  });
  overlay.addEventListener('mouseout', () => {
    anchor.style.display = 'none';
  });
}

/**
 * Destroy the edit overlay if it exists.
 */
function destroyEditOverlay() {
  if (overlay) {
    try{
    overlay.parentNode.removeChild(overlay);
    }catch(e){}
    overlay = null;
  }

  document.removeEventListener('click', handleDocumentClick);
  document.removeEventListener('keyup', handleDocumentKeyup);
  document.removeEventListener('mousedown', handleDocumentMousedown);
  document.removeEventListener('mousemove', handleDocumentMousemove);
  document.removeEventListener('mouseup', handleDocumentMouseup);
  (0,_utils__WEBPACK_IMPORTED_MODULE_3__.enableUserSelect)();
}

/**
 * Delete currently selected annotation
 */
function deleteAnnotation() {
  if (!overlay) {
    return;
  }

  let annotationId = overlay.getAttribute('data-target-id');
  let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__["default"].annotationSvgQuery());
  let { documentId } = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getMetadata)(svg);

  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().deleteAnnotation(documentId, annotationId).then(() => {
    let nodes = document.querySelectorAll(`[data-pdf-annotate-id="${annotationId}"]`);

    [...nodes].forEach((n) => {
      n.parentNode.removeChild(n);
    });
  });

  destroyEditOverlay();
}

/**
 * Handle document.click event
 *
 * @param {Event} e The DOM event that needs to be handled
 */
function handleDocumentClick(e) {
  if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.findSVGAtPoint)(e.clientX, e.clientY)) { return; }
  // Remove current overlay
  let overlay = document.getElementById('pdf-annotate-edit-overlay');
  if (overlay) {
    if (isDragging || e.target === overlay) {
      return;
    }

    destroyEditOverlay();
  }
}

/**
 * Handle document.keyup event
 *
 * @param {KeyboardEvent} e The DOM event that needs to be handled
 */
function handleDocumentKeyup(e) {
  // keyCode is deprecated, so prefer the newer "key" method if possible
  let keyTest;
  if (e.key) {
    keyTest = e.key.toLowerCase() === 'delete' || e.key.toLowerCase() === 'backspace';
  }
  else {
    keyTest = e.keyCode === 8 || e.keyCode === 46;
  }
  if (overlay && keyTest &&
      e.target.nodeName.toLowerCase() !== 'textarea' &&
      e.target.nodeName.toLowerCase() !== 'input') {
    e.preventDefault();
    deleteAnnotation();
  }
}

/**
 * Handle document.mousedown event
 *
 * @param {Event} e The DOM event that needs to be handled
 */
function handleDocumentMousedown(e) {
  if (e.target !== overlay) {
    return;
  }

  // Highlight and strikeout annotations are bound to text within the document.
  // It doesn't make sense to allow repositioning these types of annotations.
  let annotationId = overlay.getAttribute('data-target-id');
  let target = document.querySelector(`[data-pdf-annotate-id="${annotationId}"]`);
  let type = target.getAttribute('data-pdf-annotate-type');

  if (type === 'highlight' || type === 'strikeout'|| type === 'underline') { return; }

  isDragging = true;
  dragOffsetX = e.clientX;
  dragOffsetY = e.clientY;
  dragStartX = overlay.offsetLeft;
  dragStartY = overlay.offsetTop;

  overlay.style.background = 'rgba(255, 255, 255, 0.7)';
  overlay.style.cursor = 'move';
  overlay.querySelector('a').style.display = 'none';

  document.addEventListener('mousemove', handleDocumentMousemove);
  document.addEventListener('mouseup', handleDocumentMouseup);
  (0,_utils__WEBPACK_IMPORTED_MODULE_3__.disableUserSelect)();
}

/**
 * Handle document.mousemove event
 *
 * @param {Event} e The DOM event that needs to be handled
 */
function handleDocumentMousemove(e) {
  let parentNode = overlay.parentNode;
  let rect = parentNode.getBoundingClientRect();
  let y = (dragStartY + (e.clientY - dragOffsetY));
  let x = (dragStartX + (e.clientX - dragOffsetX));
  let minY = 0;
  let maxY = rect.height;
  let minX = 0;
  let maxX = rect.width;

  if (y > minY && y + overlay.offsetHeight < maxY) {
    overlay.style.top = `${y}px`;
  }

  if (x > minX && x + overlay.offsetWidth < maxX) {
    overlay.style.left = `${x}px`;
  }
}

/**
 * Handle document.mouseup event
 *
 * @param {Event} e The DOM event that needs to be handled
 */
function handleDocumentMouseup(e) {
  let annotationId = overlay.getAttribute('data-target-id');
  let target = document.querySelectorAll(`[data-pdf-annotate-id="${annotationId}"]`);
  let type = target[0].getAttribute('data-pdf-annotate-type');
  let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__["default"].annotationSvgQuery());
  let { documentId } = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getMetadata)(svg);

  overlay.querySelector('a').style.display = '';

  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().getAnnotation(documentId, annotationId).then((annotation) => {
    let attribX = 'x';
    let attribY = 'y';
    if (['circle', 'fillcircle', 'emptycircle'].indexOf(type) > -1) {
      attribX = 'cx';
      attribY = 'cy';
    }

    if (type === 'point') {
      // Broken
      /*
      [...target].forEach((t, i) => {
        let moveTo = {
          x: overlay.offsetLeft + 3,
          y: overlay.offsetTop + 3
        };
        t.setAttribute(attribX, moveTo.x);
        t.setAttribute(attribY, moveTo.y);
        annotation[attribX] = moveTo.x;
        annotation[attribY] = moveTo.y;
      });
      */
      return;
    }
    else if (['area', 'highlight', 'textbox', 'circle', 'fillcircle', 'emptycircle'].indexOf(type) > -1) {
      let modelStart = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.convertToSvgPoint)([dragStartX, dragStartY], svg);
      let modelEnd = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.convertToSvgPoint)([overlay.offsetLeft, overlay.offsetTop], svg);
      let modelDelta = {
        x: modelEnd[0] - modelStart[0],
        y: modelEnd[1] - modelStart[1]
      };

      if (type === 'textbox') {
        target = [target[0].firstChild];
      }

      [...target].forEach((t, i) => {
        let modelX = parseInt(t.getAttribute(attribX), 10);
        let modelY = parseInt(t.getAttribute(attribY), 10);
        if (modelDelta.y !== 0) {
          modelY = modelY + modelDelta.y;

          t.setAttribute(attribY, modelY);
          if (annotation.rectangles && i < annotation.rectangles.length) {
            annotation.rectangles[i].y = modelY;
          }
          else if (annotation[attribY]) {
            annotation[attribY] = modelY;
          }
          // 循环给下面的子元素偏移
          for(const child of t.children){
            let cy = child.getAttribute('y');
            if(cy){
              cy = parseInt(cy,10)+modelDelta.y;
              child.setAttribute('y',cy);
            }
          }
        }
        if (modelDelta.x !== 0) {
          modelX = modelX + modelDelta.x;

          t.setAttribute(attribX, modelX);
          if (annotation.rectangles && i < annotation.rectangles.length) {
            annotation.rectangles[i].x = modelX;
          }
          else if (annotation[attribX]) {
            annotation[attribX] = modelX;
          }
          // 循环给下面的子元素偏移
          for(const child of t.children){
            let cx = child.getAttribute('x');
            if(cx){
              cx = parseInt(cx,10) + modelDelta.x;
              child.setAttribute('x',cx);
            }
          }
        }
      });
    }
    else if (type === 'strikeout' || type === 'underline') {
      return;
    //   let { deltaX, deltaY } = getDelta('x1', 'y1');
    //   [...target].forEach(target, (t, i) => {
    //     if (deltaY !== 0) {
    //       t.setAttribute('y1', parseInt(t.getAttribute('y1'), 10) + deltaY);
    //       t.setAttribute('y2', parseInt(t.getAttribute('y2'), 10) + deltaY);
    //       annotation.rectangles[i].y = parseInt(t.getAttribute('y1'), 10);
    //     }
    //     if (deltaX !== 0) {
    //       t.setAttribute('x1', parseInt(t.getAttribute('x1'), 10) + deltaX);
    //       t.setAttribute('x2', parseInt(t.getAttribute('x2'), 10) + deltaX);
    //       annotation.rectangles[i].x = parseInt(t.getAttribute('x1'), 10);
    //     }
    //   });
    }
    else if (type === 'drawing' || type === 'arrow') {
      // Do nothing as currently broken
      let modelStart = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.convertToSvgPoint)([dragStartX, dragStartY], svg);
      let modelEnd = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.convertToSvgPoint)([overlay.offsetLeft, overlay.offsetTop], svg);
      let modelDelta = {
        x: modelEnd[0] - modelStart[0],
        y: modelEnd[1] - modelStart[1]
      };
      annotation.lines.forEach((line, i) => {
        let [x, y] = annotation.lines[i];
        annotation.lines[i][0] = parseInt(x,10) + modelDelta.x;
        annotation.lines[i][1] = parseInt(y,10) + modelDelta.y;
      });
      const path = (0,_render_renderPath__WEBPACK_IMPORTED_MODULE_4__["default"])(annotation);
      const td = path.getAttribute('d');
      target[0].setAttribute('d',td);
    }

    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().editAnnotation(documentId, annotationId, annotation);
  });

  setTimeout(() => {
    isDragging = false;
  }, 0);

  overlay.style.background = '';
  overlay.style.cursor = '';

  document.removeEventListener('mousemove', handleDocumentMousemove);
  document.removeEventListener('mouseup', handleDocumentMouseup);
  (0,_utils__WEBPACK_IMPORTED_MODULE_3__.enableUserSelect)();
}

/**
 * Handle annotation.click event
 *
 * @param {Element} e The annotation element that was clicked
 */
function handleAnnotationClick(target) {
  createEditOverlay(target);
}

/**
 * Enable edit mode behavior.
 */
function enableEdit() {
  if (_enabled) {
    return;
  }

  _enabled = true;
  (0,_event__WEBPACK_IMPORTED_MODULE_2__.addEventListener)('annotation:click', handleAnnotationClick);
};

/**
 * Disable edit mode behavior.
 */
function disableEdit() {
  destroyEditOverlay();

  if (!_enabled) {
    return;
  }

  _enabled = false;
  (0,_event__WEBPACK_IMPORTED_MODULE_2__.removeEventListener)('annotation:click', handleAnnotationClick);
};



/***/ }),

/***/ "./src/online_annotate/UI/eraser.js":
/*!******************************************!*\
  !*** ./src/online_annotate/UI/eraser.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableEraser": function() { return /* binding */ enableEraser; },
/* harmony export */   "disableEraser": function() { return /* binding */ disableEraser; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");



let _canerase = false;
let previousPoint = null;

/**
 *
 * @param {PointerEvent} e DOM event to handle
 */
function handleDocumentDown(e) {
  _canerase = true;
  previousPoint = [e.clientX, e.clientY];
}

/**
 *
 * @param {PointerEvent} e DOM event to handle
 */
function handleDocumentUp(e) {
  _canerase = false;
  erase((0,_utils__WEBPACK_IMPORTED_MODULE_1__.findAnnotationAtPoint)(e.clientX, e.clientY));
}

/**
 *
 * @param {PointerEvent} e DOM event to handle
 */
function handleDocumentMouseMove(e) {
  if (!_canerase) {
    return;
  }

  // This algorithm attempts to get the various points between the last
  // PointerEvent and this one
  let check = [];
  let diffX = Math.abs(previousPoint[0] - e.clientX);
  let diffY = Math.abs(previousPoint[1] - e.clientY);
  if (diffX >= 1 || diffY >= 1) {
    let maxSteps = Math.round(Math.max(diffX, diffY));
    let subStepSize = Math.min(diffX, diffY) / maxSteps;
    let smallerTest = diffX < diffY;
    let startPoint = [
      Math.min(previousPoint[0], e.clientX),
      Math.min(previousPoint[1], e.clientY)
    ];
    for (let i = 0; i < maxSteps; i++) {
      if (smallerTest) {
        check.push([Math.round(startPoint[0] + (subStepSize * i)), Math.round(startPoint[1] + i)]);
      }
      else {
        check.push([Math.round(startPoint[0] + i), Math.round(startPoint[1] + (subStepSize * i))]);
      }
    }
  }
  for (let point of check) {
    erase((0,_utils__WEBPACK_IMPORTED_MODULE_1__.findAnnotationAtPoint)(point[0], point[1]));
  }
  previousPoint = [e.clientX, e.clientY];
}

function erase(target) {
  if (!_canerase) {
    return;
  }

  if (target) {
    let { documentId } = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getMetadata)(target.parentElement);
    let annotationId = target.getAttribute('data-pdf-annotate-id');
    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().deleteAnnotation(documentId, annotationId).then(() => {
      let nodes = document.querySelectorAll(`[data-pdf-annotate-id="${annotationId}"]`);
      [...nodes].forEach((n) => {
        n.parentNode.removeChild(n);
      });
    });
  }
}

function enableEraser() {
  document.addEventListener('pointermove', handleDocumentMouseMove);
  document.addEventListener('pointerdown', handleDocumentDown);
  document.addEventListener('pointerup', handleDocumentUp);
  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.disableUserSelect)();
}

function disableEraser() {
  document.removeEventListener('pointermove', handleDocumentMouseMove);
  document.removeEventListener('pointerdown', handleDocumentDown);
  document.removeEventListener('pointerup', handleDocumentUp);
  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.enableUserSelect)();
}


/***/ }),

/***/ "./src/online_annotate/UI/event.js":
/*!*****************************************!*\
  !*** ./src/online_annotate/UI/event.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fireEvent": function() { return /* binding */ fireEvent; },
/* harmony export */   "addEventListener": function() { return /* binding */ addEventListener; },
/* harmony export */   "removeEventListener": function() { return /* binding */ removeEventListener; }
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");



const emitter = new (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default())();

let clickNode;

/**
 * Handle document.click event
 *
 * @param {Event} e The DOM event to be handled
 */
document.addEventListener('click', function handleDocumentClick(e) {
  if (!(0,_utils__WEBPACK_IMPORTED_MODULE_1__.findSVGAtPoint)(e.clientX, e.clientY)) {
    return;
  }
  let target = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.findAnnotationAtPoint)(e.clientX, e.clientY);
  // Emit annotation:blur if clickNode is no longer clicked
  if (clickNode && clickNode !== target) {
    emitter.emit('annotation:blur', clickNode);
  }

  // Emit annotation:click if target was clicked
  if (target) {
    emitter.emit('annotation:click', target);
  }

  clickNode = target;
});

// let mouseOverNode;
// document.addEventListener('mousemove', function handleDocumentMousemove(e) {
//   let target = findAnnotationAtPoint(e.clientX, e.clientY);
//
//   // Emit annotation:mouseout if target was mouseout'd
//   if (mouseOverNode && !target) {
//     emitter.emit('annotation:mouseout', mouseOverNode);
//   }
//
//   // Emit annotation:mouseover if target was mouseover'd
//   if (target && mouseOverNode !== target) {
//     emitter.emit('annotation:mouseover', target);
//   }
//
//   mouseOverNode = target;
// });

function fireEvent() { emitter.emit(...arguments); };
function addEventListener() { emitter.on(...arguments); };
function removeEventListener() { emitter.removeListener(...arguments); };


/***/ }),

/***/ "./src/online_annotate/UI/index.js":
/*!*****************************************!*\
  !*** ./src/online_annotate/UI/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ "./src/online_annotate/UI/event.js");
/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edit */ "./src/online_annotate/UI/edit.js");
/* harmony import */ var _pen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pen */ "./src/online_annotate/UI/pen.js");
/* harmony import */ var _arrow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./arrow */ "./src/online_annotate/UI/arrow.js");
/* harmony import */ var _eraser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./eraser */ "./src/online_annotate/UI/eraser.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./point */ "./src/online_annotate/UI/point.js");
/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rect */ "./src/online_annotate/UI/rect.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./circle */ "./src/online_annotate/UI/circle.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./text */ "./src/online_annotate/UI/text.js");
/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./page */ "./src/online_annotate/UI/page.js");











/* harmony default export */ __webpack_exports__["default"] = ({
  addEventListener: _event__WEBPACK_IMPORTED_MODULE_0__.addEventListener,
  removeEventListener: _event__WEBPACK_IMPORTED_MODULE_0__.removeEventListener,
  fireEvent: _event__WEBPACK_IMPORTED_MODULE_0__.fireEvent,

  disableEdit: _edit__WEBPACK_IMPORTED_MODULE_1__.disableEdit,
  enableEdit: _edit__WEBPACK_IMPORTED_MODULE_1__.enableEdit,

  disablePen: _pen__WEBPACK_IMPORTED_MODULE_2__.disablePen,
  enablePen: _pen__WEBPACK_IMPORTED_MODULE_2__.enablePen,


  disablePoint: _point__WEBPACK_IMPORTED_MODULE_5__.disablePoint,
  enablePoint: _point__WEBPACK_IMPORTED_MODULE_5__.enablePoint,

  disableRect: _rect__WEBPACK_IMPORTED_MODULE_6__.disableRect,
  enableRect: _rect__WEBPACK_IMPORTED_MODULE_6__.enableRect,

  disableCircle: _circle__WEBPACK_IMPORTED_MODULE_7__.disableCircle,
  enableCircle: _circle__WEBPACK_IMPORTED_MODULE_7__.enableCircle,
  setCircle: _circle__WEBPACK_IMPORTED_MODULE_7__.setCircle,
  addCircle: _circle__WEBPACK_IMPORTED_MODULE_7__.addCircle,

  disableArrow: _arrow__WEBPACK_IMPORTED_MODULE_3__.disableArrow,
  enableArrow: _arrow__WEBPACK_IMPORTED_MODULE_3__.enableArrow,
  setArrow: _arrow__WEBPACK_IMPORTED_MODULE_3__.setArrow,

  disableEraser: _eraser__WEBPACK_IMPORTED_MODULE_4__.disableEraser,
  enableEraser: _eraser__WEBPACK_IMPORTED_MODULE_4__.enableEraser,

  disableText: _text__WEBPACK_IMPORTED_MODULE_8__.disableText,
  enableText: _text__WEBPACK_IMPORTED_MODULE_8__.enableText,
  setText: _text__WEBPACK_IMPORTED_MODULE_8__.setText,

  createPage: _page__WEBPACK_IMPORTED_MODULE_9__.createPage,
  renderPage: _page__WEBPACK_IMPORTED_MODULE_9__.renderPage
});


/***/ }),

/***/ "./src/online_annotate/UI/page.js":
/*!****************************************!*\
  !*** ./src/online_annotate/UI/page.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPage": function() { return /* binding */ createPage; },
/* harmony export */   "renderPage": function() { return /* binding */ renderPage; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./src/online_annotate/config.js");
/* harmony import */ var _a11y_renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../a11y/renderScreenReaderHints */ "./src/online_annotate/a11y/renderScreenReaderHints.js");
/* harmony import */ var _event_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../event_utils */ "./src/event_utils.js");




// Template for creating a new page
const PAGE_TEMPLATE =
    `
  <div style="visibility: hidden;" class="page" data-loaded="false">
    <div class="canvasWrapper">
      <canvas></canvas>
    </div>
    <div class="` +
    _config__WEBPACK_IMPORTED_MODULE_1__["default"].textLayerName +
    `"></div>
    <svg class="` +
    _config__WEBPACK_IMPORTED_MODULE_1__["default"].annotationLayerName +
    `"></svg>
  </div>
`;

/**
 * Create a new page to be appended to the DOM.
 *
 * @param {Number} pageNumber The page number that is being created
 * @return {HTMLElement}
 */
function createPage(pageNumber) {
    let temp = document.createElement('div');
    temp.innerHTML = PAGE_TEMPLATE;

    let page = temp.children[0];
    let canvas = page.querySelector('canvas');

    page.setAttribute('id', `page${pageNumber}`);
    page.setAttribute('data-page-number', pageNumber);

    canvas.mozOpaque = true;
    canvas.setAttribute('id', `page${pageNumber}`);

    return page;
}

/**
 * Render a page that has already been created.
 *
 * @param {Number} pageNumber The page number to be rendered
 * @param {Object} renderOptions The options for rendering
 * @return {Promise} Settled once rendering has completed
 *  A settled Promise will be either:
 *    - fulfilled: [pdfPage, annotations]
 *    - rejected: Error
 */
function renderPage(pageNumber, renderOptions, pdfPage) {
    let { documentId, pdfDocument, scale, rotate } = renderOptions;

    const eventBus = window.PDFViewerApplication.eventBus;
    // Load the page and annotations
    return Promise.all([_PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getAnnotations(documentId, pageNumber)]).then(([annotations]) => {
        let page = document.getElementById(`page${pageNumber}`);
        let svg = page.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__["default"].annotationClassQuery());
        let canvas = page.querySelector('.canvasWrapper canvas');
        let canvasContext = canvas.getContext('2d', { alpha: false });
        let totalRotation = rotate; //(rotate + pdfPage.rotate) % 360;
        let viewport = pdfPage.getViewport({ scale: scale, rotation: totalRotation });
        let transform = scalePage(pageNumber, viewport, canvasContext);
        // Render the page
        return Promise.all([
            // pdfPage.render({ canvasContext, viewport, transform }).promise,
            _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].render(svg, viewport, annotations),
        ])
            .then(() => {
                // Text content is needed for a11y, but is also necessary for creating
                // highlight and strikeout annotations which require selecting text.
                return new Promise((resolve, reject) => {
                    //Render text layer for a11y of text content
                    // let textLayer = page.querySelector(config.textClassQuery());
                    // let textLayerFactory = new pdfjsViewer.DefaultTextLayerFactory();
                    // let textLayerBuilder = textLayerFactory.createTextLayerBuilder(
                    //   textLayer,
                    //   pageNumber - 1,
                    //   viewport,
                    //   false,
                    //   eventBus
                    // );
                    // textLayerBuilder.setTextContent(textContent);
                    // textLayerBuilder.render();

                    //Enable a11y for annotations
                    //Timeout is needed to wait for `textLayerBuilder.render`
                    setTimeout(() => {
                        try {
                            (0,_a11y_renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_2__["default"])(annotations.annotations);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            })
            .then(() => {
                // Indicate that the page was loaded
                page.setAttribute('data-anno-loaded', 'true');

                return [pdfPage, annotations];
            });
    });
}

/**
 * Scale the elements of a page.
 *
 * @param {Number} pageNumber The page number to be scaled
 * @param {Object} viewport The viewport of the PDF page (see pdfPage.getViewport(scale, rotate))
 * @param {Object} context The canvas context that the PDF page is rendered to
 * @return {Array} The transform data for rendering the PDF page
 */
function scalePage(pageNumber, viewport, context) {
    let page = document.getElementById(`page${pageNumber}`);
    let svg = page.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__["default"].annotationClassQuery());
    let wrapper = page.querySelector('.canvasWrapper');
    let textLayer = page.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__["default"].textClassQuery());
    let outputScale = getOutputScale(context);
    let transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
    let sfx = approximateFraction(outputScale.sx);
    let sfy = approximateFraction(outputScale.sy);

    // Adjust width/height for scale
    page.style.visibility = '';
    // canvas.width = roundToDivide(viewport.width * outputScale.sx, sfx[0]);
    // canvas.height = roundToDivide(viewport.height * outputScale.sy, sfy[0]);
    // canvas.style.width = roundToDivide(viewport.width, sfx[1]) + 'px';
    // canvas.style.height = roundToDivide(viewport.height, sfx[1]) + 'px';
    svg.setAttribute('width', viewport.width);
    svg.setAttribute('height', viewport.height);
    svg.style.width = `${viewport.width}px`;
    svg.style.height = `${viewport.height}px`;
    page.style.width = `${viewport.width}px`;
    page.style.height = `${viewport.height}px`;
    wrapper.style.width = `${viewport.width}px`;
    wrapper.style.height = `${viewport.height}px`;
    textLayer.style.width = `${viewport.width}px`;
    textLayer.style.height = `${viewport.height}px`;

    return transform;
}

/**
 * Approximates a float number as a fraction using Farey sequence (max order of 8).
 *
 * @param {Number} x Positive float number
 * @return {Array} Estimated fraction: the first array item is a numerator,
 *                 the second one is a denominator.
 */
function approximateFraction(x) {
    // Fast path for int numbers or their inversions.
    if (Math.floor(x) === x) {
        return [x, 1];
    }

    const xinv = 1 / x;
    const limit = 8;
    if (xinv > limit) {
        return [1, limit];
    } else if (Math.floor(xinv) === xinv) {
        return [1, xinv];
    }

    const x_ = x > 1 ? xinv : x;

    // a/b and c/d are neighbours in Farey sequence.
    let a = 0;
    let b = 1;
    let c = 1;
    let d = 1;

    // Limit search to order 8.
    while (true) {
        // Generating next term in sequence (order of q).
        let p = a + c;
        let q = b + d;
        if (q > limit) {
            break;
        }
        if (x_ <= p / q) {
            c = p;
            d = q;
        } else {
            a = p;
            b = q;
        }
    }

    // Select closest of neighbours to x.
    if (x_ - a / b < c / d - x_) {
        return x_ === x ? [a, b] : [b, a];
    } else {
        return x_ === x ? [c, d] : [d, c];
    }
}

function getOutputScale(ctx) {
    let devicePixelRatio = window.devicePixelRatio || 1;
    let backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
    let pixelRatio = devicePixelRatio / backingStoreRatio;
    return {
        sx: pixelRatio,
        sy: pixelRatio,
        scaled: pixelRatio !== 1,
    };
}

function roundToDivide(x, div) {
    let r = x % div;
    return r === 0 ? x : Math.round(x - r + div);
}


/***/ }),

/***/ "./src/online_annotate/UI/pen.js":
/*!***************************************!*\
  !*** ./src/online_annotate/UI/pen.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPen": function() { return /* binding */ getPen; },
/* harmony export */   "enablePen": function() { return /* binding */ enablePen; },
/* harmony export */   "disablePen": function() { return /* binding */ disablePen; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ "./src/online_annotate/render/appendChild.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");




let _enabled = false;
let _candraw = false;
let path;
let lines = [];

/**
 * Handle document.touchdown or document.pointerdown event
 * @param {PointerEvent} e The DOM event to be handled
 */
function handleDocumentPointerdown(e) {
  if(window.colorPaletteOpen) return;
  path = null;
  lines = [];
  if (!(0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(e.clientX, e.clientY)) {
    return;
  }
  _candraw = true;
  e.preventDefault();
}

/**
 * Handle document.pointerup event
 *
 * @param {PointerEvent} e The DOM event to be handled
 */
function handleDocumentPointerup(e) {
  if(window.colorPaletteOpen) return;
  saveToStorage(e.clientX, e.clientY);
}

function saveToStorage(x, y) {
  if (!_candraw) {
    return;
  }
  _candraw = false;
  let svg;
  if (lines.length > 1 && (svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(x, y))) {
    let { documentId, pageNumber } = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getMetadata)(svg);
    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().addAnnotation(documentId, pageNumber, {
      type: 'drawing',
      width: window.currentAnnoteSize,
      color: window.currentAnnoteColor,
      opacity:window.currentOpacity,
      lines
    }).then((annotation) => {
      if (path) {
        svg.removeChild(path);
      }

      (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_1__.appendChild)(svg, annotation);
    });
  }
}

/**
 * Handle document.mousemove event
 *
 * @param {PointerEvent} e The DOM event to be handled
 */
function handleDocumentPointermove(e) {
  if(window.colorPaletteOpen) return;
  if (!(0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(e.clientX, e.clientY) || !_candraw) {
    return;
  }
  savePoint(e.clientX, e.clientY);
}

/**
 * Handle document.keyup event
 *
 * @param {KeyboardEvent} e The DOM event to be handled
 * } e The DOM event to be handled
 */
function handleDocumentKeyup(e) {
  if(window.colorPaletteOpen) return;
  // Cancel rect if Esc is pressed
  if (e.keyCode === 27) {
    lines = null;
    path.parentNode.removeChild(path);
    document.removeEventListener('pointermove', handleDocumentPointermove);
    document.removeEventListener('pointerup', handleDocumentPointerup);
  }
}

/**
 * Save a point to the line being drawn.
 *
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 */
function savePoint(x, y) {
  let svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(x, y);
  if (!svg) {
    return;
  }

  let rect = svg.getBoundingClientRect();
  let point = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.convertToSvgPoint)([
    x - rect.left,
    y - rect.top
  ], svg);
  point[0] = point[0].toFixed(2);
  point[1] = point[1].toFixed(2);
  lines.push(point);

  if (lines.length <= 1) {
    return;
  }

  if (path) {
    svg.removeChild(path);
  }

  path = (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_1__.appendChild)(svg, {
    type: 'drawing',
    color: window.currentAnnoteColor,
    width: window.currentAnnoteSize,
    opacity:window.currentOpacity,
    lines
  });
}

/**
 * Set the attributes of the pen.
 *
 * @param {Number} penSize The size of the lines drawn by the pen, rounded to 2 decimal places
 * @param {String} penColor The color of the lines drawn by the pen
 */

/**
 * Return pen attributes of the pen
 *
 * @return {Object} Object with size and color
 */
function getPen() {
  return {
    size: window.currentAnnoteSize,
    color: window.currentAnnoteColor
  };
}

/**
 * Enable the pen behavior
 */
function enablePen() {
  if (_enabled) {
    return;
  }

  _enabled = true;
  // Chrome and Firefox has different behaviors with how pen works, so we need different events.
  document.addEventListener('pointerdown', handleDocumentPointerdown);
  document.addEventListener('pointermove', handleDocumentPointermove);
  document.addEventListener('pointerup', handleDocumentPointerup);

  document.addEventListener('keyup', handleDocumentKeyup);
  (0,_utils__WEBPACK_IMPORTED_MODULE_2__.disableUserSelect)();
}

/**
 * Disable the pen behavior
 */
function disablePen() {
  if (!_enabled) {
    return;
  }

  _enabled = false;
  document.removeEventListener('pointerdown', handleDocumentPointerdown);
  document.removeEventListener('pointermove', handleDocumentPointermove);
  document.removeEventListener('pointerup', handleDocumentPointerup);

  document.removeEventListener('keyup', handleDocumentKeyup);
  (0,_utils__WEBPACK_IMPORTED_MODULE_2__.enableUserSelect)();
}


/***/ }),

/***/ "./src/online_annotate/UI/point.js":
/*!*****************************************!*\
  !*** ./src/online_annotate/UI/point.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enablePoint": function() { return /* binding */ enablePoint; },
/* harmony export */   "disablePoint": function() { return /* binding */ disablePoint; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ "./src/online_annotate/render/appendChild.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");




let _enabled = false;
let input;

/**
 * Handle document.mouseup event
 *
 * @param {Event} The DOM event to be handled
 */
function handleDocumentMouseup(e) {
  if (input || !(0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(e.clientX, e.clientY)) {
    return;
  }

  input = document.createElement('input');
  input.setAttribute('id', 'pdf-annotate-point-input');
  input.setAttribute('placeholder', 'Enter comment');
  input.style.border = `3px solid ${_utils__WEBPACK_IMPORTED_MODULE_2__.BORDER_COLOR}`;
  input.style.borderRadius = '3px';
  input.style.position = 'absolute';
  input.style.top = `${e.clientY}px`;
  input.style.left = `${e.clientX}px`;

  input.addEventListener('blur', handleInputBlur);
  input.addEventListener('keyup', handleInputKeyup);

  document.body.appendChild(input);
  input.focus();
}

/**
 * Handle input.blur event
 */
function handleInputBlur() {
  savePoint();
}

/**
 * Handle input.keyup event
 *
 * @param {Event} e The DOM event to handle
 */
function handleInputKeyup(e) {
  if (e.keyCode === 27) {
    closeInput();
  }
  else if (e.keyCode === 13) {
    savePoint();
  }
}

/**
 * Save a new point annotation from input
 */
function savePoint() {
  if (input.value.trim().length > 0) {
    let clientX = parseInt(input.style.left, 10);
    let clientY = parseInt(input.style.top, 10);
    let content = input.value.trim();
    let svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(clientX, clientY);
    if (!svg) {
      return;
    }

    let rect = svg.getBoundingClientRect();
    let { documentId, pageNumber } = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getMetadata)(svg);
    let annotation = Object.assign({
      type: 'point'
    }, (0,_utils__WEBPACK_IMPORTED_MODULE_2__.scaleDown)(svg, {
      x: clientX - rect.left,
      y: clientY - rect.top
    }));

    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)
      .then((annotation) => {
        _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().addComment(
          documentId,
          annotation.uuid,
          content
        );

        (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_1__.appendChild)(svg, annotation);
      });
  }

  closeInput();
}

/**
 * Close the input element
 */
function closeInput() {
  input.removeEventListener('blur', handleInputBlur);
  input.removeEventListener('keyup', handleInputKeyup);
  document.body.removeChild(input);
  input = null;
}

/**
 * Enable point annotation behavior
 */
function enablePoint() {
  if (_enabled) { return; }

  _enabled = true;
  document.addEventListener('mouseup', handleDocumentMouseup);
}

/**
 * Disable point annotation behavior
 */
function disablePoint() {
  if (!_enabled) { return; }

  _enabled = false;
  document.removeEventListener('mouseup', handleDocumentMouseup);
}



/***/ }),

/***/ "./src/online_annotate/UI/rect.js":
/*!****************************************!*\
  !*** ./src/online_annotate/UI/rect.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableRect": function() { return /* binding */ enableRect; },
/* harmony export */   "disableRect": function() { return /* binding */ disableRect; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./src/online_annotate/config.js");
/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/appendChild */ "./src/online_annotate/render/appendChild.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");





let _enabled = false;
let _type;
let overlay;
let originY;
let originX;

/**
 * Get the current window selection as rects
 *
 * @return {Array} An Array of rects
 */
function getSelectionRects() {
  try {
    let selection = window.getSelection();
    let range = selection.getRangeAt(0);
    let rects = range.getClientRects();

    if (rects.length > 0 &&
        rects[0].width > 0 &&
        rects[0].height > 0) {
      return rects;
    }
  }
  catch (e) {}

  return null;
}

/**
 * Handle document.mousedown event
 *
 * @param {Event} e The DOM event to handle
 */
function handleDocumentMousedown(e) {
  if((0,_utils__WEBPACK_IMPORTED_MODULE_3__.hasButton)(e)) return;
  let svg;
  if (_type !== 'area' || !(svg = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.findSVGAtPoint)(e.clientX, e.clientY))) {
    return;
  }

  let rect = svg.getBoundingClientRect();
  originY = e.clientY;
  originX = e.clientX;

  overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.top = `${originY - rect.top}px`;
  overlay.style.left = `${originX - rect.left}px`;
  overlay.style.border = `3px solid ${_utils__WEBPACK_IMPORTED_MODULE_3__.BORDER_COLOR}`;
  overlay.style.borderRadius = '3px';
  svg.parentNode.appendChild(overlay);

  document.addEventListener('mousemove', handleDocumentMousemove);
  (0,_utils__WEBPACK_IMPORTED_MODULE_3__.disableUserSelect)();
}

/**
 * Handle document.mousemove event
 *
 * @param {Event} e The DOM event to handle
 */
function handleDocumentMousemove(e) {
  let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__["default"].annotationSvgQuery());
  let rect = svg.getBoundingClientRect();

  if (originX + (e.clientX - originX) < rect.right) {
    overlay.style.width = `${e.clientX - originX}px`;
  }

  if (originY + (e.clientY - originY) < rect.bottom) {
    overlay.style.height = `${e.clientY - originY}px`;
  }
}

/**
 * Handle document.mouseup event
 *
 * @param {Event} e The DOM event to handle
 */
function handleDocumentMouseup(e) {
  if((0,_utils__WEBPACK_IMPORTED_MODULE_3__.hasButton)(e)) return;
  let rects;
  if (_type !== 'area' && (rects = getSelectionRects())) {
    saveRect(_type, [...rects].map((r) => {
      return {
        top: r.top,
        left: r.left,
        width: r.width,
        height: r.height
      };
    }),window.currentAnnoteColor);
    let selection = window.getSelection();
    selection.removeAllRanges();
  }
  else if (_type === 'area' && overlay) {
    let svg = overlay.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__["default"].annotationSvgQuery());
    let rect = svg.getBoundingClientRect();
    saveRect(_type, [{
      top: parseInt(overlay.style.top, 10) + rect.top,
      left: parseInt(overlay.style.left, 10) + rect.left,
      width: parseInt(overlay.style.width, 10),
      height: parseInt(overlay.style.height, 10)
    }],window.currentAnnoteColor);

    overlay.parentNode.removeChild(overlay);
    overlay = null;

    document.removeEventListener('mousemove', handleDocumentMousemove);
    (0,_utils__WEBPACK_IMPORTED_MODULE_3__.enableUserSelect)();
  }
}

/**
 * Handle document.keyup event
 *
 * @param {Event} e The DOM event to handle
 */
function handleDocumentKeyup(e) {
  // Cancel rect if Esc is pressed
  if (e.keyCode === 27) {
    let selection = window.getSelection();
    selection.removeAllRanges();
    if (overlay && overlay.parentNode) {
      overlay.parentNode.removeChild(overlay);
      overlay = null;
      document.removeEventListener('mousemove', handleDocumentMousemove);
    }
  }
}

/**
 * Save a rect annotation
 *
 * @param {String} type The type of rect (area, highlight, strikeout,underline)
 * @param {Array} rects The rects to use for annotation
 * @param {String} color The color of the rects
 */
function saveRect(type, rects, color) {
  let svg = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.findSVGAtPoint)(rects[0].left, rects[0].top);
  let annotation;

  if (!svg) {
    return;
  }

  let boundingRect = svg.getBoundingClientRect();

  if (!color) {
    if (type === 'highlight') {
      color = 'FFFF00';
    }
    else if (type === 'strikeout') {
      color = 'FF0000';
    }
    else if (type === 'underline') {
      color = '00FFFF';
    }
  }

  // Initialize the annotation
  annotation = {
    type,
    color,
    rectangles: [...rects].map((r) => {
      let offset = 0;

      if (type === 'strikeout') {
        offset = r.height / 2;
      }else if(type === 'underline') {
        offset = r.height;
      }

      return (0,_utils__WEBPACK_IMPORTED_MODULE_3__.convertToSvgRect)({
        y: (r.top + offset) - boundingRect.top,
        x: r.left - boundingRect.left,
        width: r.width,
        height: r.height
      }, svg);
    }).filter((r) => r.width > 0 && r.height > 0 && r.x > -1 && r.y > -1)
  };

  // Short circuit if no rectangles exist
  if (annotation.rectangles.length === 0) {
    return;
  }

  // Special treatment for area as it only supports a single rect
  if (type === 'area') {
    let rect = annotation.rectangles[0];
    delete annotation.rectangles;
    annotation.x = rect.x;
    annotation.y = rect.y;
    annotation.width = rect.width;
    annotation.height = rect.height;
  }

  let { documentId, pageNumber } = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getMetadata)(svg);

  // Add the annotation
  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)
    .then((annotation) => {
      (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_2__.appendChild)(svg, annotation);
    });
}

/**
 * Enable rect behavior
 */
function enableRect(type) {
  _type = type;

  if (_enabled) { return; }

  _enabled = true;
  document.addEventListener('mouseup', handleDocumentMouseup);
  document.addEventListener('mousedown', handleDocumentMousedown);
  document.addEventListener('keyup', handleDocumentKeyup);
}

/**
 * Disable rect behavior
 */
function disableRect() {
  if (!_enabled) { return; }

  _enabled = false;
  document.removeEventListener('mouseup', handleDocumentMouseup);
  document.removeEventListener('mousedown', handleDocumentMousedown);
  document.removeEventListener('keyup', handleDocumentKeyup);
}



/***/ }),

/***/ "./src/online_annotate/UI/text.js":
/*!****************************************!*\
  !*** ./src/online_annotate/UI/text.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setText": function() { return /* binding */ setText; },
/* harmony export */   "enableText": function() { return /* binding */ enableText; },
/* harmony export */   "disableText": function() { return /* binding */ disableText; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/appendChild */ "./src/online_annotate/render/appendChild.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/online_annotate/UI/utils.js");




let _enabled = false;
let input;

/**
 * Handle document.mouseup event
 *
 * @param {Event} e The DOM event to handle
 */
function handleDocumentMouseup(e) {
  if (input || !(0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(e.clientX, e.clientY)) {
    return;
  }
  if (!e.srcElement.classList.contains('onlineAnnotationLayer')) {
    return;
  }
  input = document.createElement('textarea');
  input.setAttribute('id', 'pdf-annotate-text-input');
  input.setAttribute('placeholder', 'Enter text... SHIFT + ENTER for new line');
  input.style.border = `3px solid ${_utils__WEBPACK_IMPORTED_MODULE_2__.BORDER_COLOR}`;
  input.style.borderRadius = '3px';
  input.style.position = 'absolute';
  input.style.top = `${e.clientY}px`;
  input.style.left = `${e.clientX}px`;
  input.style.fontSize = `${window.currentAnnoteSize}px`;
  input.style.zIndex = '41';
  input.addEventListener('blur', handleInputBlur);
  input.addEventListener('keyup', handleInputKeyup);

  document.body.appendChild(input);
  input.focus();
}

/**
 * Handle input.blur event
 */
function handleInputBlur() {
  saveText();
}

/**
 * Handle input.keyup event
 *
 * @param {Event} e The DOM event to handle
 */
function handleInputKeyup(e) {
  if (e.keyCode === 27) {
    closeInput();
  }
  else if (e.keyCode === 13 && !e.shiftKey) {
    saveText();
  }
}

/**
 * Save a text annotation from input
 */
function saveText() {
  let value = (input.value) ? input.value.replace(/ +$/, '') : '';
  if (value.length > 0) {
    let clientX = parseInt(input.style.left, 10);
    let clientY = parseInt(input.style.top, 10);
    let svg = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findSVGAtPoint)(clientX, clientY);
    if (!svg) {
      return;
    }
    let height = window.currentAnnoteSize;
    let { documentId, pageNumber, viewport } = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getMetadata)(svg);
    let scale = 1 / viewport.scale;
    let rect = svg.getBoundingClientRect();
    let pt = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.convertToSvgPoint)([
      clientX - rect.left,
      clientY - rect.top + height], svg, viewport);
    let annotation = {
      type: 'textbox',
      size: window.currentAnnoteSize * scale,
      color: window.currentAnnoteColor,
      content: value,
      x: pt[0],
      y: pt[1],
      rotation: -viewport.rotation
    };
    _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().addAnnotation(documentId, pageNumber, annotation)
      .then((annotation) => {
        (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_1__.appendChild)(svg, annotation);
      });
  }

  closeInput();
}

/**
 * Close the input
 */
function closeInput() {
  if (input) {
    input.removeEventListener('blur', handleInputBlur);
    input.removeEventListener('keyup', handleInputKeyup);
    document.body.removeChild(input);
    input = null;
  }
}

/**
 * Set the text attributes
 *
 * @param {Number} textSize The size of the text
 * @param {String} textColor The color of the text
 */
function setText(textSize = 12, textColor = '000000') {
  // window.currentAnnoteSize = parseInt(textSize, 10);
  // window.currentAnnoteColor = textColor;
}

/**
 * Enable text behavior
 */
function enableText() {
  if (_enabled) {
    return;
  }
  (0,_utils__WEBPACK_IMPORTED_MODULE_2__.disableTextPointerEvent)();
  _enabled = true;
  document.addEventListener('mouseup', handleDocumentMouseup);
}

/**
 * Disable text behavior
 */
function disableText() {
  if (!_enabled) { return; }
  (0,_utils__WEBPACK_IMPORTED_MODULE_2__.enableTextPointerEvent)();
  _enabled = false;
  document.removeEventListener('mouseup', handleDocumentMouseup);
}



/***/ }),

/***/ "./src/online_annotate/UI/utils.js":
/*!*****************************************!*\
  !*** ./src/online_annotate/UI/utils.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BORDER_COLOR": function() { return /* binding */ BORDER_COLOR; },
/* harmony export */   "findSVGContainer": function() { return /* binding */ findSVGContainer; },
/* harmony export */   "hasButton": function() { return /* binding */ hasButton; },
/* harmony export */   "findSVGAtPoint": function() { return /* binding */ findSVGAtPoint; },
/* harmony export */   "findAnnotationAtPoint": function() { return /* binding */ findAnnotationAtPoint; },
/* harmony export */   "pointIntersectsRect": function() { return /* binding */ pointIntersectsRect; },
/* harmony export */   "getOffsetAnnotationRect": function() { return /* binding */ getOffsetAnnotationRect; },
/* harmony export */   "scaleUp": function() { return /* binding */ scaleUp; },
/* harmony export */   "convertToSvgRect": function() { return /* binding */ convertToSvgRect; },
/* harmony export */   "convertToSvgPoint": function() { return /* binding */ convertToSvgPoint; },
/* harmony export */   "convertToScreenPoint": function() { return /* binding */ convertToScreenPoint; },
/* harmony export */   "scaleDown": function() { return /* binding */ scaleDown; },
/* harmony export */   "getScroll": function() { return /* binding */ getScroll; },
/* harmony export */   "getOffset": function() { return /* binding */ getOffset; },
/* harmony export */   "disableUserSelect": function() { return /* binding */ disableUserSelect; },
/* harmony export */   "enableUserSelect": function() { return /* binding */ enableUserSelect; },
/* harmony export */   "disableTextPointerEvent": function() { return /* binding */ disableTextPointerEvent; },
/* harmony export */   "enableTextPointerEvent": function() { return /* binding */ enableTextPointerEvent; },
/* harmony export */   "getMetadata": function() { return /* binding */ getMetadata; }
/* harmony export */ });
/* harmony import */ var _render_appendChild__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/appendChild */ "./src/online_annotate/render/appendChild.js");
/* harmony import */ var _utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mathUtils */ "./src/online_annotate/utils/mathUtils.js");



const BORDER_COLOR = '#00BFFF';

const userSelectStyleSheet = document.createElement('style');
userSelectStyleSheet.innerHTML = `
body {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
`;

userSelectStyleSheet.setAttribute('data-pdf-annotate-user-select', 'true');

const disaplePointStyleSheet = document.createElement('style');
disaplePointStyleSheet.innerHTML = `
.textLayer {
  pointer-events:none;
}
`;

disaplePointStyleSheet.setAttribute('data-pdf-annotate-pointer', 'true');

/**
 * Find the SVGElement that contains all the annotations for a page
 *
 * @param {Element} node An annotation within that container
 * @return {SVGElement} The container SVG or null if it can't be found
 */
function findSVGContainer(node) {
  let parentNode = node;

  while ((parentNode = parentNode.parentNode) &&
          parentNode !== document) {
    if (parentNode.nodeName.toUpperCase() === 'SVG' &&
        parentNode.getAttribute('data-pdf-annotate-container') === 'true') {
      return parentNode;
    }
  }

  return null;
}

function hasButton(evt){
  const path = evt.path;
  for(let i=0;i<path.length;i++){
    if(path[i].tagName=='BUTTON')
    return true;
  }
  return false;
}

/**
 * Find an SVGElement container at a given point
 *
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 * @return {SVGElement} The container SVG or null if one can't be found
 */
function findSVGAtPoint(x, y) {
  let elements = document.querySelectorAll('svg[data-pdf-annotate-container="true"]');

  for (let i = 0, l = elements.length; i < l; i++) {
    let el = elements[i];
    let rect = el.getBoundingClientRect();
    if (pointIntersectsRect(x, y, rect)) {
      return el;
    }
  }

  return null;
}

/**
 * Find an Element that represents an annotation at a given point.
 *
 * IMPORTANT: Requires the annotation layer to be the top most element so
 *            either use z-ordering or make it the leaf container.
 *
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 * @return {Element} The annotation element or null if one can't be found
 */
function findAnnotationAtPoint(x, y) {
  let candidates = document.elementsFromPoint(x, y);
  for(let candidate of candidates){
    while (candidate && candidate !== document) {
      let type = candidate.getAttribute('data-pdf-annotate-type');
      if (type) {
        return candidate;
      }
      candidate = candidate.parentNode;
    }
  }
  return null;
}

/**
 * Determine if a point intersects a rect
 *
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 * @param {Object} rect The points of a rect (likely from getBoundingClientRect)
 * @return {Boolean} True if a collision occurs, otherwise false
 */
function pointIntersectsRect(x, y, rect) {
  return y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
}

/**
 * Get the rect of an annotation element accounting for offset.
 *
 * @param {Element} el The element to get the rect of
 * @return {Object} The dimensions of the element
 */
function getOffsetAnnotationRect(el) {
  let rect = el.getBoundingClientRect();
  let { width, height } = rect;
  let extraOffsetWidth = 0;
  let extraOffsetHeight = 0;
  if (['line', 'path'].indexOf(el.tagName.toLowerCase()) > -1 && el.getBBox) {
    let bbox = el.getBBox();
    extraOffsetWidth = (rect.width - bbox.width) / 2;
    extraOffsetHeight = (rect.height - bbox.height) / 2;
    width = bbox.width;
    height = bbox.height;
  }
  let { offsetLeft, offsetTop } = getOffset(el);
  return {
    top: rect.top - offsetTop + extraOffsetHeight,
    left: rect.left - offsetLeft + extraOffsetWidth,
    bottom: rect.bottom - offsetTop - extraOffsetHeight,
    right: rect.right - offsetLeft - extraOffsetWidth,
    width: width,
    height: height
  };
}

/**
 * Adjust scale from normalized scale (100%) to rendered scale.
 *
 * @param {SVGElement} svg The SVG to gather metadata from
 * @param {Object} rect A map of numeric values to scale
 * @return {Object} A copy of `rect` with values scaled up
 */
function scaleUp(svg, rect) {
  let result = {};
  let { viewport } = getMetadata(svg);

  Object.keys(rect).forEach((key) => {
    result[key] = rect[key] * viewport.scale;
  });

  return result;
}

function convertToSvgRect(rect, svg, viewport) {
  let pt1 = [rect.x, rect.y];
  let pt2 = [rect.x + rect.width, rect.y + rect.height];

  pt1 = convertToSvgPoint(pt1, svg, viewport);
  pt2 = convertToSvgPoint(pt2, svg, viewport);

  return {
    x: Math.min(pt1[0], pt2[0]),
    y: Math.min(pt1[1], pt2[1]),
    width: Math.abs(pt2[0] - pt1[0]),
    height: Math.abs(pt2[1] - pt1[1])
  };
}

function convertToSvgPoint(pt, svg, viewport) {
  viewport = viewport || getMetadata(svg).viewport;

  let xform = [ 1, 0, 0, 1, 0, 0 ];
  xform = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.scale)(xform, viewport.scale, viewport.scale);
  xform = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.rotate)(xform, viewport.rotation);

  let offset = (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_0__.getTranslation)(viewport);
  xform = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.translate)(xform, offset.x, offset.y);

  return (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.applyInverseTransform)(pt, xform);
}

function convertToScreenPoint(pt, svg, viewport) {
  viewport = viewport || getMetadata(svg).viewport;

  let xform = [ 1, 0, 0, 1, 0, 0 ];
  xform = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.scale)(xform, viewport.scale, viewport.scale);
  xform = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.rotate)(xform, viewport.rotation);

  let offset = (0,_render_appendChild__WEBPACK_IMPORTED_MODULE_0__.getTranslation)(viewport);
  xform = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.translate)(xform, offset.x, offset.y);

  return (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_1__.applyTransform)(pt, xform);
}

/**
 * Adjust scale from rendered scale to a normalized scale (100%).
 *
 * @param {SVGElement} svg The SVG to gather metadata from
 * @param {Object} rect A map of numeric values to scale
 * @return {Object} A copy of `rect` with values scaled down
 */
function scaleDown(svg, rect) {
  let result = {};
  let { viewport } = getMetadata(svg);

  Object.keys(rect).forEach((key) => {
    result[key] = rect[key] / viewport.scale;
  });

  return result;
}

/**
 * Get the scroll position of an element, accounting for parent elements
 *
 * @param {Element} el The element to get the scroll position for
 * @return {Object} The scrollTop and scrollLeft position
 */
function getScroll(el) {
  let scrollTop = 0;
  let scrollLeft = 0;
  let parentNode = el;

  while ((parentNode = parentNode.parentNode) &&
          parentNode !== document) {
    scrollTop += parentNode.scrollTop;
    scrollLeft += parentNode.scrollLeft;
  }

  return { scrollTop, scrollLeft };
}

/**
 * Get the offset position of an element, accounting for parent elements
 *
 * @param {Element} el The element to get the offset position for
 * @return {Object} The offsetTop and offsetLeft position
 */
function getOffset(el) {
  let parentNode = el;

  while ((parentNode = parentNode.parentNode) &&
          parentNode !== document) {
    if (parentNode.nodeName.toUpperCase() === 'SVG') {
      break;
    }
  }

  let rect = parentNode.getBoundingClientRect();

  return { offsetLeft: rect.left, offsetTop: rect.top };
}

/**
 * Disable user ability to select text on page
 */
function disableUserSelect() {
  if (!userSelectStyleSheet.parentNode) {
    document.head.appendChild(userSelectStyleSheet);
  }
}

/**
 * Enable user ability to select text on page
 */
function enableUserSelect() {
  if (userSelectStyleSheet.parentNode) {
    userSelectStyleSheet.parentNode.removeChild(userSelectStyleSheet);
  }
}

/**
 * Disable user ability to select text on page
 */
 function disableTextPointerEvent() {
  if (!disaplePointStyleSheet.parentNode) {
    document.head.appendChild(disaplePointStyleSheet);
  }
}

/**
 * Enable user ability to select text on page
 */
function enableTextPointerEvent() {
  if (disaplePointStyleSheet.parentNode) {
    disaplePointStyleSheet.parentNode.removeChild(disaplePointStyleSheet);
  }
}

/**
 * Get the metadata for a SVG container
 *
 * @param {SVGElement} svg The SVG container to get metadata for
 */
function getMetadata(svg) {
  return {
    documentId: svg.getAttribute('data-pdf-annotate-document'),
    pageNumber: parseInt(svg.getAttribute('data-pdf-annotate-page'), 10),
    viewport: JSON.parse(svg.getAttribute('data-pdf-annotate-viewport'))
  };
}


/***/ }),

/***/ "./src/online_annotate/a11y/createScreenReaderOnly.js":
/*!************************************************************!*\
  !*** ./src/online_annotate/a11y/createScreenReaderOnly.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ createScreenReaderOnly; }
/* harmony export */ });
/**
 * Create a node that is only visible to screen readers
 *
 * @param {String} content The text content that should be read by screen reader
 * @param {String} [annotationId] The ID of the annotation assocaited
 * @return {Element} An Element that is only visible to screen readers
 */
function createScreenReaderOnly(content, annotationId) {
  let node = document.createElement('div');
  let text = document.createTextNode(content);
  node.appendChild(text);
  node.setAttribute('id', `pdf-annotate-screenreader-${annotationId}`);
  node.style.position = 'absolute';
  node.style.left = '-10000px';
  node.style.top = 'auto';
  node.style.width = '1px';
  node.style.height = '1px';
  node.style.overflow = 'hidden';
  return node;
}


/***/ }),

/***/ "./src/online_annotate/a11y/initEventHandlers.js":
/*!*******************************************************!*\
  !*** ./src/online_annotate/a11y/initEventHandlers.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ initEventHandlers; }
/* harmony export */ });
/* harmony import */ var _renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderScreenReaderHints */ "./src/online_annotate/a11y/renderScreenReaderHints.js");
/* harmony import */ var _insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertScreenReaderComment */ "./src/online_annotate/a11y/insertScreenReaderComment.js");
/* harmony import */ var _renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderScreenReaderComments */ "./src/online_annotate/a11y/renderScreenReaderComments.js");
/* harmony import */ var _UI_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../UI/event */ "./src/online_annotate/UI/event.js");
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");






/**
 * Initialize the event handlers for keeping screen reader hints synced with data
 */
function initEventHandlers() {
  (0,_UI_event__WEBPACK_IMPORTED_MODULE_3__.addEventListener)('annotation:add', (documentId, pageNumber, annotation) => {
    reorderAnnotationsByType(documentId, pageNumber, annotation.type);
  });
  (0,_UI_event__WEBPACK_IMPORTED_MODULE_3__.addEventListener)('annotation:edit', (documentId, annotationId, annotation) => {
    reorderAnnotationsByType(documentId, annotation.page, annotation.type);
  });
  (0,_UI_event__WEBPACK_IMPORTED_MODULE_3__.addEventListener)('annotation:delete', removeAnnotation);
  (0,_UI_event__WEBPACK_IMPORTED_MODULE_3__.addEventListener)('comment:add', insertComment);
  (0,_UI_event__WEBPACK_IMPORTED_MODULE_3__.addEventListener)('comment:delete', removeComment);
}

/**
 * Reorder the annotation numbers by annotation type
 *
 * @param {String} documentId The ID of the document
 * @param {Number} pageNumber The page number of the annotations
 * @param {Strig} type The annotation type
 */
function reorderAnnotationsByType(documentId, pageNumber, type) {
  _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_4__["default"].getStoreAdapter().getAnnotations(documentId, pageNumber)
    .then((annotations) => {
      return annotations.annotations.filter((a) => {
        return a.type === type;
      });
    })
    .then((annotations) => {
      annotations.forEach((a) => {
        removeAnnotation(documentId, a.uuid);
      });

      return annotations;
    })
    .then(_renderScreenReaderHints__WEBPACK_IMPORTED_MODULE_0__["default"]);
}

/**
 * Remove the screen reader hint for an annotation
 *
 * @param {String} documentId The ID of the document
 * @param {String} annotationId The Id of the annotation
 */
function removeAnnotation(documentId, annotationId) {
  removeElementById(`pdf-annotate-screenreader-${annotationId}`);
  removeElementById(`pdf-annotate-screenreader-${annotationId}-end`);
}

/**
 * Insert a screen reader hint for a comment
 *
 * @param {String} documentId The ID of the document
 * @param {String} annotationId The ID of tha assocated annotation
 * @param {Object} comment The comment to insert a hint for
 */
function insertComment(documentId, annotationId, comment) {
  let list = document.querySelector(`pdf-annotate-screenreader-comment-list-${annotationId}`);
  let promise;

  if (!list) {
    promise = (0,_renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_2__["default"])(documentId, annotationId, []).then(() => {
      list = document.querySelector(`pdf-annotate-screenreader-comment-list-${annotationId}`);
      return true;
    });
  }
  else {
    promise = Promise.resolve(true);
  }

  promise.then(() => {
    (0,_insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__["default"])(comment);
  });
}

/**
 * Remove a screen reader hint for a comment
 *
 * @param {String} documentId The ID of the document
 * @param {String} commentId The ID of the comment
 */
function removeComment(documentId, commentId) {
  removeElementById(`pdf-annotate-screenreader-comment-${commentId}`);
}

/**
 * Remove an element from the DOM by it's ID if it exists
 *
 * @param {String} elementId The ID of the element to be removed
 */
function removeElementById(elementId) {
  let el = document.getElementById(elementId);
  if (el) {
    el.parentNode.removeChild(el);
  }
}


/***/ }),

/***/ "./src/online_annotate/a11y/insertElementWithinChildren.js":
/*!*****************************************************************!*\
  !*** ./src/online_annotate/a11y/insertElementWithinChildren.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ insertElementWithinChildren; }
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ "./src/online_annotate/config.js");
/* harmony import */ var _insertElementWithinElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertElementWithinElement */ "./src/online_annotate/a11y/insertElementWithinElement.js");
/* harmony import */ var _UI_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../UI/utils */ "./src/online_annotate/UI/utils.js");




/**
 * Insert an element at a point within the document.
 * This algorithm will try to insert between elements if possible.
 * It will however use `insertElementWithinElement` if it is more accurate.
 *
 * @param {Element} el The element to be inserted
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 * @param {Number} pageNumber The page number to limit elements to
 * @return {Boolean} True if element was able to be inserted, otherwise false
 */
function insertElementWithinChildren(el, x, y, pageNumber) {
  // Try and use most accurate method of inserting within an element
  if ((0,_insertElementWithinElement__WEBPACK_IMPORTED_MODULE_1__["default"])(el, x, y, pageNumber, true)) {
    return true;
  }

  // Fall back to inserting between elements
  let svg = document.querySelector(`svg[data-pdf-annotate-page="${pageNumber}"]`);
  let rect = svg.getBoundingClientRect();
  let nodes = [...svg.parentNode.querySelectorAll(_config__WEBPACK_IMPORTED_MODULE_0__["default"].textClassQuery() + ' > div')];

  y = (0,_UI_utils__WEBPACK_IMPORTED_MODULE_2__.scaleUp)(svg, {y}).y + rect.top;
  x = (0,_UI_utils__WEBPACK_IMPORTED_MODULE_2__.scaleUp)(svg, {x}).x + rect.left;

  // Find the best node to insert before
  for (let i = 0, l = nodes.length; i < l; i++) {
    let n = nodes[i];
    let r = n.getBoundingClientRect();
    if (y <= r.top) {
      n.parentNode.insertBefore(el, n);
      return true;
    }
  }

  // If all else fails try to append to the bottom
  let textLayer = svg.parentNode.querySelector(_config__WEBPACK_IMPORTED_MODULE_0__["default"].textClassQuery());
  if (textLayer) {
    let textRect = textLayer.getBoundingClientRect();
    if ((0,_UI_utils__WEBPACK_IMPORTED_MODULE_2__.pointIntersectsRect)(x, y, textRect)) {
      textLayer.appendChild(el);
      return true;
    }
  }

  return false;
}


/***/ }),

/***/ "./src/online_annotate/a11y/insertElementWithinElement.js":
/*!****************************************************************!*\
  !*** ./src/online_annotate/a11y/insertElementWithinElement.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ insertElementWithinElement; }
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ "./src/online_annotate/config.js");
/* harmony import */ var _UI_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/utils */ "./src/online_annotate/UI/utils.js");



/**
 * Insert an element at a point within the document.
 * This algorithm will only insert within an element amidst it's text content.
 *
 * @param {Element} el The element to be inserted
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 * @param {Number} pageNumber The page number to limit elements to
 * @param {Boolean} insertBefore Whether the element is to be inserted before or after x
 * @return {Boolean} True if element was able to be inserted, otherwise false
 */
function insertElementWithinElement(el, x, y, pageNumber, insertBefore) {
  const OFFSET_ADJUST = 2;

  // If inserting before adjust `x` by looking for element a few px to the right
  // Otherwise adjust a few px to the left
  // This is to allow a little tolerance by searching within the box, instead
  // of getting a false negative by testing right on the border.
  x = Math.max(x + (OFFSET_ADJUST * (insertBefore ? 1 : -1)), 0);

  let node = textLayerElementFromPoint(x, y + OFFSET_ADJUST, pageNumber);
  if (!node) {
    return false;
  }

  // Now that node has been found inverse the adjustment for `x`.
  // This is done to accomodate tolerance by cutting off on the outside of the
  // text boundary, instead of missing a character by cutting off within.
  x = x + (OFFSET_ADJUST * (insertBefore ? -1 : 1));

  let svg = document.querySelector(`svg[data-pdf-annotate-page="${pageNumber}"]`);
  let left = (0,_UI_utils__WEBPACK_IMPORTED_MODULE_1__.scaleDown)(svg, {left: node.getBoundingClientRect().left}).left - svg.getBoundingClientRect().left;
  let temp = node.cloneNode(true);
  let head = temp.innerHTML.split('');
  let tail = [];

  // Insert temp off screen
  temp.style.position = 'absolute';
  temp.style.top = '-10000px';
  temp.style.left = '-10000px';
  document.body.appendChild(temp);

  while (head.length) {
    // Don't insert within HTML tags
    if (head[head.length - 1] === '>') {
      while (head.length) {
        tail.unshift(head.pop());
        if (tail[0] === '<') {
          break;
        }
      }
    }

    // Check if width of temp based on current head value satisfies x
    temp.innerHTML = head.join('');
    let width = (0,_UI_utils__WEBPACK_IMPORTED_MODULE_1__.scaleDown)(svg, {width: temp.getBoundingClientRect().width}).width;
    if (left + width <= x) {
      break;
    }
    tail.unshift(head.pop());
  }

  // Update original node with new markup, including element to be inserted
  node.innerHTML = head.join('') + el.outerHTML + tail.join('');
  temp.parentNode.removeChild(temp);

  return true;
}

/**
 * Get a text layer element at a given point on a page
 *
 * @param {Number} x The x coordinate of the point
 * @param {Number} y The y coordinate of the point
 * @param {Number} pageNumber The page to limit elements to
 * @return {Element} First text layer element found at the point
 */
function textLayerElementFromPoint(x, y, pageNumber) {
  let svg = document.querySelector(`svg[data-pdf-annotate-page="${pageNumber}"]`);
  let rect = svg.getBoundingClientRect();
  y = (0,_UI_utils__WEBPACK_IMPORTED_MODULE_1__.scaleUp)(svg, {y}).y + rect.top;
  x = (0,_UI_utils__WEBPACK_IMPORTED_MODULE_1__.scaleUp)(svg, {x}).x + rect.left;
  return [...svg.parentNode.querySelectorAll(_config__WEBPACK_IMPORTED_MODULE_0__["default"].textClassQuery() + ' [data-canvas-width]')].filter((el) => {
    return (0,_UI_utils__WEBPACK_IMPORTED_MODULE_1__.pointIntersectsRect)(x, y, el.getBoundingClientRect());
  })[0];
}


/***/ }),

/***/ "./src/online_annotate/a11y/insertScreenReaderComment.js":
/*!***************************************************************!*\
  !*** ./src/online_annotate/a11y/insertScreenReaderComment.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ insertScreenReaderComment; }
/* harmony export */ });
/**
 * Insert a comment into the DOM to be available by screen reader
 *
 * @param {Object} comment The comment to be inserted
 */
function insertScreenReaderComment(comment) {
  if (!comment) {
    return;
  }

  let list = document.querySelector(`#pdf-annotate-screenreader-${comment.annotation} ol`);
  if (list) {
    let item = document.createElement('li');
    item.setAttribute('id', `pdf-annotate-screenreader-comment-${comment.uuid}`);
    item.appendChild(document.createTextNode(`${comment.content}`));
    list.appendChild(item);
  }
}


/***/ }),

/***/ "./src/online_annotate/a11y/insertScreenReaderHint.js":
/*!************************************************************!*\
  !*** ./src/online_annotate/a11y/insertScreenReaderHint.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ insertScreenReaderHint; }
/* harmony export */ });
/* harmony import */ var _createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createScreenReaderOnly */ "./src/online_annotate/a11y/createScreenReaderOnly.js");
/* harmony import */ var _insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertElementWithinChildren */ "./src/online_annotate/a11y/insertElementWithinChildren.js");
/* harmony import */ var _insertElementWithinElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./insertElementWithinElement */ "./src/online_annotate/a11y/insertElementWithinElement.js");
/* harmony import */ var _renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderScreenReaderComments */ "./src/online_annotate/a11y/renderScreenReaderComments.js");





// Annotation types that support comments
const COMMENT_TYPES = ['highlight', 'point', 'area', 'circle', 'emptycircle', 'fillcircle'];

/**
 * Insert a hint into the DOM for screen readers for a specific annotation.
 *
 * @param {Object} annotation The annotation to insert a hint for
 * @param {Number} num The number of the annotation out of all annotations of the same type
 */
function insertScreenReaderHint(annotation, num = 0) {
  switch (annotation.type) {
    case 'highlight':
    case 'strikeout':
    case 'underline':
      let rects = annotation.rectangles;
      let first = rects[0];
      let last = rects[rects.length - 1];

      (0,_insertElementWithinElement__WEBPACK_IMPORTED_MODULE_2__["default"])(
        (0,_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__["default"])(`Begin ${annotation.type} annotation ${num}`, annotation.uuid),
        first.x, first.y, annotation.page, true
      );

      (0,_insertElementWithinElement__WEBPACK_IMPORTED_MODULE_2__["default"])(
        (0,_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__["default"])(`End ${annotation.type} annotation ${num}`, `${annotation.uuid}-end`),
        last.x + last.width, last.y, annotation.page, false
      );
      break;

    case 'textbox':
    case 'point':
      let text = annotation.type === 'textbox' ? ` (content: ${annotation.content})` : '';

      (0,_insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__["default"])(
        (0,_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__["default"])(`${annotation.type} annotation ${num}${text}`, annotation.uuid),
        annotation.x, annotation.y, annotation.page
      );
      break;

    case 'drawing':
    case 'area':
      let x = typeof annotation.x !== 'undefined' ? annotation.x : annotation.lines[0][0];
      let y = typeof annotation.y !== 'undefined' ? annotation.y : annotation.lines[0][1];

      (0,_insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__["default"])(
        (0,_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__["default"])(`Unlabeled drawing`, annotation.uuid),
        x, y, annotation.page
      );
      break;

    case 'circle':
    case 'fillcircle':
    case 'emptycircle':
      let x2 = typeof annotation.cx !== 'undefined' ? annotation.cx : annotation.lines[0][0];
      let y2 = typeof annotation.cy !== 'undefined' ? annotation.cy : annotation.lines[0][1];

      (0,_insertElementWithinChildren__WEBPACK_IMPORTED_MODULE_1__["default"])(
        (0,_createScreenReaderOnly__WEBPACK_IMPORTED_MODULE_0__["default"])(`Unlabeled drawing`, annotation.uuid),
        x2, y2, annotation.page
      );
      break;
  }

  // Include comments in screen reader hint
  if (COMMENT_TYPES.includes(annotation.type)) {
    (0,_renderScreenReaderComments__WEBPACK_IMPORTED_MODULE_3__["default"])(annotation.documentId, annotation.uuid);
  }
}


/***/ }),

/***/ "./src/online_annotate/a11y/renderScreenReaderComments.js":
/*!****************************************************************!*\
  !*** ./src/online_annotate/a11y/renderScreenReaderComments.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderScreenReaderComments; }
/* harmony export */ });
/* harmony import */ var _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDFJSAnnotate */ "./src/online_annotate/PDFJSAnnotate.js");
/* harmony import */ var _insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./insertScreenReaderComment */ "./src/online_annotate/a11y/insertScreenReaderComment.js");



/**
 * Insert the comments into the DOM to be available by screen reader
 *
 * Example output:
 *   <div class="screenReaderOnly">
 *    <div>Begin highlight 1</div>
 *    <ol aria-label="Comments">
 *      <li>Foo</li>
 *      <li>Bar</li>
 *      <li>Baz</li>
 *      <li>Qux</li>
 *    </ol>
 *  </div>
 *  <div>Some highlighted text goes here...</div>
 *  <div class="screenReaderOnly">End highlight 1</div>
 *
 * NOTE: `screenReaderOnly` is not a real class, just used for brevity
 *
 * @param {String} documentId The ID of the document
 * @param {String} annotationId The ID of the annotation
 * @param {Array} [comments] Optionally preloaded comments to be rendered
 * @return {Promise} Promise that once has comments, render them for screen reader
 */
function renderScreenReaderComments(documentId, annotationId, comments) {
  let promise;

  if (Array.isArray(comments)) {
    promise = Promise.resolve(comments);
  }
  else {
    promise = _PDFJSAnnotate__WEBPACK_IMPORTED_MODULE_0__["default"].getStoreAdapter().getComments(documentId, annotationId);
  }

  return promise.then((comments) => {
    // Node needs to be found by querying DOM as it may have been inserted as innerHTML
    // leaving `screenReaderNode` as an invalid reference (see `insertElementWithinElement`).
    let node = document.getElementById(`pdf-annotate-screenreader-${annotationId}`);
    if (node) {
      let list = document.createElement('ol');
      list.setAttribute('id', `pdf-annotate-screenreader-comment-list-${annotationId}`);
      list.setAttribute('aria-label', 'Comments');
      node.appendChild(list);
      comments.forEach(_insertScreenReaderComment__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
  });
}


/***/ }),

/***/ "./src/online_annotate/a11y/renderScreenReaderHints.js":
/*!*************************************************************!*\
  !*** ./src/online_annotate/a11y/renderScreenReaderHints.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderScreenReaderHints; }
/* harmony export */ });
/* harmony import */ var _insertScreenReaderHint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./insertScreenReaderHint */ "./src/online_annotate/a11y/insertScreenReaderHint.js");
/* harmony import */ var _initEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./initEventHandlers */ "./src/online_annotate/a11y/initEventHandlers.js");



// TODO This is not the right place for this to live
(0,_initEventHandlers__WEBPACK_IMPORTED_MODULE_1__["default"])();

/**
 * Insert hints into the DOM for screen readers.
 *
 * @param {Array} annotations The annotations that hints are inserted for
 */
function renderScreenReaderHints(annotations) {
  annotations = Array.isArray(annotations) ? annotations : [];

  // Insert hints for each type
  Object.keys(SORT_TYPES).forEach((type) => {
    let sortBy = SORT_TYPES[type];
    annotations
      .filter((a) => a.type === type)
      .sort(sortBy)
      .forEach((a, i) => (0,_insertScreenReaderHint__WEBPACK_IMPORTED_MODULE_0__["default"])(a, i + 1));
  });
}

// Sort annotations first by y, then by x.
// This allows hints to be injected in the order they appear,
// which makes numbering them easier.
function sortByPoint(a, b) {
  if (a.y < b.y) {
    return a.x - b.x;
  }
  else {
    return 1;
  }
}

// Sort annotation by it's first rectangle
function sortByRectPoint(a, b) {
  return sortByPoint(a.rectangles[0], b.rectangles[0]);
}

// Sort annotation by it's first line
function sortByLinePoint(a, b) {
  let lineA = a.lines[0];
  let lineB = b.lines[0];
  return sortByPoint(
    {x: lineA[0], y: lineA[1]},
    {x: lineB[0], y: lineB[1]}
  );
}

// Arrange supported types and associated sort methods
const SORT_TYPES = {
  'highlight': sortByRectPoint,
  'strikeout': sortByRectPoint,
  'underline': sortByRectPoint,
  'drawing': sortByLinePoint,
  'textbox': sortByPoint,
  'point': sortByPoint,
  'area': sortByPoint
};



/***/ }),

/***/ "./src/online_annotate/adapter/LocalStoreAdapter.js":
/*!**********************************************************!*\
  !*** ./src/online_annotate/adapter/LocalStoreAdapter.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LocalStoreAdapter; }
/* harmony export */ });
/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/uuid */ "./src/online_annotate/utils/uuid.js");
/* harmony import */ var _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StoreAdapter */ "./src/online_annotate/adapter/StoreAdapter.js");



// StoreAdapter for working with localStorage
// This is ideal for testing, examples, and prototyping
class LocalStoreAdapter extends _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super({
      getAnnotations(documentId, pageNumber) {
        return new Promise((resolve, reject) => {
          let annotations = getAnnotations(documentId).filter((i) => {
            return i.page === pageNumber && i.class === 'Annotation';
          });

          resolve({
            documentId,
            pageNumber,
            annotations
          });
        });
      }
    });

    this.getAnnotation = (documentId, annotationId) => {
      return Promise.resolve(getAnnotations(documentId)[findAnnotation(documentId, annotationId)]);
    };

    this.addAnnotation = (documentId, pageNumber, annotation) => {
      //console.error('aa');
      return new Promise((resolve, reject) => {
        annotation.class = 'Annotation';
        annotation.uuid = (0,_utils_uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
        annotation.page = pageNumber;

        let annotations = getAnnotations(documentId);
        annotations.push(annotation);
        updateAnnotations(documentId, annotations);

        resolve(annotation);
      });
    };

    this.editAnnotation = (documentId, annotationId, annotation) => {
      return new Promise((resolve, reject) => {
        let annotations = getAnnotations(documentId);
        annotations[findAnnotation(documentId, annotationId)] = annotation;
        updateAnnotations(documentId, annotations);
        resolve(annotation);
      });
    };

    this.deleteAnnotation = (documentId, annotationId) => {
      return new Promise((resolve, reject) => {
        let annotation = getAnnotations(documentId).filter(i => i.uuid === annotationId)[0] || {};
        if (!annotation) {
          return reject('Could not find annotation');
        }
        let index = findAnnotation(documentId, annotationId);
        if (index > -1) {
          let annotations = getAnnotations(documentId);
          annotations.splice(index, 1);
          updateAnnotations(documentId, annotations);
        }

        resolve(true);
      });
    };

    this.getComments = (documentId, annotationId) => {
      return new Promise((resolve, reject) => {
        resolve(getAnnotations(documentId).filter((i) => {
          return i.class === 'Comment' && i.annotation === annotationId;
        }));
      });
    };

    this.addComment = (documentId, annotationId, content) => {
      return new Promise((resolve, reject) => {
        let comment = {
          class: 'Comment',
          uuid: (0,_utils_uuid__WEBPACK_IMPORTED_MODULE_0__["default"])(),
          annotation: annotationId,
          content: content
        };

        let annotations = getAnnotations(documentId);
        annotations.push(comment);
        updateAnnotations(documentId, annotations);

        resolve(comment);
      });
    };

    this.deleteComment = (documentId, commentId) => {
      return new Promise((resolve, reject) => {
        let comment = getAnnotations(documentId).filter(i => i.uuid === commentId)[0] || {};
        if (!comment) {
          return reject('Could not find annotation');
        }
        let index = -1;
        let annotations = getAnnotations(documentId);
        for (let i = 0, l = annotations.length; i < l; i++) {
          if (annotations[i].uuid === commentId) {
            index = i;
            break;
          }
        }

        if (index > -1) {
          annotations.splice(index, 1);
          updateAnnotations(documentId, annotations);
        }

        resolve(true);
      });
    };
  }
}

function getAnnotations(documentId) {
  return JSON.parse(localStorage.getItem(`${documentId}/annotations`)) || [];
}

function updateAnnotations(documentId, annotations) {
  localStorage.setItem(`${documentId}/annotations`, JSON.stringify(annotations));
}
/**
 *
 * @param {String} documentId Document id of the annotation
 * @param {String} annotationId The id of the annotation
 *
 * This function finds all the annotation made by one user.
 *
 * @return {int} The index of the annotation in localstorage
 */
function findAnnotation(documentId, annotationId) {
  let index = -1;
  let annotations = getAnnotations(documentId);
  for (let i = 0, l = annotations.length; i < l; i++) {
    if (annotations[i].uuid === annotationId) {
      index = i;
      break;
    }
  }
  return index;
}


/***/ }),

/***/ "./src/online_annotate/adapter/LocalUserStoreAdapter.js":
/*!**************************************************************!*\
  !*** ./src/online_annotate/adapter/LocalUserStoreAdapter.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LocalUserStoreAdapter; }
/* harmony export */ });
/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/uuid */ "./src/online_annotate/utils/uuid.js");
/* harmony import */ var _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StoreAdapter */ "./src/online_annotate/adapter/StoreAdapter.js");



// StoreAdapter for working with localStorage and associated user id
// This is ideal for testing, examples, and prototyping
class LocalUserStoreAdapter extends _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(userId = 'user', globalEdit = false) {
    super({
      getAnnotations(documentId, pageNumber) {
        return new Promise((resolve, reject) => {
          let annotations = getAllAnnotations(documentId).filter((i) => {
            return i.page === pageNumber && i.class === 'Annotation';
          });

          resolve({
            documentId,
            pageNumber,
            annotations
          });
        });
      }
    });

    this._userId = userId;
    this._globalEdit = globalEdit;

    this.getAnnotation = (documentId, annotationId) => {
      return Promise.resolve(getAnnotations(documentId, this._userId)[findAnnotation(documentId, this._userId, annotationId)]);
    };

    this.addAnnotation = (documentId, pageNumber, annotation) => {
      return new Promise((resolve, reject) => {
        annotation.class = 'Annotation';
        annotation.uuid = (0,_utils_uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
        annotation.page = pageNumber;
        annotation.userId = this._userId;

        let annotations = getAnnotations(documentId, this._userId);
        annotations.push(annotation);
        updateAnnotations(documentId, this._userId, annotations);

        resolve(annotation);
      });
    };

    this.editAnnotation = (documentId, annotationId, annotation) => {
      return new Promise((resolve, reject) => {
        if (!this._globalEdit && annotation.userId && annotation.userId !== this._userId) {
          reject('Non-matching userId');
        }
        let annotations = getAnnotations(documentId, annotation.userId);
        annotations[findAnnotation(documentId, annotation.userId, annotationId)] = annotation;
        updateAnnotations(documentId, annotation.userId, annotations);
        resolve(annotation);
      });
    };

    this.deleteAnnotation = (documentId, annotationId) => {
      return new Promise((resolve, reject) => {
        let annotation = getAllAnnotations(documentId).filter(i => i.uuid === annotationId)[0] || {};
        if (!annotation) {
          return reject('Could not find annotation');
        }
        else if (!this._globalEdit && annotation.userId && annotation.userId !== this._userId) {
          return reject('Non-matching userId');
        }
        let index = findAnnotation(documentId, annotation.userId, annotationId);
        if (index > -1) {
          let annotations = getAnnotations(documentId, annotation.userId);
          annotations.splice(index, 1);
          updateAnnotations(documentId, annotation.userId, annotations);
        }

        resolve(true);
      });
    };

    this.getComments = (documentId, annotationId) => {
      return new Promise((resolve, reject) => {
        resolve(getAnnotations(documentId, this._userId).filter((i) => {
          return i.class === 'Comment' && i.annotation === annotationId;
        }));
      });
    };

    this.addComment = (documentId, annotationId, content) => {
      return new Promise((resolve, reject) => {
        let comment = {
          class: 'Comment',
          uuid: (0,_utils_uuid__WEBPACK_IMPORTED_MODULE_0__["default"])(),
          annotation: annotationId,
          content: content,
          userId: this._userId
        };

        let annotations = getAnnotations(documentId, this._userId);
        annotations.push(comment);
        updateAnnotations(documentId, this._userId, annotations);

        resolve(comment);
      });
    };

    this.deleteComment = (documentId, commentId) => {
      return new Promise((resolve, reject) => {
        let comment = getAllAnnotations(documentId).filter(i => i.uuid === commentId)[0] || {};
        if (!comment) {
          return reject('Could not find annotation');
        }
        else if (!this._globalEdit && comment.userId && comment.userId !== this._userId) {
          return reject('Non-matching userId');
        }
        let index = -1;
        let annotations = getAnnotations(documentId, comment.userId);
        for (let i = 0, l = annotations.length; i < l; i++) {
          if (annotations[i].uuid === commentId) {
            index = i;
            break;
          }
        }

        if (index > -1) {
          annotations.splice(index, 1);
          updateAnnotations(documentId, comment.userId, annotations);
        }

        resolve(true);
      });
    };
  }

  get userId() {
    return this._userId;
  }
}

function getAllAnnotations(documentId) {
  let all_annotations = [];
  let re = new RegExp(`${documentId}/(.*)/annotations`);
  for (let i = 0; i < localStorage.length; i++) {
    if (localStorage.key(i).search(re) > -1) {
      all_annotations.push(...JSON.parse(localStorage.getItem(localStorage.key(i))));
    }
  }
  return all_annotations;
}

function getAnnotations(documentId, userId) {
  return JSON.parse(localStorage.getItem(`${documentId}/${userId}/annotations`)) || [];
}

function updateAnnotations(documentId, userId, annotations) {
  localStorage.setItem(`${documentId}/${userId}/annotations`, JSON.stringify(annotations));
}
/**
 *
 * @param {String} documentId Document id of the annotation
 * @param {String} userId User id of the annotation
 * @param {String} annotationId The id of the annotation
 *
 * This function finds all the annotation made by one user.
 *
 * @return {int} The index of the annotation in localstorage
 */
function findAnnotation(documentId, userId, annotationId) {
  let index = -1;
  let annotations = getAnnotations(documentId, userId);
  for (let i = 0, l = annotations.length; i < l; i++) {
    if (annotations[i].uuid === annotationId) {
      index = i;
      break;
    }
  }
  return index;
}


/***/ }),

/***/ "./src/online_annotate/adapter/SaltDogAdapter.js":
/*!*******************************************************!*\
  !*** ./src/online_annotate/adapter/SaltDogAdapter.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ SaltDogAdapter; }
/* harmony export */ });
/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/uuid */ "./src/online_annotate/utils/uuid.js");
/* harmony import */ var _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StoreAdapter */ "./src/online_annotate/adapter/StoreAdapter.js");



// StoreAdapter for working with localStorage
// This is ideal for testing, examples, and prototyping
class SaltDogAdapter extends _StoreAdapter__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super({
            getAnnotations(documentId, pageNumber) {
                return new Promise((resolve, reject) => {
                    getAnnotations(documentId).then((annotations) => {
                        const annotation = annotations.filter((i) => {
                            return i.page === pageNumber && i.class === 'Annotation';
                        });

                        resolve({
                            documentId,
                            pageNumber,
                            annotations: annotation,
                        });
                    });
                });
            },
        });

        this.getAnnotation = (documentId, annotationId) => {
            return new Promise((resolve, reject) => {
                getAnnotations(documentId).then((anno) => {
                    resolve(anno[findAnnotation(anno, annotationId)]);
                });
            });
        };

        this.addAnnotation = (documentId, pageNumber, annotation) => {
            //console.error('aa');
            return new Promise((resolve, reject) => {
                annotation.class = 'Annotation';
                annotation.uuid = (0,_utils_uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
                annotation.page = pageNumber;
                if (annotation.documentId) delete annotation.documentId;
                getAnnotations(documentId).then((annotations) => {
                    annotations.push(annotation);
                    updateAnnotations(documentId, annotations);
                    resolve(annotation);
                });
            });
        };

        this.editAnnotation = (documentId, annotationId, annotation) => {
            return new Promise((resolve, reject) => {
                getAnnotations(documentId).then((annotations) => {
                    annotations[findAnnotation(annotations, annotationId)] = annotation;
                    updateAnnotations(documentId, annotations);
                    resolve(annotation);
                });
            });
        };

        this.deleteAnnotation = (documentId, annotationId) => {
            return new Promise((resolve, reject) => {
                getAnnotations(documentId).then((anno) => {
                    let annotation = anno.filter((i) => i.uuid === annotationId)[0] || {};
                    if (!annotation) {
                        return reject('Could not find annotation');
                    }
                    let index = findAnnotation(anno, annotationId);
                    if (index > -1) {
                        let annotations = anno;
                        annotations.splice(index, 1);
                        updateAnnotations(documentId, annotations);
                    }
                    resolve(true);
                });
            });
        };

        this.getComments = (documentId, annotationId) => {
            return new Promise((resolve, reject) => {
                getAnnotations(documentId).then((anno) => {
                    resolve(
                        anno.filter((i) => {
                            return i.class === 'Comment' && i.annotation === annotationId;
                        })
                    );
                });
            });
        };

        this.addComment = (documentId, annotationId, content) => {
            return new Promise((resolve, reject) => {
                let comment = {
                    class: 'Comment',
                    uuid: (0,_utils_uuid__WEBPACK_IMPORTED_MODULE_0__["default"])(),
                    annotation: annotationId,
                    content: content,
                };
                getAnnotations(documentId).then((annotations) => {
                    annotations.push(comment);
                    updateAnnotations(documentId, annotations);

                    resolve(comment);
                });
            });
        };

        this.deleteComment = (documentId, commentId) => {
            return new Promise((resolve, reject) => {
                getAnnotations(documentId).then((anno) => {
                    let comment = anno.filter((i) => i.uuid === commentId)[0] || {};
                    if (!comment) {
                        return reject('Could not find annotation');
                    }
                    let index = -1;
                    let annotations = anno;
                    for (let i = 0, l = annotations.length; i < l; i++) {
                        if (annotations[i].uuid === commentId) {
                            index = i;
                            break;
                        }
                    }

                    if (index > -1) {
                        annotations.splice(index, 1);
                        updateAnnotations(documentId, annotations);
                    }

                    resolve(true);
                });
            });
        };
    }
}

function getAnnotations(documentId) {
    if (window._annotations) return Promise.resolve(window._annotations);
    else {
        return new Promise((resolve, reject) => {
            window.__sdJSBridge &&
                window.__sdJSBridge.invoke('reader.getAnnotations', documentId, (annotations) => {
                    window._annotations = annotations || [];
                    console.log(`getAnnotations: ${annotations} Loaded`);
                    resolve(window._annotations);
                });
        });
    }
}

function updateAnnotations(documentId, annotations) {
    window._annotations = annotations;
    window.__sdJSBridge && window.__sdJSBridge.publish('pdfModified');
}
/**
 *
 * @param {String} documentId Document id of the annotation
 * @param {String} annotationId The id of the annotation
 *
 * This function finds all the annotation made by one user.
 *
 * @return {int} The index of the annotation in localstorage
 */
function findAnnotation(anno, annotationId) {
    let index = -1;
    let annotations = anno;
    for (let i = 0, l = annotations.length; i < l; i++) {
        if (annotations[i].uuid === annotationId) {
            index = i;
            break;
        }
    }
    return index;
}


/***/ }),

/***/ "./src/online_annotate/adapter/StoreAdapter.js":
/*!*****************************************************!*\
  !*** ./src/online_annotate/adapter/StoreAdapter.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ StoreAdapter; }
/* harmony export */ });
/* harmony import */ var _utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/abstractFunction */ "./src/online_annotate/utils/abstractFunction.js");
/* harmony import */ var _UI_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/event */ "./src/online_annotate/UI/event.js");
// Disable JSDoc as it cannot really deal with the odd way that the functions are defined
/* eslint valid-jsdoc: 0 */




// Adapter should never be invoked publicly
class StoreAdapter {
  /**
   * Create a new StoreAdapter instance
   *
   * @param {Object} [definition] The definition to use for overriding abstract methods
   */
  constructor(definition = {}) {
    // Copy each function from definition if it is a function we know about
    Object.keys(definition).forEach((key) => {
      if (typeof definition[key] === 'function' &&
          typeof this[key] === 'function') {
        this[key] = definition[key];
      }
    });
  }

  /**
   * Get all the annotations for a given document and page number.
   *
   * @param {String} documentId The ID for the document the annotations belong to
   * @param {Number} pageNumber The number of the page the annotations belong to
   * @return {Promise} Promise that returns with list of annotations for document and page
   */
  __getAnnotations(documentId, pageNumber) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('getAnnotations'); }
  get getAnnotations() { return this.__getAnnotations; }
  set getAnnotations(fn) {
    this.__getAnnotations = function getAnnotations(documentId, pageNumber) {
      return fn(...arguments).then((annotations) => {
        // TODO may be best to have this happen on the server
        if (annotations.annotations) {
          annotations.annotations.forEach((a) => {
            a.documentId = documentId;
          });
        }
        return annotations;
      });
    };
  }

  /**
   * Get the definition for a specific annotation.
   *
   * @param {String} documentId The ID for the document the annotation belongs to
   * @param {String} annotationId The ID for the annotation
   * @return {Promise} Promise that returns the requested annotation
   */
  getAnnotation(documentId, annotationId) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('getAnnotation'); }

  /**
   * Add an annotation
   *
   * @param {String} documentId The ID for the document to add the annotation to
   * @param {String} pageNumber The page number to add the annotation to
   * @param {Object} annotation The definition for the new annotation
   * @return {Promise} Promise that returns with the added annotation
   */
  __addAnnotation(documentId, pageNumber, annotation) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('addAnnotation'); }
  get addAnnotation() { return this.__addAnnotation; }
  set addAnnotation(fn) {
    this.__addAnnotation = function addAnnotation(documentId, pageNumber, annotation) {
      return fn(...arguments).then((annotation) => {
        (0,_UI_event__WEBPACK_IMPORTED_MODULE_1__.fireEvent)('annotation:add', documentId, pageNumber, annotation);
        return annotation;
      });
    };
  }

  /**
   * Edit an annotation
   *
   * @param {String} documentId The ID for the document
   * @param {String} pageNumber the page number of the annotation
   * @param {Object} annotation The definition of the modified annotation
   * @return {Promise} Promise that returns with the edited annotation
   */
  __editAnnotation(documentId, pageNumber, annotation) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('editAnnotation'); }
  get editAnnotation() { return this.__editAnnotation; }
  set editAnnotation(fn) {
    this.__editAnnotation = function editAnnotation(documentId, annotationId, annotation) {
      return fn(...arguments).then((annotation) => {
        (0,_UI_event__WEBPACK_IMPORTED_MODULE_1__.fireEvent)('annotation:edit', documentId, annotationId, annotation);
        return annotation;
      });
    };
  }

  /**
   * Delete an annotation
   *
   * @param {String} documentId The ID for the document
   * @param {String} annotationId The ID for the annotation
   * @return {Promise} Promise that returns with boolean if annotation was deleted
   */
  __deleteAnnotation(documentId, annotationId) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('deleteAnnotation'); }
  get deleteAnnotation() { return this.__deleteAnnotation; }
  set deleteAnnotation(fn) {
    this.__deleteAnnotation = function deleteAnnotation(documentId, annotationId) {
      return fn(...arguments).then((success) => {
        if (success) {
          (0,_UI_event__WEBPACK_IMPORTED_MODULE_1__.fireEvent)('annotation:delete', documentId, annotationId);
        }
        return success;
      });
    };
  }

  /**
   * Get all the comments for an annotation
   *
   * @param {String} documentId The ID for the document
   * @param {String} annotationId The ID for the annotation
   * @return {Promise} Promise that returns with comments for annotation
   */
  getComments(documentId, annotationId) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('getComments'); }

  /**
   * Add a new comment
   *
   * @param {String} documentId The ID for the document
   * @param {String} annotationId The ID for the annotation
   * @param {Object} content The definition of the comment
   * @return {Promise} Promise that returns with the added comment
   */
  __addComment(documentId, annotationId, content) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('addComment'); }
  get addComment() { return this.__addComment; }
  set addComment(fn) {
    this.__addComment = function addComment(documentId, annotationId, content) {
      return fn(...arguments).then((comment) => {
        (0,_UI_event__WEBPACK_IMPORTED_MODULE_1__.fireEvent)('comment:add', documentId, annotationId, comment);
        return comment;
      });
    };
  }

  /**
   * Delete a comment
   *
   * @param {String} documentId The ID for the document
   * @param {String} commentId The ID for the comment
   * @return {Promise} Promise that returns with boolean if comment was deleted
   */
  __deleteComment(documentId, commentId) { (0,_utils_abstractFunction__WEBPACK_IMPORTED_MODULE_0__["default"])('deleteComment'); }
  get deleteComment() { return this.__deleteComment; }
  set deleteComment(fn) {
    this.__deleteComment = function deleteComment(documentId, commentId) {
      return fn(...arguments).then((success) => {
        if (success) {
          (0,_UI_event__WEBPACK_IMPORTED_MODULE_1__.fireEvent)('comment:delete', documentId, commentId);
        }
        return success;
      });
    };
  }
}


/***/ }),

/***/ "./src/online_annotate/config.js":
/*!***************************************!*\
  !*** ./src/online_annotate/config.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  annotationLayerName: 'onlineAnnotationLayer',
  textLayerName: 'textLayer',
  annotationSvgQuery: function() {
    return 'svg.' + this.annotationLayerName;
  },
  annotationClassQuery: function() {
    return '.' + this.annotationLayerName;
  },
  textClassQuery: function() {
    return '.' + this.textLayerName;
  }
});


/***/ }),

/***/ "./src/online_annotate/initColorPicker.js":
/*!************************************************!*\
  !*** ./src/online_annotate/initColorPicker.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ initColorPicker; }
/* harmony export */ });
// Color picker component
const COLORS = [
  {hex: '#000000', name: 'Black'},
  {hex: '#EF4437', name: 'Red'},
  {hex: '#E71F63', name: 'Pink'},
  {hex: '#8F3E97', name: 'Purple'},
  {hex: '#65499D', name: 'Deep Purple'},
  {hex: '#4554A4', name: 'Indigo'},
  {hex: '#2083C5', name: 'Blue'},
  {hex: '#35A4DC', name: 'Light Blue'},
  {hex: '#09BCD3', name: 'Cyan'},
  {hex: '#009688', name: 'Teal'},
  {hex: '#43A047', name: 'Green'},
  {hex: '#8BC34A', name: 'Light Green'},
  {hex: '#FDC010', name: 'Yellow'},
  {hex: '#F8971C', name: 'Orange'},
  {hex: '#F0592B', name: 'Deep Orange'},
  {hex: '#F06291', name: 'Light Pink'}
];

function initColorPicker(el, value, onChange) {
  function getNameFromHex(hex) {
    for (let color of COLORS) {
      if (color.hex === hex) {
        return color.name;
      }
    }
  }

  function setColor(hex, name, fireOnChange = true) {
    a.setAttribute('data-color', hex);
    a.setAttribute('data-name', name);
    a.setAttribute('title', name);
    a.style.background = hex;
    if (fireOnChange && typeof onChange === 'function') {
      onChange(hex);
    }
    closePicker();
  }

  function togglePicker() {
    if (isPickerOpen) {
      closePicker();
    }
    else {
      openPicker();
    }
  }

  function closePicker() {
    document.removeEventListener('keyup', handleDocumentKeyup);
    if (picker && picker.parentNode) {
      picker.parentNode.removeChild(picker);
    }
    isPickerOpen = false;
    a.focus();
  }

  function openPicker() {
    if (!picker) {
      picker = document.createElement('div');
      picker.style.background = '#fff';
      picker.style.border = '1px solid #ccc';
      picker.style.padding = '2px';
      picker.style.position = 'absolute';
      picker.style.width = '122px';
      el.style.position = 'relative';

      COLORS.map(createColorOption).forEach((c) => {
        c.style.margin = '2px';
        c.onclick = function() {
          setColor(c.getAttribute('data-color'), c.getAttribute('data-name'));
        };
        picker.appendChild(c);
      });
    }

    document.addEventListener('keyup', handleDocumentKeyup);
    el.appendChild(picker);
    isPickerOpen = true;
  }

  function createColorOption(color) {
    let e = document.createElement('a');
    e.className = 'color';
    e.setAttribute('href', 'javascript://');
    e.setAttribute('title', color.name);
    e.setAttribute('data-name', color.name);
    e.setAttribute('data-color', color.hex);
    e.style.background = color.hex;
    return e;
  }

  function handleDocumentKeyup(e) {
    if (e.keyCode === 27) {
      closePicker();
    }
  }

  let picker;
  let isPickerOpen = false;
  let name = getNameFromHex(value);
  let a = createColorOption({hex: value, name: name});
  a.onclick = togglePicker;
  el.appendChild(a);
  setColor(value, name, false);
}


/***/ }),

/***/ "./src/online_annotate/render/appendChild.js":
/*!***************************************************!*\
  !*** ./src/online_annotate/render/appendChild.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTranslation": function() { return /* binding */ getTranslation; },
/* harmony export */   "appendChild": function() { return /* binding */ appendChild; },
/* harmony export */   "transformChild": function() { return /* binding */ transformChild; }
/* harmony export */ });
/* harmony import */ var _renderLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderLine */ "./src/online_annotate/render/renderLine.js");
/* harmony import */ var _renderPath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderPath */ "./src/online_annotate/render/renderPath.js");
/* harmony import */ var _renderPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderPoint */ "./src/online_annotate/render/renderPoint.js");
/* harmony import */ var _renderRect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderRect */ "./src/online_annotate/render/renderRect.js");
/* harmony import */ var _renderText__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderText */ "./src/online_annotate/render/renderText.js");
/* harmony import */ var _renderCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderCircle */ "./src/online_annotate/render/renderCircle.js");
/* harmony import */ var _renderArrow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderArrow */ "./src/online_annotate/render/renderArrow.js");








const isFirefox = /firefox/i.test(navigator.userAgent);

/**
 * Get the x/y translation to be used for transforming the annotations
 * based on the rotation of the viewport.
 *
 * @param {Object} viewport The viewport data from the page
 * @return {Object}
 */
function getTranslation(viewport) {
  let x;
  let y;

  // Modulus 360 on the rotation so that we only
  // have to worry about four possible values.
  switch (viewport.rotation % 360) {
    case 0:
      x = y = 0;
      break;
    case 90:
      x = 0;
      y = (viewport.width / viewport.scale) * -1;
      break;
    case 180:
      x = (viewport.width / viewport.scale) * -1;
      y = (viewport.height / viewport.scale) * -1;
      break;
    case 270:
      x = (viewport.height / viewport.scale) * -1;
      y = 0;
      break;
  }

  return { x, y };
}

/**
 * Transform the rotation and scale of a node using SVG's native transform attribute.
 *
 * @param {Node} node The node to be transformed
 * @param {Object} viewport The page's viewport data
 * @return {Node}
 */
function transform(node, viewport) {
  let trans = getTranslation(viewport);

  // Let SVG natively transform the element
  node.setAttribute('transform', `scale(${viewport.scale}) rotate(${viewport.rotation}) translate(${trans.x}, ${trans.y})`);

  // Manually adjust x/y for nested SVG nodes
  if (!isFirefox && node.nodeName.toLowerCase() === 'svg') {
    node.setAttribute('x', parseInt(node.getAttribute('x'), 10) * viewport.scale);
    node.setAttribute('y', parseInt(node.getAttribute('y'), 10) * viewport.scale);

    let x = parseInt(node.getAttribute('x', 10));
    let y = parseInt(node.getAttribute('y', 10));
    let width = parseInt(node.getAttribute('width'), 10);
    let height = parseInt(node.getAttribute('height'), 10);
    let path = node.querySelector('path');
    let svg = path.parentNode;

    // Scale width/height
    [node, svg, path, node.querySelector('rect')].forEach((n) => {
      n.setAttribute('width', parseInt(n.getAttribute('width'), 10) * viewport.scale);
      n.setAttribute('height', parseInt(n.getAttribute('height'), 10) * viewport.scale);
    });

    // Transform path but keep scale at 100% since it will be handled natively
    transform(path, Object.assign({}, viewport, { scale: 1 }));

    switch (viewport.rotation % 360) {
      case 90:
        node.setAttribute('x', viewport.width - y - width);
        node.setAttribute('y', x);
        svg.setAttribute('x', 1);
        svg.setAttribute('y', 0);
        break;
      case 180:
        node.setAttribute('x', viewport.width - x - width);
        node.setAttribute('y', viewport.height - y - height);
        svg.setAttribute('y', 2);
        break;
      case 270:
        node.setAttribute('x', y);
        node.setAttribute('y', viewport.height - x - height);
        svg.setAttribute('x', -1);
        svg.setAttribute('y', 0);
        break;
    }
  }

  return node;
}

/**
 * Append an annotation as a child of an SVG.
 *
 * @param {SVGElement} svg The SVG element to append the annotation to
 * @param {Object} annotation The annotation definition to render and append
 * @param {Object} viewport The page's viewport data
 * @return {SVGElement} A node that was created and appended by this function
 */
function appendChild(svg, annotation, viewport) {
  if (!viewport) {
    viewport = JSON.parse(svg.getAttribute('data-pdf-annotate-viewport'));
  }

  let child;
  switch (annotation.type) {
    case 'area':
    case 'highlight':
      child = (0,_renderRect__WEBPACK_IMPORTED_MODULE_3__["default"])(annotation);
      break;
    case 'circle':
    case 'fillcircle':
    case 'emptycircle':
      child = (0,_renderCircle__WEBPACK_IMPORTED_MODULE_5__["default"])(annotation);
      break;
    case 'strikeout':
      case 'underline':
      child = (0,_renderLine__WEBPACK_IMPORTED_MODULE_0__["default"])(annotation);
      break;
    case 'point':
      child = (0,_renderPoint__WEBPACK_IMPORTED_MODULE_2__["default"])(annotation);
      break;
    case 'textbox':
      child = (0,_renderText__WEBPACK_IMPORTED_MODULE_4__["default"])(annotation);
      break;
    case 'drawing':
      child = (0,_renderPath__WEBPACK_IMPORTED_MODULE_1__["default"])(annotation);
      break;
    case 'arrow':
      child = (0,_renderArrow__WEBPACK_IMPORTED_MODULE_6__["default"])(annotation);
      break;
  }

  // If no type was provided for an annotation it will result in node being null.
  // Skip appending/transforming if node doesn't exist.
  if (child) {
    // Set attributes
    child.setAttribute('data-pdf-annotate-id', annotation.uuid);
    child.setAttribute('aria-hidden', true);

    // Dynamically set any other attributes associated with annotation that is not related to drawing it
    Object.keys(annotation).filter((key) => {
      return ['color', 'x', 'y', 'cx', 'cy', 'color', 'documentId', 'lines', 'page',
        'width', 'class', 'content', 'size', 'rotation', 'r'].indexOf(key) === -1;
    }).forEach((key) => {
      child.setAttribute(`data-pdf-annotate-${key}`, annotation[key]);
    });

    svg.appendChild(transform(child, viewport));
  }

  return child;
}

/**
 * Transform a child annotation of an SVG.
 *
 * @param {SVGElement} svg The SVG element with the child annotation
 * @param {Object} child The SVG child to transform
 * @param {Object} viewport The page's viewport data
 * @return {SVGElement} A node that was transformed by this function
 */
function transformChild(svg, child, viewport) {
  if (!viewport) {
    viewport = JSON.parse(svg.getAttribute('data-pdf-annotate-viewport'));
  }

  // If no type was provided for an annotation it will result in node being null.
  // Skip transforming if node doesn't exist.
  if (child) {
    child = transform(child, viewport);
  }

  return child;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Get the x/y translation to be used for transforming the annotations
   * based on the rotation of the viewport.
   */
  getTranslation,

  /**
   * Append an SVG child for an annotation
   */
  appendChild,

  /**
   * Transform an existing SVG child
   */
  transformChild
});


/***/ }),

/***/ "./src/online_annotate/render/index.js":
/*!*********************************************!*\
  !*** ./src/online_annotate/render/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var _appendChild__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appendChild */ "./src/online_annotate/render/appendChild.js");


/**
 * Render the response from PDFJSAnnotate.getStoreAdapter().getAnnotations to SVG
 *
 * @param {SVGElement} svg The SVG element to render the annotations to
 * @param {Object} viewport The page viewport data
 * @param {Object} data The response from PDFJSAnnotate.getStoreAdapter().getAnnotations
 * @return {Promise} Settled once rendering has completed
 *  A settled Promise will be either:
 *    - fulfilled: SVGElement
 *    - rejected: Error
 */
function render(svg, viewport, data) {
  return new Promise((resolve, reject) => {
    // Reset the content of the SVG
    svg.setAttribute('data-pdf-annotate-container', true);
    svg.setAttribute('data-pdf-annotate-viewport', JSON.stringify(viewport));
    svg.removeAttribute('data-pdf-annotate-document');
    svg.removeAttribute('data-pdf-annotate-page');

    // If there's no data nothing can be done
    if (!data) {
      svg.innerHTML = '';
      return resolve(svg);
    }

    svg.setAttribute('data-pdf-annotate-document', data.documentId);
    svg.setAttribute('data-pdf-annotate-page', data.pageNumber);

    // Make sure annotations is an array
    if (!Array.isArray(data.annotations) || data.annotations.length === 0) {
      return resolve(svg);
    }

    // Append or transform annotation to svg
    data.annotations.forEach((a) => {
      let node = svg.querySelector('[data-pdf-annotate-id="' + a.uuid + '"]');
      if (node) {
        (0,_appendChild__WEBPACK_IMPORTED_MODULE_0__.transformChild)(svg, node, viewport);
      }
      else {
        (0,_appendChild__WEBPACK_IMPORTED_MODULE_0__.appendChild)(svg, a, viewport);
      }
    });

    resolve(svg);
  });
}


/***/ }),

/***/ "./src/online_annotate/render/renderArrow.js":
/*!***************************************************!*\
  !*** ./src/online_annotate/render/renderArrow.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderArrow; }
/* harmony export */ });
/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ "./src/online_annotate/utils/setAttributes.js");
/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ "./src/online_annotate/utils/normalizeColor.js");
/* harmony import */ var _utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mathUtils */ "./src/online_annotate/utils/mathUtils.js");




/**
 * Create SVGPathElement from an annotation definition.
 * This is used for anntations of type `drawing`.
 *
 * @param {Object} a The annotation definition
 * @return {SVGPathElement} The path to be rendered
 */
function renderArrow(a) {
  let arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');

  if (a.lines.length === 2) {
    let p1 = a.lines[0];
    let p2 = a.lines[a.lines.length - 1];

    let arrowLength = 40;
    let pt0 = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.makePoint)(p1[0], p1[1], 0);
    let pt1 = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.makePoint)(p2[0], p2[1], 0);
    let x = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.makeVectorFromPoints)(pt0, pt1);
    let unitX = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.unitVector)(x);
    pt1 = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.addVector)(pt0, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.multiplyVector)(unitX, arrowLength));
    x = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.makeVectorFromPoints)(pt0, pt1);
    let unitZ = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.makeVector)(0, 0, 1);
    let unitY = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.unitVector)((0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.crossProduct)(unitX, unitZ));
    let thickness = a.width || 10;

    let A = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.addVector)(pt0, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.multiplyVector)(unitY, thickness * 0.5));
    let B = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.addVector)(A, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.multiplyVector)(unitX, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.magnitude)(x) - thickness * 2.0));
    let C = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.addVector)(B, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.multiplyVector)(unitY, thickness));
    let D = pt1;
    let G = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.addVector)(pt0, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.multiplyVector)((0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.negateVector)(unitY), thickness * 0.5));
    let F = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.addVector)(G, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.multiplyVector)(unitX, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.magnitude)(x) - thickness * 2.0));
    let E = (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.addVector)(F, (0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.multiplyVector)((0,_utils_mathUtils__WEBPACK_IMPORTED_MODULE_2__.negateVector)(unitY), thickness));

    let points = '' +
      A.x + ',' + A.y + ' ' +
      B.x + ',' + B.y + ' ' +
      C.x + ',' + C.y + ' ' +
      D.x + ',' + D.y + ' ' +
      E.x + ',' + E.y + ' ' +
      F.x + ',' + F.y + ' ' +
      G.x + ',' + G.y;

    (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(arrow, {
      points: points,
      stroke: (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#000'),
      fill: (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#000')
    });
  }

  return arrow;
}


/***/ }),

/***/ "./src/online_annotate/render/renderCircle.js":
/*!****************************************************!*\
  !*** ./src/online_annotate/render/renderCircle.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderCircle; }
/* harmony export */ });
/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ "./src/online_annotate/utils/setAttributes.js");
/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ "./src/online_annotate/utils/normalizeColor.js");



/**
 * Create an SVGCircleElement from an annotation definition.
 * This is used for annotations of type `circle`.
 *
 * @param {Object} a The annotation definition
 * @return {SVGGElement|SVGCircleElement} A circle to be rendered
 */
function renderCircle(a) {
  let circle = createCircle(a);
  let color = (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#f00');

  if (a.type === 'circle') {
    (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(circle, {
      stroke: color,
      fill: 'none',
      'stroke-width': 5
    });
  }
  if (a.type === 'emptycircle') {
    (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(circle, {
      stroke: color,
      fill: 'none',
      'stroke-width': 2
    });
  }

  if (a.type === 'fillcircle') {
    (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(circle, {
      stroke: color,
      fill: color,
      'stroke-width': 5
    });
  }

  return circle;
}

function createCircle(a) {
  let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(circle, {
    cx: a.cx,
    cy: a.cy,
    r: a.r
  });

  return circle;
}


/***/ }),

/***/ "./src/online_annotate/render/renderLine.js":
/*!**************************************************!*\
  !*** ./src/online_annotate/render/renderLine.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderLine; }
/* harmony export */ });
/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ "./src/online_annotate/utils/setAttributes.js");
/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ "./src/online_annotate/utils/normalizeColor.js");



/**
 * Create SVGLineElements from an annotation definition.
 * This is used for anntations of type `strikeout`.
 *
 * @param {Object} a The annotation definition
 * @return {SVGGElement} A group of all lines to be rendered
 */
function renderLine(a) {
  let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(group, {
    stroke: (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#f00'),
    strokeWidth: 1
  });

  a.rectangles.forEach((r) => {
    let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

    (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(line, {
      x1: r.x,
      y1: r.y,
      x2: r.x + r.width,
      y2: r.y
    });

    group.appendChild(line);
  });

  return group;
}


/***/ }),

/***/ "./src/online_annotate/render/renderPath.js":
/*!**************************************************!*\
  !*** ./src/online_annotate/render/renderPath.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderPath; }
/* harmony export */ });
/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ "./src/online_annotate/utils/setAttributes.js");
/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ "./src/online_annotate/utils/normalizeColor.js");



/**
 * Create SVGPathElement from an annotation definition.
 * This is used for anntations of type `drawing`.
 *
 * @param {Object} a The annotation definition
 * @return {SVGPathElement} The path to be rendered
 */
function renderPath(a) {
  let d = [];
  let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

  if (a.lines.length > 0) {
    d.push(`M${a.lines[0][0]} ${a.lines[0][1]}`);
    for (let i = 1, l = a.lines.length; i < l; i++) {
      let p1 = a.lines[i];
      let p2 = a.lines[i + 1];
      if (p2) {
        d.push(`L${p1[0]} ${p1[1]}`);
      }
    }
  }

  /*

   if(a.lines.length>2) {
    var p1 = a.lines[0];
    var p2 = a.lines[a.lines.length-1];

    var p3 = []; //arrow
    var p4 = [];
    var p0 = []; //arrow intersection

    if (p2) {
      var k = -(p2[0]-p1[0])/(p2[1]-p1[1]);

      var deltaX = 3;
      p0[0] = p1[0]+0.8*(p2[0]-p1[0]);
      p0[1] = p1[1]+0.8*(p2[1]-p1[1]);

      p3[0] = p0[0] + deltaX;
      p3[1] = p0[1] + k*deltaX;

      p4[0] = p0[0] - deltaX;
      p4[1] = p0[1] - k*deltaX;

      if(Math.abs(p2[1]-p1[1]) < 20) {

        p3[0] = p0[0] ;
        p3[1] = p0[1] + deltaX*1;

        p4[0] = p0[0] ;
        p4[1] = p0[1] - deltaX*1;

      }

      d.push(`M${p1[0]} ${p1[1]} ${p2[0]} ${p2[1]}`);
       //d.push(`M${p1[0]} ${p1[1]} ${p2[0]} ${p2[1]}`);
      d.push(`M${p2[0]} ${p2[1]} ${p3[0]} ${p3[1]}`);
      d.push(`M${p3[0]} ${p3[1]} ${p4[0]} ${p4[1]}`);
      d.push(`M${p4[0]} ${p4[1]} ${p2[0]} ${p2[1]}`);
     }
    } */

  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(path, {
    d: `${d.join(' ')}`, // `${d.join(' ')}Z`,
    stroke: (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#000'),
    strokeWidth: a.width || 1,
    fill: 'none',
    strokeOpacity:a.opacity||1,
  });

  return path;
}


/***/ }),

/***/ "./src/online_annotate/render/renderPoint.js":
/*!***************************************************!*\
  !*** ./src/online_annotate/render/renderPoint.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderPoint; }
/* harmony export */ });
/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ "./src/online_annotate/utils/setAttributes.js");


const SIZE = 25;
const D = 'M499.968 214.336q-113.832 0 -212.877 38.781t-157.356 104.625 -58.311 142.29q0 62.496 39.897 119.133t112.437 97.929l48.546 27.9 -15.066 53.568q-13.392 50.778 -39.06 95.976 84.816 -35.154 153.45 -95.418l23.994 -21.204 31.806 3.348q38.502 4.464 72.54 4.464 113.832 0 212.877 -38.781t157.356 -104.625 58.311 -142.29 -58.311 -142.29 -157.356 -104.625 -212.877 -38.781z';

/**
 * Create SVGElement from an annotation definition.
 * This is used for anntations of type `comment`.
 *
 * @param {Object} a The annotation definition
 * @return {SVGElement} A svg to be rendered
 */
function renderPoint(a) {
  let outerSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  let innerSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(outerSVG, {
    width: SIZE,
    height: SIZE,
    x: a.x,
    y: a.y,
  });

  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(innerSVG, {
    width: SIZE,
    height: SIZE,
    x: 0,
    y: (SIZE * 0.05) * -1,
    viewBox: '0 0 1000 1000'
  });

  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(rect, {
    width: SIZE,
    height: SIZE,
    stroke: '#000',
    fill: '#ff0',
  });

  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(path, {
    d: D,
    strokeWidth: 50,
    stroke: '#000',
    fill: '#fff',
  });

  innerSVG.appendChild(path);
  outerSVG.appendChild(rect);
  outerSVG.appendChild(innerSVG);

  return outerSVG;
}


/***/ }),

/***/ "./src/online_annotate/render/renderRect.js":
/*!**************************************************!*\
  !*** ./src/online_annotate/render/renderRect.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderRect; }
/* harmony export */ });
/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ "./src/online_annotate/utils/setAttributes.js");
/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ "./src/online_annotate/utils/normalizeColor.js");



/**
 * Create SVGRectElements from an annotation definition.
 * This is used for anntations of type `area` and `highlight`.
 *
 * @param {Object} a The annotation definition
 * @return {SVGGElement|SVGRectElement} A group of all rects to be rendered
 */
function renderRect(a) {
  if (a.type === 'highlight') {
    let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(group, {
      fill: (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#ff0'),
      fillOpacity: 0.2
    });

    a.rectangles.forEach((r) => {
      group.appendChild(createRect(r));
    });

    return group;
  }
  else {
    let rect = createRect(a);
    (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(rect, {
      stroke: (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#f00'),
      fill: 'none'
    });

    return rect;
  }
}

function createRect(r) {
  let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(rect, {
    x: r.x,
    y: r.y,
    width: r.width,
    height: r.height
  });

  return rect;
}


/***/ }),

/***/ "./src/online_annotate/render/renderText.js":
/*!**************************************************!*\
  !*** ./src/online_annotate/render/renderText.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ renderText; }
/* harmony export */ });
/* harmony import */ var _utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/setAttributes */ "./src/online_annotate/utils/setAttributes.js");
/* harmony import */ var _utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/normalizeColor */ "./src/online_annotate/utils/normalizeColor.js");



/**
 * Wrap each line of given text in a `<tspan>` element and append these
 * lines to the given SVGTextElement
 *
 * @param {SVGTextElement} textElement A text element to hold the split text
 * @param {String} textContent String to render with line breaks
 */
function insertLineBreaks(textElement, textContent) {
  const lines = (textContent || '').split('\n');
  // can't use dy attribute here since we want empty lines to take up space as well,
  // so we will update y manually based on font size
  const x = textElement.getAttribute('x');
  let y = Number(textElement.getAttribute('y'));
  const size = Number(textElement.getAttribute('font-size'));
  for (const line of lines) {
    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    tspan.setAttribute('y', y.toString());
    tspan.setAttribute('x', x);
    tspan.innerHTML = line;
    textElement.appendChild(tspan);

    y += size;
  }
}

/**
 * Create SVGTextElement from an annotation definition.
 * This is used for anntations of type `textbox`.
 *
 * @param {Object} a The annotation definition
 * @return {SVGTextElement} A text to be rendered
 */
function renderText(a) {
  // Text should be rendered at 0 degrees relative to
  // document rotation
  let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  (0,_utils_setAttributes__WEBPACK_IMPORTED_MODULE_0__["default"])(text, {
    x: a.x,
    y: a.y,
    fill: (0,_utils_normalizeColor__WEBPACK_IMPORTED_MODULE_1__["default"])(a.color || '#000'),
    fontSize: a.size,
    transform: `rotate(${a.rotation})`,
    style: 'white-space: pre'
  });

  insertLineBreaks(text, a.content);

  let g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.appendChild(text);

  return g;
}


/***/ }),

/***/ "./src/online_annotate/utils/abstractFunction.js":
/*!*******************************************************!*\
  !*** ./src/online_annotate/utils/abstractFunction.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ abstractFunction; }
/* harmony export */ });
/**
 * Throw an Error for an abstract function that hasn't been implemented.
 *
 * @param {String} name The name of the abstract function
 */
function abstractFunction(name) {
  throw new Error(name + ' is not implemented');
}


/***/ }),

/***/ "./src/online_annotate/utils/mathUtils.js":
/*!************************************************!*\
  !*** ./src/online_annotate/utils/mathUtils.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyTransform": function() { return /* binding */ applyTransform; },
/* harmony export */   "applyInverseTransform": function() { return /* binding */ applyInverseTransform; },
/* harmony export */   "transform": function() { return /* binding */ transform; },
/* harmony export */   "translate": function() { return /* binding */ translate; },
/* harmony export */   "rotate": function() { return /* binding */ rotate; },
/* harmony export */   "scale": function() { return /* binding */ scale; },
/* harmony export */   "makePoint": function() { return /* binding */ makePoint; },
/* harmony export */   "makeVector": function() { return /* binding */ makeVector; },
/* harmony export */   "makeVectorFromPoints": function() { return /* binding */ makeVectorFromPoints; },
/* harmony export */   "addVector": function() { return /* binding */ addVector; },
/* harmony export */   "multiplyVector": function() { return /* binding */ multiplyVector; },
/* harmony export */   "magnitude": function() { return /* binding */ magnitude; },
/* harmony export */   "negateVector": function() { return /* binding */ negateVector; },
/* harmony export */   "unitVector": function() { return /* binding */ unitVector; },
/* harmony export */   "crossProduct": function() { return /* binding */ crossProduct; }
/* harmony export */ });
// Transform point by matrix
//
function applyTransform(p, m) {
  return [
    p[0] * m[0] + p[1] * m[2] + m[4],
    p[0] * m[1] + p[1] * m[3] + m[5]
  ];
};

// Transform point by matrix inverse
//
function applyInverseTransform(p, m) {
  let d = m[0] * m[3] - m[1] * m[2];
  return [
    (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d,
    (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d
  ];
};

// Concatenates two transformation matrices together and returns the result.
function transform(m1, m2) {
  return [
    m1[0] * m2[0] + m1[2] * m2[1],
    m1[1] * m2[0] + m1[3] * m2[1],
    m1[0] * m2[2] + m1[2] * m2[3],
    m1[1] * m2[2] + m1[3] * m2[3],
    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
  ];
};

function translate(m, x, y) {
  return [
    m[0],
    m[1],
    m[2],
    m[3],
    m[0] * x + m[2] * y + m[4],
    m[1] * x + m[3] * y + m[5]
  ];
};

function rotate(m, angle) {
  angle = angle * Math.PI / 180;

  let cosValue = Math.cos(angle);
  let sinValue = Math.sin(angle);

  return [
    m[0] * cosValue + m[2] * sinValue,
    m[1] * cosValue + m[3] * sinValue,
    m[0] * (-sinValue) + m[2] * cosValue,
    m[1] * (-sinValue) + m[3] * cosValue,
    m[4],
    m[5]
  ];
};

function scale(m, x, y) {
  return [
    m[0] * x,
    m[1] * x,
    m[2] * y,
    m[3] * y,
    m[4],
    m[5]
  ];
};

function makePoint(x, y, z) {
  return { x: x, y: y, z: z };
};

function makeVector(xcoord, ycoord, zcoord) {
  return { xcoord: xcoord, ycoord: ycoord, zcoord: zcoord };
};

function makeVectorFromPoints(pt1, pt2) {
  let xcoord = pt2.x - pt1.x;
  let ycoord = pt2.y - pt1.y;
  let zcoord = pt2.z - pt1.z;
  return makeVector(xcoord, ycoord, zcoord);
};

function addVector(pt, v) {
  return makePoint(pt.x + v.xcoord, pt.y + v.ycoord, pt.z + v.zcoord);
};

function multiplyVector(v, scalar) {
  return makeVector(v.xcoord * scalar, v.ycoord * scalar, v.zcoord * scalar);
};

function magnitude(v) {
  return Math.sqrt(
    Math.pow(v.xcoord, 2) + Math.pow(v.ycoord, 2) + Math.pow(v.zcoord, 2)
  );
};

function negateVector(v) {
  return multiplyVector(v, -1);
};

function unitVector(v) {
  let mag = magnitude(v);
  let xcoord = v.xcoord / mag;
  let ycoord = v.ycoord / mag;
  let zcoord = v.zcoord / mag;
  return makeVector(xcoord, ycoord, zcoord);
};

function crossProduct(u, v) {
  //
  // u X v = < u2*v3 - u3*v2,
  //           u3*v1 - u1*v3,
  //           u1*v2 - u2*v1 >
  let xcoord = u.ycoord * v.zcoord - u.zcoord * v.ycoord;
  let ycoord = u.zcoord * v.xcoord - u.xcoord * v.zcoord;
  let zcoord = u.xcoord * v.ycoord - u.ycoord * v.xcoord;
  return makeVector(xcoord, ycoord, zcoord);
};


/***/ }),

/***/ "./src/online_annotate/utils/normalizeColor.js":
/*!*****************************************************!*\
  !*** ./src/online_annotate/utils/normalizeColor.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ normalizeColor; }
/* harmony export */ });
const REGEX_HASHLESS_HEX = /^([a-f0-9]{6}|[a-f0-9]{3})$/i;

/**
 * Normalize a color value
 *
 * @param {String} color The color to normalize
 * @return {String}
 */
function normalizeColor(color) {
  if (REGEX_HASHLESS_HEX.test(color)) {
    color = `#${color}`;
  }
  return color;
}


/***/ }),

/***/ "./src/online_annotate/utils/setAttributes.js":
/*!****************************************************!*\
  !*** ./src/online_annotate/utils/setAttributes.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ setAttributes; }
/* harmony export */ });
const UPPER_REGEX = /[A-Z]/g;

// Don't convert these attributes from camelCase to hyphenated-attributes
const BLACKLIST = [
  'viewBox'
];

let keyCase = (key) => {
  if (BLACKLIST.indexOf(key) === -1) {
    key = key.replace(UPPER_REGEX, match => '-' + match.toLowerCase());
  }
  return key;
};

/**
 * Set attributes for a node from a map
 *
 * @param {Node} node The node to set attributes on
 * @param {Object} attributes The map of key/value pairs to use for attributes
 */
function setAttributes(node, attributes) {
  Object.keys(attributes).forEach((key) => {
    node.setAttribute(keyCase(key), attributes[key]);
  });
}


/***/ }),

/***/ "./src/online_annotate/utils/uuid.js":
/*!*******************************************!*\
  !*** ./src/online_annotate/utils/uuid.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ uuid; }
/* harmony export */ });
const REGEXP = /[xy]/g;
const PATTERN = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';

function replacement(c) {
  let r = Math.random() * 16 | 0;
  let v = c === 'x' ? r : (r & 0x3 | 0x8);
  return v.toString(16);
}

/**
 * Generate a univierally unique identifier
 *
 * @return {String} A UUID
 */
function uuid() {
  return PATTERN.replace(REGEXP, replacement);
}


/***/ }),

/***/ "./src/overlay_manager.js":
/*!********************************!*\
  !*** ./src/overlay_manager.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OverlayManager": function() { return /* binding */ OverlayManager; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

class OverlayManager {
 constructor() {
  this._overlays = {};
  this._active = null;
  this._keyDownBound = this._keyDown.bind(this);
 }
 get active() {
  return this._active;
 }
 async register(name, element, callerCloseMethod = null, canForceClose = false) {
  let container;
  if (!name || !element || !(container = element.parentNode)) {
   throw new Error("Not enough parameters.");
  } else if (this._overlays[name]) {
   throw new Error("The overlay is already registered.");
  }
  this._overlays[name] = {
   element,
   container,
   callerCloseMethod,
   canForceClose
  };
 }
 async unregister(name) {
  if (!this._overlays[name]) {
   throw new Error("The overlay does not exist.");
  } else if (this._active === name) {
   throw new Error("The overlay cannot be removed while it is active.");
  }
  delete this._overlays[name];
 }
 async open(name) {
  if (!this._overlays[name]) {
   throw new Error("The overlay does not exist.");
  } else if (this._active) {
   if (this._overlays[name].canForceClose) {
    this._closeThroughCaller();
   } else if (this._active === name) {
    throw new Error("The overlay is already active.");
   } else {
    throw new Error("Another overlay is currently active.");
   }
  }
  this._active = name;
  this._overlays[this._active].element.classList.remove("hidden");
  this._overlays[this._active].container.classList.remove("hidden");
  window.addEventListener("keydown", this._keyDownBound);
 }
 async close(name) {
  if (!this._overlays[name]) {
   throw new Error("The overlay does not exist.");
  } else if (!this._active) {
   throw new Error("The overlay is currently not active.");
  } else if (this._active !== name) {
   throw new Error("Another overlay is currently active.");
  }
  this._overlays[this._active].container.classList.add("hidden");
  this._overlays[this._active].element.classList.add("hidden");
  this._active = null;
  window.removeEventListener("keydown", this._keyDownBound);
 }
 _keyDown(evt) {
  if (this._active && evt.keyCode === 27) {
   this._closeThroughCaller();
   evt.preventDefault();
  }
 }
 _closeThroughCaller() {
  if (this._overlays[this._active].callerCloseMethod) {
   this._overlays[this._active].callerCloseMethod();
  }
  if (this._active) {
   this.close(this._active);
  }
 }
}



/***/ }),

/***/ "./src/password_prompt.js":
/*!********************************!*\
  !*** ./src/password_prompt.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PasswordPrompt": function() { return /* binding */ PasswordPrompt; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {PasswordResponses} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
class PasswordPrompt {
 constructor(options, overlayManager, l10n, isViewerEmbedded = false) {
  this.overlayName = options.overlayName;
  this.container = options.container;
  this.label = options.label;
  this.input = options.input;
  this.submitButton = options.submitButton;
  this.cancelButton = options.cancelButton;
  this.overlayManager = overlayManager;
  this.l10n = l10n;
  this._isViewerEmbedded = isViewerEmbedded;
  this.updateCallback = null;
  this.reason = null;
  this.submitButton.addEventListener("click", this.#verify.bind(this));
  this.cancelButton.addEventListener("click", this.#cancel.bind(this));
  this.input.addEventListener("keydown", e => {
   if (e.keyCode === 13) {
    this.#verify();
   }
  });
  this.overlayManager.register(this.overlayName, this.container, this.#cancel.bind(this), true);
 }
 async open() {
  await this.overlayManager.open(this.overlayName);
  const passwordIncorrect = this.reason === PasswordResponses.INCORRECT_PASSWORD;
  if (!this._isViewerEmbedded || passwordIncorrect) {
   this.input.focus();
  }
  this.label.textContent = await this.l10n.get(`password_${ passwordIncorrect ? "invalid" : "label" }`);
 }
 close() {
  this.overlayManager.close(this.overlayName).then(() => {
   this.input.value = "";
  });
 }
 #verify() {
  const password = this.input.value;
  if (password?.length > 0) {
   this.close();
   this.updateCallback(password);
  }
 }
 #cancel() {
  this.close();
  this.updateCallback(new Error("PasswordPrompt cancelled."));
 }
 setUpdateCallback(updateCallback, reason) {
  this.updateCallback = updateCallback;
  this.reason = reason;
 }
}



/***/ }),

/***/ "./src/pdf_cursor_tools.js":
/*!*********************************!*\
  !*** ./src/pdf_cursor_tools.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CursorTool": function() { return /* binding */ CursorTool; },
/* harmony export */   "PDFCursorTools": function() { return /* binding */ PDFCursorTools; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {GrabToPan} = __webpack_require__(/*! ./grab_to_pan.js */ "./src/grab_to_pan.js");

const CursorTool = {
 SELECT: 0,
 HAND: 1,
 ZOOM: 2
};
class PDFCursorTools {
 constructor({container, eventBus, cursorToolOnLoad = CursorTool.SELECT}) {
  this.container = container;
  this.eventBus = eventBus;
  this.active = CursorTool.SELECT;
  this.activeBeforePresentationMode = null;
  this.handTool = new GrabToPan({ element: this.container });
  this._addEventListeners();
  Promise.resolve().then(() => {
   this.switchTool(cursorToolOnLoad);
  });
 }
 get activeTool() {
  return this.active;
 }
 switchTool(tool) {
  if (this.activeBeforePresentationMode !== null) {
   return;
  }
  // if (tool === this.active) {
  //  return;
  // }
  const disableActiveTool = () => {
   switch (this.active) {
   case CursorTool.SELECT:
    break;
   case CursorTool.HAND:
    this.handTool.deactivate();
    break;
   case CursorTool.ZOOM:
   }
  };
  switch (tool) {
  case CursorTool.SELECT:
   disableActiveTool();
   break;
  case CursorTool.HAND:
   disableActiveTool();
   this.handTool.activate();
   break;
  case CursorTool.ZOOM:
  default:
   console.error(`switchTool: "${ tool }" is an unsupported value.`);
   return;
  }
  this.active = tool;
  this._dispatchEvent();
 }
 _dispatchEvent() {
  this.eventBus.dispatch("cursortoolchanged", {
   source: this,
   tool: this.active
  });
 }
 _addEventListeners() {
  this.eventBus._on("switchcursortool", evt => {
    // sdpdfcore annotation
    window._setActiveToolbarItem&&window._setActiveToolbarItem('cursor',null);
   this.switchTool(evt.tool);
  });
  
 }
}



/***/ }),

/***/ "./src/pdf_find_bar.js":
/*!*****************************!*\
  !*** ./src/pdf_find_bar.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDFFindBar": function() { return /* binding */ PDFFindBar; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {FindState} = __webpack_require__(/*! ./pdf_find_controller.js */ "./src/pdf_find_controller.js");
const MATCHES_COUNT_LIMIT = 1000;
class PDFFindBar {
 constructor(options, eventBus, l10n) {
  this.opened = false;
  this.bar = options.bar;
  this.toggleButton = options.toggleButton;
  this.findField = options.findField;
  this.highlightAll = options.highlightAllCheckbox;
  this.caseSensitive = options.caseSensitiveCheckbox;
  this.matchDiacritics = options.matchDiacriticsCheckbox;
  this.entireWord = options.entireWordCheckbox;
  this.findMsg = options.findMsg;
  this.findResultsCount = options.findResultsCount;
  this.findPreviousButton = options.findPreviousButton;
  this.findNextButton = options.findNextButton;
  this.eventBus = eventBus;
  this.l10n = l10n;
  this.toggleButton.addEventListener("click", () => {
   this.toggle();
  });
  this.findField.addEventListener("input", () => {
   this.dispatchEvent("");
  });
  this.bar.addEventListener("keydown", e => {
   switch (e.keyCode) {
   case 13:
    if (e.target === this.findField) {
     this.dispatchEvent("again", e.shiftKey);
    }
    break;
   case 27:
    this.close();
    break;
   }
  });
  this.findPreviousButton.addEventListener("click", () => {
   this.dispatchEvent("again", true);
  });
  this.findNextButton.addEventListener("click", () => {
   this.dispatchEvent("again", false);
  });
  this.highlightAll.addEventListener("click", () => {
   this.dispatchEvent("highlightallchange");
  });
  this.caseSensitive.addEventListener("click", () => {
   this.dispatchEvent("casesensitivitychange");
  });
  this.entireWord.addEventListener("click", () => {
   this.dispatchEvent("entirewordchange");
  });
  this.matchDiacritics.addEventListener("click", () => {
   this.dispatchEvent("diacriticmatchingchange");
  });
  this.eventBus._on("resize", this._adjustWidth.bind(this));
 }
 reset() {
  this.updateUIState();
 }
 dispatchEvent(type, findPrev = false) {
     console.log("find Event dispatch",{
        source: this,
        type,
        query: this.findField.value,
        phraseSearch: true,
        caseSensitive: this.caseSensitive.checked,
        entireWord: this.entireWord.checked,
        highlightAll: this.highlightAll.checked,
        findPrevious: findPrev,
        matchDiacritics: this.matchDiacritics.checked
     });
  this.eventBus.dispatch("find", {
   source: this,
   type,
   query: this.findField.value,
   phraseSearch: true,
   caseSensitive: this.caseSensitive.checked,
   entireWord: this.entireWord.checked,
   highlightAll: this.highlightAll.checked,
   findPrevious: findPrev,
   matchDiacritics: this.matchDiacritics.checked
  });
 }
 updateUIState(state, previous, matchesCount) {
  let findMsg = Promise.resolve("");
  let status = "";
  switch (state) {
  case FindState.FOUND:
   break;
  case FindState.PENDING:
   status = "pending";
   break;
  case FindState.NOT_FOUND:
   findMsg = this.l10n.get("find_not_found");
   status = "notFound";
   break;
  case FindState.WRAPPED:
   findMsg = this.l10n.get(`find_reached_${ previous ? "top" : "bottom" }`);
   break;
  }
  this.findField.setAttribute("data-status", status);
  findMsg.then(msg => {
   this.findMsg.textContent = msg;
   this._adjustWidth();
  });
  this.updateResultsCount(matchesCount);
 }
 updateResultsCount({current = 0, total = 0} = {}) {
  const limit = MATCHES_COUNT_LIMIT;
  let matchCountMsg = Promise.resolve("");
  if (total > 0) {
   if (total > limit) {
    let key = "find_match_count_limit";
    matchCountMsg = this.l10n.get(key, { limit });
   } else {
    let key = "find_match_count";
    matchCountMsg = this.l10n.get(key, {
     current,
     total
    });
   }
  }
  matchCountMsg.then(msg => {
   this.findResultsCount.textContent = msg;
   this._adjustWidth();
  });
 }
 open() {
  if (!this.opened) {
   this.opened = true;
   this.toggleButton.classList.add("toggled");
   this.toggleButton.setAttribute("aria-expanded", "true");
   this.bar.classList.remove("hidden");
  }
  this.findField.select();
  this.findField.focus();
  this._adjustWidth();
 }
 close() {
  if (!this.opened) {
   return;
  }
  this.opened = false;
  this.toggleButton.classList.remove("toggled");
  this.toggleButton.setAttribute("aria-expanded", "false");
  this.bar.classList.add("hidden");
  this.eventBus.dispatch("findbarclose", { source: this });
 }
 toggle() {
  if (this.opened) {
   this.close();
  } else {
   this.open();
  }
 }
 _adjustWidth() {
  if (!this.opened) {
   return;
  }
  this.bar.classList.remove("wrapContainers");
  const findbarHeight = this.bar.clientHeight;
  const inputContainerHeight = this.bar.firstElementChild.clientHeight;
  if (findbarHeight > inputContainerHeight) {
   this.bar.classList.add("wrapContainers");
  }
 }
}



/***/ }),

/***/ "./src/pdf_find_controller.js":
/*!************************************!*\
  !*** ./src/pdf_find_controller.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FindState": function() { return /* binding */ FindState; },
/* harmony export */   "PDFFindController": function() { return /* binding */ PDFFindController; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const { binarySearchFirstItem, scrollIntoView } = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const { createPromiseCapability } = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const { getCharacterType } = __webpack_require__(/*! ./pdf_find_utils.js */ "./src/pdf_find_utils.js");
const FindState = {
    FOUND: 0,
    NOT_FOUND: 1,
    WRAPPED: 2,
    PENDING: 3,
};
const FIND_TIMEOUT = 250;
const MATCH_SCROLL_OFFSET_TOP = -50;
const MATCH_SCROLL_OFFSET_LEFT = -400;
const CHARACTERS_TO_NORMALIZE = {
    '\u2010': '-',
    '\u2018': "'",
    '\u2019': "'",
    '\u201A': "'",
    '\u201B': "'",
    '\u201C': '"',
    '\u201D': '"',
    '\u201E': '"',
    '\u201F': '"',
    '\u00BC': '1/4',
    '\u00BD': '1/2',
    '\u00BE': '3/4',
};
const DIACRITICS_EXCEPTION = new Set([
    0x3099, 0x309a, 0x094d, 0x09cd, 0x0a4d, 0x0acd, 0x0b4d, 0x0bcd, 0x0c4d, 0x0ccd, 0x0d3b, 0x0d3c, 0x0d4d, 0x0dca,
    0x0e3a, 0x0eba, 0x0f84, 0x1039, 0x103a, 0x1714, 0x1734, 0x17d2, 0x1a60, 0x1b44, 0x1baa, 0x1bab, 0x1bf2, 0x1bf3,
    0x2d7f, 0xa806, 0xa82c, 0xa8c4, 0xa953, 0xa9c0, 0xaaf6, 0xabed, 0x0c56, 0x0f71, 0x0f72, 0x0f7a, 0x0f7b, 0x0f7c,
    0x0f7d, 0x0f80, 0x0f74,
]);
const DIACRITICS_EXCEPTION_STR = [...DIACRITICS_EXCEPTION.values()].map((x) => String.fromCharCode(x)).join('');
const DIACRITICS_REG_EXP = /\p{M}+/gu;
const SPECIAL_CHARS_REG_EXP = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu;
const NOT_DIACRITIC_FROM_END_REG_EXP = /([^\p{M}])\p{M}*$/u;
const NOT_DIACRITIC_FROM_START_REG_EXP = /^\p{M}*([^\p{M}])/u;
let normalizationRegex = null;
function normalize(text) {
    if (!normalizationRegex) {
        const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join('');
        normalizationRegex = new RegExp(`([${replace}])|(\\S-\\n)|(\\n)|(\\p{M}+)`, 'gum');
    }
    const rawDiacriticsPositions = [];
    let m;
    while ((m = DIACRITICS_REG_EXP.exec(text)) !== null) {
        rawDiacriticsPositions.push([m[0].length, m.index]);
    }
    let normalized = text.normalize('NFD');
    const positions = [[0, 0]];
    let k = 0;
    let shift = 0;
    let shiftOrigin = 0;
    let eol = 0;
    let hasDiacritics = false;
    normalized = normalized.replace(normalizationRegex, (match, p1, p2, p3, p4, i) => {
        i -= shiftOrigin;
        if (p1) {
            const replacement = CHARACTERS_TO_NORMALIZE[match];
            const jj = replacement.length;
            for (let j = 1; j < jj; j++) {
                positions.push([i - shift + j, shift - j]);
            }
            shift -= jj - 1;
            return replacement;
        }
        if (p2) {
            positions.push([i - shift, 1 + shift]);
            shift += 1;
            shiftOrigin += 1;
            eol += 1;
            return p2.charAt(0);
        }
        if (p3) {
            positions.push([i - shift + 1, shift - 1]);
            shift -= 1;
            shiftOrigin += 1;
            eol += 1;
            return ' ';
        }
        hasDiacritics = true;
        let jj = p4.length;
        if (i + eol === rawDiacriticsPositions[k]?.[1]) {
            jj -= rawDiacriticsPositions[k][0];
            ++k;
        }
        for (let j = 1; j < jj + 1; j++) {
            positions.push([i - 1 - shift + j, shift - j]);
        }
        shift -= jj;
        shiftOrigin += jj;
        return p4;
    });
    positions.push([normalized.length, shift]);
    return [normalized, positions, hasDiacritics];
}
function getOriginalIndex(diffs, pos, len) {
    if (!diffs) {
        return [pos, len];
    }
    const start = pos;
    const end = pos + len;
    let i = binarySearchFirstItem(diffs, (x) => x[0] >= start);
    if (diffs[i][0] > start) {
        --i;
    }
    let j = binarySearchFirstItem(diffs, (x) => x[0] >= end, i);
    if (diffs[j][0] > end) {
        --j;
    }
    return [start + diffs[i][1], len + diffs[j][1] - diffs[i][1]];
}
class PDFFindController {
    constructor({ linkService, eventBus }) {
        this._linkService = linkService;
        this._eventBus = eventBus;
        this._reset();
        eventBus._on('find', this._onFind.bind(this));
        eventBus._on('findbarclose', this._onFindBarClose.bind(this));
        this.executeCommand = (cmd, state) => {
            console.error(
                'Deprecated method `PDFFindController.executeCommand` called, ' +
                    'please dispatch a "find"-event using the EventBus instead.'
            );
            const eventState = Object.assign(Object.create(null), state, { type: cmd.substring('find'.length) });
            this._onFind(eventState);
        };
    }
    get highlightMatches() {
        return this._highlightMatches;
    }
    get pageMatches() {
        return this._pageMatches;
    }
    get pageMatchesLength() {
        return this._pageMatchesLength;
    }
    get selected() {
        return this._selected;
    }
    get state() {
        return this._state;
    }
    setDocument(pdfDocument) {
        if (this._pdfDocument) {
            this._reset();
        }
        if (!pdfDocument) {
            return;
        }
        this._pdfDocument = pdfDocument;
        this._firstPageCapability.resolve();
    }
    _onFind(state) {
        if (!state) {
            return;
        }
        const pdfDocument = this._pdfDocument;
        const { type } = state;
        if (this._state === null || this._shouldDirtyMatch(state)) {
            this._dirtyMatch = true;
        }
        this._state = state;
        if (type !== 'highlightallchange') {
            this._updateUIState(FindState.PENDING);
        }
        this._firstPageCapability.promise.then(() => {
            if (!this._pdfDocument || (pdfDocument && this._pdfDocument !== pdfDocument)) {
                return;
            }
            this._extractText();
            const findbarClosed = !this._highlightMatches;
            const pendingTimeout = !!this._findTimeout;
            if (this._findTimeout) {
                clearTimeout(this._findTimeout);
                this._findTimeout = null;
            }
            if (!type) {
                this._findTimeout = setTimeout(() => {
                    this._nextMatch();
                    this._findTimeout = null;
                }, FIND_TIMEOUT);
            } else if (this._dirtyMatch) {
                this._nextMatch();
            } else if (type === 'again') {
                this._nextMatch();
                if (findbarClosed && this._state.highlightAll) {
                    this._updateAllPages();
                }
            } else if (type === 'highlightallchange') {
                if (pendingTimeout) {
                    this._nextMatch();
                } else {
                    this._highlightMatches = true;
                }
                this._updateAllPages();
            } else {
                this._nextMatch();
            }
        });
    }

    scrollMatchIntoView({ element = null, selectedLeft = 0, pageIndex = -1, matchIndex = -1 }) {
        if (!this._scrollMatches || !element) {
            return;
        } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
            return;
        } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
            return;
        }
        this._scrollMatches = false;
        const spot = {
            top: MATCH_SCROLL_OFFSET_TOP,
            left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT,
        };
        scrollIntoView(element, spot, true);
    }
    _reset() {
        this._highlightMatches = false;
        this._scrollMatches = false;
        this._pdfDocument = null;
        this._pageMatches = [];
        this._pageMatchesLength = [];
        this._state = null;
        this._selected = {
            pageIdx: -1,
            matchIdx: -1,
        };
        this._offset = {
            pageIdx: null,
            matchIdx: null,
            wrapped: false,
        };
        this._extractTextPromises = [];
        this._pageContents = [];
        this._pageDiffs = [];
        this._hasDiacritics = [];
        this._matchesCountTotal = 0;
        this._pagesToSearch = null;
        this._pendingFindMatches = new Set();
        this._resumePageIdx = null;
        this._dirtyMatch = false;
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
        this._firstPageCapability = createPromiseCapability();
    }
    get _query() {
        if (this._state.query !== this._rawQuery) {
            this._rawQuery = this._state.query;
            [this._normalizedQuery] = normalize(this._state.query);
        }
        return this._normalizedQuery;
    }
    _shouldDirtyMatch(state) {
        if (state.query !== this._state.query) {
            return true;
        }
        switch (state.type) {
            case 'again':
                const pageNumber = this._selected.pageIdx + 1;
                const linkService = this._linkService;
                if (
                    pageNumber >= 1 &&
                    pageNumber <= linkService.pagesCount &&
                    pageNumber !== linkService.page &&
                    !linkService.isPageVisible(pageNumber)
                ) {
                    return true;
                }
                return false;
            case 'highlightallchange':
                return false;
        }
        return true;
    }
    _isEntireWord(content, startIdx, length) {
        let match = content.slice(0, startIdx).match(NOT_DIACRITIC_FROM_END_REG_EXP);
        if (match) {
            const first = content.charCodeAt(startIdx);
            const limit = match[1].charCodeAt(0);
            if (getCharacterType(first) === getCharacterType(limit)) {
                return false;
            }
        }
        match = content.slice(startIdx + length).match(NOT_DIACRITIC_FROM_START_REG_EXP);
        if (match) {
            const last = content.charCodeAt(startIdx + length - 1);
            const limit = match[1].charCodeAt(0);
            if (getCharacterType(last) === getCharacterType(limit)) {
                return false;
            }
        }
        return true;
    }
    _calculateRegExpMatch(query, entireWord, pageIndex, pageContent, sdpdfcoreRequestId = -1) {
        const matches = [],
            matchesLength = [],
            matchesDigests = [];
        let id = 0;
        const diffs = this._pageDiffs[pageIndex];
        let match;
        if (sdpdfcoreRequestId != (this._state.sdpdfcoreRequestId || -1)) return;
        while ((match = query.exec(pageContent)) !== null) {
            if (entireWord && !this._isEntireWord(pageContent, match.index, match[0].length)) {
                continue;
            }
            const [matchPos, matchLen] = getOriginalIndex(diffs, match.index, match[0].length);
            if (matchLen) {
                matches.push(matchPos);
                matchesLength.push(matchLen);
                const predigest = match.input.substring(match.index - 50 > 0 ? match.index - 50 : 0, match.index);
                const middigest = match.input.substring(match.index, match.index + match[0].length);
                const aftdigest = match.input.substring(
                    match.index + match[0].length,
                    match.index + match[0].length + 50 < match.input.length
                        ? match.index + match[0].length + 50
                        : match.input.length - 1
                );
                matchesDigests.push({
                    pageIndex,
                    matchIndex: id,
                    digestHtml: `${predigest}<span class="__searchHighLight">${middigest}</span>${aftdigest}`,
                });
                id++;
            }
        }

        this._pageMatches[pageIndex] = matches;
        this._pageMatchesLength[pageIndex] = matchesLength;
        if (matches.length != 0) {
            window.__sdJSBridge &&
                __sdJSBridge.publish('find_digests', {
                    requestId: sdpdfcoreRequestId,
                    pageIndex,
                    matchesDigests,
                    matches,
                });
        }
    }
    _convertToRegExpString(query, hasDiacritics) {
        const { matchDiacritics } = this._state;
        let isUnicode = false;
        query = query.replace(SPECIAL_CHARS_REG_EXP, (match, p1, p2, p3, p4, p5) => {
            if (p1) {
                return `[ ]*\\${p1}[ ]*`;
            }
            if (p2) {
                return `[ ]*${p2}[ ]*`;
            }
            if (p3) {
                return '[ ]+';
            }
            if (matchDiacritics) {
                return p4 || p5;
            }
            if (p4) {
                return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : '';
            }
            if (hasDiacritics) {
                isUnicode = true;
                return `${p5}\\p{M}*`;
            }
            return p5;
        });
        const trailingSpaces = '[ ]*';
        if (query.endsWith(trailingSpaces)) {
            query = query.slice(0, query.length - trailingSpaces.length);
        }
        if (matchDiacritics) {
            if (hasDiacritics) {
                isUnicode = true;
                query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\p{M}]|$)`;
            }
        }
        return [isUnicode, query];
    }
    _calculateMatch(pageIndex, sdpdfcoreRequestId = -1) {
        if (sdpdfcoreRequestId != (this._state.sdpdfcoreRequestId || -1)) return;
        let query = this._query;
        if (query.length === 0) {
            return;
        }
        const { caseSensitive, entireWord, phraseSearch } = this._state;
        const pageContent = this._pageContents[pageIndex];
        const hasDiacritics = this._hasDiacritics[pageIndex];
        let isUnicode = false;
        if (phraseSearch) {
            [isUnicode, query] = this._convertToRegExpString(query, hasDiacritics);
        } else {
            const match = query.match(/\S+/g);
            if (match) {
                query = match
                    .sort()
                    .reverse()
                    .map((q) => {
                        const [isUnicodePart, queryPart] = this._convertToRegExpString(q, hasDiacritics);
                        isUnicode ||= isUnicodePart;
                        return `(${queryPart})`;
                    })
                    .join('|');
            }
        }
        const flags = `g${isUnicode ? 'u' : ''}${caseSensitive ? '' : 'i'}`;
        query = new RegExp(query, flags);
        this._calculateRegExpMatch(query, entireWord, pageIndex, pageContent, sdpdfcoreRequestId);
        if (this._state.highlightAll) {
            this._updatePage(pageIndex);
        }
        if (this._resumePageIdx === pageIndex) {
            this._resumePageIdx = null;
            this._nextPageMatch();
        }
        const pageMatchesCount = this._pageMatches[pageIndex].length;
        if (pageMatchesCount > 0) {
            this._matchesCountTotal += pageMatchesCount;
            this._updateUIResultsCount();
        }
    }
    _extractText() {
        if (this._extractTextPromises.length > 0) {
            return;
        }
        let promise = Promise.resolve();
        for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
            const extractTextCapability = createPromiseCapability();
            this._extractTextPromises[i] = extractTextCapability.promise;
            promise = promise.then(() => {
                return this._pdfDocument
                    .getPage(i + 1)
                    .then((pdfPage) => {
                        return pdfPage.getTextContent();
                    })
                    .then(
                        (textContent) => {
                            const textItems = textContent.items;
                            const strBuf = [];
                            for (let j = 0, jj = textItems.length; j < jj; j++) {
                                strBuf.push(textItems[j].str);
                                if (textItems[j].hasEOL) {
                                    strBuf.push('\n');
                                }
                            }
                            [this._pageContents[i], this._pageDiffs[i], this._hasDiacritics[i]] = normalize(
                                strBuf.join('')
                            );
                            extractTextCapability.resolve(i);
                        },
                        (reason) => {
                            console.error(`Unable to get text content for page ${i + 1}`, reason);
                            this._pageContents[i] = '';
                            this._pageDiffs[i] = null;
                            this._hasDiacritics[i] = false;
                            extractTextCapability.resolve(i);
                        }
                    );
            });
        }
    }
    _updatePage(index) {
        if (this._scrollMatches && this._selected.pageIdx === index) {
            this._linkService.page = index + 1;
        }
        this._eventBus.dispatch('updatetextlayermatches', {
            source: this,
            pageIndex: index,
        });
    }
    _updateAllPages() {
        this._eventBus.dispatch('updatetextlayermatches', {
            source: this,
            pageIndex: -1,
        });
    }

    // sdpdfcore
    _gotoMatch(p, m) {
        this._scrollMatches = true;
        this.selected.pageIdx = p;
        this.selected.matchIdx = m;
        this._selected.pageIdx = p;
        this._selected.matchIdx = m;
        this._offset.pageIdx = p;
        this._offset.matchIdx = m;
        this._offset.wrapped = false;
        this._updatePage(p);
        this._updateUIResultsCount();
    }

    _nextMatch() {
        const previous = this._state.findPrevious;
        const currentPageIndex = this._linkService.page - 1;
        const numPages = this._linkService.pagesCount;
        this._highlightMatches = true;
        const sdpdfcoreRequestId = this._state.sdpdfcoreRequestId || -1;
        if (this._dirtyMatch) {
            this._dirtyMatch = false;
            this._selected.pageIdx = this._selected.matchIdx = -1;
            this._offset.pageIdx = currentPageIndex;
            this._offset.matchIdx = null;
            this._offset.wrapped = false;
            this._resumePageIdx = null;
            this._pageMatches.length = 0;
            this._pageMatchesLength.length = 0;
            this._matchesCountTotal = 0;
            this._updateAllPages();
            for (let i = 0; i < numPages; i++) {
                if (this._pendingFindMatches.has(i)) {
                    continue;
                }
                this._pendingFindMatches.add(i);
                this._extractTextPromises[i].then((pageIdx) => {
                    this._pendingFindMatches.delete(pageIdx);
                    this._calculateMatch(pageIdx, sdpdfcoreRequestId);
                });
            }
        }
        if (this._query === '') {
            this._updateUIState(FindState.FOUND);
            return;
        }
        if (this._resumePageIdx) {
            return;
        }
        const offset = this._offset;
        this._pagesToSearch = numPages;
        if (offset.matchIdx !== null) {
            const numPageMatches = this._pageMatches[offset.pageIdx].length;
            if ((!previous && offset.matchIdx + 1 < numPageMatches) || (previous && offset.matchIdx > 0)) {
                offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;
                this._updateMatch(true);
                return;
            }
            this._advanceOffsetPage(previous);
        }
        this._nextPageMatch();
    }

    _matchesReady(matches) {
        const offset = this._offset;
        const numMatches = matches.length;
        const previous = this._state.findPrevious;
        if (numMatches) {
            offset.matchIdx = previous ? numMatches - 1 : 0;
            this._updateMatch(true);
            return true;
        }
        this._advanceOffsetPage(previous);
        if (offset.wrapped) {
            offset.matchIdx = null;
            if (this._pagesToSearch < 0) {
                this._updateMatch(false);
                return true;
            }
        }
        return false;
    }
    _nextPageMatch() {
        if (this._resumePageIdx !== null) {
            console.error('There can only be one pending page.');
        }
        let matches = null;
        do {
            const pageIdx = this._offset.pageIdx;
            matches = this._pageMatches[pageIdx];
            if (!matches) {
                this._resumePageIdx = pageIdx;
                break;
            }
        } while (!this._matchesReady(matches));
    }

    _advanceOffsetPage(previous) {
        const offset = this._offset;
        const numPages = this._linkService.pagesCount;
        offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
        offset.matchIdx = null;
        this._pagesToSearch--;
        if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
            offset.pageIdx = previous ? numPages - 1 : 0;
            offset.wrapped = true;
        }
    }
    _updateMatch(found = false) {
        let state = FindState.NOT_FOUND;
        const wrapped = this._offset.wrapped;
        this._offset.wrapped = false;
        if (found) {
            const previousPage = this._selected.pageIdx;
            this._selected.pageIdx = this._offset.pageIdx;
            this._selected.matchIdx = this._offset.matchIdx;
            state = wrapped ? FindState.WRAPPED : FindState.FOUND;
            if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
                this._updatePage(previousPage);
            }
        }
        this._updateUIState(state, this._state.findPrevious);
        if (this._selected.pageIdx !== -1) {
            this._scrollMatches = true;
            this._updatePage(this._selected.pageIdx);
        }
    }
    _onFindBarClose(evt) {
        const pdfDocument = this._pdfDocument;
        this._firstPageCapability.promise.then(() => {
            if (!this._pdfDocument || (pdfDocument && this._pdfDocument !== pdfDocument)) {
                return;
            }
            if (this._findTimeout) {
                clearTimeout(this._findTimeout);
                this._findTimeout = null;
            }
            if (this._resumePageIdx) {
                this._resumePageIdx = null;
                this._dirtyMatch = true;
            }
            this._updateUIState(FindState.FOUND);
            this._highlightMatches = false;
            this._updateAllPages();
        });
    }
    _requestMatchesCount() {
        const { pageIdx, matchIdx } = this._selected;
        let current = 0,
            total = this._matchesCountTotal;
        if (matchIdx !== -1) {
            for (let i = 0; i < pageIdx; i++) {
                current += this._pageMatches[i]?.length || 0;
            }
            current += matchIdx + 1;
        }
        if (current < 1 || current > total) {
            current = total = 0;
        }
        return {
            current,
            total,
        };
    }
    _updateUIResultsCount() {
        this._eventBus.dispatch('updatefindmatchescount', {
            source: this,
            matchesCount: this._requestMatchesCount(),
        });
        window.__sdJSBridge && window.__sdJSBridge.publish('find_matchCount', this._requestMatchesCount());
    }
    _updateUIState(state, previous = false) {
        console.log('sdpdfcore updatefindcontrolstate', {
            source: this,
            state,
            previous,
            matchesCount: this._requestMatchesCount(),
            rawQuery: this._state?.query ?? null,
        });
        this._eventBus.dispatch('updatefindcontrolstate', {
            source: this,
            state,
            previous,
            matchesCount: this._requestMatchesCount(),
            rawQuery: this._state?.query ?? null,
        });
    }
}



/***/ }),

/***/ "./src/pdf_find_utils.js":
/*!*******************************!*\
  !*** ./src/pdf_find_utils.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharacterType": function() { return /* binding */ CharacterType; },
/* harmony export */   "getCharacterType": function() { return /* binding */ getCharacterType; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const CharacterType = {
 SPACE: 0,
 ALPHA_LETTER: 1,
 PUNCT: 2,
 HAN_LETTER: 3,
 KATAKANA_LETTER: 4,
 HIRAGANA_LETTER: 5,
 HALFWIDTH_KATAKANA_LETTER: 6,
 THAI_LETTER: 7
};
function isAlphabeticalScript(charCode) {
 return charCode < 0x2e80;
}
function isAscii(charCode) {
 return (charCode & 0xff80) === 0;
}
function isAsciiAlpha(charCode) {
 return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;
}
function isAsciiDigit(charCode) {
 return charCode >= 0x30 && charCode <= 0x39;
}
function isAsciiSpace(charCode) {
 return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;
}
function isHan(charCode) {
 return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;
}
function isKatakana(charCode) {
 return charCode >= 0x30a0 && charCode <= 0x30ff;
}
function isHiragana(charCode) {
 return charCode >= 0x3040 && charCode <= 0x309f;
}
function isHalfwidthKatakana(charCode) {
 return charCode >= 0xff60 && charCode <= 0xff9f;
}
function isThai(charCode) {
 return (charCode & 0xff80) === 0x0e00;
}
function getCharacterType(charCode) {
 if (isAlphabeticalScript(charCode)) {
  if (isAscii(charCode)) {
   if (isAsciiSpace(charCode)) {
    return CharacterType.SPACE;
   } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {
    return CharacterType.ALPHA_LETTER;
   }
   return CharacterType.PUNCT;
  } else if (isThai(charCode)) {
   return CharacterType.THAI_LETTER;
  } else if (charCode === 0xa0) {
   return CharacterType.SPACE;
  }
  return CharacterType.ALPHA_LETTER;
 }
 if (isHan(charCode)) {
  return CharacterType.HAN_LETTER;
 } else if (isKatakana(charCode)) {
  return CharacterType.KATAKANA_LETTER;
 } else if (isHiragana(charCode)) {
  return CharacterType.HIRAGANA_LETTER;
 } else if (isHalfwidthKatakana(charCode)) {
  return CharacterType.HALFWIDTH_KATAKANA_LETTER;
 }
 return CharacterType.ALPHA_LETTER;
}



/***/ }),

/***/ "./src/pdf_history.js":
/*!****************************!*\
  !*** ./src/pdf_history.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isDestArraysEqual": function() { return /* binding */ isDestArraysEqual; },
/* harmony export */   "isDestHashesEqual": function() { return /* binding */ isDestHashesEqual; },
/* harmony export */   "PDFHistory": function() { return /* binding */ PDFHistory; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {isValidRotation, parseQueryString} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const {waitOnEventOrTimeout} = __webpack_require__(/*! ./event_utils.js */ "./src/event_utils.js");
const HASH_CHANGE_TIMEOUT = 1000;
const POSITION_UPDATED_THRESHOLD = 50;
const UPDATE_VIEWAREA_TIMEOUT = 1000;
function getCurrentHash() {
 return document.location.hash;
}
class PDFHistory {
 constructor({linkService, eventBus}) {
  this.linkService = linkService;
  this.eventBus = eventBus;
  this._initialized = false;
  this._fingerprint = "";
  this.reset();
  this._boundEvents = null;

  this.eventBus._on("pagesinit", () => {
   this._isPagesLoaded = false;
   this.eventBus._on("pagesloaded", evt => {
    this._isPagesLoaded = !!evt.pagesCount;
   }, { once: true });
  });
 }
 initialize({fingerprint, resetHistory = false, updateUrl = false}) {
  if (!fingerprint || typeof fingerprint !== "string") {
   console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
   return;
  }
  if (this._initialized) {
   this.reset();
  }
  const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
  this._fingerprint = fingerprint;
  this._updateUrl = updateUrl === true;
  this._initialized = true;
  this._bindEvents();
  const state = window.history.state;
  this._popStateInProgress = false;
  this._blockHashChange = 0;
  this._currentHash = getCurrentHash();
  this._numPositionUpdates = 0;
  this._uid = this._maxUid = 0;
  this._destination = null;
  this._position = null;
  if (!this._isValidState(state, true) || resetHistory) {
   const {hash, page, rotation} = this._parseCurrentHash(true);
   if (!hash || reInitialized || resetHistory) {
    this._pushOrReplaceState(null, true);
    return;
   }
   this._pushOrReplaceState({
    hash,
    page,
    rotation
   }, true);
   return;
  }
  const destination = state.destination;
  this._updateInternalState(destination, state.uid, true);
  if (destination.rotation !== undefined) {
   this._initialRotation = destination.rotation;
  }
  if (destination.dest) {
   this._initialBookmark = JSON.stringify(destination.dest);
   this._destination.page = null;
  } else if (destination.hash) {
   this._initialBookmark = destination.hash;
  } else if (destination.page) {
   this._initialBookmark = `page=${ destination.page }`;
  }
 }
 reset() {
  if (this._initialized) {
   this._pageHide();
   this._initialized = false;
   this._unbindEvents();
  }
  if (this._updateViewareaTimeout) {
   clearTimeout(this._updateViewareaTimeout);
   this._updateViewareaTimeout = null;
  }
  this._initialBookmark = null;
  this._initialRotation = null;
 }
 push({namedDest = null, explicitDest, pageNumber}) {
  if (!this._initialized) {
   return;
  }
  if (namedDest && typeof namedDest !== "string") {
   console.error("PDFHistory.push: " + `"${ namedDest }" is not a valid namedDest parameter.`);
   return;
  } else if (!Array.isArray(explicitDest)) {
   console.error("PDFHistory.push: " + `"${ explicitDest }" is not a valid explicitDest parameter.`);
   return;
  } else if (!this._isValidPage(pageNumber)) {
   if (pageNumber !== null || this._destination) {
    console.error("PDFHistory.push: " + `"${ pageNumber }" is not a valid pageNumber parameter.`);
    return;
   }
  }
  const hash = namedDest || JSON.stringify(explicitDest);
  if (!hash) {
   return;
  }
  let forceReplace = false;
  if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
   if (this._destination.page) {
    return;
   }
   forceReplace = true;
  }
  if (this._popStateInProgress && !forceReplace) {
   return;
  }
  this._pushOrReplaceState({
   dest: explicitDest,
   hash,
   page: pageNumber,
   rotation: this.linkService.rotation
  }, forceReplace);
  if (!this._popStateInProgress) {
   this._popStateInProgress = true;
   Promise.resolve().then(() => {
    this._popStateInProgress = false;
   });
  }
 }
 pushPage(pageNumber) {
  if (!this._initialized) {
   return;
  }
  if (!this._isValidPage(pageNumber)) {
   console.error(`PDFHistory.pushPage: "${ pageNumber }" is not a valid page number.`);
   return;
  }
  if (this._destination?.page === pageNumber) {
   return;
  }
  if (this._popStateInProgress) {
   return;
  }
  this._pushOrReplaceState({
   dest: null,
   hash: `page=${ pageNumber }`,
   page: pageNumber,
   rotation: this.linkService.rotation
  });
  if (!this._popStateInProgress) {
   this._popStateInProgress = true;
   Promise.resolve().then(() => {
    this._popStateInProgress = false;
   });
  }
 }
 pushCurrentPosition() {
  if (!this._initialized || this._popStateInProgress) {
   return;
  }
  this._tryPushCurrentPosition();
 }
 back() {
  if (!this._initialized || this._popStateInProgress) {
   return;
  }
  const state = window.history.state;
  if (this._isValidState(state) && state.uid > 0) {
   window.history.back();
  }
 }
 forward() {
  if (!this._initialized || this._popStateInProgress) {
   return;
  }
  const state = window.history.state;
  if (this._isValidState(state) && state.uid < this._maxUid) {
   window.history.forward();
  }
 }
 get popStateInProgress() {
  return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
 }
 get initialBookmark() {
  return this._initialized ? this._initialBookmark : null;
 }
 get initialRotation() {
  return this._initialized ? this._initialRotation : null;
 }
 _pushOrReplaceState(destination, forceReplace = false) {
  const shouldReplace = forceReplace || !this._destination;
  const newState = {
   fingerprint: this._fingerprint,
   uid: shouldReplace ? this._uid : this._uid + 1,
   destination
  };
  this._updateInternalState(destination, newState.uid);
  let newUrl;
  if (this._updateUrl && destination?.hash) {
   const baseUrl = document.location.href.split("#")[0];
   if (!baseUrl.startsWith("file://")) {
    newUrl = `${ baseUrl }#${ destination.hash }`;
   }
  }
  if (shouldReplace) {
   window.history.replaceState(newState, "", newUrl);
  } else {
   window.history.pushState(newState, "", newUrl);
  }
 }
 _tryPushCurrentPosition(temporary = false) {
  if (!this._position) {
   return;
  }
  let position = this._position;
  if (temporary) {
   position = Object.assign(Object.create(null), this._position);
   position.temporary = true;
  }
  if (!this._destination) {
   this._pushOrReplaceState(position);
   return;
  }
  if (this._destination.temporary) {
   this._pushOrReplaceState(position, true);
   return;
  }
  if (this._destination.hash === position.hash) {
   return;
  }
  if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
   return;
  }
  let forceReplace = false;
  if (this._destination.page >= position.first && this._destination.page <= position.page) {
   if (this._destination.dest !== undefined || !this._destination.first) {
    return;
   }
   forceReplace = true;
  }
  this._pushOrReplaceState(position, forceReplace);
 }
 _isValidPage(val) {
  return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;
 }
 _isValidState(state, checkReload = false) {
  if (!state) {
   return false;
  }
  if (state.fingerprint !== this._fingerprint) {
   if (checkReload) {
    if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
     return false;
    }
    const [perfEntry] = performance.getEntriesByType("navigation");
    if (perfEntry?.type !== "reload") {
     return false;
    }
   } else {
    return false;
   }
  }
  if (!Number.isInteger(state.uid) || state.uid < 0) {
   return false;
  }
  if (state.destination === null || typeof state.destination !== "object") {
   return false;
  }
  return true;
 }
 _updateInternalState(destination, uid, removeTemporary = false) {
  if (this._updateViewareaTimeout) {
   clearTimeout(this._updateViewareaTimeout);
   this._updateViewareaTimeout = null;
  }
  if (removeTemporary && destination?.temporary) {
   delete destination.temporary;
  }
  this._destination = destination;
  this._uid = uid;
  this._maxUid = Math.max(this._maxUid, uid);
  this._numPositionUpdates = 0;
 }
 _parseCurrentHash(checkNameddest = false) {
  const hash = unescape(getCurrentHash()).substring(1);
  const params = parseQueryString(hash);
  const nameddest = params.get("nameddest") || "";
  let page = params.get("page") | 0;
  if (!this._isValidPage(page) || checkNameddest && nameddest.length > 0) {
   page = null;
  }
  return {
   hash,
   page,
   rotation: this.linkService.rotation
  };
 }
 _updateViewarea({location}) {
  if (this._updateViewareaTimeout) {
   clearTimeout(this._updateViewareaTimeout);
   this._updateViewareaTimeout = null;
  }
  this._position = {
   hash:  location.pdfOpenParams.substring(1),
   page: this.linkService.page,
   first: location.pageNumber,
   rotation: location.rotation
  };
  if (this._popStateInProgress) {
   return;
  }
  if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
   this._numPositionUpdates++;
  }
  if (UPDATE_VIEWAREA_TIMEOUT > 0) {
   this._updateViewareaTimeout = setTimeout(() => {
    if (!this._popStateInProgress) {
     this._tryPushCurrentPosition(true);
    }
    this._updateViewareaTimeout = null;
   }, UPDATE_VIEWAREA_TIMEOUT);
  }
 }
 _popState({state}) {
  const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash;
  this._currentHash = newHash;
  if (!state) {
   this._uid++;
   const {hash, page, rotation} = this._parseCurrentHash();
   this._pushOrReplaceState({
    hash,
    page,
    rotation
   }, true);
   return;
  }
  if (!this._isValidState(state)) {
   return;
  }
  this._popStateInProgress = true;
  if (hashChanged) {
   this._blockHashChange++;
   waitOnEventOrTimeout({
    target: window,
    name: "hashchange",
    delay: HASH_CHANGE_TIMEOUT
   }).then(() => {
    this._blockHashChange--;
   });
  }
  const destination = state.destination;
  this._updateInternalState(destination, state.uid, true);
  if (isValidRotation(destination.rotation)) {
   this.linkService.rotation = destination.rotation;
  }
  if (destination.dest) {
   this.linkService.goToDestination(destination.dest);
  } else if (destination.hash) {
   this.linkService.setHash(destination.hash);
  } else if (destination.page) {
   this.linkService.page = destination.page;
  }
  Promise.resolve().then(() => {
   this._popStateInProgress = false;
  });
 }
 _pageHide() {
  if (!this._destination || this._destination.temporary) {
   this._tryPushCurrentPosition();
  }
 }
 _bindEvents() {
  if (this._boundEvents) {
   return;
  }
  this._boundEvents = {
   updateViewarea: this._updateViewarea.bind(this),
   popState: this._popState.bind(this),
   pageHide: this._pageHide.bind(this)
  };
  this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);
  window.addEventListener("popstate", this._boundEvents.popState);
  window.addEventListener("pagehide", this._boundEvents.pageHide);
 }
 _unbindEvents() {
  if (!this._boundEvents) {
   return;
  }
  this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);
  window.removeEventListener("popstate", this._boundEvents.popState);
  window.removeEventListener("pagehide", this._boundEvents.pageHide);
  this._boundEvents = null;
 }
}
function isDestHashesEqual(destHash, pushHash) {
 if (typeof destHash !== "string" || typeof pushHash !== "string") {
  return false;
 }
 if (destHash === pushHash) {
  return true;
 }
 const nameddest = parseQueryString(destHash).get("nameddest");
 if (nameddest === pushHash) {
  return true;
 }
 return false;
}
function isDestArraysEqual(firstDest, secondDest) {
 function isEntryEqual(first, second) {
  if (typeof first !== typeof second) {
   return false;
  }
  if (Array.isArray(first) || Array.isArray(second)) {
   return false;
  }
  if (first !== null && typeof first === "object" && second !== null) {
   if (Object.keys(first).length !== Object.keys(second).length) {
    return false;
   }
   for (const key in first) {
    if (!isEntryEqual(first[key], second[key])) {
     return false;
    }
   }
   return true;
  }
  return first === second || Number.isNaN(first) && Number.isNaN(second);
 }
 if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
  return false;
 }
 if (firstDest.length !== secondDest.length) {
  return false;
 }
 for (let i = 0, ii = firstDest.length; i < ii; i++) {
  if (!isEntryEqual(firstDest[i], secondDest[i])) {
   return false;
  }
 }
 return true;
}



/***/ }),

/***/ "./src/pdf_link_service.js":
/*!*********************************!*\
  !*** ./src/pdf_link_service.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkTarget": function() { return /* binding */ LinkTarget; },
/* harmony export */   "PDFLinkService": function() { return /* binding */ PDFLinkService; },
/* harmony export */   "SimpleLinkService": function() { return /* binding */ SimpleLinkService; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {parseQueryString, removeNullCharacters} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
const LinkTarget = {
 NONE: 0,
 SELF: 1,
 BLANK: 2,
 PARENT: 3,
 TOP: 4
};
function addLinkAttributes(link, {url, target, rel, enabled = true} = {}) {
 if (!url || typeof url !== "string") {
  throw new Error('A valid "url" parameter must provided.');
 }
 const urlNullRemoved = removeNullCharacters(url);
 if (enabled) {
  link.href = link.title = urlNullRemoved;
 } else {
  link.href = "";
  link.title = `Disabled: ${ urlNullRemoved }`;
  link.onclick = () => {
   return false;
  };
 }
 let targetStr = "";
 switch (target) {
 case LinkTarget.NONE:
  break;
 case LinkTarget.SELF:
  targetStr = "_self";
  break;
 case LinkTarget.BLANK:
  targetStr = "_blank";
  break;
 case LinkTarget.PARENT:
  targetStr = "_parent";
  break;
 case LinkTarget.TOP:
  targetStr = "_top";
  break;
 }
 link.target = targetStr;
 link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
}
class PDFLinkService {
 #pagesRefCache = new Map();
 constructor({eventBus, externalLinkTarget = null, externalLinkRel = null, ignoreDestinationZoom = false} = {}) {
  this.eventBus = eventBus;
  this.externalLinkTarget = externalLinkTarget;
  this.externalLinkRel = externalLinkRel;
  this.externalLinkEnabled = true;
  this._ignoreDestinationZoom = ignoreDestinationZoom;
  this.baseUrl = null;
  this.pdfDocument = null;
  this.pdfViewer = null;
  this.pdfHistory = null;
 }
 setDocument(pdfDocument, baseUrl = null) {
  this.baseUrl = baseUrl;
  this.pdfDocument = pdfDocument;
  this.#pagesRefCache.clear();
 }
 setViewer(pdfViewer) {
  this.pdfViewer = pdfViewer;
 }
 setHistory(pdfHistory) {
  this.pdfHistory = pdfHistory;
 }
 get pagesCount() {
  return this.pdfDocument ? this.pdfDocument.numPages : 0;
 }
 get page() {
  return this.pdfViewer.currentPageNumber;
 }
 set page(value) {
  this.pdfViewer.currentPageNumber = value;
 }
 get rotation() {
  return this.pdfViewer.pagesRotation;
 }
 set rotation(value) {
  this.pdfViewer.pagesRotation = value;
 }
 #goToDestinationHelper(rawDest, namedDest = null, explicitDest) {
  const destRef = explicitDest[0];
  let pageNumber;
  if (typeof destRef === "object" && destRef !== null) {
   pageNumber = this._cachedPageNumber(destRef);
   if (!pageNumber) {
    this.pdfDocument.getPageIndex(destRef).then(pageIndex => {
     this.cachePageRef(pageIndex + 1, destRef);
     this.#goToDestinationHelper(rawDest, namedDest, explicitDest);
    }).catch(() => {
     console.error(`PDFLinkService.#goToDestinationHelper: "${ destRef }" is not ` + `a valid page reference, for dest="${ rawDest }".`);
    });
    return;
   }
  } else if (Number.isInteger(destRef)) {
   pageNumber = destRef + 1;
  } else {
   console.error(`PDFLinkService.#goToDestinationHelper: "${ destRef }" is not ` + `a valid destination reference, for dest="${ rawDest }".`);
   return;
  }
  if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
   console.error(`PDFLinkService.#goToDestinationHelper: "${ pageNumber }" is not ` + `a valid page number, for dest="${ rawDest }".`);
   return;
  }
  if (this.pdfHistory) {
   this.pdfHistory.pushCurrentPosition();
   this.pdfHistory.push({
    namedDest,
    explicitDest,
    pageNumber
   });
  }
  this.pdfViewer.scrollPageIntoView({
   pageNumber,
   destArray: explicitDest,
   ignoreDestinationZoom: this._ignoreDestinationZoom
  });
 }
 async goToDestination(dest) {
  if (!this.pdfDocument) {
   return;
  }
  let namedDest, explicitDest;
  if (typeof dest === "string") {
   namedDest = dest;
   explicitDest = await this.pdfDocument.getDestination(dest);
  } else {
   namedDest = null;
   explicitDest = await dest;
  }
  if (!Array.isArray(explicitDest)) {
   console.error(`PDFLinkService.goToDestination: "${ explicitDest }" is not ` + `a valid destination array, for dest="${ dest }".`);
   return;
  }
  this.#goToDestinationHelper(dest, namedDest, explicitDest);
 }
 goToPage(val) {
  if (!this.pdfDocument) {
   return;
  }
  const pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;
  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
   console.error(`PDFLinkService.goToPage: "${ val }" is not a valid page.`);
   return;
  }
  if (this.pdfHistory) {
   this.pdfHistory.pushCurrentPosition();
   this.pdfHistory.pushPage(pageNumber);
  }
  this.pdfViewer.scrollPageIntoView({ pageNumber });
 }
 addLinkAttributes(link, url, newWindow = false) {
  addLinkAttributes(link, {
   url,
   target: newWindow ? LinkTarget.BLANK : this.externalLinkTarget,
   rel: this.externalLinkRel,
   enabled: this.externalLinkEnabled
  });
 }
 getDestinationHash(dest) {
  if (typeof dest === "string") {
   if (dest.length > 0) {
    return this.getAnchorUrl("#" + escape(dest));
   }
  } else if (Array.isArray(dest)) {
   const str = JSON.stringify(dest);
   if (str.length > 0) {
    return this.getAnchorUrl("#" + escape(str));
   }
  }
  return this.getAnchorUrl("");
 }
 getAnchorUrl(anchor) {
  return (this.baseUrl || "") + anchor;
 }
 setHash(hash) {
  if (!this.pdfDocument) {
   return;
  }
  let pageNumber, dest;
  if (hash.includes("=")) {
   const params = parseQueryString(hash);
   if (params.has("search")) {
    this.eventBus.dispatch("findfromurlhash", {
     source: this,
     query: params.get("search").replace(/"/g, ""),
     phraseSearch: params.get("phrase") === "true"
    });
   }
   if (params.has("page")) {
    pageNumber = params.get("page") | 0 || 1;
   }
   if (params.has("zoom")) {
    const zoomArgs = params.get("zoom").split(",");
    const zoomArg = zoomArgs[0];
    const zoomArgNumber = parseFloat(zoomArg);
    if (!zoomArg.includes("Fit")) {
     dest = [
      null,
      { name: "XYZ" },
      zoomArgs.length > 1 ? zoomArgs[1] | 0 : null,
      zoomArgs.length > 2 ? zoomArgs[2] | 0 : null,
      zoomArgNumber ? zoomArgNumber / 100 : zoomArg
     ];
    } else {
     if (zoomArg === "Fit" || zoomArg === "FitB") {
      dest = [
       null,
       { name: zoomArg }
      ];
     } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
      dest = [
       null,
       { name: zoomArg },
       zoomArgs.length > 1 ? zoomArgs[1] | 0 : null
      ];
     } else if (zoomArg === "FitR") {
      if (zoomArgs.length !== 5) {
       console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
      } else {
       dest = [
        null,
        { name: zoomArg },
        zoomArgs[1] | 0,
        zoomArgs[2] | 0,
        zoomArgs[3] | 0,
        zoomArgs[4] | 0
       ];
      }
     } else {
      console.error(`PDFLinkService.setHash: "${ zoomArg }" is not a valid zoom value.`);
     }
    }
   }
   if (dest) {
    this.pdfViewer.scrollPageIntoView({
     pageNumber: pageNumber || this.page,
     destArray: dest,
     allowNegativeOffset: true
    });
   } else if (pageNumber) {
    this.page = pageNumber;
   }
   if (params.has("pagemode")) {
    this.eventBus.dispatch("pagemode", {
     source: this,
     mode: params.get("pagemode")
    });
   }
   if (params.has("nameddest")) {
    this.goToDestination(params.get("nameddest"));
   }
  } else {
   dest = unescape(hash);
   try {
    dest = JSON.parse(dest);
    if (!Array.isArray(dest)) {
     dest = dest.toString();
    }
   } catch (ex) {
   }
   if (typeof dest === "string" || PDFLinkService.#isValidExplicitDestination(dest)) {
    this.goToDestination(dest);
    return;
   }
   console.error(`PDFLinkService.setHash: "${ unescape(hash) }" is not a valid destination.`);
  }
 }
 executeNamedAction(action) {
  switch (action) {
  case "GoBack":
   this.pdfHistory?.back();
   break;
  case "GoForward":
   this.pdfHistory?.forward();
   break;
  case "NextPage":
   this.pdfViewer.nextPage();
   break;
  case "PrevPage":
   this.pdfViewer.previousPage();
   break;
  case "LastPage":
   this.page = this.pagesCount;
   break;
  case "FirstPage":
   this.page = 1;
   break;
  default:
   break;
  }
  this.eventBus.dispatch("namedaction", {
   source: this,
   action
  });
 }
 cachePageRef(pageNum, pageRef) {
  if (!pageRef) {
   return;
  }
  const refStr = pageRef.gen === 0 ? `${ pageRef.num }R` : `${ pageRef.num }R${ pageRef.gen }`;
  this.#pagesRefCache.set(refStr, pageNum);
 }
 _cachedPageNumber(pageRef) {
  if (!pageRef) {
   return null;
  }
  const refStr = pageRef.gen === 0 ? `${ pageRef.num }R` : `${ pageRef.num }R${ pageRef.gen }`;
  return this.#pagesRefCache.get(refStr) || null;
 }
 isPageVisible(pageNumber) {
  return this.pdfViewer.isPageVisible(pageNumber);
 }
 isPageCached(pageNumber) {
  return this.pdfViewer.isPageCached(pageNumber);
 }
 static #isValidExplicitDestination(dest) {
  if (!Array.isArray(dest)) {
   return false;
  }
  const destLength = dest.length;
  if (destLength < 2) {
   return false;
  }
  const page = dest[0];
  if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
   return false;
  }
  const zoom = dest[1];
  if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
   return false;
  }
  let allowNull = true;
  switch (zoom.name) {
  case "XYZ":
   if (destLength !== 5) {
    return false;
   }
   break;
  case "Fit":
  case "FitB":
   return destLength === 2;
  case "FitH":
  case "FitBH":
  case "FitV":
  case "FitBV":
   if (destLength !== 3) {
    return false;
   }
   break;
  case "FitR":
   if (destLength !== 6) {
    return false;
   }
   allowNull = false;
   break;
  default:
   return false;
  }
  for (let i = 2; i < destLength; i++) {
   const param = dest[i];
   if (!(typeof param === "number" || allowNull && param === null)) {
    return false;
   }
  }
  return true;
 }
}
class SimpleLinkService {
 constructor() {
  this.externalLinkEnabled = true;
 }
 get pagesCount() {
  return 0;
 }
 get page() {
  return 0;
 }
 set page(value) {
 }
 get rotation() {
  return 0;
 }
 set rotation(value) {
 }
 async goToDestination(dest) {
 }
 goToPage(val) {
 }
 addLinkAttributes(link, url, newWindow = false) {
  addLinkAttributes(link, {
   url,
   enabled: this.externalLinkEnabled
  });
 }
 getDestinationHash(dest) {
  return "#";
 }
 getAnchorUrl(hash) {
  return "#";
 }
 setHash(hash) {
 }
 executeNamedAction(action) {
 }
 cachePageRef(pageNum, pageRef) {
 }
 isPageVisible(pageNumber) {
  return true;
 }
 isPageCached(pageNumber) {
  return true;
 }
}



/***/ }),

/***/ "./src/pdf_page_view.js":
/*!******************************!*\
  !*** ./src/pdf_page_view.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDFPageView": function() { return /* binding */ PDFPageView; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {AnnotationMode, createPromiseCapability, PixelsPerInch, RenderingCancelledException, SVGGraphics} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const {approximateFraction, DEFAULT_SCALE, getOutputScale, RendererType, RenderingStates, roundToDivide, TextLayerMode} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const {compatibilityParams} = __webpack_require__(/*! ./app_options.js */ "./src/app_options.js");
const {NullL10n} = __webpack_require__(/*! ./l10n_utils.js */ "./src/l10n_utils.js");
const MAX_CANVAS_PIXELS = compatibilityParams.maxCanvasPixels || 16777216;
class PDFPageView {
 #annotationMode = AnnotationMode.ENABLE_FORMS;
 constructor(options) {
  const container = options.container;
  const defaultViewport = options.defaultViewport;
  this.id = options.id;
  this.renderingId = "page" + this.id;
  this.pdfPage = null;
  this.pageLabel = null;
  this.rotation = 0;
  this.scale = options.scale || DEFAULT_SCALE;
  this.viewport = defaultViewport;
  this.pdfPageRotate = defaultViewport.rotation;
  this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;
  this.hasRestrictedScaling = false;
  this.textLayerMode = options.textLayerMode ?? TextLayerMode.ENABLE;
  this.#annotationMode = options.annotationMode ?? AnnotationMode.ENABLE_FORMS;
  this.imageResourcesPath = options.imageResourcesPath || "";
  this.useOnlyCssZoom = options.useOnlyCssZoom || false;
  this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
  this.eventBus = options.eventBus;
  this.renderingQueue = options.renderingQueue;
  this.textLayerFactory = options.textLayerFactory;
  this.annotationLayerFactory = options.annotationLayerFactory;
  this.xfaLayerFactory = options.xfaLayerFactory;
  this.textHighlighter = options.textHighlighterFactory?.createTextHighlighter(this.id - 1, this.eventBus);
  this.structTreeLayerFactory = options.structTreeLayerFactory;
  this.renderer = options.renderer || RendererType.CANVAS;
  this.l10n = options.l10n || NullL10n;
  this.paintTask = null;
  this.paintedViewportMap = new WeakMap();
  this.renderingState = RenderingStates.INITIAL;
  this.resume = null;
  this._renderError = null;
  this._isStandalone = !this.renderingQueue?.hasViewer();
  this._annotationCanvasMap = null;
  this.annotationLayer = null;
  this.textLayer = null;
  this.zoomLayer = null;
  this.xfaLayer = null;
  this.structTreeLayer = null;
  const div = document.createElement("div");
  div.className = "page";
  div.id="page"+this.id;
  div.style.width = Math.floor(this.viewport.width) + "px";
  div.style.height = Math.floor(this.viewport.height) + "px";
  div.setAttribute("data-page-number", this.id);
  div.setAttribute("role", "region");
  this.l10n.get("page_landmark", { page: this.id }).then(msg => {
   div.setAttribute("aria-label", msg);
  });
  this.div = div;
  container?.appendChild(div);
  this.eventBus.on("annotationlayerrendered",(data)=>{
    if(data.pageNumber==this.id){
        const newOpt = {
          documentId: window._RENDER_OPTIONS.documentId,
          pdfDocument: window._RENDER_OPTIONS.pdfDocument,
          scale:this.viewport.scale.toFixed(2),
          rotate:this.viewport.rotation
        }
        window._RENDER_OPTIONS = newOpt;
        window.PDFJSAnnotate.UI.renderPage(data.pageNumber, newOpt,this.pdfPage).then(() => {
          let viewport = this.viewport;
          window._PAGE_HEIGHT = viewport.height;
        });
    }
});
 }
 setPdfPage(pdfPage) {
  this.pdfPage = pdfPage;
  this.pdfPageRotate = pdfPage.rotate;
  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
  this.viewport = pdfPage.getViewport({
   scale: this.scale * PixelsPerInch.PDF_TO_CSS_UNITS,
   rotation: totalRotation
  });
  this.reset();
 }
 destroy() {
  this.reset();
  if (this.pdfPage) {
   this.pdfPage.cleanup();
  }
 }
 async _renderAnnotationLayer() {
  let error = null;
  try {
   await this.annotationLayer.render(this.viewport, "display");
  } catch (ex) {
   error = ex;
  } finally {
   this.eventBus.dispatch("annotationlayerrendered", {
    source: this,
    pageNumber: this.id,
    error
   });
  }
 }
 async _renderXfaLayer() {
  let error = null;
  try {
   const result = await this.xfaLayer.render(this.viewport, "display");
   if (this.textHighlighter) {
    this._buildXfaTextContentItems(result.textDivs);
   }
  } catch (ex) {
   error = ex;
  } finally {
   this.eventBus.dispatch("xfalayerrendered", {
    source: this,
    pageNumber: this.id,
    error
   });
  }
 }
 async _buildXfaTextContentItems(textDivs) {
  const text = await this.pdfPage.getTextContent();
  const items = [];
  for (const item of text.items) {
   items.push(item.str);
  }
  this.textHighlighter.setTextMapping(textDivs, items);
  this.textHighlighter.enable();
 }
 _resetZoomLayer(removeFromDOM = false) {
  if (!this.zoomLayer) {
   return;
  }
  const zoomLayerCanvas = this.zoomLayer.firstChild;
  this.paintedViewportMap.delete(zoomLayerCanvas);
  zoomLayerCanvas.width = 0;
  zoomLayerCanvas.height = 0;
  if (removeFromDOM) {
   this.zoomLayer.remove();
  }
  this.zoomLayer = null;
 }
 reset({keepZoomLayer = false, keepAnnotationLayer = false, keepXfaLayer = false} = {}) {
  this.cancelRendering({
   keepAnnotationLayer,
   keepXfaLayer
  });
  this.renderingState = RenderingStates.INITIAL;
  const div = this.div;
  div.style.width = Math.floor(this.viewport.width) + "px";
  div.style.height = Math.floor(this.viewport.height) + "px";
  const childNodes = div.childNodes, zoomLayerNode = keepZoomLayer && this.zoomLayer || null, annotationLayerNode = keepAnnotationLayer && this.annotationLayer?.div || null, xfaLayerNode = keepXfaLayer && this.xfaLayer?.div || null;
  for (let i = childNodes.length - 1; i >= 0; i--) {
   const node = childNodes[i];
   switch (node) {
   case zoomLayerNode:
   case annotationLayerNode:
   case xfaLayerNode:
    continue;
   }
   node.remove();
  }
  div.removeAttribute("data-loaded");
  div.removeAttribute("data-anno-loaded");
  if (annotationLayerNode) {
   this.annotationLayer.hide();
  }
  if (xfaLayerNode) {
   this.xfaLayer.hide();
  }
  if (!zoomLayerNode) {
   if (this.canvas) {
    this.paintedViewportMap.delete(this.canvas);
    this.canvas.width = 0;
    this.canvas.height = 0;
    delete this.canvas;
   }
   this._resetZoomLayer();
  }
  if (this.svg) {
   this.paintedViewportMap.delete(this.svg);
   delete this.svg;
  }
  this.loadingIconDiv = document.createElement("div");
  this.loadingIconDiv.className = "loadingIcon notVisible";
  if (this._isStandalone) {
   this.toggleLoadingIconSpinner(true);
  }
  this.loadingIconDiv.setAttribute("role", "img");
  this.l10n.get("loading").then(msg => {
   this.loadingIconDiv?.setAttribute("aria-label", msg);
  });
  div.appendChild(this.loadingIconDiv);
 }
 update({scale = 0, rotation = null, optionalContentConfigPromise = null}) {
  if (typeof arguments[0] !== "object") {
   console.error("PDFPageView.update called with separate parameters, please use an object instead.");
   this.update({
    scale: arguments[0],
    rotation: arguments[1],
    optionalContentConfigPromise: arguments[2]
   });
   return;
  }
  this.scale = scale || this.scale;
  if (typeof rotation === "number") {
   this.rotation = rotation;
  }
  if (optionalContentConfigPromise instanceof Promise) {
   this._optionalContentConfigPromise = optionalContentConfigPromise;
  }
  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
  const viewportScale = this.scale * PixelsPerInch.PDF_TO_CSS_UNITS;
  this.viewport = this.viewport.clone({
   scale: viewportScale,
   rotation: totalRotation
  });
  if (this._isStandalone) {
   const {style} = document.documentElement;
   style.setProperty("--zoom-factor", this.scale);
   style.setProperty("--viewport-scale-factor", viewportScale);
  }
  if (this.svg) {
   this.cssTransform({
    target: this.svg,
    redrawAnnotationLayer: true,
    redrawXfaLayer: true
   });
   this.eventBus.dispatch("pagerendered", {
    source: this,
    pageNumber: this.id,
    cssTransform: true,
    timestamp: performance.now(),
    error: this._renderError
   });
   return;
  }
  let isScalingRestricted = false;
  if (this.canvas && this.maxCanvasPixels > 0) {
   const outputScale = this.outputScale;
   if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
    isScalingRestricted = true;
   }
  }
  if (this.canvas) {
   if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
    this.cssTransform({
     target: this.canvas,
     redrawAnnotationLayer: true,
     redrawXfaLayer: true
    });
    this.eventBus.dispatch("pagerendered", {
     source: this,
     pageNumber: this.id,
     cssTransform: true,
     timestamp: performance.now(),
     error: this._renderError
    });
    return;
   }
   if (!this.zoomLayer && !this.canvas.hidden) {
    this.zoomLayer = this.canvas.parentNode;
    this.zoomLayer.style.position = "absolute";
   }
  }
  if (this.zoomLayer) {
   this.cssTransform({ target: this.zoomLayer.firstChild });
  }
  this.reset({
   keepZoomLayer: true,
   keepAnnotationLayer: true,
   keepXfaLayer: true
  });
 }
 cancelRendering({keepAnnotationLayer = false, keepXfaLayer = false} = {}) {
  if (this.paintTask) {
   this.paintTask.cancel();
   this.paintTask = null;
  }
  this.resume = null;
  if (this.textLayer) {
   this.textLayer.cancel();
   this.textLayer = null;
  }
  if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) {
   this.annotationLayer.cancel();
   this.annotationLayer = null;
   this._annotationCanvasMap = null;
  }
  if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) {
   this.xfaLayer.cancel();
   this.xfaLayer = null;
   this.textHighlighter?.disable();
  }
  if (this._onTextLayerRendered) {
   this.eventBus._off("textlayerrendered", this._onTextLayerRendered);
   this._onTextLayerRendered = null;
  }
 }
 cssTransform({target, redrawAnnotationLayer = false, redrawXfaLayer = false}) {
  const width = this.viewport.width;
  const height = this.viewport.height;
  const div = this.div;
  target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
  target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
  const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
  const absRotation = Math.abs(relativeRotation);
  let scaleX = 1, scaleY = 1;
  if (absRotation === 90 || absRotation === 270) {
   scaleX = height / width;
   scaleY = width / height;
  }
  target.style.transform = `rotate(${ relativeRotation }deg) scale(${ scaleX }, ${ scaleY })`;
  if (this.textLayer) {
   const textLayerViewport = this.textLayer.viewport;
   const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
   const textAbsRotation = Math.abs(textRelativeRotation);
   let scale = width / textLayerViewport.width;
   if (textAbsRotation === 90 || textAbsRotation === 270) {
    scale = width / textLayerViewport.height;
   }
   const textLayerDiv = this.textLayer.textLayerDiv;
   let transX, transY;
   switch (textAbsRotation) {
   case 0:
    transX = transY = 0;
    break;
   case 90:
    transX = 0;
    transY = "-" + textLayerDiv.style.height;
    break;
   case 180:
    transX = "-" + textLayerDiv.style.width;
    transY = "-" + textLayerDiv.style.height;
    break;
   case 270:
    transX = "-" + textLayerDiv.style.width;
    transY = 0;
    break;
   default:
    console.error("Bad rotation value.");
    break;
   }
   textLayerDiv.style.transform = `rotate(${ textAbsRotation }deg) ` + `scale(${ scale }) ` + `translate(${ transX }, ${ transY })`;
   textLayerDiv.style.transformOrigin = "0% 0%";
  }
  if (redrawAnnotationLayer && this.annotationLayer) {
   this._renderAnnotationLayer();
  }
  if (redrawXfaLayer && this.xfaLayer) {
   this._renderXfaLayer();
  }
 }
 get width() {
  return this.viewport.width;
 }
 get height() {
  return this.viewport.height;
 }
 getPagePoint(x, y) {
  return this.viewport.convertToPdfPoint(x, y);
 }
 toggleLoadingIconSpinner(viewVisible = false) {
  this.loadingIconDiv?.classList.toggle("notVisible", !viewVisible);
 }
 draw() {
  if (this.renderingState !== RenderingStates.INITIAL) {
   console.error("Must be in new state before drawing");
   this.reset();
  }
  const {div, pdfPage} = this;
  if (!pdfPage) {
   this.renderingState = RenderingStates.FINISHED;
   if (this.loadingIconDiv) {
    this.loadingIconDiv.remove();
    delete this.loadingIconDiv;
   }
   return Promise.reject(new Error("pdfPage is not loaded"));
  }

  this.renderingState = RenderingStates.RUNNING;
  const canvasWrapper = document.createElement("div");
  canvasWrapper.style.width = div.style.width;
  canvasWrapper.style.height = div.style.height;
  canvasWrapper.classList.add("canvasWrapper");
  if (this.annotationLayer?.div) {
   div.insertBefore(canvasWrapper, this.annotationLayer.div);
  } else {
   div.appendChild(canvasWrapper);
  }
  let textLayer = null;
  if (this.textLayerMode !== TextLayerMode.DISABLE && this.textLayerFactory) {
   const textLayerDiv = document.createElement("div");
   textLayerDiv.className = "textLayer";
   textLayerDiv.style.width = canvasWrapper.style.width;
   textLayerDiv.style.height = canvasWrapper.style.height;
   if (this.annotationLayer?.div) {
    div.insertBefore(textLayerDiv, this.annotationLayer.div);
   } else {
    div.appendChild(textLayerDiv);
   }
   textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === TextLayerMode.ENABLE_ENHANCE, this.eventBus, this.textHighlighter);
  }
  this.textLayer = textLayer;
  if (this.#annotationMode !== AnnotationMode.DISABLE && this.annotationLayerFactory) {
   this._annotationCanvasMap ||= new Map();
   this.annotationLayer ||= this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, null, this.imageResourcesPath, this.#annotationMode === AnnotationMode.ENABLE_FORMS, this.l10n, null, null, null, null, this._annotationCanvasMap);
  }
  if (this.xfaLayer?.div) {
   div.appendChild(this.xfaLayer.div);
  }
  let renderContinueCallback = null;
  if (this.renderingQueue) {
   renderContinueCallback = cont => {
    if (!this.renderingQueue.isHighestPriority(this)) {
     this.renderingState = RenderingStates.PAUSED;
     this.resume = () => {
      this.renderingState = RenderingStates.RUNNING;
      cont();
     };
     return;
    }
    cont();
   };
  }
  const finishPaintTask = async (error = null) => {
   if (paintTask === this.paintTask) {
    this.paintTask = null;
   }
   if (error instanceof RenderingCancelledException) {
    this._renderError = null;
    return;
   }
   this._renderError = error;
   this.renderingState = RenderingStates.FINISHED;
   if (this.loadingIconDiv) {
    this.loadingIconDiv.remove();
    delete this.loadingIconDiv;
   }
   this._resetZoomLayer(true);
   this.eventBus.dispatch("pagerendered", {
    source: this,
    pageNumber: this.id,
    cssTransform: false,
    timestamp: performance.now(),
    error: this._renderError
   });
   if (error) {
    throw error;
   }
  };
  const paintTask = this.renderer === RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
  paintTask.onRenderContinue = renderContinueCallback;
  this.paintTask = paintTask;
  const resultPromise = paintTask.promise.then(() => {
   return finishPaintTask(null).then(() => {
    if (textLayer) {
     const readableStream = pdfPage.streamTextContent({ includeMarkedContent: true });
     textLayer.setTextContentStream(readableStream);
     textLayer.render();
    }
    if (this.annotationLayer) {
     this._renderAnnotationLayer();
    }
   });
  }, function (reason) {
   return finishPaintTask(reason);
  });
  if (this.xfaLayerFactory) {
   if (!this.xfaLayer) {
    this.xfaLayer = this.xfaLayerFactory.createXfaLayerBuilder(div, pdfPage, null);
   }
   this._renderXfaLayer();
  }
  if (this.structTreeLayerFactory && this.textLayer && this.canvas) {
   this._onTextLayerRendered = event => {
    if (event.pageNumber !== this.id) {
     return;
    }
    this.eventBus._off("textlayerrendered", this._onTextLayerRendered);
    this._onTextLayerRendered = null;
    if (!this.canvas) {
     return;
    }
    this.pdfPage.getStructTree().then(tree => {
     if (!tree) {
      return;
     }
     if (!this.canvas) {
      return;
     }
     const treeDom = this.structTreeLayer.render(tree);
     treeDom.classList.add("structTree");
     this.canvas.appendChild(treeDom);
    });
   };
   this.eventBus._on("textlayerrendered", this._onTextLayerRendered);
   this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder(pdfPage);
  }
  div.setAttribute("data-loaded", true);
  div.setAttribute("data-anno-loaded", false);

  this.eventBus.dispatch("pagerender", {
   source: this,
   pageNumber: this.id
  });
  return resultPromise;
 }
 paintOnCanvas(canvasWrapper) {
  const renderCapability = createPromiseCapability();
  const result = {
   promise: renderCapability.promise,
   onRenderContinue(cont) {
    cont();
   },
   cancel() {
    renderTask.cancel();
   }
  };
  const viewport = this.viewport;
  const canvas = document.createElement("canvas");
  canvas.hidden = true;
  let isCanvasHidden = true;
  const showCanvas = function () {
   if (isCanvasHidden) {
    canvas.hidden = false;
    isCanvasHidden = false;
   }
  };
  canvasWrapper.appendChild(canvas);
  this.canvas = canvas;
  canvas.mozOpaque = true;
  const ctx = canvas.getContext("2d", { alpha: false });
  const outputScale = getOutputScale(ctx);
  this.outputScale = outputScale;
  if (this.useOnlyCssZoom) {
   const actualSizeViewport = viewport.clone({ scale: PixelsPerInch.PDF_TO_CSS_UNITS });
   outputScale.sx *= actualSizeViewport.width / viewport.width;
   outputScale.sy *= actualSizeViewport.height / viewport.height;
   outputScale.scaled = true;
  }
  if (this.maxCanvasPixels > 0) {
   const pixelsInViewport = viewport.width * viewport.height;
   const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);
   if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
    outputScale.sx = maxScale;
    outputScale.sy = maxScale;
    outputScale.scaled = true;
    this.hasRestrictedScaling = true;
   } else {
    this.hasRestrictedScaling = false;
   }
  }
  const sfx = approximateFraction(outputScale.sx);
  const sfy = approximateFraction(outputScale.sy);
  canvas.width = roundToDivide(viewport.width * outputScale.sx, sfx[0]);
  canvas.height = roundToDivide(viewport.height * outputScale.sy, sfy[0]);
  canvas.style.width = roundToDivide(viewport.width, sfx[1]) + "px";
  canvas.style.height = roundToDivide(viewport.height, sfy[1]) + "px";
  this.paintedViewportMap.set(canvas, viewport);
  const transform = !outputScale.scaled ? null : [
   outputScale.sx,
   0,
   0,
   outputScale.sy,
   0,
   0
  ];
  const renderContext = {
   canvasContext: ctx,
   transform,
   viewport: this.viewport,
   annotationMode: this.#annotationMode,
   optionalContentConfigPromise: this._optionalContentConfigPromise,
   annotationCanvasMap: this._annotationCanvasMap
  };
  const renderTask = this.pdfPage.render(renderContext);
  renderTask.onContinue = function (cont) {
   showCanvas();
   if (result.onRenderContinue) {
    result.onRenderContinue(cont);
   } else {
    cont();
   }
  };
  renderTask.promise.then(function () {
   showCanvas();
   renderCapability.resolve();
  }, function (error) {
   showCanvas();
   renderCapability.reject(error);
  });
  return result;
 }
 paintOnSvg(wrapper) {
  let cancelled = false;
  const ensureNotCancelled = () => {
   if (cancelled) {
    throw new RenderingCancelledException(`Rendering cancelled, page ${ this.id }`, "svg");
   }
  };
  const pdfPage = this.pdfPage;
  const actualSizeViewport = this.viewport.clone({ scale: PixelsPerInch.PDF_TO_CSS_UNITS });
  const promise = pdfPage.getOperatorList({ annotationMode: this.#annotationMode }).then(opList => {
   ensureNotCancelled();
   const svgGfx = new SVGGraphics(pdfPage.commonObjs, pdfPage.objs);
   return svgGfx.getSVG(opList, actualSizeViewport).then(svg => {
    ensureNotCancelled();
    this.svg = svg;
    this.paintedViewportMap.set(svg, actualSizeViewport);
    svg.style.width = wrapper.style.width;
    svg.style.height = wrapper.style.height;
    this.renderingState = RenderingStates.FINISHED;
    wrapper.appendChild(svg);
   });
  });
  return {
   promise,
   onRenderContinue(cont) {
    cont();
   },
   cancel() {
    cancelled = true;
   }
  };
 }
 setPageLabel(label) {
  this.pageLabel = typeof label === "string" ? label : null;
  if (this.pageLabel !== null) {
   this.div.setAttribute("data-page-label", this.pageLabel);
  } else {
   this.div.removeAttribute("data-page-label");
  }
 }
}



/***/ }),

/***/ "./src/pdf_print_service.js":
/*!**********************************!*\
  !*** ./src/pdf_print_service.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDFPrintService": function() { return /* binding */ PDFPrintService; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {AnnotationMode, PixelsPerInch} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const {PDFPrintServiceFactory, PDFViewerApplication} = __webpack_require__(/*! ./app.js */ "./src/app.js");
const {getXfaHtmlForPrinting} = __webpack_require__(/*! ./print_utils.js */ "./src/print_utils.js");
let activeService = null;
let overlayManager = null;
function renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size, printResolution, optionalContentConfigPromise) {
 const scratchCanvas = activeService.scratchCanvas;
 const PRINT_UNITS = printResolution / PixelsPerInch.PDF;
 scratchCanvas.width = Math.floor(size.width * PRINT_UNITS);
 scratchCanvas.height = Math.floor(size.height * PRINT_UNITS);
 const ctx = scratchCanvas.getContext("2d");
 ctx.save();
 ctx.fillStyle = "rgb(255, 255, 255)";
 ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);
 ctx.restore();
 return pdfDocument.getPage(pageNumber).then(function (pdfPage) {
  const renderContext = {
   canvasContext: ctx,
   transform: [
    PRINT_UNITS,
    0,
    0,
    PRINT_UNITS,
    0,
    0
   ],
   viewport: pdfPage.getViewport({
    scale: 1,
    rotation: size.rotation
   }),
   intent: "print",
   annotationMode: AnnotationMode.ENABLE_STORAGE,
   optionalContentConfigPromise
  };
  return pdfPage.render(renderContext).promise;
 });
}
function PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise = null, l10n) {
 this.pdfDocument = pdfDocument;
 this.pagesOverview = pagesOverview;
 this.printContainer = printContainer;
 this._printResolution = printResolution || 150;
 this._optionalContentConfigPromise = optionalContentConfigPromise || pdfDocument.getOptionalContentConfig();
 this.l10n = l10n;
 this.currentPage = -1;
 this.scratchCanvas = document.createElement("canvas");
}
PDFPrintService.prototype = {
 layout() {
  this.throwIfInactive();
  const body = document.querySelector("body");
  body.setAttribute("data-pdfjsprinting", true);
  const hasEqualPageSizes = this.pagesOverview.every(function (size) {
   return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height;
  }, this);
  if (!hasEqualPageSizes) {
   console.warn("Not all pages have the same size. The printed " + "result may be incorrect!");
  }
  this.pageStyleSheet = document.createElement("style");
  const pageSize = this.pagesOverview[0];
  this.pageStyleSheet.textContent = "@page { size: " + pageSize.width + "pt " + pageSize.height + "pt;}";
  body.appendChild(this.pageStyleSheet);
 },
 destroy() {
  if (activeService !== this) {
   return;
  }
  this.printContainer.textContent = "";
  const body = document.querySelector("body");
  body.removeAttribute("data-pdfjsprinting");
  if (this.pageStyleSheet) {
   this.pageStyleSheet.remove();
   this.pageStyleSheet = null;
  }
  this.scratchCanvas.width = this.scratchCanvas.height = 0;
  this.scratchCanvas = null;
  activeService = null;
  ensureOverlay().then(function () {
   if (overlayManager.active !== "printServiceOverlay") {
    return;
   }
   overlayManager.close("printServiceOverlay");
  });
 },
 renderPages() {
  if (this.pdfDocument.isPureXfa) {
   getXfaHtmlForPrinting(this.printContainer, this.pdfDocument);
   return Promise.resolve();
  }
  const pageCount = this.pagesOverview.length;
  const renderNextPage = (resolve, reject) => {
   this.throwIfInactive();
   if (++this.currentPage >= pageCount) {
    renderProgress(pageCount, pageCount, this.l10n);
    resolve();
    return;
   }
   const index = this.currentPage;
   renderProgress(index, pageCount, this.l10n);
   renderPage(this, this.pdfDocument, index + 1, this.pagesOverview[index], this._printResolution, this._optionalContentConfigPromise).then(this.useRenderedPage.bind(this)).then(function () {
    renderNextPage(resolve, reject);
   }, reject);
  };
  return new Promise(renderNextPage);
 },
 useRenderedPage() {
  this.throwIfInactive();
  const img = document.createElement("img");
  const scratchCanvas = this.scratchCanvas;
  if ("toBlob" in scratchCanvas) {
   scratchCanvas.toBlob(function (blob) {
    img.src = URL.createObjectURL(blob);
   });
  } else {
   img.src = scratchCanvas.toDataURL();
  }
  const wrapper = document.createElement("div");
  wrapper.className = "printedPage";
  wrapper.appendChild(img);
  this.printContainer.appendChild(wrapper);
  return new Promise(function (resolve, reject) {
   img.onload = resolve;
   img.onerror = reject;
  });
 },
 performPrint() {
  this.throwIfInactive();
  return new Promise(resolve => {
   setTimeout(() => {
    if (!this.active) {
     resolve();
     return;
    }
    print.call(window);
    setTimeout(resolve, 20);
   }, 0);
  });
 },
 get active() {
  return this === activeService;
 },
 throwIfInactive() {
  if (!this.active) {
   throw new Error("This print request was cancelled or completed.");
  }
 }
};
const print = window.print;
window.print = function () {
 if (activeService) {
  console.warn("Ignored window.print() because of a pending print job.");
  return;
 }
 ensureOverlay().then(function () {
  if (activeService) {
   overlayManager.open("printServiceOverlay");
  }
 });
 try {
  dispatchEvent("beforeprint");
 } finally {
  if (!activeService) {
   console.error("Expected print service to be initialized.");
   ensureOverlay().then(function () {
    if (overlayManager.active === "printServiceOverlay") {
     overlayManager.close("printServiceOverlay");
    }
   });
   return;
  }
  const activeServiceOnEntry = activeService;
  activeService.renderPages().then(function () {
   return activeServiceOnEntry.performPrint();
  }).catch(function () {
  }).then(function () {
   if (activeServiceOnEntry.active) {
    abort();
   }
  });
 }
};
function dispatchEvent(eventType) {
 const event = document.createEvent("CustomEvent");
 event.initCustomEvent(eventType, false, false, "custom");
 window.dispatchEvent(event);
}
function abort() {
 if (activeService) {
  activeService.destroy();
  dispatchEvent("afterprint");
 }
}
function renderProgress(index, total, l10n) {
 const progressContainer = document.getElementById("printServiceOverlay");
 const progress = Math.round(100 * index / total);
 const progressBar = progressContainer.querySelector("progress");
 const progressPerc = progressContainer.querySelector(".relative-progress");
 progressBar.value = progress;
 l10n.get("print_progress_percent", { progress }).then(msg => {
  progressPerc.textContent = msg;
 });
}
window.addEventListener("keydown", function (event) {
 if (event.keyCode === 80 && (event.ctrlKey || event.metaKey) && !event.altKey && (!event.shiftKey || window.chrome || window.opera)) {
  window.print();
  event.preventDefault();
  if (event.stopImmediatePropagation) {
   event.stopImmediatePropagation();
  } else {
   event.stopPropagation();
  }
 }
}, true);
if ("onbeforeprint" in window) {
 const stopPropagationIfNeeded = function (event) {
  if (event.detail !== "custom" && event.stopImmediatePropagation) {
   event.stopImmediatePropagation();
  }
 };
 window.addEventListener("beforeprint", stopPropagationIfNeeded);
 window.addEventListener("afterprint", stopPropagationIfNeeded);
}
let overlayPromise;
function ensureOverlay() {
 if (!overlayPromise) {
  overlayManager = PDFViewerApplication.overlayManager;
  if (!overlayManager) {
   throw new Error("The overlay manager has not yet been initialized.");
  }
  overlayPromise = overlayManager.register("printServiceOverlay", document.getElementById("printServiceOverlay"), abort, true);
  document.getElementById("printCancel").onclick = abort;
 }
 return overlayPromise;
}
PDFPrintServiceFactory.instance = {
 supportsPrinting: true,
 createPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, l10n) {
  if (activeService) {
   throw new Error("The print service is created and active.");
  }
  activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, l10n);
  return activeService;
 }
};



/***/ }),

/***/ "./src/pdf_rendering_queue.js":
/*!************************************!*\
  !*** ./src/pdf_rendering_queue.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDFRenderingQueue": function() { return /* binding */ PDFRenderingQueue; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {RenderingCancelledException} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const {RenderingStates} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const CLEANUP_TIMEOUT = 30000;
class PDFRenderingQueue {
 constructor() {
  this.pdfViewer = null;
  this.pdfThumbnailViewer = null;
  this.onIdle = null;
  this.highestPriorityPage = null;
  this.idleTimeout = null;
  this.printing = false;
  this.isThumbnailViewEnabled = false;
 }
 setViewer(pdfViewer) {
  this.pdfViewer = pdfViewer;
 }
 setThumbnailViewer(pdfThumbnailViewer) {
  this.pdfThumbnailViewer = pdfThumbnailViewer;
 }
 isHighestPriority(view) {
  return this.highestPriorityPage === view.renderingId;
 }
 hasViewer() {
  return !!this.pdfViewer;
 }
 renderHighestPriority(currentlyVisiblePages) {
  if (this.idleTimeout) {
   clearTimeout(this.idleTimeout);
   this.idleTimeout = null;
  }
  if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
   return;
  }
  if (this.isThumbnailViewEnabled && this.pdfThumbnailViewer?.forceRendering()) {
   return;
  }
  if (this.printing) {
   return;
  }
  if (this.onIdle) {
   this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
  }
 }
 getHighestPriority(visible, views, scrolledDown, preRenderExtra = false) {
  const visibleViews = visible.views, numVisible = visibleViews.length;
  if (numVisible === 0) {
   return null;
  }
  for (let i = 0; i < numVisible; i++) {
   const view = visibleViews[i].view;
   if (!this.isViewFinished(view)) {
    return view;
   }
  }
  const firstId = visible.first.id, lastId = visible.last.id;
  if (lastId - firstId + 1 > numVisible) {
   const visibleIds = visible.ids;
   for (let i = 1, ii = lastId - firstId; i < ii; i++) {
    const holeId = scrolledDown ? firstId + i : lastId - i;
    if (visibleIds.has(holeId)) {
     continue;
    }
    const holeView = views[holeId - 1];
    if (!this.isViewFinished(holeView)) {
     return holeView;
    }
   }
  }
  let preRenderIndex = scrolledDown ? lastId : firstId - 2;
  let preRenderView = views[preRenderIndex];
  if (preRenderView && !this.isViewFinished(preRenderView)) {
   return preRenderView;
  }
  if (preRenderExtra) {
   preRenderIndex += scrolledDown ? 1 : -1;
   preRenderView = views[preRenderIndex];
   if (preRenderView && !this.isViewFinished(preRenderView)) {
    return preRenderView;
   }
  }
  return null;
 }
 isViewFinished(view) {
  return view.renderingState === RenderingStates.FINISHED;
 }
 renderView(view) {
  switch (view.renderingState) {
  case RenderingStates.FINISHED:
   return false;
  case RenderingStates.PAUSED:
   this.highestPriorityPage = view.renderingId;
   view.resume();
   break;
  case RenderingStates.RUNNING:
   this.highestPriorityPage = view.renderingId;
   break;
  case RenderingStates.INITIAL:
   this.highestPriorityPage = view.renderingId;
   view.draw().finally(() => {
    this.renderHighestPriority();
   }).catch(reason => {
    if (reason instanceof RenderingCancelledException) {
     return;
    }
    console.error(`renderView: "${ reason }"`);
   });
   break;
  }
  return true;
 }
}



/***/ }),

/***/ "./src/pdf_scripting_manager.js":
/*!**************************************!*\
  !*** ./src/pdf_scripting_manager.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDFScriptingManager": function() { return /* binding */ PDFScriptingManager; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {apiPageLayoutToViewerModes, RenderingStates} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const {createPromiseCapability, shadow} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
class PDFScriptingManager {
 constructor({eventBus, sandboxBundleSrc = null, scriptingFactory = null, docPropertiesLookup = null}) {
  this._pdfDocument = null;
  this._pdfViewer = null;
  this._closeCapability = null;
  this._destroyCapability = null;
  this._scripting = null;
  this._mouseState = Object.create(null);
  this._ready = false;
  this._eventBus = eventBus;
  this._sandboxBundleSrc = sandboxBundleSrc;
  this._scriptingFactory = scriptingFactory;
  this._docPropertiesLookup = docPropertiesLookup;
 }
 setViewer(pdfViewer) {
  this._pdfViewer = pdfViewer;
 }
 async setDocument(pdfDocument) {
  if (this._pdfDocument) {
   await this._destroyScripting();
  }
  this._pdfDocument = pdfDocument;
  if (!pdfDocument) {
   return;
  }
  const [objects, calculationOrder, docActions] = await Promise.all([
   pdfDocument.getFieldObjects(),
   pdfDocument.getCalculationOrderIds(),
   pdfDocument.getJSActions()
  ]);
  if (!objects && !docActions) {
   await this._destroyScripting();
   return;
  }
  if (pdfDocument !== this._pdfDocument) {
   return;
  }
  try {
   this._scripting = this._createScripting();
  } catch (error) {
   console.error(`PDFScriptingManager.setDocument: "${ error?.message }".`);
   await this._destroyScripting();
   return;
  }
  this._internalEvents.set("updatefromsandbox", event => {
   if (event?.source !== window) {
    return;
   }
   this._updateFromSandbox(event.detail);
  });
  this._internalEvents.set("dispatcheventinsandbox", event => {
   this._scripting?.dispatchEventInSandbox(event.detail);
  });
  this._internalEvents.set("pagechanging", ({pageNumber, previous}) => {
   if (pageNumber === previous) {
    return;
   }
   this._dispatchPageClose(previous);
   this._dispatchPageOpen(pageNumber);
  });
  this._internalEvents.set("pagerendered", ({pageNumber}) => {
   if (!this._pageOpenPending.has(pageNumber)) {
    return;
   }
   if (pageNumber !== this._pdfViewer.currentPageNumber) {
    return;
   }
   this._dispatchPageOpen(pageNumber);
  });
  this._internalEvents.set("pagesdestroy", async event => {
   await this._dispatchPageClose(this._pdfViewer.currentPageNumber);
   await this._scripting?.dispatchEventInSandbox({
    id: "doc",
    name: "WillClose"
   });
   this._closeCapability?.resolve();
  });
  this._domEvents.set("mousedown", event => {
   this._mouseState.isDown = true;
  });
  this._domEvents.set("mouseup", event => {
   this._mouseState.isDown = false;
  });
  for (const [name, listener] of this._internalEvents) {
   this._eventBus._on(name, listener);
  }
  for (const [name, listener] of this._domEvents) {
   window.addEventListener(name, listener);
  }
  try {
   const docProperties = await this._getDocProperties();
   if (pdfDocument !== this._pdfDocument) {
    return;
   }
   await this._scripting.createSandbox({
    objects,
    calculationOrder,
    appInfo: {
     platform: navigator.platform,
     language: navigator.language
    },
    docInfo: {
     ...docProperties,
     actions: docActions
    }
   });
   this._eventBus.dispatch("sandboxcreated", { source: this });
  } catch (error) {
   console.error(`PDFScriptingManager.setDocument: "${ error?.message }".`);
   await this._destroyScripting();
   return;
  }
  await this._scripting?.dispatchEventInSandbox({
   id: "doc",
   name: "Open"
  });
  await this._dispatchPageOpen(this._pdfViewer.currentPageNumber, true);
  Promise.resolve().then(() => {
   if (pdfDocument === this._pdfDocument) {
    this._ready = true;
   }
  });
 }
 async dispatchWillSave(detail) {
  return this._scripting?.dispatchEventInSandbox({
   id: "doc",
   name: "WillSave"
  });
 }
 async dispatchDidSave(detail) {
  return this._scripting?.dispatchEventInSandbox({
   id: "doc",
   name: "DidSave"
  });
 }
 async dispatchWillPrint(detail) {
  return this._scripting?.dispatchEventInSandbox({
   id: "doc",
   name: "WillPrint"
  });
 }
 async dispatchDidPrint(detail) {
  return this._scripting?.dispatchEventInSandbox({
   id: "doc",
   name: "DidPrint"
  });
 }
 get mouseState() {
  return this._mouseState;
 }
 get destroyPromise() {
  return this._destroyCapability?.promise || null;
 }
 get ready() {
  return this._ready;
 }
 get _internalEvents() {
  return shadow(this, "_internalEvents", new Map());
 }
 get _domEvents() {
  return shadow(this, "_domEvents", new Map());
 }
 get _pageOpenPending() {
  return shadow(this, "_pageOpenPending", new Set());
 }
 get _visitedPages() {
  return shadow(this, "_visitedPages", new Map());
 }
 async _updateFromSandbox(detail) {
  const {id, siblings, command, value} = detail;
  if (!id) {
   switch (command) {
   case "clear":
    console.clear();
    break;
   case "error":
    console.error(value);
    break;
   case "layout":

    const modes = apiPageLayoutToViewerModes(value);
    this._pdfViewer.spreadMode = modes.spreadMode;
    break;
   case "page-num":
    this._pdfViewer.currentPageNumber = value + 1;
    break;
   case "print":
    await this._pdfViewer.pagesPromise;
    this._eventBus.dispatch("print", { source: this });
    break;
   case "println":
    console.log(value);
    break;
   case "zoom":

    this._pdfViewer.currentScaleValue = value;
    break;
   case "SaveAs":
    this._eventBus.dispatch("save", { source: this });
    break;
   case "FirstPage":
    this._pdfViewer.currentPageNumber = 1;
    break;
   case "LastPage":
    this._pdfViewer.currentPageNumber = this._pdfViewer.pagesCount;
    break;
   case "NextPage":
    this._pdfViewer.nextPage();
    break;
   case "PrevPage":
    this._pdfViewer.previousPage();
    break;
   case "ZoomViewIn":
  
    this._pdfViewer.increaseScale();
    break;
   case "ZoomViewOut":
  
    this._pdfViewer.decreaseScale();
    break;
   }
   return;
  }

  delete detail.id;
  delete detail.siblings;
  const ids = siblings ? [
   id,
   ...siblings
  ] : [id];
  for (const elementId of ids) {
   const element = document.getElementById(elementId);
   if (element) {
    element.dispatchEvent(new CustomEvent("updatefromsandbox", { detail }));
   } else {
    this._pdfDocument?.annotationStorage.setValue(elementId, detail);
   }
  }
 }
 async _dispatchPageOpen(pageNumber, initialize = false) {
  const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;
  if (initialize) {
   this._closeCapability = createPromiseCapability();
  }
  if (!this._closeCapability) {
   return;
  }
  const pageView = this._pdfViewer.getPageView(pageNumber - 1);
  if (pageView?.renderingState !== RenderingStates.FINISHED) {
   this._pageOpenPending.add(pageNumber);
   return;
  }
  this._pageOpenPending.delete(pageNumber);
  const actionsPromise = ((async () => {
   const actions = await (!visitedPages.has(pageNumber) ? pageView.pdfPage?.getJSActions() : null);
   if (pdfDocument !== this._pdfDocument) {
    return;
   }
   await this._scripting?.dispatchEventInSandbox({
    id: "page",
    name: "PageOpen",
    pageNumber,
    actions
   });
  })());
  visitedPages.set(pageNumber, actionsPromise);
 }
 async _dispatchPageClose(pageNumber) {
  const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;
  if (!this._closeCapability) {
   return;
  }
  if (this._pageOpenPending.has(pageNumber)) {
   return;
  }
  const actionsPromise = visitedPages.get(pageNumber);
  if (!actionsPromise) {
   return;
  }
  visitedPages.set(pageNumber, null);
  await actionsPromise;
  if (pdfDocument !== this._pdfDocument) {
   return;
  }
  await this._scripting?.dispatchEventInSandbox({
   id: "page",
   name: "PageClose",
   pageNumber
  });
 }
 async _getDocProperties() {
  if (this._docPropertiesLookup) {
   return this._docPropertiesLookup(this._pdfDocument);
  }
  throw new Error("_getDocProperties: Unable to lookup properties.");
 }
 _createScripting() {
  this._destroyCapability = createPromiseCapability();
  if (this._scripting) {
   throw new Error("_createScripting: Scripting already exists.");
  }
  if (this._scriptingFactory) {
   return this._scriptingFactory.createScripting({ sandboxBundleSrc: this._sandboxBundleSrc });
  }
  throw new Error("_createScripting: Cannot create scripting.");
 }
 async _destroyScripting() {
  if (!this._scripting) {
   this._pdfDocument = null;
   this._destroyCapability?.resolve();
   return;
  }
  if (this._closeCapability) {
   await Promise.race([
    this._closeCapability.promise,
    new Promise(resolve => {
     setTimeout(resolve, 1000);
    })
   ]).catch(reason => {
   });
   this._closeCapability = null;
  }
  this._pdfDocument = null;
  try {
   await this._scripting.destroySandbox();
  } catch (ex) {
  }
  for (const [name, listener] of this._internalEvents) {
   this._eventBus._off(name, listener);
  }
  this._internalEvents.clear();
  for (const [name, listener] of this._domEvents) {
   window.removeEventListener(name, listener);
  }
  this._domEvents.clear();
  this._pageOpenPending.clear();
  this._visitedPages.clear();
  this._scripting = null;
  delete this._mouseState.isDown;
  this._ready = false;
  this._destroyCapability?.resolve();
 }
}



/***/ }),

/***/ "./src/pdf_viewer.js":
/*!***************************!*\
  !*** ./src/pdf_viewer.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDFSinglePageViewer": function() { return /* binding */ PDFSinglePageViewer; },
/* harmony export */   "PDFViewer": function() { return /* binding */ PDFViewer; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {ScrollMode, SpreadMode} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const {BaseViewer} = __webpack_require__(/*! ./base_viewer.js */ "./src/base_viewer.js");
class PDFViewer extends BaseViewer {
}
class PDFSinglePageViewer extends BaseViewer {
 _resetView() {
  super._resetView();
  this._scrollMode = ScrollMode.PAGE;
  this._spreadMode = SpreadMode.NONE;
 }
 set scrollMode(mode) {
 }
 _updateScrollMode() {
 }
 set spreadMode(mode) {
 }
 _updateSpreadMode() {
 }
}



/***/ }),

/***/ "./src/print_utils.js":
/*!****************************!*\
  !*** ./src/print_utils.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getXfaHtmlForPrinting": function() { return /* binding */ getXfaHtmlForPrinting; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {getXfaPageViewport, PixelsPerInch} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const {SimpleLinkService} = __webpack_require__(/*! ./pdf_link_service.js */ "./src/pdf_link_service.js");
const {XfaLayerBuilder} = __webpack_require__(/*! ./xfa_layer_builder.js */ "./src/xfa_layer_builder.js");
function getXfaHtmlForPrinting(printContainer, pdfDocument) {
 const xfaHtml = pdfDocument.allXfaHtml;
 const linkService = new SimpleLinkService();
 const scale = Math.round(PixelsPerInch.PDF_TO_CSS_UNITS * 100) / 100;
 for (const xfaPage of xfaHtml.children) {
  const page = document.createElement("div");
  page.className = "xfaPrintedPage";
  printContainer.appendChild(page);
  const builder = new XfaLayerBuilder({
   pageDiv: page,
   pdfPage: null,
   annotationStorage: pdfDocument.annotationStorage,
   linkService,
   xfaHtml: xfaPage
  });
  const viewport = getXfaPageViewport(xfaPage, { scale });
  builder.render(viewport, "print");
 }
}



/***/ }),

/***/ "./src/sdpdfcore.js":
/*!**************************!*\
  !*** ./src/sdpdfcore.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

const {AppOptions} = __webpack_require__(/*! ./app_options.js */ "./src/app_options.js");

class SDPDFCore {
    // this.PDFViewerApplication = app;
    // this.PDFViewerApplicationConfig = config;
    // this.pdfTabId;
    // this.callbackId;
    // this.callbackMap;

    init(app,config){
        this.PDFViewerApplication = app;
        this.PDFViewerApplicationConfig = config;
        this.callbackId=0;
        this.callbackMap={};
        window.addEventListener('message',(msg)=>{
            const {type,callbackId} = msg;
            let rt;
            switch(type){
                case 'RENDERER_TO_SDPDFCORE_CALLBACK':
                    this.handleCallback(msg);
                    break;
                case 'RENDERER_TO_SDPDFCORE_INVOKE':
                    this.handleInvoke(msg);
                    break;
                default:
                    console.warn(`INVALID TYPE ${type}`);
            }
        })
    }

    loadPDF(msg,callback){
        this.pdfTabId = msg.data.pdfTabId
        AppOptions.set('fileBlob',msg.data.fileBlob);
        this.PDFViewerApplication.run(this.PDFViewerApplicationConfig);
        callback('initReady');
    }

    getOutLine(msg,callback){
        this.PDFViewerApplication.pdfDocument.getOutline().then((o)=>{
            callback(o);
        });
    }
    callbackToRenderer(callbackId,data){
        window.postMessage({
            type:'SDPDFCORE_TO_RENDERER_CALLBACK',
            callbackId:`${callbackId}`,
            data
        })
    }
    postMessageToRenderer(data,callback){
        let callbackId=-1;
        if(callback&&typeof callback=='function'){
            callbackId = this.callbackId;
            this.callbackMap[`${callbackId}`] = callback;
            this.callbackId++;
        }
        window.postMessage({
            type:'SDPDFCORE_TO_RENDERER_INVOKE',
            callbackId:`${callbackId}`,
            data
        })
    }
    handleInvoke(msg){
        switch(msg.method){
            case 'loadPDF':
                this.loadPDF(msg,this.generalCallback(msg.callbackId));
                break;
            case 'getOutline':
                this.getOutLine(msg,this.generalCallback(msg.callbackId));
                break;
            default:
                console.warn(`Unknown invoke ${msg.method}`)
        }
    }
    generalCallback(callbackId){
        if(callbackId==-1){
            return function(){}
        }else{
            return function(data){
                this.callbackToRenderer(callbackId,data);
            }
        }
    }
    handleCallback(msg){
        const {callbackId} = msg
        if(callbackId!='-1'&&this.callbackMap[callbackId]&&typeof this.callbackMap[callbackId]=='function'){
            this.callbackMap[callbackId](msg.data)
        }
    }
}

/***/ }),

/***/ "./src/secondary_toolbar.js":
/*!**********************************!*\
  !*** ./src/secondary_toolbar.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SecondaryToolbar": function() { return /* binding */ SecondaryToolbar; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {SCROLLBAR_PADDING, ScrollMode, SpreadMode} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const {CursorTool} = __webpack_require__(/*! ./pdf_cursor_tools.js */ "./src/pdf_cursor_tools.js");
const {PagesCountLimit} = __webpack_require__(/*! ./base_viewer.js */ "./src/base_viewer.js");
class SecondaryToolbar {
 constructor(options, mainContainer, eventBus) {
  this.toolbar = options.toolbar;
  this.toggleButton = options.toggleButton;
  this.buttons = [

  //  {
  //   element: options.openFileButton,
  //   eventName: "openfile",
  //   close: true
  //  },
  //  {
  //   element: options.printButton,
  //   eventName: "print",
  //   close: true
  //  },
  //  {
  //   element: options.downloadButton,
  //   eventName: "download",
  //   close: true
  //  },
   {
    element: options.viewBookmarkButton,
    eventName: null,
    close: true
   },
   {
    element: options.firstPageButton,
    eventName: "firstpage",
    close: true
   },
   {
    element: options.lastPageButton,
    eventName: "lastpage",
    close: true
   },
   {
    element: options.pageRotateCwButton,
    eventName: "rotatecw",
    close: false
   },
   {
    element: options.pageRotateCcwButton,
    eventName: "rotateccw",
    close: false
   },
   {
    element: options.cursorSelectToolButton,
    eventName: "switchcursortool",
    eventDetails: { tool: CursorTool.SELECT },
    close: true
   },
   {
    element: options.cursorHandToolButton,
    eventName: "switchcursortool",
    eventDetails: { tool: CursorTool.HAND },
    close: true
   },
   {
    element: options.scrollPageButton,
    eventName: "switchscrollmode",
    eventDetails: { mode: ScrollMode.PAGE },
    close: true
   },
   {
    element: options.scrollVerticalButton,
    eventName: "switchscrollmode",
    eventDetails: { mode: ScrollMode.VERTICAL },
    close: true
   },
   {
    element: options.scrollHorizontalButton,
    eventName: "switchscrollmode",
    eventDetails: { mode: ScrollMode.HORIZONTAL },
    close: true
   },
   {
    element: options.scrollWrappedButton,
    eventName: "switchscrollmode",
    eventDetails: { mode: ScrollMode.WRAPPED },
    close: true
   },
   {
    element: options.spreadNoneButton,
    eventName: "switchspreadmode",
    eventDetails: { mode: SpreadMode.NONE },
    close: true
   },
   {
    element: options.spreadOddButton,
    eventName: "switchspreadmode",
    eventDetails: { mode: SpreadMode.ODD },
    close: true
   },
   {
    element: options.spreadEvenButton,
    eventName: "switchspreadmode",
    eventDetails: { mode: SpreadMode.EVEN },
    close: true
   }
   // saltdog disable documentProperties
//    ,
//    {
//     element: options.documentPropertiesButton,
//     eventName: "documentproperties",
//     close: true
//    }
  ];
  this.items = {
   firstPage: options.firstPageButton,
   lastPage: options.lastPageButton,
   pageRotateCw: options.pageRotateCwButton,
   pageRotateCcw: options.pageRotateCcwButton
  };
  this.mainContainer = mainContainer;
  this.eventBus = eventBus;
  this.opened = false;
  this.containerHeight = null;
  this.previousContainerHeight = null;
  this.reset();
  this._bindClickListeners();
  this._bindCursorToolsListener(options);
  this._bindScrollModeListener(options);
  this._bindSpreadModeListener(options);
  this.eventBus._on("resize", this._setMaxHeight.bind(this));
 }
 get isOpen() {
  return this.opened;
 }
 setPageNumber(pageNumber) {
  this.pageNumber = pageNumber;
  this._updateUIState();
 }
 setPagesCount(pagesCount) {
  this.pagesCount = pagesCount;
  this._updateUIState();
 }
 reset() {
  this.pageNumber = 0;
  this.pagesCount = 0;
  this._updateUIState();
  this.eventBus.dispatch("secondarytoolbarreset", { source: this });
 }
 _updateUIState() {
  this.items.firstPage.disabled = this.pageNumber <= 1;
  this.items.lastPage.disabled = this.pageNumber >= this.pagesCount;
  this.items.pageRotateCw.disabled = this.pagesCount === 0;
  this.items.pageRotateCcw.disabled = this.pagesCount === 0;
 }
 _bindClickListeners() {
  this.toggleButton.addEventListener("click", this.toggle.bind(this));
  console.log(this.buttons);
  for (const {element, eventName, close, eventDetails} of this.buttons) {
   element.addEventListener("click", evt => {
    if (eventName !== null) {
     const details = { source: this };
     for (const property in eventDetails) {
      details[property] = eventDetails[property];
     }
     this.eventBus.dispatch(eventName, details);
    }
    if (close) {
     this.close();
    }
   });
  }
 }
 _bindCursorToolsListener(buttons) {
  this.eventBus._on("cursortoolchanged", function ({tool}) {

   buttons.cursorSelectToolButton.classList.toggle("active", tool === CursorTool.SELECT);
   buttons.cursorHandToolButton.classList.toggle("active", tool === CursorTool.HAND);
  });
 }
 _bindScrollModeListener(buttons) {
  const scrollModeChanged = ({mode}) => {
   buttons.scrollPageButton.classList.toggle("active", mode === ScrollMode.PAGE);
   buttons.scrollVerticalButton.classList.toggle("active", mode === ScrollMode.VERTICAL);
   buttons.scrollHorizontalButton.classList.toggle("active", mode === ScrollMode.HORIZONTAL);
   buttons.scrollWrappedButton.classList.toggle("active", mode === ScrollMode.WRAPPED);
   const forceScrollModePage = this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE;
   buttons.scrollPageButton.disabled = forceScrollModePage;
   buttons.scrollVerticalButton.disabled = forceScrollModePage;
   buttons.scrollHorizontalButton.disabled = forceScrollModePage;
   buttons.scrollWrappedButton.disabled = forceScrollModePage;
   const isScrollModeHorizontal = mode === ScrollMode.HORIZONTAL;
   buttons.spreadNoneButton.disabled = isScrollModeHorizontal;
   buttons.spreadOddButton.disabled = isScrollModeHorizontal;
   buttons.spreadEvenButton.disabled = isScrollModeHorizontal;
  };
  this.eventBus._on("scrollmodechanged", scrollModeChanged);
  this.eventBus._on("secondarytoolbarreset", evt => {
   if (evt.source === this) {
    scrollModeChanged({ mode: ScrollMode.VERTICAL });
   }
  });
 }
 _bindSpreadModeListener(buttons) {
  function spreadModeChanged({mode}) {
   buttons.spreadNoneButton.classList.toggle("active", mode === SpreadMode.NONE);
   buttons.spreadOddButton.classList.toggle("active", mode === SpreadMode.ODD);
   buttons.spreadEvenButton.classList.toggle("active", mode === SpreadMode.EVEN);
  }
  this.eventBus._on("spreadmodechanged", spreadModeChanged);
  this.eventBus._on("secondarytoolbarreset", evt => {
   if (evt.source === this) {
    spreadModeChanged({ mode: SpreadMode.NONE });
   }
  });
 }
 open() {
  if (this.opened) {
   return;
  }
  this.opened = true;
  this._setMaxHeight();
  this.toggleButton.classList.add("active");
  this.toggleButton.setAttribute("aria-expanded", "true");
  this.toolbar.classList.remove("closed");
 }
 close() {
  if (!this.opened) {
   return;
  }
  this.opened = false;
  this.toolbar.classList.add("closed");
  this.toggleButton.classList.remove("active");
  this.toggleButton.setAttribute("aria-expanded", "false");
 }
 toggle() {
  if (this.opened) {
   this.close();
  } else {
   this.open();
  }
 }
 _setMaxHeight() {
  if (!this.opened) {
   return;
  }
 }
}



/***/ }),

/***/ "./src/struct_tree_layer_builder.js":
/*!******************************************!*\
  !*** ./src/struct_tree_layer_builder.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StructTreeLayerBuilder": function() { return /* binding */ StructTreeLayerBuilder; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const PDF_ROLE_TO_HTML_ROLE = {
 Document: null,
 DocumentFragment: null,
 Part: "group",
 Sect: "group",
 Div: "group",
 Aside: "note",
 NonStruct: "none",
 P: null,
 H: "heading",
 Title: null,
 FENote: "note",
 Sub: "group",
 Lbl: null,
 Span: null,
 Em: null,
 Strong: null,
 Link: "link",
 Annot: "note",
 Form: "form",
 Ruby: null,
 RB: null,
 RT: null,
 RP: null,
 Warichu: null,
 WT: null,
 WP: null,
 L: "list",
 LI: "listitem",
 LBody: null,
 Table: "table",
 TR: "row",
 TH: "columnheader",
 TD: "cell",
 THead: "columnheader",
 TBody: null,
 TFoot: null,
 Caption: null,
 Figure: "figure",
 Formula: null,
 Artifact: null
};
const HEADING_PATTERN = /^H(\d+)$/;
class StructTreeLayerBuilder {
 constructor({pdfPage}) {
  this.pdfPage = pdfPage;
 }
 render(structTree) {
  return this._walk(structTree);
 }
 _setAttributes(structElement, htmlElement) {
  if (structElement.alt !== undefined) {
   htmlElement.setAttribute("aria-label", structElement.alt);
  }
  if (structElement.id !== undefined) {
   htmlElement.setAttribute("aria-owns", structElement.id);
  }
  if (structElement.lang !== undefined) {
   htmlElement.setAttribute("lang", structElement.lang);
  }
 }
 _walk(node) {
  if (!node) {
   return null;
  }
  const element = document.createElement("span");
  if ("role" in node) {
   const {role} = node;
   const match = role.match(HEADING_PATTERN);
   if (match) {
    element.setAttribute("role", "heading");
    element.setAttribute("aria-level", match[1]);
   } else if (PDF_ROLE_TO_HTML_ROLE[role]) {
    element.setAttribute("role", PDF_ROLE_TO_HTML_ROLE[role]);
   }
  }
  this._setAttributes(node, element);
  if (node.children) {
   if (node.children.length === 1 && "id" in node.children[0]) {
    this._setAttributes(node.children[0], element);
   } else {
    for (const kid of node.children) {
     element.appendChild(this._walk(kid));
    }
   }
  }
  return element;
 }
}



/***/ }),

/***/ "./src/text_highlighter.js":
/*!*********************************!*\
  !*** ./src/text_highlighter.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextHighlighter": function() { return /* binding */ TextHighlighter; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

class TextHighlighter {
 constructor({findController, eventBus, pageIndex}) {
  this.findController = findController;
  this.matches = [];
  this.eventBus = eventBus;
  this.pageIdx = pageIndex;
  this._onUpdateTextLayerMatches = null;
  this.textDivs = null;
  this.textContentItemsStr = null;
  this.enabled = false;
 }
 setTextMapping(divs, texts) {
  this.textDivs = divs;
  this.textContentItemsStr = texts;
 }
 enable() {
  if (!this.textDivs || !this.textContentItemsStr) {
   throw new Error("Text divs and strings have not been set.");
  }
  if (this.enabled) {
   throw new Error("TextHighlighter is already enabled.");
  }
  this.enabled = true;
  if (!this._onUpdateTextLayerMatches) {
   this._onUpdateTextLayerMatches = evt => {
    if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
     this._updateMatches();
    }
   };
   this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
  }
  this._updateMatches();
 }
 disable() {
  if (!this.enabled) {
   return;
  }
  this.enabled = false;
  if (this._onUpdateTextLayerMatches) {
   this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);
   this._onUpdateTextLayerMatches = null;
  }
 }
 _convertMatches(matches, matchesLength) {
  if (!matches) {
   return [];
  }
  const {textContentItemsStr} = this;
  let i = 0, iIndex = 0;
  const end = textContentItemsStr.length - 1;
  const result = [];
  for (let m = 0, mm = matches.length; m < mm; m++) {
   let matchIdx = matches[m];
   while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
    iIndex += textContentItemsStr[i].length;
    i++;
   }
   if (i === textContentItemsStr.length) {
    console.error("Could not find a matching mapping");
   }
   const match = {
    begin: {
     divIdx: i,
     offset: matchIdx - iIndex
    }
   };
   matchIdx += matchesLength[m];
   while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
    iIndex += textContentItemsStr[i].length;
    i++;
   }
   match.end = {
    divIdx: i,
    offset: matchIdx - iIndex
   };
   result.push(match);
  }
  return result;
 }

 _renderMatches(matches) {
  if (matches.length === 0) {
   return;
  }
  const {findController, pageIdx} = this;
  const {textContentItemsStr, textDivs} = this;
  const isSelectedPage = pageIdx === findController.selected.pageIdx;
  const selectedMatchIdx = findController.selected.matchIdx;
  const highlightAll = findController.state.highlightAll;
  let prevEnd = null;
  const infinity = {
   divIdx: -1,
   offset: undefined
  };
  function beginText(begin, className) {
   const divIdx = begin.divIdx;
   textDivs[divIdx].textContent = "";
   return appendTextToDiv(divIdx, 0, begin.offset, className);
  }
  function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
   let div = textDivs[divIdx];
   if (div.nodeType === Node.TEXT_NODE) {
    const span = document.createElement("span");
    div.parentNode.insertBefore(span, div);
    span.appendChild(div);
    textDivs[divIdx] = span;
    div = span;
   }
   const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
   const node = document.createTextNode(content);
   if (className) {
    const span = document.createElement("span");
    span.className = `${ className } appended`;
    span.appendChild(node);
    div.appendChild(span);
    return className.includes("selected") ? span.offsetLeft : 0;
   }
   div.appendChild(node);
   return 0;
  }
  let i0 = selectedMatchIdx, i1 = i0 + 1;
  if (highlightAll) {
   i0 = 0;
   i1 = matches.length;
  } else if (!isSelectedPage) {
   return;
  }
  for (let i = i0; i < i1; i++) {
   const match = matches[i];
   const begin = match.begin;
   const end = match.end;
   const isSelected = isSelectedPage && i === selectedMatchIdx;
   const highlightSuffix = isSelected ? " selected" : "";
   let selectedLeft = 0;
   if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
    if (prevEnd !== null) {
     appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
    }
    beginText(begin);
   } else {
    appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
   }
   if (begin.divIdx === end.divIdx) {
    selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
   } else {
    selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);
    for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
     textDivs[n0].className = "highlight middle" + highlightSuffix;
    }
    beginText(end, "highlight end" + highlightSuffix);
   }
   prevEnd = end;
   if (isSelected) {
    findController.scrollMatchIntoView({
     element: textDivs[begin.divIdx],
     selectedLeft,
     pageIndex: pageIdx,
     matchIndex: selectedMatchIdx
    });
   }
  }
  if (prevEnd) {
   appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
  }
 }


 _updateMatches() {
  if (!this.enabled) {
   return;
  }
  const {findController, matches, pageIdx} = this;
  const {textContentItemsStr, textDivs} = this;
  let clearedUntilDivIdx = -1;
  for (let i = 0, ii = matches.length; i < ii; i++) {
   const match = matches[i];
   const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
   for (let n = begin, end = match.end.divIdx; n <= end; n++) {
    const div = textDivs[n];
    div.textContent = textContentItemsStr[n];
    div.className = "";
   }
   clearedUntilDivIdx = match.end.divIdx + 1;
  }
  if (!findController?.highlightMatches) {
   return;
  }
  const pageMatches = findController.pageMatches[pageIdx] || null;
  const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
  this.matches = this._convertMatches(pageMatches, pageMatchesLength);
  this._renderMatches(this.matches);
 }

 _moveToHere(selectedMatchIdx) {
    const matches = this.matches;
    const {findController, pageIdx} = this;
    const {textContentItemsStr, textDivs} = this;
    const isSelectedPage = true;
    const highlightAll = false;
    let prevEnd = null;
    const infinity = {
     divIdx: -1,
     offset: undefined
    };
    function beginText(begin, className) {
     const divIdx = begin.divIdx;
     textDivs[divIdx].textContent = "";
     return appendTextToDiv(divIdx, 0, begin.offset, className);
    }
    function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
     let div = textDivs[divIdx];
     if (div.nodeType === Node.TEXT_NODE) {
      const span = document.createElement("span");
      div.parentNode.insertBefore(span, div);
      span.appendChild(div);
      textDivs[divIdx] = span;
      div = span;
     }
     const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
     const node = document.createTextNode(content);
     if (className) {
      const span = document.createElement("span");
      span.className = `${ className } appended`;
      span.appendChild(node);
      div.appendChild(span);
      return className.includes("selected") ? span.offsetLeft : 0;
     }
     div.appendChild(node);
     return 0;
    }
    let i0 = selectedMatchIdx, i1 = i0 + 1;

     const match = matches[selectedMatchIdx];
     const begin = match.begin;
     const end = match.end;
     const isSelected = true;
     const highlightSuffix = isSelected ? " selected" : "";
     let selectedLeft = 0;
     if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
      if (prevEnd !== null) {
       appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
      }
      beginText(begin);
     } else {
      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
     }
     if (begin.divIdx === end.divIdx) {
      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
     } else {
      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);
      for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
       textDivs[n0].className = "highlight middle" + highlightSuffix;
      }
      beginText(end, "highlight end" + highlightSuffix);
     }
     prevEnd = end;
     if (isSelected) {
      findController.whatEverScrollMatchIntoView({
       element: textDivs[begin.divIdx],
       selectedLeft,
       pageIndex: pageIdx,
       matchIndex: selectedMatchIdx
      });
     }
    if (prevEnd) {
     appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
    }
   }
 
}



/***/ }),

/***/ "./src/text_layer_builder.js":
/*!***********************************!*\
  !*** ./src/text_layer_builder.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextLayerBuilder": function() { return /* binding */ TextLayerBuilder; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {renderTextLayer} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
const EXPAND_DIVS_TIMEOUT = 300;
class TextLayerBuilder {
 constructor({textLayerDiv, eventBus, pageIndex, viewport, highlighter = null, enhanceTextSelection = false}) {
  this.textLayerDiv = textLayerDiv;
  this.eventBus = eventBus;
  this.textContent = null;
  this.textContentItemsStr = [];
  this.textContentStream = null;
  this.renderingDone = false;
  this.pageNumber = pageIndex + 1;
  this.viewport = viewport;
  this.textDivs = [];
  this.textLayerRenderTask = null;
  this.highlighter = highlighter;
  this.enhanceTextSelection = enhanceTextSelection;
  this._bindMouse();
 }
 _finishRendering() {
  this.renderingDone = true;
  if (!this.enhanceTextSelection) {
   const endOfContent = document.createElement("div");
   endOfContent.className = "endOfContent";
   this.textLayerDiv.appendChild(endOfContent);
  }
  this.eventBus.dispatch("textlayerrendered", {
   source: this,
   pageNumber: this.pageNumber,
   numTextDivs: this.textDivs.length
  });
 }
 render(timeout = 0) {
  if (!(this.textContent || this.textContentStream) || this.renderingDone) {
   return;
  }
  this.cancel();
  this.textDivs.length = 0;
  this.highlighter?.setTextMapping(this.textDivs, this.textContentItemsStr);
  const textLayerFrag = document.createDocumentFragment();
  this.textLayerRenderTask = renderTextLayer({
   textContent: this.textContent,
   textContentStream: this.textContentStream,
   container: textLayerFrag,
   viewport: this.viewport,
   textDivs: this.textDivs,
   textContentItemsStr: this.textContentItemsStr,
   timeout,
   enhanceTextSelection: this.enhanceTextSelection
  });
  this.textLayerRenderTask.promise.then(() => {
   this.textLayerDiv.appendChild(textLayerFrag);
   this._finishRendering();
   this.highlighter?.enable();
  }, function (reason) {
  });
 }
 cancel() {
  if (this.textLayerRenderTask) {
   this.textLayerRenderTask.cancel();
   this.textLayerRenderTask = null;
  }
  this.highlighter?.disable();
 }
 setTextContentStream(readableStream) {
  this.cancel();
  this.textContentStream = readableStream;
 }
 setTextContent(textContent) {
  this.cancel();
  this.textContent = textContent;
 }
 _bindMouse() {
  const div = this.textLayerDiv;
  let expandDivsTimer = null;
  div.addEventListener("mousedown", evt => {
   if (this.enhanceTextSelection && this.textLayerRenderTask) {
    this.textLayerRenderTask.expandTextDivs(true);
    if (expandDivsTimer) {
     clearTimeout(expandDivsTimer);
     expandDivsTimer = null;
    }
    return;
   }
   const end = div.querySelector(".endOfContent");
   if (!end) {
    return;
   }
   let adjustTop = evt.target !== div;
   adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";
   if (adjustTop) {
    const divBounds = div.getBoundingClientRect();
    const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
    end.style.top = (r * 100).toFixed(2) + "%";
   }
   end.classList.add("active");
  });
  div.addEventListener("mouseup", () => {
   if (this.enhanceTextSelection && this.textLayerRenderTask) {
    expandDivsTimer = setTimeout(() => {
     if (this.textLayerRenderTask) {
      this.textLayerRenderTask.expandTextDivs(false);
     }
     expandDivsTimer = null;
    }, EXPAND_DIVS_TIMEOUT);
    return;
   }
   const end = div.querySelector(".endOfContent");
   if (!end) {
    return;
   }
   end.style.top = "";
   end.classList.remove("active");
  });
 }
}



/***/ }),

/***/ "./src/toolbar.js":
/*!************************!*\
  !*** ./src/toolbar.js ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Toolbar": function() { return /* binding */ Toolbar; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {animationStarted, DEFAULT_SCALE, DEFAULT_SCALE_VALUE, MAX_SCALE, MIN_SCALE, noContextMenuHandler} = __webpack_require__(/*! ./ui_utils.js */ "./src/ui_utils.js");
const PAGE_NUMBER_LOADING_INDICATOR = "visiblePageIsLoading";
class Toolbar {
 constructor(options, eventBus, l10n) {
  this.toolbar = options.container;
  this.eventBus = eventBus;
  this.l10n = l10n;
  this.buttons = [
   {
    element: options.previous,
    eventName: "previouspage"
   },
   {
    element: options.next,
    eventName: "nextpage"
   },
   {
    element: options.zoomIn,
    eventName: "zoomin"
   },
   {
    element: options.zoomOut,
    eventName: "zoomout"
   },
   {
    element: options.openFile,
    eventName: "openfile"
   },
   {
    element: options.print,
    eventName: "print"
   },
   {
    element: options.download,
    eventName: "download"
   },
   {
    element: options.viewBookmark,
    eventName: null
   }
  ];
  this.items = {
   numPages: options.numPages,
   pageNumber: options.pageNumber,
   scaleSelect: options.scaleSelect,
   scaleSelectOptions:options.scaleSelectOptions,
   scaleSelectShowOptionsButton:options.scaleSelectShowOptionsButton,
   previous: options.previous,
   next: options.next,
   zoomIn: options.zoomIn,
   zoomOut: options.zoomOut
  };
  this._wasLocalized = false;
  this.reset();
  this._bindListeners();
 }
 setPageNumber(pageNumber, pageLabel) {
  this.pageNumber = pageNumber;
  this.pageLabel = pageLabel;
  this._updateUIState(false);
 }
 setPagesCount(pagesCount, hasPageLabels) {
  this.pagesCount = pagesCount;
  this.hasPageLabels = hasPageLabels;
  this._updateUIState(true);
 }
 setPageScale(pageScaleValue, pageScale) {
  this.pageScaleValue = (pageScaleValue || pageScale).toString();
  this.pageScale = pageScale;
  this._updateUIState(false);
 }
 reset() {
  this.pageNumber = 0;
  this.pageLabel = null;
  this.hasPageLabels = false;
  this.pagesCount = 0;
  this.pageScaleValue = DEFAULT_SCALE_VALUE;
  this.pageScale = DEFAULT_SCALE;
  this._updateUIState(true);
  this.updateLoadingIndicatorState();
 }
 _bindListeners() {
  const {pageNumber, scaleSelect,scaleSelectOptions,scaleSelectShowOptionsButton} = this.items;
  const self = this;
  for (const {element, eventName} of this.buttons) {
   element.addEventListener("click", evt => {
    if (eventName !== null) {
     this.eventBus.dispatch(eventName, { source: this });
    }
   });
  }

  pageNumber.addEventListener("click", function () {
   this.select();
  });
  pageNumber.addEventListener("change", function () {
   self.eventBus.dispatch("pagenumberchanged", {
    source: self,
    value: parseInt(this.value)
   });
  });

  const scaleOptionBtns=Array.from(scaleSelectOptions.children).filter((ele)=>{
      return ele.tagName=='BUTTON';
  })

  for(const ele of scaleOptionBtns){
    ele.addEventListener('click',function(){
        if (ele.ariaLabel === "custom") {
            return;
           }
           let disPatchValue = ele.ariaLabel;
           if(!isNaN(parseInt(ele.ariaLabel))){
            disPatchValue = parseInt(ele.ariaLabel)/100
           }
           self.eventBus.dispatch("scalechanged", {
            source: self,
            value: disPatchValue
           });
           Array.from(scaleSelectOptions.children).forEach((e)=>{
            e.classList.remove('selected');
        });

           ele.classList.add("selected");
           scaleSelect.value=ele.ariaLabel;
           scaleSelectOptions.classList.add('closed');
    })
  }
  scaleSelect.addEventListener("change", function () {
   if (this.value === "custom") {
    return;
   }
   let disPatchValue = this.value;
   if(!isNaN(parseInt(this.value))){
    disPatchValue = parseInt(this.value)/100
   }
   self.eventBus.dispatch("scalechanged", {
    source: self,
    value: disPatchValue
   });
  });
  scaleSelectShowOptionsButton.addEventListener('click',()=>{
      if(scaleSelectOptions.classList.contains('closed')){
        scaleSelectOptions.classList.remove('closed');
      }else{
        scaleSelectOptions.classList.add('closed');
      }
    
  })
  scaleSelect.addEventListener("click", function (evt) {
   const target = evt.target;
   if (this.value === self.pageScaleValue && target.tagName.toUpperCase() === "OPTION") {
    this.blur();
   }
  });
  scaleSelect.oncontextmenu = noContextMenuHandler;
  this.eventBus._on("localized", () => {
   this._wasLocalized = true;
   this._adjustScaleWidth();
   this._updateUIState(true);
  });
 }
 _updateUIState(resetNumPages = false) {
  if (!this._wasLocalized) {
   return;
  }
  const {pageNumber, pagesCount, pageScaleValue, pageScale, items} = this;
  if (resetNumPages) {
   if (this.hasPageLabels) {
    items.pageNumber.type = "text";
   } else {
    items.pageNumber.type = "text";
    this.l10n.get("of_pages", { pagesCount }).then(msg => {
     items.numPages.textContent = msg;
    });
   }

   items.pageNumber.max = pagesCount;
  }
  if (this.hasPageLabels) {
   items.pageNumber.value = this.pageLabel;
   this.l10n.get("page_of_pages", {
    pageNumber,
    pagesCount
   }).then(msg => {
    items.numPages.textContent = msg;
   });
  } else {
   items.pageNumber.value = pageNumber;
  }
  items.previous.disabled = pageNumber <= 1;
  items.next.disabled = pageNumber >= pagesCount;
  items.zoomOut.disabled = pageScale <= MIN_SCALE;
  items.zoomIn.disabled = pageScale >= MAX_SCALE;
  let predefinedValueFound = false;


  this.l10n.get("page_scale_percent", { scale: Math.round(pageScale * 10000) / 100 }).then(msg => {
    let predefinedValueFound = false;
    for (const option of items.scaleSelect.children) {
        if (parseInt(option.ariaLabel)/100 !== pageScaleValue) {
            option.classList.remove('selected');
            continue;
           }
           option.classList.add('selected');
     predefinedValueFound = true;
    }
    if (!predefinedValueFound) {
     scaleSelect.value = Math.round(pageScale * 10000) / 100;
    }
   });
 }
 updateLoadingIndicatorState(loading = false) {
  const pageNumberInput = this.items.pageNumber;
  pageNumberInput.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading);
 }
 async _adjustScaleWidth() {
  const {items, l10n} = this;
  const predefinedValuesPromise = Promise.all([
   l10n.get("page_scale_auto"),
   l10n.get("page_scale_actual"),
   l10n.get("page_scale_fit"),
   l10n.get("page_scale_width")
  ]);
  const style = getComputedStyle(items.scaleSelect), scaleSelectContainerWidth = parseInt(style.getPropertyValue("--scale-select-container-width"), 10), scaleSelectOverflow = parseInt(style.getPropertyValue("--scale-select-overflow"), 10);
  let canvas = document.createElement("canvas");
  canvas.mozOpaque = true;
  let ctx = canvas.getContext("2d", { alpha: false });
  await animationStarted;
  ctx.font = `${ style.fontSize } ${ style.fontFamily }`;
  let maxWidth = 0;
  for (const predefinedValue of await predefinedValuesPromise) {
   const {width} = ctx.measureText(predefinedValue);
   if (width > maxWidth) {
    maxWidth = width;
   }
  }
  maxWidth += 2 * scaleSelectOverflow;
  if (maxWidth > scaleSelectContainerWidth) {
   const doc = document.documentElement;
   doc.style.setProperty("--scale-select-container-width", `${ maxWidth }px`);
  }
  canvas.width = 0;
  canvas.height = 0;
  canvas = ctx = null;
 }
}



/***/ }),

/***/ "./src/ui_utils.js":
/*!*************************!*\
  !*** ./src/ui_utils.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animationStarted": function() { return /* binding */ animationStarted; },
/* harmony export */   "apiPageLayoutToViewerModes": function() { return /* binding */ apiPageLayoutToViewerModes; },
/* harmony export */   "apiPageModeToSidebarView": function() { return /* binding */ apiPageModeToSidebarView; },
/* harmony export */   "approximateFraction": function() { return /* binding */ approximateFraction; },
/* harmony export */   "AutoPrintRegExp": function() { return /* binding */ AutoPrintRegExp; },
/* harmony export */   "backtrackBeforeAllVisibleElements": function() { return /* binding */ backtrackBeforeAllVisibleElements; },
/* harmony export */   "binarySearchFirstItem": function() { return /* binding */ binarySearchFirstItem; },
/* harmony export */   "DEFAULT_SCALE": function() { return /* binding */ DEFAULT_SCALE; },
/* harmony export */   "DEFAULT_SCALE_DELTA": function() { return /* binding */ DEFAULT_SCALE_DELTA; },
/* harmony export */   "DEFAULT_SCALE_VALUE": function() { return /* binding */ DEFAULT_SCALE_VALUE; },
/* harmony export */   "getActiveOrFocusedElement": function() { return /* binding */ getActiveOrFocusedElement; },
/* harmony export */   "getOutputScale": function() { return /* binding */ getOutputScale; },
/* harmony export */   "getPageSizeInches": function() { return /* binding */ getPageSizeInches; },
/* harmony export */   "getVisibleElements": function() { return /* binding */ getVisibleElements; },
/* harmony export */   "isPortraitOrientation": function() { return /* binding */ isPortraitOrientation; },
/* harmony export */   "isValidRotation": function() { return /* binding */ isValidRotation; },
/* harmony export */   "isValidScrollMode": function() { return /* binding */ isValidScrollMode; },
/* harmony export */   "isValidSpreadMode": function() { return /* binding */ isValidSpreadMode; },
/* harmony export */   "MAX_AUTO_SCALE": function() { return /* binding */ MAX_AUTO_SCALE; },
/* harmony export */   "MAX_SCALE": function() { return /* binding */ MAX_SCALE; },
/* harmony export */   "MIN_SCALE": function() { return /* binding */ MIN_SCALE; },
/* harmony export */   "noContextMenuHandler": function() { return /* binding */ noContextMenuHandler; },
/* harmony export */   "normalizeWheelEventDelta": function() { return /* binding */ normalizeWheelEventDelta; },
/* harmony export */   "normalizeWheelEventDirection": function() { return /* binding */ normalizeWheelEventDirection; },
/* harmony export */   "parseQueryString": function() { return /* binding */ parseQueryString; },
/* harmony export */   "ProgressBar": function() { return /* binding */ ProgressBar; },
/* harmony export */   "removeNullCharacters": function() { return /* binding */ removeNullCharacters; },
/* harmony export */   "RendererType": function() { return /* binding */ RendererType; },
/* harmony export */   "RenderingStates": function() { return /* binding */ RenderingStates; },
/* harmony export */   "roundToDivide": function() { return /* binding */ roundToDivide; },
/* harmony export */   "SCROLLBAR_PADDING": function() { return /* binding */ SCROLLBAR_PADDING; },
/* harmony export */   "scrollIntoView": function() { return /* binding */ scrollIntoView; },
/* harmony export */   "ScrollMode": function() { return /* binding */ ScrollMode; },
/* harmony export */   "SidebarView": function() { return /* binding */ SidebarView; },
/* harmony export */   "SpreadMode": function() { return /* binding */ SpreadMode; },
/* harmony export */   "TextLayerMode": function() { return /* binding */ TextLayerMode; },
/* harmony export */   "UNKNOWN_SCALE": function() { return /* binding */ UNKNOWN_SCALE; },
/* harmony export */   "VERTICAL_PADDING": function() { return /* binding */ VERTICAL_PADDING; },
/* harmony export */   "watchScroll": function() { return /* binding */ watchScroll; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const DEFAULT_SCALE_VALUE = "auto";
const DEFAULT_SCALE = 1.0;
const DEFAULT_SCALE_DELTA = 1.1;
const MIN_SCALE = 0.1;
const MAX_SCALE = 10.0;
const UNKNOWN_SCALE = 0;
const MAX_AUTO_SCALE = 1.25;
const SCROLLBAR_PADDING = 40;
const VERTICAL_PADDING = 5;
const LOADINGBAR_END_OFFSET_VAR = "--loadingBar-end-offset";
const RenderingStates = {
 INITIAL: 0,
 RUNNING: 1,
 PAUSED: 2,
 FINISHED: 3
};
const SidebarView = {
 UNKNOWN: -1,
 NONE: 0,
 THUMBS: 1,
 OUTLINE: 2,
 ATTACHMENTS: 3,
 LAYERS: 4
};
const RendererType = {
 CANVAS: "canvas",
 SVG: "svg"
};
const TextLayerMode = {
 DISABLE: 0,
 ENABLE: 1,
 ENABLE_ENHANCE: 2
};
const ScrollMode = {
 UNKNOWN: -1,
 VERTICAL: 0,
 HORIZONTAL: 1,
 WRAPPED: 2,
 PAGE: 3
};
const SpreadMode = {
 UNKNOWN: -1,
 NONE: 0,
 ODD: 1,
 EVEN: 2
};
const AutoPrintRegExp = /\bprint\s*\(/;
function getOutputScale(ctx) {
 const devicePixelRatio = window.devicePixelRatio || 1;
 const backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
 const pixelRatio = devicePixelRatio / backingStoreRatio;
 return {
  sx: pixelRatio,
  sy: pixelRatio,
  scaled: pixelRatio !== 1
 };
}
function scrollIntoView(element, spot, scrollMatches = false) {
 let parent = element.offsetParent;
 if (!parent) {
  console.error("offsetParent is not set -- cannot scroll");
  return;
 }
 let offsetY = element.offsetTop + element.clientTop;
 let offsetX = element.offsetLeft + element.clientLeft;
 while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains("markedContent") || getComputedStyle(parent).overflow === "hidden")) {
  offsetY += parent.offsetTop;
  offsetX += parent.offsetLeft;
  parent = parent.offsetParent;
  if (!parent) {
   return;
  }
 }
 if (spot) {
  if (spot.top !== undefined) {
   offsetY += spot.top;
  }
  if (spot.left !== undefined) {
   offsetX += spot.left;
   parent.scrollLeft = offsetX;
  }
 }
 parent.scrollTop = offsetY;
}
function watchScroll(viewAreaElement, callback) {
 const debounceScroll = function (evt) {
  if (rAF) {
   return;
  }
  rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
   rAF = null;
   const currentX = viewAreaElement.scrollLeft;
   const lastX = state.lastX;
   if (currentX !== lastX) {
    state.right = currentX > lastX;
   }
   state.lastX = currentX;
   const currentY = viewAreaElement.scrollTop;
   const lastY = state.lastY;
   if (currentY !== lastY) {
    state.down = currentY > lastY;
   }
   state.lastY = currentY;
   callback(state);
  });
 };
 const state = {
  right: true,
  down: true,
  lastX: viewAreaElement.scrollLeft,
  lastY: viewAreaElement.scrollTop,
  _eventHandler: debounceScroll
 };
 let rAF = null;
 viewAreaElement.addEventListener("scroll", debounceScroll, true);
 return state;
}
function parseQueryString(query) {
 const params = new Map();
 for (const [key, value] of new URLSearchParams(query)) {
  params.set(key.toLowerCase(), value);
 }
 return params;
}
const NullCharactersRegExp = /\x00/g;
const InvisibleCharactersRegExp = /[\x01-\x1F]/g;
function removeNullCharacters(str, replaceInvisible = false) {
 if (typeof str !== "string") {
  console.error(`The argument must be a string.`);
  return str;
 }
 if (replaceInvisible) {
  str = str.replace(InvisibleCharactersRegExp, " ");
 }
 return str.replace(NullCharactersRegExp, "");
}
function binarySearchFirstItem(items, condition, start = 0) {
 let minIndex = start;
 let maxIndex = items.length - 1;
 if (maxIndex < 0 || !condition(items[maxIndex])) {
  return items.length;
 }
 if (condition(items[minIndex])) {
  return minIndex;
 }
 while (minIndex < maxIndex) {
  const currentIndex = minIndex + maxIndex >> 1;
  const currentItem = items[currentIndex];
  if (condition(currentItem)) {
   maxIndex = currentIndex;
  } else {
   minIndex = currentIndex + 1;
  }
 }
 return minIndex;
}
function approximateFraction(x) {
 if (Math.floor(x) === x) {
  return [
   x,
   1
  ];
 }
 const xinv = 1 / x;
 const limit = 8;
 if (xinv > limit) {
  return [
   1,
   limit
  ];
 } else if (Math.floor(xinv) === xinv) {
  return [
   1,
   xinv
  ];
 }
 const x_ = x > 1 ? xinv : x;
 let a = 0, b = 1, c = 1, d = 1;
 while (true) {
  const p = a + c, q = b + d;
  if (q > limit) {
   break;
  }
  if (x_ <= p / q) {
   c = p;
   d = q;
  } else {
   a = p;
   b = q;
  }
 }
 let result;
 if (x_ - a / b < c / d - x_) {
  result = x_ === x ? [
   a,
   b
  ] : [
   b,
   a
  ];
 } else {
  result = x_ === x ? [
   c,
   d
  ] : [
   d,
   c
  ];
 }
 return result;
}
function roundToDivide(x, div) {
 const r = x % div;
 return r === 0 ? x : Math.round(x - r + div);
}
function getPageSizeInches({view, userUnit, rotate}) {
 const [x1, y1, x2, y2] = view;
 const changeOrientation = rotate % 180 !== 0;
 const width = (x2 - x1) / 72 * userUnit;
 const height = (y2 - y1) / 72 * userUnit;
 return {
  width: changeOrientation ? height : width,
  height: changeOrientation ? width : height
 };
}
function backtrackBeforeAllVisibleElements(index, views, top) {
 if (index < 2) {
  return index;
 }
 let elt = views[index].div;
 let pageTop = elt.offsetTop + elt.clientTop;
 if (pageTop >= top) {
  elt = views[index - 1].div;
  pageTop = elt.offsetTop + elt.clientTop;
 }
 for (let i = index - 2; i >= 0; --i) {
  elt = views[i].div;
  if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
   break;
  }
  index = i;
 }
 return index;
}
function getVisibleElements({scrollEl, views, sortByVisibility = false, horizontal = false, rtl = false}) {
 const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
 const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;
 function isElementBottomAfterViewTop(view) {
  const element = view.div;
  const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
  return elementBottom > top;
 }
 function isElementNextAfterViewHorizontally(view) {
  const element = view.div;
  const elementLeft = element.offsetLeft + element.clientLeft;
  const elementRight = elementLeft + element.clientWidth;
  return rtl ? elementLeft < right : elementRight > left;
 }
 const visible = [], ids = new Set(), numViews = views.length;
 let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);
 if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
  firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
 }
 let lastEdge = horizontal ? right : -1;
 for (let i = firstVisibleElementInd; i < numViews; i++) {
  const view = views[i], element = view.div;
  const currentWidth = element.offsetLeft + element.clientLeft;
  const currentHeight = element.offsetTop + element.clientTop;
  const viewWidth = element.clientWidth, viewHeight = element.clientHeight;
  const viewRight = currentWidth + viewWidth;
  const viewBottom = currentHeight + viewHeight;
  if (lastEdge === -1) {
   if (viewBottom >= bottom) {
    lastEdge = viewBottom;
   }
  } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
   break;
  }
  if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
   continue;
  }
  const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
  const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
  const fractionHeight = (viewHeight - hiddenHeight) / viewHeight, fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
  const percent = fractionHeight * fractionWidth * 100 | 0;
  visible.push({
   id: view.id,
   x: currentWidth,
   y: currentHeight,
   view,
   percent,
   widthPercent: fractionWidth * 100 | 0
  });
  ids.add(view.id);
 }
 const first = visible[0], last = visible[visible.length - 1];
 if (sortByVisibility) {
  visible.sort(function (a, b) {
   const pc = a.percent - b.percent;
   if (Math.abs(pc) > 0.001) {
    return -pc;
   }
   return a.id - b.id;
  });
 }
 return {
  first,
  last,
  views: visible,
  ids
 };
}
function noContextMenuHandler(evt) {
 evt.preventDefault();
}
function normalizeWheelEventDirection(evt) {
 let delta = Math.hypot(evt.deltaX, evt.deltaY);
 const angle = Math.atan2(evt.deltaY, evt.deltaX);
 if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
  delta = -delta;
 }
 return delta;
}
function normalizeWheelEventDelta(evt) {
 let delta = normalizeWheelEventDirection(evt);
 const MOUSE_DOM_DELTA_PIXEL_MODE = 0;
 const MOUSE_DOM_DELTA_LINE_MODE = 1;
 const MOUSE_PIXELS_PER_LINE = 30;
 const MOUSE_LINES_PER_PAGE = 30;
 if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
  delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
 } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
  delta /= MOUSE_LINES_PER_PAGE;
 }
 return delta;
}
function isValidRotation(angle) {
 return Number.isInteger(angle) && angle % 90 === 0;
}
function isValidScrollMode(mode) {
 return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
}
function isValidSpreadMode(mode) {
 return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
}
function isPortraitOrientation(size) {
 return size.width <= size.height;
}
const animationStarted = new Promise(function (resolve) {
 if (typeof window === "undefined") {
  setTimeout(resolve, 20);
  return;
 }
 window.requestAnimationFrame(resolve);
});
function clamp(v, min, max) {
 return Math.min(Math.max(v, min), max);
}
class ProgressBar {
 constructor(id, {height, width, units} = {}) {
  this.visible = true;
  this.div = document.querySelector(id + " .progress");
  this.bar = this.div.parentNode;
  this.height = height || 100;
  this.width = width || 100;
  this.units = units || "%";
  this.div.style.height = this.height + this.units;
  this.percent = 0;
 }
 _updateBar() {
  if (this._indeterminate) {
   this.div.classList.add("indeterminate");
   this.div.style.width = this.width + this.units;
   return;
  }
  this.div.classList.remove("indeterminate");
  const progressSize = this.width * this._percent / 100;
  this.div.style.width = progressSize + this.units;
 }
 get percent() {
  return this._percent;
 }
 set percent(val) {
  this._indeterminate = isNaN(val);
  this._percent = clamp(val, 0, 100);
  this._updateBar();
 }
 setWidth(viewer) {
  if (!viewer) {
   return;
  }
  const container = viewer.parentNode;
  const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
  if (scrollbarWidth > 0) {
   const doc = document.documentElement;
   doc.style.setProperty(LOADINGBAR_END_OFFSET_VAR, `${ scrollbarWidth }px`);
  }
 }
 hide() {
  if (!this.visible) {
   return;
  }
  this.visible = false;
  this.bar.classList.add("hidden");
 }
 show() {
  if (this.visible) {
   return;
  }
  this.visible = true;
  this.bar.classList.remove("hidden");
 }
}
function getActiveOrFocusedElement() {
 let curRoot = document;
 let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
 while (curActiveOrFocused?.shadowRoot) {
  curRoot = curActiveOrFocused.shadowRoot;
  curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
 }
 return curActiveOrFocused;
}
function apiPageLayoutToViewerModes(layout) {
 let scrollMode = ScrollMode.VERTICAL, spreadMode = SpreadMode.NONE;
 switch (layout) {
 case "SinglePage":
  scrollMode = ScrollMode.PAGE;
  break;
 case "OneColumn":
  break;
 case "TwoPageLeft":
  scrollMode = ScrollMode.PAGE;
 case "TwoColumnLeft":
  spreadMode = SpreadMode.ODD;
  break;
 case "TwoPageRight":
  scrollMode = ScrollMode.PAGE;
 case "TwoColumnRight":
  spreadMode = SpreadMode.EVEN;
  break;
 }
 return {
  scrollMode,
  spreadMode
 };
}
function apiPageModeToSidebarView(mode) {
 switch (mode) {
 case "UseNone":
  return SidebarView.NONE;
 case "UseThumbs":
  return SidebarView.THUMBS;
 case "UseOutlines":
  return SidebarView.OUTLINE;
 case "UseAttachments":
  return SidebarView.ATTACHMENTS;
 case "UseOC":
  return SidebarView.LAYERS;
 }
 return SidebarView.NONE;
}



/***/ }),

/***/ "./src/view_history.js":
/*!*****************************!*\
  !*** ./src/view_history.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewHistory": function() { return /* binding */ ViewHistory; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20;
class ViewHistory {
 constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) {
  this.fingerprint = fingerprint;
  this.cacheSize = cacheSize;
  this._initializedPromise = this._readFromStorage().then(databaseStr => {
   const database = JSON.parse(databaseStr || "{}");
   let index = -1;
   if (!Array.isArray(database.files)) {
    database.files = [];
   } else {
    while (database.files.length >= this.cacheSize) {
     database.files.shift();
    }
    for (let i = 0, ii = database.files.length; i < ii; i++) {
     const branch = database.files[i];
     if (branch.fingerprint === this.fingerprint) {
      index = i;
      break;
     }
    }
   }
   if (index === -1) {
    index = database.files.push({ fingerprint: this.fingerprint }) - 1;
   }
   this.file = database.files[index];
   this.database = database;
  });
 }
 async _writeToStorage() {
  const databaseStr = JSON.stringify(this.database);
  localStorage.setItem("pdfjs.history", databaseStr);
 }
 async _readFromStorage() {
  return localStorage.getItem("pdfjs.history");
 }
 async set(name, val) {
  await this._initializedPromise;
  this.file[name] = val;
  return this._writeToStorage();
 }
 async setMultiple(properties) {
  await this._initializedPromise;
  for (const name in properties) {
   this.file[name] = properties[name];
  }
  return this._writeToStorage();
 }
 async get(name, defaultValue) {
  await this._initializedPromise;
  const val = this.file[name];
  return val !== undefined ? val : defaultValue;
 }
 async getMultiple(properties) {
  await this._initializedPromise;
  const values = Object.create(null);
  for (const name in properties) {
   const val = this.file[name];
   values[name] = val !== undefined ? val : properties[name];
  }
  return values;
 }
}



/***/ }),

/***/ "./src/xfa_layer_builder.js":
/*!**********************************!*\
  !*** ./src/xfa_layer_builder.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XfaLayerBuilder": function() { return /* binding */ XfaLayerBuilder; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const {XfaLayer} = __webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js");
class XfaLayerBuilder {
 constructor({pageDiv, pdfPage, annotationStorage = null, linkService, xfaHtml = null}) {
  this.pageDiv = pageDiv;
  this.pdfPage = pdfPage;
  this.annotationStorage = annotationStorage;
  this.linkService = linkService;
  this.xfaHtml = xfaHtml;
  this.div = null;
  this._cancelled = false;
 }
 render(viewport, intent = "display") {
  if (intent === "print") {
   const parameters = {
    viewport: viewport.clone({ dontFlip: true }),
    div: this.div,
    xfaHtml: this.xfaHtml,
    annotationStorage: this.annotationStorage,
    linkService: this.linkService,
    intent
   };
   const div = document.createElement("div");
   this.pageDiv.appendChild(div);
   parameters.div = div;
   const result = XfaLayer.render(parameters);
   return Promise.resolve(result);
  }
  return this.pdfPage.getXfa().then(xfaHtml => {
   if (this._cancelled || !xfaHtml) {
    return { textDivs: [] };
   }
   const parameters = {
    viewport: viewport.clone({ dontFlip: true }),
    div: this.div,
    xfaHtml,
    annotationStorage: this.annotationStorage,
    linkService: this.linkService,
    intent
   };
   if (this.div) {
    return XfaLayer.update(parameters);
   }
   this.div = document.createElement("div");
   this.pageDiv.appendChild(this.div);
   parameters.div = this.div;
   return XfaLayer.render(parameters);
  }).catch(error => {
   console.error(error);
  });
 }
 cancel() {
  this._cancelled = true;
 }
 hide() {
  if (!this.div) {
   return;
  }
  this.div.hidden = true;
 }
}



/***/ }),

/***/ "?9157":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?4a14":
/*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?fe90":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?d446":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?4c38":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?9f5f":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?afbb":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?4a96":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	!function() {
/******/ 		var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });
/******/ 			}
/******/ 			def['default'] = function() { return value; };
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".SDPDFCore.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "saltdogreader:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunksaltdogreader"] = self["webpackChunksaltdogreader"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PDFViewerApplication": function() { return /* binding */ PDFViewerApplication; },
/* harmony export */   "PDFViewerApplicationOptions": function() { return /* binding */ AppOptions; }
/* harmony export */ });
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Edited 2022 SaltDog Project
 */
/* eslint-disable */

//
// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!
//

const { AppOptions } = __webpack_require__(/*! ./app_options.js */ "./src/app_options.js");
const { PDFViewerApplication } = __webpack_require__(/*! ./app.js */ "./src/app.js");
const { SDPDFCore } = __webpack_require__(/*! ./sdpdfcore.js */ "./src/sdpdfcore.js");
const { initOnlineAnnotation } = __webpack_require__(/*! ./online_annotate.js */ "./src/online_annotate.js");

const pdfjsVersion = '2.12.313';
const pdfjsBuild = '2.12.313';
window.PDFViewerApplication = PDFViewerApplication;
window.PDFViewerApplicationOptions = AppOptions;

{
    __webpack_require__(/*! ./pdf_print_service.js */ "./src/pdf_print_service.js");
}
const fakediv = document.createElement('div');
const fakebutton = document.createElement('button');
const faketxtarea = document.createElement('textarea');
const fakeselect = document.createElement('select');
const fakeoption = document.createElement('option');
const fakea = document.createElement('a');
const fakeinput = document.createElement('input');
const fakespan = document.createElement('span');
const fakep = document.createElement('p');
function getViewerConfiguration() {
    let errorWrapper = null;
    errorWrapper = {
        container: document.getElementById('errorWrapper') || fakediv,
        errorMessage: document.getElementById('errorMessage') || fakediv,
        closeButton: document.getElementById('errorClose') || fakebutton,
    };
    return {
        appContainer: document.body,
        mainContainer: document.getElementById('viewerContainer') || fakediv,
        viewerContainer: document.getElementById('viewer') || fakediv,
        toolbar: {
            container: document.getElementById('toolbarViewer') || fakediv,
            numPages: document.getElementById('numPages') || fakespan,
            pageNumber: document.getElementById('pageNumber') || fakeinput,
            scaleSelect: document.getElementById('scaleSelect') || fakeselect,
            scaleSelectOptions: document.getElementById('scaleSelectOptions'),
            scaleSelectShowOptionsButton: document.getElementById('scaleSelectShowOptionsButton'),
            previous: document.getElementById('previous') || fakebutton,
            next: document.getElementById('next') || fakebutton,
            zoomIn: document.getElementById('zoomIn') || fakebutton,
            zoomOut: document.getElementById('zoomOut') || fakebutton,
            viewFind: document.getElementById('viewFind') || fakebutton, //TODO:
            openFile: document.getElementById('openFile') || fakebutton, //TODO:
            print: document.getElementById('print') || fakebutton, //TODO:

            download: document.getElementById('download') || fakebutton, //TODO:
            viewBookmark: document.getElementById('viewBookmark') || fakea, //TODO:
        },
        secondaryToolbar: {
            toolbar: document.getElementById('secondaryToolbar'),
            toggleButton: document.getElementById('secondaryToolbarToggle'),

            openFileButton: document.getElementById('secondaryOpenFile') || fakebutton,
            printButton: document.getElementById('secondaryPrint') || fakebutton,
            downloadButton: document.getElementById('secondaryDownload') || fakebutton,
            viewBookmarkButton: document.getElementById('secondaryViewBookmark') || fakea,
            firstPageButton: document.getElementById('firstPage') || fakebutton,
            lastPageButton: document.getElementById('lastPage') || fakebutton,
            pageRotateCwButton: document.getElementById('pageRotateCw'),
            pageRotateCcwButton: document.getElementById('pageRotateCcw'),
            cursorSelectToolButton: document.getElementById('cursorSelectTool'),
            cursorHandToolButton: document.getElementById('cursorHandTool'),
            scrollPageButton: document.getElementById('scrollPage'),
            scrollVerticalButton: document.getElementById('scrollVertical'),
            scrollHorizontalButton: document.getElementById('scrollHorizontal'),
            scrollWrappedButton: document.getElementById('scrollWrapped'),
            spreadNoneButton: document.getElementById('spreadNone'),
            spreadOddButton: document.getElementById('spreadOdd'),
            spreadEvenButton: document.getElementById('spreadEven'),
            // saltdog disable documentProperties
            //  documentPropertiesButton: document.getElementById("documentProperties")
        },
        // sdpdfcore disable sidebar
        //   sidebar: {
        //    outerContainer: document.getElementById("outerContainer"),
        //    viewerContainer: document.getElementById("viewerContainer"),
        //    toggleButton: document.getElementById("sidebarToggle"),
        //    thumbnailButton: document.getElementById("viewThumbnail"),
        //    outlineButton: document.getElementById("viewOutline"),
        //    attachmentsButton: document.getElementById("viewAttachments"),
        //    layersButton: document.getElementById("viewLayers"),
        //    thumbnailView: document.getElementById("thumbnailView"),
        //    outlineView: document.getElementById("outlineView"),
        //    attachmentsView: document.getElementById("attachmentsView"),
        //    layersView: document.getElementById("layersView"),
        //    outlineOptionsContainer: document.getElementById("outlineOptionsContainer"),
        //    currentOutlineItemButton: document.getElementById("currentOutlineItem")
        //   },
        //   sidebarResizer: {
        //    outerContainer: document.getElementById("outerContainer"),
        //    resizer: document.getElementById("sidebarResizer")
        //   },
        findBar: {
            bar: document.getElementById('findbar') || fakediv,
            toggleButton: document.getElementById('viewFind') || fakebutton,
            findField: document.getElementById('findInput') || fakeinput,
            highlightAllCheckbox: document.getElementById('findHighlightAll') || fakeinput,
            caseSensitiveCheckbox: document.getElementById('findMatchCase') || fakeinput,
            matchDiacriticsCheckbox: document.getElementById('findMatchDiacritics') || fakeinput,
            entireWordCheckbox: document.getElementById('findEntireWord') || fakeinput,
            findMsg: document.getElementById('findMsg') || fakespan,
            findResultsCount: document.getElementById('findResultsCount') || fakespan,
            findPreviousButton: document.getElementById('findPrevious') || fakebutton,
            findNextButton: document.getElementById('findNext') || fakebutton,
        },
        passwordOverlay: {
            overlayName: 'passwordOverlay',
            container: document.getElementById('passwordOverlay') || fakediv,
            label: document.getElementById('passwordText') || fakep,
            input: document.getElementById('password') || fakeinput,
            submitButton: document.getElementById('passwordSubmit') || fakebutton,
            cancelButton: document.getElementById('passwordCancel') || fakebutton,
        },
        // saltdog disable documentProperties
        // documentProperties: {
        //  overlayName: "documentPropertiesOverlay",
        //  container: document.getElementById("documentPropertiesOverlay"),
        //  closeButton: document.getElementById("documentPropertiesClose"),
        //  fields: {
        //   fileName: document.getElementById("fileNameField"),
        //   fileSize: document.getElementById("fileSizeField"),
        //   title: document.getElementById("titleField"),
        //   author: document.getElementById("authorField"),
        //   subject: document.getElementById("subjectField"),
        //   keywords: document.getElementById("keywordsField"),
        //   creationDate: document.getElementById("creationDateField"),
        //   modificationDate: document.getElementById("modificationDateField"),
        //   creator: document.getElementById("creatorField"),
        //   producer: document.getElementById("producerField"),
        //   version: document.getElementById("versionField"),
        //   pageCount: document.getElementById("pageCountField"),
        //   pageSize: document.getElementById("pageSizeField"),
        //   linearized: document.getElementById("linearizedField")
        //  }
        // },
        annotationButton: {
            highLightAnnotation: document.getElementById('highLightAnno') || fakebutton,
        },
        errorWrapper,
        printContainer: document.getElementById('printContainer') || fakediv,
        openFileInputName: 'fileInput',
        debuggerScriptPath: './debugger.js',
    };
}

function webViewerLoad() {
    console.log(`webViewerLoad`);
    const config = getViewerConfiguration();
    Promise.all([__webpack_require__.e(/*! import() */ "src_genericcom_js").then(__webpack_require__.bind(__webpack_require__, /*! ./genericcom.js */ "./src/genericcom.js")), Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./pdf_print_service.js */ "./src/pdf_print_service.js"))]).then(function ([genericCom, pdfPrintService]) {
        // console.log(`SDPDFCore Ready`);
        // wait to run app
        PDFViewerApplication.run(config);
    });
}
///////PDF MODE INIT BEGIN/////////////
function closeSubToolbar() {
    const toolContainer = document.querySelector('.HeaderToolsContainer');
    if (toolContainer) {
        toolContainer.style.display = 'none';
    }
    const viewer = document.getElementById(`viewerContainer`);
    viewer.style.top = '42px';
}
function openSubToolbar(modeName) {
    if (modeName == 'View') return;
    const toolContainer = document.querySelector('.HeaderToolsContainer');
    if (toolContainer) {
        toolContainer.style.display = 'block';
    }
    const viewer = document.getElementById(`viewerContainer`);
    viewer.style.top = '82px';
    const btnGroups = document.querySelector(`.Header .Tools`);
    for (let i = 0; i < btnGroups.children.length; i++) {
        btnGroups[i].classList.add('hidden');
    }
    switch (modeName) {
        case 'Annotate':
            document.querySelector(`.AnnotationBtns`).classList.classList.remove('hidden');
    }
}
let ribbons = document.getElementById(`ribbonsContainer`);
ribbons.addEventListener('click', (e) => {
    if (e.target.tagName != 'BUTTON') return;
    const btn = e.target;
    const mode = btn.getAttribute('data-pdf-mode') || 'View';
    const ribbonsChild = ribbons.children;
    // 按钮状态
    for (let i = 0; i < ribbonsChild.length; i++) {
        if (ribbonsChild[i].getAttribute('data-pdf-mode') != mode) ribbonsChild[i].classList.remove('active');
        else ribbonsChild[i].classList.add('active');
    }
    switch (mode) {
        case 'View':
            closeSubToolbar();
            break;
        case 'Annotate':
            openSubToolbar(mode);
            break;
    }
});
// if(ribbons){
//   ribbons = ribbons.children;
//   for(let i=0;i<ribbons.length;i++){

//   }
// }
///////PDF MODE INIT END/////////////
///////PDF ANNOTATE JS INIT BEGIN//////////////
window.initAnnotation = function (id, preference) {
    try {
        initOnlineAnnotation(id, preference);
    } catch (e) {
        console.error('Init Online Annotation failed, detail:', e);
    }
};
////////PDF ANNOTATE JS INIT END/////////////

if (document.blockUnblockOnload) {
    document.blockUnblockOnload(true);
}
if (document.readyState === 'interactive' || document.readyState === 'complete') {
    webViewerLoad();
} else {
    document.addEventListener('DOMContentLoaded', webViewerLoad, true);
}



}();
/******/ })()
;
//# sourceMappingURL=SDPDFCore.js.map