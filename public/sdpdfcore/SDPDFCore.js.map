{"version":3,"file":"SDPDFCore.js","mappings":";;;;;;;;;AAAA,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,4DAAc,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,8DAAe;AAC/I;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,mBAAmB;AACvD;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACzOD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,oDAAU;AAC1E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,WAAW;AAC/B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,yGAAyG,iBAAiB;AAC1H;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,mBAAmB,MAAM;AACzB,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C,oCAAoC;AAC9E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,kBAAkB;AACtC,oBAAoB,WAAW;AAC/B,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,QAAQ;AAC1H,kHAAkH,yCAAyC;AAC3J;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,qBAAqB;AACzC,oBAAoB,WAAW;AAC/B,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA,uHAAuH,yCAAyC;AAChK,oHAAoH,yCAAyC;AAC7J;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,2BAA2B;;AAElE;AACA;AACA;;AAEA;AACA,0CAA0C,8BAA8B;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,kBAAkB;AACtC,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,iCAAiC;AAC3J;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,qBAAqB;AACzC,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA,+HAA+H,iCAAiC;AAChK,4HAA4H,iCAAiC;AAC7J;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN,EAAE;;;AAGF,CAAC;;;;;;;;;;ACz3BD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA;AACA;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,qBAAM,oBAAoB,qBAAM;AAC3D,kBAAkB,qBAAM;AACxB;;AAEA;AACA,oBAAoB,UAAc;AAClC;AACA,sBAAsB,mBAAO,CAAC,qBAAQ;AACtC,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,eAAe;AACf;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACtyBD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;;AAEA;;AAEA,iCAAiC,sCAAsC;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACvID,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;;AAEA;;AAEA,iCAAiC,sCAAsC;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA,CAAC;;;;;;;;;;AC3ID,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACpJD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,gDAAQ;AAC3F;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE,wDAAwD,8BAA8B;AACtF;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC,gBAAgB,QAAQ;AACxB;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE,wDAAwD,8BAA8B;AACtF;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACrID,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wBAAwB;AAClE;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACjED,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,EAAE;;;AAGF,CAAC;;;;;;;;;;AC9ID,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,wDAAY,GAAG,mBAAO,CAAC,sEAAmB,GAAG,mBAAO,CAAC,0DAAa,GAAG,mBAAO,CAAC,4DAAc,GAAG,mBAAO,CAAC,kEAAiB,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,0DAAa,GAAG,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,8DAAe,GAAG,mBAAO,CAAC,wDAAY,GAAG,mBAAO,CAAC,wDAAY,GAAG,mBAAO,CAAC,wEAAoB,GAAG,mBAAO,CAAC,wDAAY,GAAG,mBAAO,CAAC,wDAAY,GAAG,mBAAO,CAAC,gEAAgB,GAAG,mBAAO,CAAC,gEAAgB,GAAG,mBAAO,CAAC,gEAAgB,GAAG,mBAAO,CAAC,sEAAmB,GAAG,mBAAO,CAAC,kEAAiB,GAAG,mBAAO,CAAC,4DAAc,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,0DAAa,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,kEAAiB;AAC9zB;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;;AAEA,CAAC;;;;;;;;;;ACjBD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC3ED,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC3QD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC/ED,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,EAAE;;;;;AAKF;;AAEA,CAAC;;;;;;;;;;ACnHD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACzDD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACvCD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACrDD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA,CAAC;;;;;;;;;;AChDD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA,CAAC;;;;;;;;;;AC3CD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA,CAAC;;;;;;;;;;ACvCD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;;AAGA;;AAEA,CAAC;;;;;;;;;;AC7BD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,8DAAe;AAC/E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,CAAC;;;;;;;;;;AC9CD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,gDAAQ;AAC3F;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE,wDAAwD,8BAA8B;AACtF;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC,gBAAgB,QAAQ;AACxB;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE,wDAAwD,8BAA8B;AACtF;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AChJD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,4DAAc,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,8DAAe;AAC/I;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,OAAO;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,OAAO;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC7LD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,4DAAc,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,8DAAe;AAC/I;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,OAAO;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,OAAO;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC/LD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,4DAAc,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,8DAAe;AAC/I;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;;AAEA;AACA,oCAAoC,SAAS;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC1ID,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;;AAEA,mdAAmd,+BAA+B;AAClf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC1QD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACrJD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,oDAAU;AAC1E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC/ED,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACtMD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,wDAAY;AAC5E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,OAAO;AAChC,6BAA6B,OAAO;AACpC;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;;AAEA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,YAAY;AAC7C;AACA,iCAAiC,OAAO;AACxC;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,gBAAgB;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACrUD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,wDAAY,GAAG,mBAAO,CAAC,oDAAU;AACjG;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AClFD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,wDAAY;AAC5E;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;ACrUD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ,GAAG,mBAAO,CAAC,4DAAc,GAAG,mBAAO,CAAC,8CAAO,GAAG,mBAAO,CAAC,oDAAU,GAAG,mBAAO,CAAC,8DAAe;AAC/I;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;AC1wBD,CAAC;AACD,KAAK,IAA2B;AAChC;AACA,qCAAqC,mBAAO,CAAC,gDAAQ;AACrD;AACA,MAAM,EAOJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;;AAEA;AACA;AACA,MAAM;AACN,EAAE;;;AAGF;;AAEA,CAAC;;;;;;;;;;;AC/SD;AACa;;AAEb,QAAQ,qCAAqC,EAAE,mBAAO,CAAC,yDAAe;;AAEtE,QAAQ,uCAAuC,EAAE,mBAAO,CAAC,yDAAe;;AAExE,kBAAkB,mBAAO,CAAC,uEAAsB;;AAEhD,sBAAsB;AACtB,sBAAsB;AACtB,yBAAyB;AACzB,mBAAmB;AACnB,sBAAsB;AACtB,sBAAsB;AACtB,yBAAyB;AACzB,qBAAqB;AACrB,wBAAwB;;;;;;;;;;;;ACjBX;;;AAGb,qBAAqB,mBAAO,CAAC,+DAAgB;AAC7C,qBAAqB,mBAAO,CAAC,+DAAgB;AAC7C,qBAAqB,mBAAO,CAAC,iEAAiB;AAC9C,qBAAqB,mBAAO,CAAC,iEAAiB;AAC9C,qBAAqB,mBAAO,CAAC,+DAAgB;;AAE7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,mEAAkB;;AAE9B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA,gCAAgC;AAChC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,eAAe;;AAElB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,sBAAsB;AACtB,sBAAsB;AACtB,yBAAyB;AACzB,mBAAmB;AACnB,mHAAsD;;;;;;;;;;;;AC3XzC;;;AAGb,qBAAqB,mBAAO,CAAC,+DAAgB;AAC7C,qBAAqB,mBAAO,CAAC,+DAAgB;AAC7C,qBAAqB,mBAAO,CAAC,iEAAiB;AAC9C,qBAAqB,mBAAO,CAAC,iEAAiB;AAC9C,qBAAqB,mBAAO,CAAC,+DAAgB;AAC7C,qBAAqB,mBAAO,CAAC,iEAAiB;;AAE9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,mEAAkB;;AAE9B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA,gCAAgC;AAChC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,eAAe;;AAElB;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,sBAAsB;AACtB,sBAAsB;AACtB,yBAAyB;AACzB,qBAAqB;AACrB,mHAAsD;;;;;;;;;;;;AClazC;;;AAGb;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,4BAA4B;AAC5B;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;;AAEA;AACA;;AAEA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC/CA;AACa;;;AAGb;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,sDAAsD,aAAa;;;AAGzE;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,mCAAmC;;;AAGnC;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;;AAGA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;AACA,oBAAoB,qBAAqB;;AAEzC;AACA;AACA,qBAAqB,0BAA0B,gBAAgB;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,0BAA0B;;AAE/C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,0BAA0B;;AAE1B;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,mBAAmB;;AAEnB;AACA;;;;;;;;;;;;AC7Ka;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;AClDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACnEa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;;AAEA,uBAAuB;AACvB;;;AAGA;;;;;;;;;;;;AC1Da;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,oEAAoE,EAAE,mBAAO,CAAC,sDAAS;AAC/F,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,gBAAgB,mBAAO,CAAC,sDAAS;AACjC,gBAAgB,mBAAO,CAAC,4DAAY;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8DAAa;;AAEzB;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;;AAE7B,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB;AACpB,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C,yBAAyB;AACzB,mCAAmC;AACnC,qCAAqC;AACrC,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA;;AAEA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,wBAAwB;;AAExB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA,0DAA0D;AAC1D;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,2BAA2B;;AAE3B;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;;AAEzB;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qEAAqE;AACrE;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB;AACtB,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B,gCAAgC;AAChC,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,4BAA4B;AAC5B,0BAA0B;;AAE1B,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;;AAEtB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;;AAEA,uBAAuB;;AAEvB;;AAEA;;AAEA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;;AAEhC;AACA;AACA;;AAEA,gCAAgC;AAChC,iDAAiD;AACjD;;AAEA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;;;AAG1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;;;AAGA;;AAEA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB,uCAAuC;;AAEvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B,4BAA4B;AAC5B,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA,gBAAgB;;AAEhB;AACA;AACA,iCAAiC;AACjC,0BAA0B;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,0BAA0B;AAC1B,2BAA2B;AAC3B,2BAA2B;AAC3B,+BAA+B;AAC/B,+BAA+B;AAC/B,sBAAsB;AACtB,yBAAyB;AACzB,mCAAmC;AACnC,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzzDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B;;;AAGA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,2CAA2C;AAC3C;AACA,wCAAwC;AACxC;AACA;AACA;AACA,oBAAoB;AACpB,uCAAuC;AACvC;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,oBAAoB;AACpB;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,wCAAwC;AACxC;AACA;AACA;AACA,oBAAoB;AACpB,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvVa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,0DAAW;AACzC,sBAAsB,mBAAO,CAAC,sDAAS;AACvC,sBAAsB,mBAAO,CAAC,0DAAW;AACzC,sBAAsB,mBAAO,CAAC,4DAAY;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8DAAa;;;AAGzB;AACA;;;AAGA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;;AAEzB;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA,8BAA8B;;AAE9B;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA,8BAA8B;;AAE9B;AACA,gCAAgC;AAChC,gCAAgC;AAChC,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,iCAAiC;;AAEjC,oCAAoC;AACpC,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC;;;AAGA;;AAEA,8BAA8B;AAC9B;AACA;AACA,iBAAiB;AACjB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,eAAe;AACf,uCAAuC;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;;AAGrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;;AAExB,wEAAwE,SAAS;;AAEjF;AACA;AACA,uBAAuB;;AAEvB,wEAAwE,SAAS;;AAEjF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,uCAAuC;AACvC;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,gCAAgC;AAChC,oCAAoC;AACpC,8BAA8B;AAC9B,8BAA8B;AAC9B,qCAAqC;AACrC;;AAEA,SAAS;;AAET;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,0BAA0B;;;AAGvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B,4BAA4B;AAC5B,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oEAAoE;AACpE;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,oEAAoE;AACpE;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,oEAAoE;AACpE;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,cAAc;AACd,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,UAAU;AACV,kCAAkC;AAClC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,8BAA8B;AAC9B;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,2BAA2B;AAC3B,4BAA4B;AAC5B,+BAA+B;AAC/B,0BAA0B;AAC1B,2BAA2B;AAC3B,sBAAsB;AACtB,yBAAyB;AACzB,+BAA+B;AAC/B,mCAAmC;AACnC,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1gDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;;AAE1B,6BAA6B;AAC7B,6BAA6B;AAC7B,iCAAiC;AACjC,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,kCAAkC;AAClC,6BAA6B;AAC7B,6BAA6B;AAC7B,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,wBAAwB;AACxB,uBAAuB;AACvB;AACA,qBAAqB;AACrB,8BAA8B;AAC9B,8CAA8C,kBAAkB;AAChE,6CAA6C,mBAAmB;AAChE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;AACA,sBAAsB,UAAU;AAChC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,uCAAuC;AACvC,wCAAwC,6BAA6B;AACrE,0CAA0C;AAC1C,2CAA2C;AAC3C;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA,gBAAgB,WAAW;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,IAAI,0BAA0B;AAC9B;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,mCAAmC;AACnC,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACvVa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;;;AAGA,qBAAqB,sBAAsB,qBAAqB;;AAEhE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;;AAEpC;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC;;;;AAIA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;;AAEtB,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;;AAEhD,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC,6BAA6B;AAC7B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC;AACA,6CAA6C;AAC7C,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;;AAE7B;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA,cAAc;AACd,SAAS,gBAAgB;AACzB;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA,cAAc,cAAc,OAAO;AACnC,cAAc,cAAc,OAAO;AACnC,cAAc,cAAc,OAAO;;AAEnC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,2BAA2B;AAC3B;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA,QAAQ;AACR;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,yCAAyC;AACzC;AACA,gBAAgB;AAChB;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,QAAQ;;AAER;AACA;AACA;;AAEA,MAAM;AACN;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,WAAW;AACzB;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,QAAQ,OAAO;;AAEvD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;;AAE7B,yCAAyC;;AAEzC,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;;AAEA,MAAM;AACN;;AAEA,MAAM;;AAEN,gCAAgC;AAChC;;AAEA,MAAM;AACN;;AAEA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,0BAA0B;AAC1B;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;;AAE7B,yCAAyC;;AAEzC,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;;AAE7B,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;;AAEA,MAAM;AACN,WAAW,mCAAmC;;AAE9C,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iCAAiC;AACjC,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;;AAEA,yCAAyC;AACzC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,MAAM,GAAG,MAAM,GAAG;AAChD;AACA;AACA;AACA,SAAS,IAAI,KAAK,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,IAAI,MAAM,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB;AACA,4DAA4D;AAC5D,wCAAwC;AACxC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB;AACA,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;;AAEnC,IAAI;AACJ;AACA,6CAA6C;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,+BAA+B;AAC/B,8BAA8B;AAC9B,wBAAwB;AACxB,wBAAwB;;;;;;;;;;;;AC5sCX;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAKqD;AAC3D,CAAC;AACD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,8BAA8B,eAAe;;AAE7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,KAAK;AAC3D;;AAEA;AACA;;AAEA;AACA;AACA,wDAAwD,KAAK;AAC7D;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,2BAA2B,EAAE,SAAS;AAC3D;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD,WAAW;AAC5D;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,EAAE,WAAW,EAAE,YAAY,EAAE,YAAY,EAAE,YAAY,EAAE,YAAY,EAAE,2BAA2B,EAAE,mBAAmB,EAAE;AAC7K;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;;AAEA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,IAAI;AAC9B;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc,EAAE,cAAc,EAAE,cAAc;AAC7D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,IAAI;AACJ,oBAAoB,YAAY;AAChC;AACA;AACA,IAAI;AACJ,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,gBAAgB,MAAM;AACtB,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,uBAAuB,aAAa;;AAEpC,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,mCAAmC,WAAW,IAAI;AAC1F,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,aAAa,EAAE,SAAS;AAC3C;AACA,sDAAsD,IAAI;AAC1D,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,MAAM;AACvC,kCAAkC,OAAO;AACzC;AACA,uCAAuC,OAAO,EAAE,OAAO;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,yDAAyD,GAAG;AAC5D;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,wCAAwC;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI,IAAI;AACR;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,SAAS;AACT;AACA;AACA;;AAEA,4FAA4F;AAC5F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE,kBAAkB;AACxF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAc;AACzC;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,IAAI,GAAG;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD;;AAEnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb,YAAY;AACZ;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL,gFAAgF,eAAe;AAC/F,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,UAAc;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gEAAgE,OAAO;AACvE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,eAAe;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB,GAAG,aAAa;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D,KAAK;AACjE;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD,KAAK;AAC1D;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,mEAAmE,MAAM;AACzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uGAAuG,oBAAoB;AAC3H;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gDAAgD,WAAW;;AAE3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,WAAW;;AAEX,kDAAkD,sBAAsB,MAAM,GAAG;AACjF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,WAAW,EAAE,sBAAsB;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS,WAAW,EAAE;AAChE,gCAAgC,eAAe,eAAe,EAAE,MAAM,KAAK;AAC3E;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kEAAkE;AAClE,MAAM;AACN;AACA;AACA;;AAEA;AACA,+BAA+B,6BAA6B;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,eAAe,SAAS,WAAW,EAAE;AACjE;;AAEA;AACA,0BAA0B,eAAe,gBAAgB,EAAE,MAAM,KAAK;AACtE,MAAM;AACN,gCAAgC,6BAA6B;;AAE7D;AACA,sCAAsC,6BAA6B,IAAI;AACvE;;AAEA,0BAA0B,eAAe,4BAA4B,EAAE,EAAE,IAAI,MAAM,KAAK;AACxF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,iEAAiE,GAAG;AACpE;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,iBAAI;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,qBAAqB,mBAAO,CAAC,qBAAQ;;AAErC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,WAAW;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,WAAW;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,WAAW;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,sBAAsB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;;AAER;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,gBAAgB,gBAAgB;AAChC;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;;AAEA;;AAEA,iCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,uCAAuC,aAAa;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,YAAY;AACzD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,yBAAyB,KAAK,KAAK,qBAAqB;AACxD;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,uBAAuB,QAAQ,EAAE,MAAM,EAAE,gBAAgB,KAAK,SAAS;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,kBAAkB;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,kBAAkB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,qBAAqB;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,qCAAqC,MAAM;AAC3C,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR,kEAAkE,YAAY;AAC9E;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,UAAU;AAC5B;;AAEA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,MAAM;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA+D,UAAU;AACzE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,oDAAoD,YAAY;AAChE;;AAEA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD,WAAW;AAChE;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,uDAAuD,YAAY;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gEAAgE,WAAW;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR,6DAA6D,QAAQ;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE,GAAG;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA,iEAAiE,GAAG;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA,iEAAiE,GAAG;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA,iEAAiE,GAAG;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,aAAa;AACtE;AACA;;AAEA,0CAA0C,WAAW;AACrD;AACA;;AAEA;AACA;AACA,2DAA2D,GAAG;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,OAAO;AAC7B;AACA;;AAEA,4CAA4C,oBAAoB;AAChE,MAAM;AACN,4CAA4C,6BAA6B;AACzE;;AAEA,yCAAyC,SAAS,KAAK,SAAS;;AAEhE;AACA,uCAAuC,uBAAuB;;AAE9D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,iBAAiB,OAAO,eAAe;AACjE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA,8BAA8B,QAAQ;AACtC,6BAA6B,QAAQ;;AAErC;AACA;AACA,MAAM;AACN,iCAAiC,MAAM;AACvC,kCAAkC,OAAO;AACzC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yEAAyE,GAAG;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,0BAA0B,SAAS;AACnC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA,MAAM;AACN;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,mBAAmB;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,8CAA8C,WAAW,KAAK,UAAU;AACxE,mCAAmC,UAAU;AAC7C,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wCAAwC,MAAM,IAAI,MAAM;AACxD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,EAAE,GAAG,EAAE;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,6BAA6B,oBAAoB;AACjD;;AAEA;AACA,oEAAoE,QAAQ;;AAE5E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,OAAO;AACrC;AACA;;AAEA,oCAAoC,uBAAuB;AAC3D;;AAEA;AACA;AACA,oCAAoC,KAAK;AACzC,mCAAmC,IAAI;AACvC,+CAA+C,MAAM,KAAK,KAAK;AAC/D;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE,GAAG;;AAEnE;AACA;AACA;;AAEA;AACA;AACA,QAAQ;;AAER;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE,EAAE,EAAE,EAAE,EAAE;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE,EAAE,EAAE,EAAE,EAAE;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM;AACN;;AAEA;AACA,2BAA2B,gBAAgB,GAAG,OAAO;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,wCAAwC;AAC1E;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,kBAAkB,KAAK,WAAW;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,0BAA0B,KAAK;AAC/B,yBAAyB,IAAI;AAC7B,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAsB,4DAA4D;AAClF;AACA;;AAEA,sBAAsB,sEAAsE;AAC5F;AACA;;AAEA,kBAAkB,oCAAoC;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+FAA+F;;AAE/F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD,YAAY;AAC9D;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA,sCAAsC,UAAU,EAAE,WAAW;AAC7D;AACA;AACA;;AAEA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,MAAM;AACpC;AACA;;AAEA;AACA,4BAA4B,wBAAwB,OAAO,UAAU;AACrE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,oBAAoB;AACjD,0CAA0C,qBAAqB;AAC/D,UAAU;AACV;AACA;;AAEA;AACA,6BAA6B,uCAAuC;AACpE,UAAU;AACV;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD,UAAU;AACV;AACA;;AAEA;AACA,6BAA6B,sCAAsC;AACnE,0CAA0C,uCAAuC;AACjF,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA,sBAAsB,OAAO;AAC7B;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,SAAS;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA,uBAAuB,sDAA2B;AAClD;AACA,SAAS;;AAET;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,YAAY;AACpC;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,UAAU,EAAE,SAAS;AAC7C;;AAEA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA,MAAM;AACN;AACA,4BAA4B,UAAU,EAAE,SAAS;AACjD;AACA;;AAEA,qBAAqB,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,OAAO,SAAS;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sDAAsD,GAAG;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,yDAAyD,qBAAqB;;AAE9E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,8DAA8D,gBAAgB,QAAQ,eAAe;AACrG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,gBAAgB,mBAAmB,EAAE,iBAAiB,IAAI,IAAI;AAC/G;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;;AAEhD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,QAAQ;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU;;AAEnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,OAAO;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oEAAoE,IAAI;AACxE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0DAA0D,OAAO;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe,EAAE,gBAAgB;;AAExF;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA,WAAW,mBAAO,CAAC,iBAAI;;AAEvB,aAAa,mBAAO,CAAC,mBAAM;;AAE3B,cAAc,mBAAO,CAAC,oBAAO;;AAE7B,YAAY,mBAAO,CAAC,kBAAK;;AAEzB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,UAAU;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE,UAAU;AAC9E;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,MAAM,GAAG,QAAQ;;AAExD;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gEAAgE,KAAK;AACrE;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8EAA8E,OAAO,0BAA0B,IAAI;AACnH;;AAEA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,qDAAqD,OAAO;AACzF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,QAAQ;;AAER;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C,WAAW,GAAG,aAAa;AACxE;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2CAA2C,MAAM,GAAG,QAAQ;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA,UAAU;AACV;AACA,CAAC;AACD;;;;;;;;;;;ACllfa;AACb;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yBAAyB,GAAG,uBAAuB;AACnD,eAAe,mBAAO,CAAC,0CAAU;AACjC,wBAAwB,mBAAO,CAAC,oFAA+B;AAC/D,+BAA+B,mBAAO,CAAC,kGAAsC;AAC7E,4BAA4B,mBAAO,CAAC,4FAAmC;AACvE,iCAAiC,mBAAO,CAAC,sGAAwC;AACjF,oCAAoC,mBAAO,CAAC,4GAA2C;AACvF,uBAAuB,mBAAO,CAAC,kFAA8B;AAC7D,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,eAAe,mBAAO,CAAC,0CAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,wCAAwC;AACxC;AACA,iDAAiD;AACjD,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oDAAoD;AACpD,yBAAyB,mBAAO,CAAC,iBAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,6CAA6C;AAC7C;AACA;AACA,gDAAgD;AAChD,qBAAqB,mBAAO,CAAC,iBAAI;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;;;;;;;;;;;;AC7lBZ;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,wBAAwB,GAAG,4BAA4B,GAAG,oCAAoC,GAAG,kCAAkC,GAAG,4BAA4B,GAAG,6BAA6B,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,oCAAoC,GAAG,4BAA4B,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,kCAAkC;AACld;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wBAAwB;;;;;;;;;;;;ACtLX;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,2BAA2B,GAAG,kBAAkB,GAAG,wBAAwB,GAAG,yBAAyB,GAAG,oBAAoB,GAAG,uBAAuB;AACxJ,eAAe,mBAAO,CAAC,2CAAW;AAClC,aAAa,mBAAO,CAAC,uCAAS;AAC9B,0BAA0B,mBAAO,CAAC,4EAAqB;AACvD,oBAAoB,mBAAO,CAAC,qDAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA,oCAAoC;AACpC,iCAAiC;AACjC,+CAA+C;AAC/C;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,6DAA6D,qDAAqD;AAClH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,uBAAuB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wBAAwB;AACxB;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,2BAA2B;;;;;;;;;;;;ACjcd;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,2BAA2B,GAAG,2BAA2B,GAAG,iCAAiC;AAC7F,yBAAyB,mBAAO,CAAC,0EAAoB;AACrD,0BAA0B,mBAAO,CAAC,4EAAqB;AACvD,oBAAoB,mBAAO,CAAC,qDAAgB;AAC5C,0BAA0B,mBAAO,CAAC,iEAAsB;AACxD,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,uBAAuB,mBAAO,CAAC,2DAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kDAAkD,kDAAkD,GAAG;AAC3J;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,2BAA2B;;;;;;;;;;;;AC3Kd;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,6BAA6B,GAAG,oBAAoB,GAAG,yBAAyB;AAChF,yBAAyB,mBAAO,CAAC,0EAAoB;AACrD,0BAA0B,mBAAO,CAAC,4EAAqB;AACvD,oBAAoB,mBAAO,CAAC,qDAAgB;AAC5C,aAAa,mBAAO,CAAC,uCAAS;AAC9B,0BAA0B,mBAAO,CAAC,iEAAsB;AACxD,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,uBAAuB,mBAAO,CAAC,2DAAmB;AAClD,cAAc,mBAAO,CAAC,yCAAU;AAChC;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yCAAyC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yCAAyC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,6BAA6B;;;;;;;;;;;;ACxOhB;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,wBAAwB;AACxB,yBAAyB,mBAAO,CAAC,0EAAoB;AACrD,0BAA0B,mBAAO,CAAC,4EAAqB;AACvD,oBAAoB,mBAAO,CAAC,qDAAgB;AAC5C,0BAA0B,mBAAO,CAAC,iEAAsB;AACxD,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,uBAAuB,mBAAO,CAAC,2DAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA,0BAA0B,kBAAkB;AAC5C,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,wBAAwB;;;;;;;;;;;;AC3FX;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,4BAA4B,GAAG,6BAA6B,GAAG,oCAAoC,GAAG,6BAA6B;AACnI,yBAAyB,mBAAO,CAAC,0EAAoB;AACrD,0BAA0B,mBAAO,CAAC,4EAAqB;AACvD,oBAAoB,mBAAO,CAAC,qDAAgB;AAC5C,0BAA0B,mBAAO,CAAC,iEAAsB;AACxD,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,uBAAuB,mBAAO,CAAC,2DAAmB;AAClD;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,4BAA4B;;;;;;;;;;;;ACrMf;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,yBAAyB,GAAG,uBAAuB,GAAG,4BAA4B,GAAG,sBAAsB;AAC3G,yBAAyB,mBAAO,CAAC,0EAAoB;AACrD,0BAA0B,mBAAO,CAAC,4EAAqB;AACvD,oBAAoB,mBAAO,CAAC,qDAAgB;AAC5C,aAAa,mBAAO,CAAC,uCAAS;AAC9B,0BAA0B,mBAAO,CAAC,iEAAsB;AACxD,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,uBAAuB,mBAAO,CAAC,2DAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C,sBAAsB,KAAK;AAC1E;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,2CAA2C;AAC3C;AACA,gDAAgD;AAChD;AACA,gDAAgD;AAChD;AACA,oFAAoF;AACpF;AACA,sEAAsE;AACtE;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;;;;;;;;;;;;ACrOZ;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,8BAA8B,GAAG,6BAA6B,GAAG,8BAA8B,GAAG,8BAA8B,GAAG,+BAA+B;AAClK,yBAAyB,mBAAO,CAAC,0EAAoB;AACrD,0BAA0B,mBAAO,CAAC,4EAAqB;AACvD,oBAAoB,mBAAO,CAAC,qDAAgB;AAC5C,0BAA0B,mBAAO,CAAC,iEAAsB;AACxD,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,uBAAuB,mBAAO,CAAC,2DAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA,oFAAoF,mGAAmG;AACvL;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,mGAAmG;AACvL;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,mGAAmG;AACvL;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC,mCAAmC,GAAG;AAC3H;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,mGAAmG;AACvL;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAmD,0CAA0C,GAAG;AAChJ;AACA;AACA,CAAC;AACD,8BAA8B;;;;;;;;;;;;ACvWjB;AACb,kBAAkB;AAClB,8BAA8B,GAAG,kBAAkB,GAAG,iBAAiB;AACvE,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,uBAAuB,mBAAO,CAAC,0DAAkB;AACjD,eAAe,mBAAO,CAAC,0CAAU;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;AAClB;AACA;AACA,oCAAoC;AACpC;AACA,iCAAiC;AACjC;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,8BAA8B;;;;;;;;;;;;AChMjB;AACb,kBAAkB;AAClB,iBAAiB;AACjB,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC;AACD,iBAAiB;;;;;;;;;;;;ACvFJ;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,qBAAqB,GAAG,kBAAkB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,gBAAgB;AAC9G,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C,4BAA4B,mBAAO,CAAC,4FAAmC;AACvE;AACA;AACA,+BAA+B;AAC/B,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,8CAA8C,gBAAgB;AAC9D;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;AAChB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,CAAC;AACD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,mCAAmC;AACnC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,CAAC;AACD,qBAAqB;;;;;;;;;;;;AC/dR;AACb,kBAAkB;AAClB,kBAAkB;AAClB,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,aAAa,mBAAO,CAAC,oDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;;;;;;;;;;;;ACjIL;AACb,kBAAkB;AAClB,uBAAuB,GAAG,sBAAsB,GAAG,kBAAkB;AACrE,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB;AACtB;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uBAAuB;;;;;;;;;;;;AC9LV;AACb,kBAAkB;AAClB,uBAAuB,GAAG,2BAA2B,GAAG,kCAAkC;AAC1F,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C;AACA,aAAa,kBAAkB,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA,gGAAgG,qBAAqB,2BAA2B,eAAe;AAC/J,wKAAwK,qBAAqB,2BAA2B,eAAe;AACvO;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qHAAqH;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,CAAC;AACD,uBAAuB;;;;;;;;;;;;ACxhBV;AACb,kBAAkB;AAClB,0BAA0B;AAC1B,0BAA0B;AAC1B,qBAAqB,o9JAAo9J;AACz+J,sBAAsB,0qCAA0qC;AAChsC,mBAAmB,+yMAA+yM;AACl0M,yBAAyB,uxDAAuxD;AAChzD,0BAA0B,k7JAAk7J;AAC58J,6BAA6B,sxDAAsxD;AACnzD,oBAAoB,8tKAA8tK;AAClvK,iBAAiB,qxDAAqxD;AACtyD,+BAA+B,qsLAAqsL;AACpuL,wBAAwB,msLAAmsL;AAC3tL,sBAAsB,4jKAA4jK;AACllK,gBAAgB,+mCAA+mC;AAC/nC,sBAAsB,qxDAAqxD;AAC3yD,2BAA2B;AAC3B;;;;;;;;;;;;AClBa;AACb,kBAAkB;AAClB,mBAAmB,GAAG,YAAY,GAAG,gBAAgB;AACrD,kBAAkB,mBAAO,CAAC,gDAAa;AACvC,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C,aAAa,mBAAO,CAAC,sCAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA,mCAAmC;AACnC,+BAA+B;AAC/B,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wGAAwG,eAAe,MAAM;AAClK;AACA;AACA;AACA;AACA,uBAAuB;AACvB,qCAAqC,sFAAsF,eAAe,MAAM;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4GAA4G,eAAe,MAAM;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iBAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,6CAA6C;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,0CAA0C;AAC1C;AACA,gDAAgD;AAChD,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA,CAAC;AACD,mBAAmB;;;;;;;;;;;;ACpjBN;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,yBAAyB,GAAG,YAAY,GAAG,oBAAoB,GAAG,yBAAyB,GAAG,4BAA4B,GAAG,uBAAuB,GAAG,sBAAsB,GAAG,uBAAuB,GAAG,yBAAyB;AACnO,eAAe,mBAAO,CAAC,0CAAU;AACjC;AACA,yBAAyB,mBAAO,CAAC,sFAAgC;AACjE;AACA,wBAAwB,mBAAO,CAAC,oFAA+B;AAC/D;AACA;AACA;AACA,4BAA4B,mBAAO,CAAC,4FAAmC;AACvE;AACA;AACA,aAAa,mBAAO,CAAC,sCAAQ;AAC7B;AACA,mBAAmB,mBAAO,CAAC,kDAAc;AACzC;;;;;;;;;;;;ACxBa;AACb,kBAAkB;AAClB,kBAAkB;AAClB,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,mBAAmB,mBAAO,CAAC,kDAAc;AACzC,eAAe,mBAAO,CAAC,0CAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;;;;;;;;;;;;AClRL;AACb;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yBAAyB,GAAG,uBAAuB,GAAG,YAAY,GAAG,aAAa,GAAG,gBAAgB,GAAG,qBAAqB,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,8BAA8B,GAAG,qBAAqB,GAAG,2BAA2B;AACpQ,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C,yBAAyB,mBAAO,CAAC,8DAAoB;AACrD,eAAe,mBAAO,CAAC,0CAAU;AACjC,yBAAyB,mBAAO,CAAC,sFAAgC;AACjE,wBAAwB,mBAAO,CAAC,oFAA+B;AAC/D,+BAA+B,mBAAO,CAAC,kGAAsC;AAC7E,4BAA4B,mBAAO,CAAC,4FAAmC;AACvE,iCAAiC,mBAAO,CAAC,sGAAwC;AACjF,oCAAoC,mBAAO,CAAC,4GAA2C;AACvF,uBAAuB,mBAAO,CAAC,kFAA8B;AAC7D,uBAAuB,mBAAO,CAAC,0DAAkB;AACjD,0BAA0B,mBAAO,CAAC,gEAAqB;AACvD,cAAc,mBAAO,CAAC,wCAAS;AAC/B,kBAAkB,mBAAO,CAAC,gDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sBAAsB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,4EAA4E,oCAAoC;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,8BAA8B;AAC1F;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,+BAA+B;AAC7F;AACA;AACA;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;;;;;;;;;;;;ACp0BZ;AACb,kBAAkB;AAClB,gBAAgB;AAChB,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C,aAAa,mBAAO,CAAC,sCAAQ;AAC7B;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2IAA2I;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,gBAAgB;AACpF;AACA,oCAAoC,6CAA6C;AACjF;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA,wCAAwC,8CAA8C;AACtF;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA,qCAAqC,2CAA2C;AAChF;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA,qCAAqC,2CAA2C;AAChF;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA,qCAAqC,2CAA2C;AAChF;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA,kCAAkC,wCAAwC;AAC1E;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA,qCAAqC,2CAA2C;AAChF;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA,mCAAmC,8CAA8C;AACjF;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;;;;;;;;;;;;AChNH;AACb;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,kBAAkB;AAClB,mBAAmB,GAAG,cAAc;AACpC,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,WAAW,mBAAO,CAAC,0CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,8BAA8B;AAC9B;AACA;AACA;AACA,4BAA4B;AAC5B,8BAA8B;AAC9B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,kCAAkC;AAClC,0CAA0C;AAC1C,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mBAAmB;;;;;;;;;;;;ACjQN;AACb;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,qBAAqB;AACrB;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU,0BAA0B,gEAAgE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,+BAA+B;AAC/B,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,iDAAiD;AACjD,6BAA6B;AAC7B,2BAA2B;AAC3B,sCAAsC;AACtC,kCAAkC;AAClC,oCAAoC;AACpC,gCAAgC;AAChC,mBAAmB;AACnB,qDAAqD;AACrD,gCAAgC;AAChC,8BAA8B;AAC9B;AACA,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;AACzC,mEAAmE;AACnE,sCAAsC;AACtC,iDAAiD;AACjD,uDAAuD;AACvD;AACA,CAAC;AACD,YAAY;;;;;;;;;;;;ACjqBC;AACb;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,eAAe,mBAAO,CAAC,0CAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,mCAAmC;AACnC,mCAAmC;AACnC,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,oDAAoD;AACpD,oDAAoD;AACpD,8DAA8D;AAC9D,sEAAsE;AACtE,0FAA0F;AAC1F,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,iFAAiF;AACjF,uFAAuF;AACvF,oDAAoD;AACpD,qEAAqE;AACrE,sFAAsF;AACtF,0DAA0D;AAC1D,gEAAgE;AAChE,gEAAgE;AAChE,2EAA2E;AAC3E,gEAAgE;AAChE,oDAAoD;AACpD,sEAAsE;AACtE,mDAAmD;AACnD,sEAAsE;AACtE,qEAAqE;AACrE,8FAA8F;AAC9F,2EAA2E;AAC3E,oEAAoE;AACpE,qEAAqE;AACrE,2DAA2D;AAC3D,yGAAyG;AACzG,8DAA8D;AAC9D,0EAA0E;AAC1E,gFAAgF;AAChF,gEAAgE;AAChE,gEAAgE;AAChE,+CAA+C;AAC/C,+DAA+D;AAC/D,mFAAmF;AACnF;AACA,4EAA4E;AAC5E;AACA,+CAA+C;AAC/C,uCAAuC;AACvC,kCAAkC;AAClC,uEAAuE;AACvE;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC,2CAA2C;AAC3C,iCAAiC;AACjC,oCAAoC;AACpC,oDAAoD;AACpD,iFAAiF;AACjF,uCAAuC;AACvC,wCAAwC;AACxC,2DAA2D;AAC3D,0CAA0C;AAC1C,kDAAkD;AAClD,gEAAgE;AAChE,2DAA2D;AAC3D,sFAAsF;AACtF,2DAA2D;AAC3D,uDAAuD;AACvD,yEAAyE;AACzE,sEAAsE;AACtE,0DAA0D;AAC1D,8CAA8C;AAC9C,kCAAkC;AAClC,6FAA6F;AAC7F,8CAA8C;AAC9C,6DAA6D;AAC7D,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;AAC/C,yEAAyE;AACzE,2CAA2C;AAC3C,4CAA4C;AAC5C,4CAA4C;AAC5C,8CAA8C;AAC9C,oDAAoD;AACpD,oDAAoD;AACpD,kCAAkC;AAClC,2CAA2C;AAC3C,4CAA4C;AAC5C,iFAAiF;AACjF,sEAAsE;AACtE,8CAA8C;AAC9C,oDAAoD;AACpD,mCAAmC;AACnC;AACA;AACA,CAAC;AACD,kBAAkB;;;;;;;;;;;;ACtRL;AACb;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd,aAAa,mBAAO,CAAC,sCAAQ;AAC7B,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C,oBAAoB,mBAAO,CAAC,oDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2BAA2B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD,8EAA8E;AACnI;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iCAAiC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4DAA4D,uBAAuB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8EAA8E;AACnI;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC;AACD,cAAc;;;;;;;;;;;;;;;;AC/dd,OAAO,mBAAmB,EAAE,mBAAO,CAAC,oDAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,6CAA6C;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,SAAS;AACT,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,iBAAiB,EAAE,mBAAO,CAAC,0DAAY;AAC9C,OAAO,UAAU,EAAE,mBAAO,CAAC,4CAAiB;AAC5C;AACA,cAAc,uQAAuQ;AACrR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;AC3FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,8WAA8W,EAAE,mBAAO,CAAC,wCAAe;AAC9Y,OAAO,wBAAwB,EAAE,mBAAO,CAAC,8CAAkB;AAC3D,OAAO,8BAA8B,EAAE,mBAAO,CAAC,8CAAkB;AACjE,OAAO,kQAAkQ,EAAE,mBAAO,CAAC,0DAAY;AAC/R,OAAO,4BAA4B,EAAE,mBAAO,CAAC,wDAAuB;AACpE,OAAO,4BAA4B,EAAE,mBAAO,CAAC,wDAAuB;AACpE,OAAO,gBAAgB,EAAE,mBAAO,CAAC,sDAAsB;AACvD,OAAO,gBAAgB,EAAE,mBAAO,CAAC,sDAAsB;AACvD;AACA,UAAU,qBAAqB;AAC/B;AACA,UAAU,uBAAuB;AACjC,OAAO,YAAY,EAAE,mBAAO,CAAC,gDAAmB;AAChD,OAAO,mBAAmB,EAAE,mBAAO,CAAC,8DAA0B;AAC9D,OAAO,YAAY,EAAE,mBAAO,CAAC,8CAAkB;AAC/C,UAAU,gBAAgB;AAC1B;AACA,UAAU,kBAAkB;AAC5B;AACA,UAAU,qBAAqB;AAC/B,OAAO,mBAAmB,EAAE,mBAAO,CAAC,8DAA0B;AAC9D,OAAO,qBAAqB,EAAE,mBAAO,CAAC,kEAA4B;AAClE;AACA,UAAU,YAAY;AACtB,UAAU,mBAAmB;AAC7B,UAAU,oBAAoB;AAC9B,OAAO,WAAW,EAAE,mBAAO,CAAC,4CAAiB;AAC7C,OAAO,kBAAkB,EAAE,mBAAO,CAAC,0DAAwB;AAC3D,OAAO,SAAS,EAAE,mBAAO,CAAC,sCAAc;AACxC,OAAO,aAAa,EAAE,mBAAO,CAAC,gDAAmB;AACjD,OAAO,oBAAoB,EAAE,mBAAO,CAAC,8DAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA,IAAI;AACJ,wCAAwC,iBAAiB;AACzD;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,4CAA4C,gBAAgB;AAC5D;AACA,EAAE;AACF;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gBAAgB,KAAK,QAAQ;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,sCAAsC,iBAAiB;AACvD;AACA,EAAE;AACF;AACA,SAAS,6BAA6B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA,SAAS,2BAA2B;AACpC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA,8EAA8E,yBAAyB;AACvG;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA,IAAI;AACJ,qDAAqD,gBAAgB;AACrE,yBAAyB,iBAAiB;AAC1C,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,sDAAsD,2BAA2B;AACjF;AACA,qDAAqD,uBAAuB;AAC5E,KAAK;AACL;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,EAAE;AACF;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D,IAAI;AACJ,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iDAAiD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa,SAAS,qBAAqB,SAAS,mBAAmB,IAAI,kBAAkB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,+BAA+B,0BAA0B;AACzD,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK,IAAI,eAAe;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,SAAS,2DAA2D;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8BAA8B,IAAI,wBAAwB,QAAQ,gCAAgC,KAAK,8BAA8B,mBAAmB,gBAAgB;AAC9L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW,KAAK,8CAA8C;AACnF,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,6CAA6C,cAAc;AAC3D,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4CAA4C;AACrD;AACA;AACA;AACA;AACA,EAAE;AACF,wBAAwB,4CAA4C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,6BAA6B,mDAAmD,IAAI;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,SAAS,wBAAwB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,SAAS,wBAAwB;AACjC;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,qDAAqD,gBAAgB;AACrE,+DAA+D,gBAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,SAAS,wBAAwB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,SAAS,cAAc;AACvB;AACA,wDAAwD,gBAAgB;AACxE,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA,IAAI;AACJ;AACA,+CAA+C,sBAAsB;AACrE,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0OAAqC;AACjE;AACA;AACA,QAAQ,mCAAmC;AAC3C;AACA,eAAe,KAAK;AACpB;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA,EAAE;AACF;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,QAAQ,wBAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,0CAA0C,aAAa;AACvD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,0CAA0C,wCAAwC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,QAAQ,gDAAgD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKE;;;;;;;;;;;;;;;;;;ACjpEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKE;;;;;;;;;;;;;;;;;;ACzRF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,iFAAiF,EAAE,mBAAO,CAAC,0DAAY;AAC9G,OAAO,wVAAwV,EAAE,mBAAO,CAAC,wCAAe;AACxX,OAAO,wBAAwB,EAAE,mBAAO,CAAC,wEAA+B;AACxE,OAAO,UAAU,EAAE,mBAAO,CAAC,4CAAiB;AAC5C,OAAO,aAAa,EAAE,mBAAO,CAAC,kDAAoB;AAClD,OAAO,mBAAmB,EAAE,mBAAO,CAAC,8DAA0B;AAC9D,OAAO,mBAAmB,EAAE,mBAAO,CAAC,wDAAuB;AAC3D,OAAO,wBAAwB,EAAE,mBAAO,CAAC,0EAAgC;AACzE,OAAO,iBAAiB,EAAE,mBAAO,CAAC,wDAAuB;AACzD,OAAO,kBAAkB,EAAE,mBAAO,CAAC,4DAAyB;AAC5D,OAAO,iBAAiB,EAAE,mBAAO,CAAC,0DAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS,wCAAwC,eAAe;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+CAA+C;AAC9F;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,2CAA2C,UAAU;AACrD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ,yCAAyC,cAAc;AACvD,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4CAA4C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yFAAyF;AAC9G;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,WAAW,OAAO;AAClB,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AAKE;;;;;;;;;;;;;;;;;;;ACzzCF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAME;;;;;;;;;;;;;;;;AC3HF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;AC9HF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,oBAAoB,aAAa,KAAK,YAAY;AAClD,4BAA4B,UAAU,MAAM,SAAS;AACrD,4BAA4B,UAAU,MAAM,SAAS;AACrD,qCAAqC,MAAM,IAAI,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ,IAAI,WAAW,OAAO,GAAG,aAAa;AAClG,yDAAyD,QAAQ,IAAI,WAAW,OAAO,GAAG,MAAM,IAAI,aAAa;AACjH;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B,2BAA2B,MAAM;AACjC,yCAAyC,MAAM;AAC/C;AACA;AACA,6BAA6B,UAAU,KAAK,QAAQ;AACpD,+BAA+B,UAAU,KAAK,QAAQ;AACtD,6CAA6C,QAAQ;AACrD,+CAA+C,QAAQ;AACvD;AACA,gCAAgC,UAAU,UAAU,OAAO;AAC3D,4BAA4B,SAAS;AACrC,wBAAwB,OAAO;AAC/B,sBAAsB,MAAM;AAC5B,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAoC;AACjE;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE,aAAa,EAAE;AACzC,wCAAwC,cAAc;AACtD,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AAKE;;;;;;;;;;;;;;;;AClIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;ACrGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mBAAmB,EAAE,mBAAO,CAAC,0DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,yCAAyC;AACrG;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;AC7EF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,WAAW,EAAE,mBAAO,CAAC,8CAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0DAA0D;AACxE;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AAIE;;;;;;;;;;;;;;;;AC9FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,WAAW,EAAE,mBAAO,CAAC,8DAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6BAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,qBAAqB,wBAAwB,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;AChMF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAwC,EAAE,mBAAO,CAAC,wCAAe;AACzE,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,0DAAY;AACxD,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,oDAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC,yCAAyC,eAAe,EAAE,YAAY,EAAE,MAAM,EAAE;AAChF,8CAA8C,EAAE,KAAK,EAAE;AACvD,8CAA8C,EAAE,OAAO,EAAE;AACzD;AACA;AACA;AACA;AACA,6CAA6C,QAAQ,wBAAwB,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,oCAAoC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,mEAAmE;AAC7F;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU,kCAAkC,UAAU,SAAS,UAAU;AAC5G,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA,gCAAgC,GAAG;AACnC;AACA;AACA,8BAA8B,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,GAAG,IAAI,EAAE;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM,MAAM,yBAAyB,QAAQ,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B,qBAAqB,EAAE,yBAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iFAAiF,MAAM;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACwC;;;;;;;;;;;;;;;;;AC7qBxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AAIE;;;;;;;;;;;;;;;;;;AC7FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mCAAmC,EAAE,mBAAO,CAAC,wCAAe;AACnE,OAAO,sBAAsB,EAAE,mBAAO,CAAC,8CAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,YAAY;AACpB,GAAG;AACH;AACA,aAAa,qDAAqD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sBAAsB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,2CAA2C;AAClD;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA,IAAI;AACJ,4CAA4C,cAAc;AAC1D;AACA,IAAI;AACJ;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,IAAI,kBAAkB;AAChD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,UAAU,sBAAsB;AAChC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AAKE;;;;;;;;;;;;;;;;;;ACndF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,wCAAwC,EAAE,mBAAO,CAAC,wCAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kCAAkC,IAAI;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4FAA4F,IAAI;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+DAA+D,SAAS,mDAAmD,SAAS;AACpI,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,6DAA6D,SAAS,0DAA0D,SAAS;AACzI;AACA;AACA;AACA,6DAA6D,YAAY,gDAAgD,SAAS;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sDAAsD,cAAc,sDAAsD,MAAM;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,SAAS,eAAe;AACxB;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,SAAS,aAAa,IAAI,aAAa;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,SAAS,aAAa,IAAI,aAAa;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKE;;;;;;;;;;;;;;;;AC3bF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kGAAkG,EAAE,mBAAO,CAAC,0DAAY;AAC/H,OAAO,iHAAiH,EAAE,mBAAO,CAAC,wCAAe;AACjJ,OAAO,qBAAqB,EAAE,mBAAO,CAAC,8CAAkB;AACxD,OAAO,UAAU,EAAE,mBAAO,CAAC,4CAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAA0E,IAAI;AACtF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,gEAAgE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,kBAAkB,mDAAmD,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB,cAAc,QAAQ,KAAK,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iBAAiB,mBAAmB,OAAO,oBAAoB,QAAQ,KAAK,QAAQ;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA,+CAA+C,uCAAuC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,SAAS;AACjF;AACA;AACA;AACA,mDAAmD,uCAAuC;AAC1F,4CAA4C,sCAAsC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;ACjoBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,+BAA+B,EAAE,mBAAO,CAAC,0DAAY;AAC5D,OAAO,8CAA8C,EAAE,mBAAO,CAAC,8BAAU;AACzE,OAAO,uBAAuB,EAAE,mBAAO,CAAC,8CAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6CAA6C,0DAA0D;AACvG;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;AC7QF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,6BAA6B,EAAE,mBAAO,CAAC,0DAAY;AAC1D,OAAO,iBAAiB,EAAE,mBAAO,CAAC,wCAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C,IAAI;AACJ;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;ACxIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,6CAA6C,EAAE,mBAAO,CAAC,wCAAe;AAC7E,OAAO,iCAAiC,EAAE,mBAAO,CAAC,0DAAY;AAC9D;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ,+CAA+C,cAAc;AAC7D,IAAI;AACJ,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,QAAQ;AACzE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0CAA0C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;AClXF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,wBAAwB,EAAE,mBAAO,CAAC,wCAAe;AACxD,OAAO,YAAY,EAAE,mBAAO,CAAC,8CAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIE;;;;;;;;;;;;;;;;AC7CF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mCAAmC,EAAE,mBAAO,CAAC,0DAAY;AAChE,OAAO,mBAAmB,EAAE,mBAAO,CAAC,wDAAuB;AAC3D,OAAO,iBAAiB,EAAE,mBAAO,CAAC,0DAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,iDAAiD,OAAO;AACxD;AACA;AACA;AAGE;;;;;;;;;;;AC/CF,OAAO,YAAY,EAAE,mBAAO,CAAC,8CAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,2CAA2C,EAAE,mBAAO,CAAC,wCAAe;AAC3E,OAAO,YAAY,EAAE,mBAAO,CAAC,wDAAuB;AACpD,OAAO,iBAAiB,EAAE,mBAAO,CAAC,8CAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC;AACvD;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA,GAAG;AACH;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA,GAAG;AACH;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0CAA0C;AAC9F;AACA;AACA;AAGE;;;;;;;;;;;;;;;;ACnRF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;AClHF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB;AAC9B;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yBAAyB;AAClC,SAAS,+BAA+B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kCAAkC;AAC3C,SAAS,+BAA+B;AACxC;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;ACvSF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,iBAAiB,EAAE,mBAAO,CAAC,0DAAY;AAC9C;AACA;AACA,cAAc,8FAA8F;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AAGE;;;;;;;;;;;;;;;;AC5IF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kGAAkG,EAAE,mBAAO,CAAC,wCAAe;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yEAAyE;AAClF;AACA,cAAc,oBAAoB;AAClC;AACA;AACA,yCAAyC,cAAc;AACvD;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS,0DAA0D;AACnE;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC,YAAY;AAC5C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4CAA4C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA,iBAAiB,iBAAiB,GAAG,kBAAkB;AACvD;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChRF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2EAA2E;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAyCE;;;;;;;;;;;;;;;;AC5gBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;ACxFF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,UAAU,EAAE,mBAAO,CAAC,0DAAY;AACvC;AACA,cAAc,wEAAwE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;ACrFF;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA,uDAAuD,qCAAqC,kBAAkB;WAC9G;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,sDAAsD;WACtD,sCAAsC,iEAAiE;WACvG,8DAA8D,wBAAwB,uBAAuB;WAC7G;WACA,+BAA+B;WAC/B;WACA;WACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD,8CAA8C;;;;;WCA9C;WACA;WACA;WACA;WACA,uBAAuB,4BAA4B;WACnD;WACA;WACA;WACA,iBAAiB,oBAAoB;WACrC;WACA,mGAAmG,YAAY;WAC/G;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,4CAA4C,mBAAmB;WAC/D;WACA;WACA;WACA,mEAAmE,iCAAiC;WACpG;WACA;WACA;WACA;;;;;WCzCA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,iCAAiC;;WAEjC;WACA;WACA;WACA,KAAK;WACL,eAAe;WACf;WACA,2DAA2D,oEAAoE;WAC/H;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,iCAAiC,mCAAmC;WACpE;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;WACA;WACA;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY,EAAE,mBAAO,CAAC,8CAAkB;AAC/C,OAAO,sBAAsB,EAAE,mBAAO,CAAC,8BAAU;AACjD,OAAO,WAAW,EAAE,mBAAO,CAAC,0CAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mBAAO,CAAC,0DAAwB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,4JAAyB;AAC3B,EAAE,gJAAgC;AAClC;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AAIE","sources":["webpack://saltdogreader/./node_modules/crypto-js/aes.js","webpack://saltdogreader/./node_modules/crypto-js/cipher-core.js","webpack://saltdogreader/./node_modules/crypto-js/core.js","webpack://saltdogreader/./node_modules/crypto-js/enc-base64.js","webpack://saltdogreader/./node_modules/crypto-js/enc-base64url.js","webpack://saltdogreader/./node_modules/crypto-js/enc-utf16.js","webpack://saltdogreader/./node_modules/crypto-js/evpkdf.js","webpack://saltdogreader/./node_modules/crypto-js/format-hex.js","webpack://saltdogreader/./node_modules/crypto-js/hmac.js","webpack://saltdogreader/./node_modules/crypto-js/index.js","webpack://saltdogreader/./node_modules/crypto-js/lib-typedarrays.js","webpack://saltdogreader/./node_modules/crypto-js/md5.js","webpack://saltdogreader/./node_modules/crypto-js/mode-cfb.js","webpack://saltdogreader/./node_modules/crypto-js/mode-ctr-gladman.js","webpack://saltdogreader/./node_modules/crypto-js/mode-ctr.js","webpack://saltdogreader/./node_modules/crypto-js/mode-ecb.js","webpack://saltdogreader/./node_modules/crypto-js/mode-ofb.js","webpack://saltdogreader/./node_modules/crypto-js/pad-ansix923.js","webpack://saltdogreader/./node_modules/crypto-js/pad-iso10126.js","webpack://saltdogreader/./node_modules/crypto-js/pad-iso97971.js","webpack://saltdogreader/./node_modules/crypto-js/pad-nopadding.js","webpack://saltdogreader/./node_modules/crypto-js/pad-zeropadding.js","webpack://saltdogreader/./node_modules/crypto-js/pbkdf2.js","webpack://saltdogreader/./node_modules/crypto-js/rabbit-legacy.js","webpack://saltdogreader/./node_modules/crypto-js/rabbit.js","webpack://saltdogreader/./node_modules/crypto-js/rc4.js","webpack://saltdogreader/./node_modules/crypto-js/ripemd160.js","webpack://saltdogreader/./node_modules/crypto-js/sha1.js","webpack://saltdogreader/./node_modules/crypto-js/sha224.js","webpack://saltdogreader/./node_modules/crypto-js/sha256.js","webpack://saltdogreader/./node_modules/crypto-js/sha3.js","webpack://saltdogreader/./node_modules/crypto-js/sha384.js","webpack://saltdogreader/./node_modules/crypto-js/sha512.js","webpack://saltdogreader/./node_modules/crypto-js/tripledes.js","webpack://saltdogreader/./node_modules/crypto-js/x64-core.js","webpack://saltdogreader/./node_modules/pako/index.js","webpack://saltdogreader/./node_modules/pako/lib/deflate.js","webpack://saltdogreader/./node_modules/pako/lib/inflate.js","webpack://saltdogreader/./node_modules/pako/lib/utils/common.js","webpack://saltdogreader/./node_modules/pako/lib/utils/strings.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/adler32.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/constants.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/crc32.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/deflate.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/gzheader.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/inffast.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/inflate.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/inftrees.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/messages.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/trees.js","webpack://saltdogreader/./node_modules/pako/lib/zlib/zstream.js","webpack://saltdogreader/./node_modules/pdfjs-dist/build/pdf.js","webpack://saltdogreader/./src/annotate/annotation.ts","webpack://saltdogreader/./src/annotate/annotations/annotation_errors.ts","webpack://saltdogreader/./src/annotate/annotations/annotation_types.ts","webpack://saltdogreader/./src/annotate/annotations/circle_square_annotation.ts","webpack://saltdogreader/./src/annotate/annotations/freetext_annotation.ts","webpack://saltdogreader/./src/annotate/annotations/ink_annotation.ts","webpack://saltdogreader/./src/annotate/annotations/polygon_polyline_annotation.ts","webpack://saltdogreader/./src/annotate/annotations/text_annotation.ts","webpack://saltdogreader/./src/annotate/annotations/text_markup_annotation.ts","webpack://saltdogreader/./src/annotate/appearance-stream.ts","webpack://saltdogreader/./src/annotate/array-util.ts","webpack://saltdogreader/./src/annotate/content-stream.ts","webpack://saltdogreader/./src/annotate/crypto-util.ts","webpack://saltdogreader/./src/annotate/crypto.ts","webpack://saltdogreader/./src/annotate/document-history.ts","webpack://saltdogreader/./src/annotate/font-data.ts","webpack://saltdogreader/./src/annotate/fonts.ts","webpack://saltdogreader/./src/annotate/index.ts","webpack://saltdogreader/./src/annotate/object-util.ts","webpack://saltdogreader/./src/annotate/parser.ts","webpack://saltdogreader/./src/annotate/resources.ts","webpack://saltdogreader/./src/annotate/stream.ts","webpack://saltdogreader/./src/annotate/util.ts","webpack://saltdogreader/./src/annotate/writer-util.ts","webpack://saltdogreader/./src/annotate/writer.ts","webpack://saltdogreader/./src/annotate_controller.js","webpack://saltdogreader/./src/annotation_layer_builder.js","webpack://saltdogreader/./src/app.js","webpack://saltdogreader/./src/app_options.js","webpack://saltdogreader/./src/base_viewer.js","webpack://saltdogreader/./src/event_utils.js","webpack://saltdogreader/./src/grab_to_pan.js","webpack://saltdogreader/./src/l10n_utils.js","webpack://saltdogreader/./src/overlay_manager.js","webpack://saltdogreader/./src/password_prompt.js","webpack://saltdogreader/./src/pdf_cursor_tools.js","webpack://saltdogreader/./src/pdf_find_bar.js","webpack://saltdogreader/./src/pdf_find_controller.js","webpack://saltdogreader/./src/pdf_find_utils.js","webpack://saltdogreader/./src/pdf_history.js","webpack://saltdogreader/./src/pdf_link_service.js","webpack://saltdogreader/./src/pdf_page_view.js","webpack://saltdogreader/./src/pdf_print_service.js","webpack://saltdogreader/./src/pdf_rendering_queue.js","webpack://saltdogreader/./src/pdf_scripting_manager.js","webpack://saltdogreader/./src/pdf_viewer.js","webpack://saltdogreader/./src/print_utils.js","webpack://saltdogreader/./src/sdpdfcore.js","webpack://saltdogreader/./src/secondary_toolbar.js","webpack://saltdogreader/./src/struct_tree_layer_builder.js","webpack://saltdogreader/./src/text_highlighter.js","webpack://saltdogreader/./src/text_layer_builder.js","webpack://saltdogreader/./src/toolbar.js","webpack://saltdogreader/./src/ui_utils.js","webpack://saltdogreader/./src/view_history.js","webpack://saltdogreader/./src/xfa_layer_builder.js","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\node_modules\\crypto-js|crypto","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\node_modules\\pdfjs-dist\\build|canvas","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\node_modules\\pdfjs-dist\\build|fs","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\node_modules\\pdfjs-dist\\build|http","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\node_modules\\pdfjs-dist\\build|https","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\node_modules\\pdfjs-dist\\build|url","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\node_modules\\pdfjs-dist\\build|zlib","webpack://saltdogreader/ignored|F:\\Develop\\SaltDog\\third_party\\SDPDFCore\\src\\annotate|fs","webpack://saltdogreader/webpack/bootstrap","webpack://saltdogreader/webpack/runtime/create fake namespace object","webpack://saltdogreader/webpack/runtime/define property getters","webpack://saltdogreader/webpack/runtime/ensure chunk","webpack://saltdogreader/webpack/runtime/get javascript chunk filename","webpack://saltdogreader/webpack/runtime/global","webpack://saltdogreader/webpack/runtime/hasOwnProperty shorthand","webpack://saltdogreader/webpack/runtime/load script","webpack://saltdogreader/webpack/runtime/make namespace object","webpack://saltdogreader/webpack/runtime/publicPath","webpack://saltdogreader/webpack/runtime/jsonp chunk loading","webpack://saltdogreader/./src/index.js"],"sourcesContent":[";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./enc-base64\"), require(\"./md5\"), require(\"./evpkdf\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./enc-base64\", \"./md5\", \"./evpkdf\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Lookup tables\n\t    var SBOX = [];\n\t    var INV_SBOX = [];\n\t    var SUB_MIX_0 = [];\n\t    var SUB_MIX_1 = [];\n\t    var SUB_MIX_2 = [];\n\t    var SUB_MIX_3 = [];\n\t    var INV_SUB_MIX_0 = [];\n\t    var INV_SUB_MIX_1 = [];\n\t    var INV_SUB_MIX_2 = [];\n\t    var INV_SUB_MIX_3 = [];\n\n\t    // Compute lookup tables\n\t    (function () {\n\t        // Compute double table\n\t        var d = [];\n\t        for (var i = 0; i < 256; i++) {\n\t            if (i < 128) {\n\t                d[i] = i << 1;\n\t            } else {\n\t                d[i] = (i << 1) ^ 0x11b;\n\t            }\n\t        }\n\n\t        // Walk GF(2^8)\n\t        var x = 0;\n\t        var xi = 0;\n\t        for (var i = 0; i < 256; i++) {\n\t            // Compute sbox\n\t            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n\t            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n\t            SBOX[x] = sx;\n\t            INV_SBOX[sx] = x;\n\n\t            // Compute multiplication\n\t            var x2 = d[x];\n\t            var x4 = d[x2];\n\t            var x8 = d[x4];\n\n\t            // Compute sub bytes, mix columns tables\n\t            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n\t            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n\t            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n\t            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n\t            SUB_MIX_3[x] = t;\n\n\t            // Compute inv sub bytes, inv mix columns tables\n\t            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n\t            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n\t            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n\t            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n\t            INV_SUB_MIX_3[sx] = t;\n\n\t            // Compute next counter\n\t            if (!x) {\n\t                x = xi = 1;\n\t            } else {\n\t                x = x2 ^ d[d[d[x8 ^ x2]]];\n\t                xi ^= d[d[xi]];\n\t            }\n\t        }\n\t    }());\n\n\t    // Precomputed Rcon lookup\n\t    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n\t    /**\n\t     * AES block cipher algorithm.\n\t     */\n\t    var AES = C_algo.AES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            var t;\n\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._nRounds && this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            // Compute number of rounds\n\t            var nRounds = this._nRounds = keySize + 6;\n\n\t            // Compute number of key schedule rows\n\t            var ksRows = (nRounds + 1) * 4;\n\n\t            // Compute key schedule\n\t            var keySchedule = this._keySchedule = [];\n\t            for (var ksRow = 0; ksRow < ksRows; ksRow++) {\n\t                if (ksRow < keySize) {\n\t                    keySchedule[ksRow] = keyWords[ksRow];\n\t                } else {\n\t                    t = keySchedule[ksRow - 1];\n\n\t                    if (!(ksRow % keySize)) {\n\t                        // Rot word\n\t                        t = (t << 8) | (t >>> 24);\n\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n\t                        // Mix Rcon\n\t                        t ^= RCON[(ksRow / keySize) | 0] << 24;\n\t                    } else if (keySize > 6 && ksRow % keySize == 4) {\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\t                    }\n\n\t                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n\t                }\n\t            }\n\n\t            // Compute inv key schedule\n\t            var invKeySchedule = this._invKeySchedule = [];\n\t            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n\t                var ksRow = ksRows - invKsRow;\n\n\t                if (invKsRow % 4) {\n\t                    var t = keySchedule[ksRow];\n\t                } else {\n\t                    var t = keySchedule[ksRow - 4];\n\t                }\n\n\t                if (invKsRow < 4 || ksRow <= 4) {\n\t                    invKeySchedule[invKsRow] = t;\n\t                } else {\n\t                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n\t                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n\t                }\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            // Swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\n\t            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n\t            // Inv swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\t        },\n\n\t        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n\t            // Shortcut\n\t            var nRounds = this._nRounds;\n\n\t            // Get input, add round key\n\t            var s0 = M[offset]     ^ keySchedule[0];\n\t            var s1 = M[offset + 1] ^ keySchedule[1];\n\t            var s2 = M[offset + 2] ^ keySchedule[2];\n\t            var s3 = M[offset + 3] ^ keySchedule[3];\n\n\t            // Key schedule row counter\n\t            var ksRow = 4;\n\n\t            // Rounds\n\t            for (var round = 1; round < nRounds; round++) {\n\t                // Shift rows, sub bytes, mix columns, add round key\n\t                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\n\t                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\n\t                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\n\t                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\n\n\t                // Update state\n\t                s0 = t0;\n\t                s1 = t1;\n\t                s2 = t2;\n\t                s3 = t3;\n\t            }\n\n\t            // Shift rows, sub bytes, add round key\n\t            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n\n\t            // Set output\n\t            M[offset]     = t0;\n\t            M[offset + 1] = t1;\n\t            M[offset + 2] = t2;\n\t            M[offset + 3] = t3;\n\t        },\n\n\t        keySize: 256/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.AES = BlockCipher._createHelper(AES);\n\t}());\n\n\n\treturn CryptoJS.AES;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./evpkdf\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./evpkdf\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            var block;\n\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            var modeCreator;\n\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var finalProcessedBlocks;\n\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            var wordArray;\n\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            var salt;\n\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native crypto in web worker (Browser)\n\t    if (typeof self !== 'undefined' && self.crypto) {\n\t        crypto = self.crypto;\n\t    }\n\n\t    // Native crypto from worker\n\t    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n\t        crypto = globalThis.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && typeof require === 'function') {\n\t        try {\n\t            crypto = require('crypto');\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }());\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var j = 0; j < thatSigBytes; j += 4) {\n\t                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              var bitsCombined = bits1 | bits2;\n\t              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64url encoding strategy.\n\t     */\n\t    var Base64url = C_enc.Base64url = {\n\t        /**\n\t         * Converts a word array to a Base64url string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {string} The Base64url string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray, urlSafe=true) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64url string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64url string.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);\n\t         */\n\t        parse: function (base64Str, urlSafe=true) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                reverseMap = this._reverseMap = [];\n\t                for (var j = 0; j < map.length; j++) {\n\t                    reverseMap[map.charCodeAt(j)] = j;\n\t                }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n\t        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t        var words = [];\n\t        var nBytes = 0;\n\t        for (var i = 0; i < base64StrLength; i++) {\n\t            if (i % 4) {\n\t                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t                var bitsCombined = bits1 | bits2;\n\t                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t                nBytes++;\n\t            }\n\t        }\n\t        return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\treturn CryptoJS.enc.Base64url;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * UTF-16 BE encoding strategy.\n\t     */\n\t    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 BE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 BE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 BE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 BE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-16 LE encoding strategy.\n\t     */\n\t    C_enc.Utf16LE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 LE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 LE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 LE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 LE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    function swapEndian(word) {\n\t        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Utf16;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./sha1\"), require(\"./hmac\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./sha1\", \"./hmac\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var MD5 = C_algo.MD5;\n\n\t    /**\n\t     * This key derivation function is meant to conform with EVP_BytesToKey.\n\t     * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n\t     */\n\t    var EvpKDF = C_algo.EvpKDF = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: MD5,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create();\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Derives a key from a password.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            var block;\n\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init hasher\n\t            var hasher = cfg.hasher.create();\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                if (block) {\n\t                    hasher.update(block);\n\t                }\n\t                block = hasher.update(password).finalize(salt);\n\t                hasher.reset();\n\n\t                // Iterations\n\t                for (var i = 1; i < iterations; i++) {\n\t                    block = hasher.finalize(block);\n\t                    hasher.reset();\n\t                }\n\n\t                derivedKey.concat(block);\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Derives a key from a password.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.EvpKDF(password, salt);\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.EvpKDF = function (password, salt, cfg) {\n\t        return EvpKDF.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.EvpKDF;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var CipherParams = C_lib.CipherParams;\n\t    var C_enc = C.enc;\n\t    var Hex = C_enc.Hex;\n\t    var C_format = C.format;\n\n\t    var HexFormatter = C_format.Hex = {\n\t        /**\n\t         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The hexadecimally encoded string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            return cipherParams.ciphertext.toString(Hex);\n\t        },\n\n\t        /**\n\t         * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n\t         *\n\t         * @param {string} input The hexadecimally encoded string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n\t         */\n\t        parse: function (input) {\n\t            var ciphertext = Hex.parse(input);\n\t            return CipherParams.create({ ciphertext: ciphertext });\n\t        }\n\t    };\n\t}());\n\n\n\treturn CryptoJS.format.Hex;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * HMAC algorithm.\n\t     */\n\t    var HMAC = C_algo.HMAC = Base.extend({\n\t        /**\n\t         * Initializes a newly created HMAC.\n\t         *\n\t         * @param {Hasher} hasher The hash algorithm to use.\n\t         * @param {WordArray|string} key The secret key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n\t         */\n\t        init: function (hasher, key) {\n\t            // Init hasher\n\t            hasher = this._hasher = new hasher.init();\n\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof key == 'string') {\n\t                key = Utf8.parse(key);\n\t            }\n\n\t            // Shortcuts\n\t            var hasherBlockSize = hasher.blockSize;\n\t            var hasherBlockSizeBytes = hasherBlockSize * 4;\n\n\t            // Allow arbitrary length keys\n\t            if (key.sigBytes > hasherBlockSizeBytes) {\n\t                key = hasher.finalize(key);\n\t            }\n\n\t            // Clamp excess bits\n\t            key.clamp();\n\n\t            // Clone key for inner and outer pads\n\t            var oKey = this._oKey = key.clone();\n\t            var iKey = this._iKey = key.clone();\n\n\t            // Shortcuts\n\t            var oKeyWords = oKey.words;\n\t            var iKeyWords = iKey.words;\n\n\t            // XOR keys with pad constants\n\t            for (var i = 0; i < hasherBlockSize; i++) {\n\t                oKeyWords[i] ^= 0x5c5c5c5c;\n\t                iKeyWords[i] ^= 0x36363636;\n\t            }\n\t            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this HMAC to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Reset\n\t            hasher.reset();\n\t            hasher.update(this._iKey);\n\t        },\n\n\t        /**\n\t         * Updates this HMAC with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {HMAC} This HMAC instance.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.update('message');\n\t         *     hmacHasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            this._hasher.update(messageUpdate);\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the HMAC computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The HMAC.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmac = hmacHasher.finalize();\n\t         *     var hmac = hmacHasher.finalize('message');\n\t         *     var hmac = hmacHasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Compute HMAC\n\t            var innerHash = hasher.finalize(messageUpdate);\n\t            hasher.reset();\n\t            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n\t            return hmac;\n\t        }\n\t    });\n\t}());\n\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./x64-core\"), require(\"./lib-typedarrays\"), require(\"./enc-utf16\"), require(\"./enc-base64\"), require(\"./enc-base64url\"), require(\"./md5\"), require(\"./sha1\"), require(\"./sha256\"), require(\"./sha224\"), require(\"./sha512\"), require(\"./sha384\"), require(\"./sha3\"), require(\"./ripemd160\"), require(\"./hmac\"), require(\"./pbkdf2\"), require(\"./evpkdf\"), require(\"./cipher-core\"), require(\"./mode-cfb\"), require(\"./mode-ctr\"), require(\"./mode-ctr-gladman\"), require(\"./mode-ofb\"), require(\"./mode-ecb\"), require(\"./pad-ansix923\"), require(\"./pad-iso10126\"), require(\"./pad-iso97971\"), require(\"./pad-zeropadding\"), require(\"./pad-nopadding\"), require(\"./format-hex\"), require(\"./aes\"), require(\"./tripledes\"), require(\"./rc4\"), require(\"./rabbit\"), require(\"./rabbit-legacy\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./x64-core\", \"./lib-typedarrays\", \"./enc-utf16\", \"./enc-base64\", \"./enc-base64url\", \"./md5\", \"./sha1\", \"./sha256\", \"./sha224\", \"./sha512\", \"./sha384\", \"./sha3\", \"./ripemd160\", \"./hmac\", \"./pbkdf2\", \"./evpkdf\", \"./cipher-core\", \"./mode-cfb\", \"./mode-ctr\", \"./mode-ctr-gladman\", \"./mode-ofb\", \"./mode-ecb\", \"./pad-ansix923\", \"./pad-iso10126\", \"./pad-iso97971\", \"./pad-zeropadding\", \"./pad-nopadding\", \"./format-hex\", \"./aes\", \"./tripledes\", \"./rc4\", \"./rabbit\", \"./rabbit-legacy\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Check if typed arrays are supported\n\t    if (typeof ArrayBuffer != 'function') {\n\t        return;\n\t    }\n\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\n\t    // Reference original init\n\t    var superInit = WordArray.init;\n\n\t    // Augment WordArray.init to handle typed arrays\n\t    var subInit = WordArray.init = function (typedArray) {\n\t        // Convert buffers to uint8\n\t        if (typedArray instanceof ArrayBuffer) {\n\t            typedArray = new Uint8Array(typedArray);\n\t        }\n\n\t        // Convert other array views to uint8\n\t        if (\n\t            typedArray instanceof Int8Array ||\n\t            (typeof Uint8ClampedArray !== \"undefined\" && typedArray instanceof Uint8ClampedArray) ||\n\t            typedArray instanceof Int16Array ||\n\t            typedArray instanceof Uint16Array ||\n\t            typedArray instanceof Int32Array ||\n\t            typedArray instanceof Uint32Array ||\n\t            typedArray instanceof Float32Array ||\n\t            typedArray instanceof Float64Array\n\t        ) {\n\t            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t        }\n\n\t        // Handle Uint8Array\n\t        if (typedArray instanceof Uint8Array) {\n\t            // Shortcut\n\t            var typedArrayByteLength = typedArray.byteLength;\n\n\t            // Extract bytes\n\t            var words = [];\n\t            for (var i = 0; i < typedArrayByteLength; i++) {\n\t                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n\t            }\n\n\t            // Initialize this word array\n\t            superInit.call(this, words, typedArrayByteLength);\n\t        } else {\n\t            // Else call normal init\n\t            superInit.apply(this, arguments);\n\t        }\n\t    };\n\n\t    subInit.prototype = WordArray;\n\t}());\n\n\n\treturn CryptoJS.lib.WordArray;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working varialbes\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher Feedback block mode.\n\t */\n\tCryptoJS.mode.CFB = (function () {\n\t    var CFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    CFB.Encryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // Remember this block to use with next block\n\t            this._prevBlock = words.slice(offset, offset + blockSize);\n\t        }\n\t    });\n\n\t    CFB.Decryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            // Remember this block to use with next block\n\t            var thisBlock = words.slice(offset, offset + blockSize);\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // This block becomes the previous block\n\t            this._prevBlock = thisBlock;\n\t        }\n\t    });\n\n\t    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n\t        var keystream;\n\n\t        // Shortcut\n\t        var iv = this._iv;\n\n\t        // Generate keystream\n\t        if (iv) {\n\t            keystream = iv.slice(0);\n\n\t            // Remove IV for subsequent blocks\n\t            this._iv = undefined;\n\t        } else {\n\t            keystream = this._prevBlock;\n\t        }\n\t        cipher.encryptBlock(keystream, 0);\n\n\t        // Encrypt\n\t        for (var i = 0; i < blockSize; i++) {\n\t            words[offset + i] ^= keystream[i];\n\t        }\n\t    }\n\n\t    return CFB;\n\t}());\n\n\n\treturn CryptoJS.mode.CFB;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n\t * derived from CryptoJS.mode.CTR\n\t * Jan Hruby jhruby.web@gmail.com\n\t */\n\tCryptoJS.mode.CTRGladman = (function () {\n\t    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tfunction incWord(word)\n\t\t{\n\t\t\tif (((word >> 24) & 0xff) === 0xff) { //overflow\n\t\t\tvar b1 = (word >> 16)&0xff;\n\t\t\tvar b2 = (word >> 8)&0xff;\n\t\t\tvar b3 = word & 0xff;\n\n\t\t\tif (b1 === 0xff) // overflow b1\n\t\t\t{\n\t\t\tb1 = 0;\n\t\t\tif (b2 === 0xff)\n\t\t\t{\n\t\t\t\tb2 = 0;\n\t\t\t\tif (b3 === 0xff)\n\t\t\t\t{\n\t\t\t\t\tb3 = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++b3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++b2;\n\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t++b1;\n\t\t\t}\n\n\t\t\tword = 0;\n\t\t\tword += (b1 << 16);\n\t\t\tword += (b2 << 8);\n\t\t\tword += b3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tword += (0x01 << 24);\n\t\t\t}\n\t\t\treturn word;\n\t\t}\n\n\t\tfunction incCounter(counter)\n\t\t{\n\t\t\tif ((counter[0] = incWord(counter[0])) === 0)\n\t\t\t{\n\t\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n\t\t\t\tcounter[1] = incWord(counter[1]);\n\t\t\t}\n\t\t\treturn counter;\n\t\t}\n\n\t    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\n\t\t\t\tincCounter(counter);\n\n\t\t\t\tvar keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTRGladman.Decryptor = Encryptor;\n\n\t    return CTRGladman;\n\t}());\n\n\n\n\n\treturn CryptoJS.mode.CTRGladman;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Counter block mode.\n\t */\n\tCryptoJS.mode.CTR = (function () {\n\t    var CTR = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = CTR.Encryptor = CTR.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            var keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Increment counter\n\t            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTR.Decryptor = Encryptor;\n\n\t    return CTR;\n\t}());\n\n\n\treturn CryptoJS.mode.CTR;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Electronic Codebook block mode.\n\t */\n\tCryptoJS.mode.ECB = (function () {\n\t    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    ECB.Encryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.encryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    ECB.Decryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.decryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    return ECB;\n\t}());\n\n\n\treturn CryptoJS.mode.ECB;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Output Feedback block mode.\n\t */\n\tCryptoJS.mode.OFB = (function () {\n\t    var OFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = OFB.Encryptor = OFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var keystream = this._keystream;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                keystream = this._keystream = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    OFB.Decryptor = Encryptor;\n\n\t    return OFB;\n\t}());\n\n\n\treturn CryptoJS.mode.OFB;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ANSI X.923 padding strategy.\n\t */\n\tCryptoJS.pad.AnsiX923 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcuts\n\t        var dataSigBytes = data.sigBytes;\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;\n\n\t        // Compute last byte position\n\t        var lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\n\t        data.sigBytes += nPaddingBytes;\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Ansix923;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO 10126 padding strategy.\n\t */\n\tCryptoJS.pad.Iso10126 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t        // Pad\n\t        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).\n\t             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso10126;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO/IEC 9797-1 Padding Method 2.\n\t */\n\tCryptoJS.pad.Iso97971 = {\n\t    pad: function (data, blockSize) {\n\t        // Add 0x80 byte\n\t        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));\n\n\t        // Zero pad the rest\n\t        CryptoJS.pad.ZeroPadding.pad(data, blockSize);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Remove zero padding\n\t        CryptoJS.pad.ZeroPadding.unpad(data);\n\n\t        // Remove one more byte -- the 0x80 byte\n\t        data.sigBytes--;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso97971;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * A noop padding strategy.\n\t */\n\tCryptoJS.pad.NoPadding = {\n\t    pad: function () {\n\t    },\n\n\t    unpad: function () {\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.NoPadding;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Zero padding strategy.\n\t */\n\tCryptoJS.pad.ZeroPadding = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Shortcut\n\t        var dataWords = data.words;\n\n\t        // Unpad\n\t        var i = data.sigBytes - 1;\n\t        for (var i = data.sigBytes - 1; i >= 0; i--) {\n\t            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {\n\t                data.sigBytes = i + 1;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.ZeroPadding;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./sha1\"), require(\"./hmac\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./sha1\", \"./hmac\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA1 = C_algo.SHA1;\n\t    var HMAC = C_algo.HMAC;\n\n\t    /**\n\t     * Password-Based Key Derivation Function 2 algorithm.\n\t     */\n\t    var PBKDF2 = C_algo.PBKDF2 = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hasher to use. Default: SHA1\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: SHA1,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create();\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Computes the Password-Based Key Derivation Function 2.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init HMAC\n\t            var hmac = HMAC.create(cfg.hasher, password);\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\t            var blockIndex = WordArray.create([0x00000001]);\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var blockIndexWords = blockIndex.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                var block = hmac.update(salt).finalize(blockIndex);\n\t                hmac.reset();\n\n\t                // Shortcuts\n\t                var blockWords = block.words;\n\t                var blockWordsLength = blockWords.length;\n\n\t                // Iterations\n\t                var intermediate = block;\n\t                for (var i = 1; i < iterations; i++) {\n\t                    intermediate = hmac.finalize(intermediate);\n\t                    hmac.reset();\n\n\t                    // Shortcut\n\t                    var intermediateWords = intermediate.words;\n\n\t                    // XOR intermediate with block\n\t                    for (var j = 0; j < blockWordsLength; j++) {\n\t                        blockWords[j] ^= intermediateWords[j];\n\t                    }\n\t                }\n\n\t                derivedKey.concat(block);\n\t                blockIndexWords[0]++;\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Computes the Password-Based Key Derivation Function 2.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.PBKDF2(password, salt);\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.PBKDF2 = function (password, salt, cfg) {\n\t        return PBKDF2.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.PBKDF2;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./enc-base64\"), require(\"./md5\"), require(\"./evpkdf\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./enc-base64\", \"./md5\", \"./evpkdf\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm.\n\t     *\n\t     * This is a legacy version that neglected to convert the key to little-endian.\n\t     * This error doesn't affect the cipher's security,\n\t     * but it does affect its compatibility with other implementations.\n\t     */\n\t    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);\n\t}());\n\n\n\treturn CryptoJS.RabbitLegacy;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./enc-base64\"), require(\"./md5\"), require(\"./evpkdf\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./enc-base64\", \"./md5\", \"./evpkdf\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm\n\t     */\n\t    var Rabbit = C_algo.Rabbit = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.Rabbit = StreamCipher._createHelper(Rabbit);\n\t}());\n\n\n\treturn CryptoJS.Rabbit;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./enc-base64\"), require(\"./md5\"), require(\"./evpkdf\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./enc-base64\", \"./md5\", \"./evpkdf\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * RC4 stream cipher algorithm.\n\t     */\n\t    var RC4 = C_algo.RC4 = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            var keySigBytes = key.sigBytes;\n\n\t            // Init sbox\n\t            var S = this._S = [];\n\t            for (var i = 0; i < 256; i++) {\n\t                S[i] = i;\n\t            }\n\n\t            // Key setup\n\t            for (var i = 0, j = 0; i < 256; i++) {\n\t                var keyByteIndex = i % keySigBytes;\n\t                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\n\n\t                j = (j + S[i] + keyByte) % 256;\n\n\t                // Swap\n\t                var t = S[i];\n\t                S[i] = S[j];\n\t                S[j] = t;\n\t            }\n\n\t            // Counters\n\t            this._i = this._j = 0;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            M[offset] ^= generateKeystreamWord.call(this);\n\t        },\n\n\t        keySize: 256/32,\n\n\t        ivSize: 0\n\t    });\n\n\t    function generateKeystreamWord() {\n\t        // Shortcuts\n\t        var S = this._S;\n\t        var i = this._i;\n\t        var j = this._j;\n\n\t        // Generate keystream word\n\t        var keystreamWord = 0;\n\t        for (var n = 0; n < 4; n++) {\n\t            i = (i + 1) % 256;\n\t            j = (j + S[i]) % 256;\n\n\t            // Swap\n\t            var t = S[i];\n\t            S[i] = S[j];\n\t            S[j] = t;\n\n\t            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\n\t        }\n\n\t        // Update counters\n\t        this._i = i;\n\t        this._j = j;\n\n\t        return keystreamWord;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4 = StreamCipher._createHelper(RC4);\n\n\t    /**\n\t     * Modified RC4 stream cipher algorithm.\n\t     */\n\t    var RC4Drop = C_algo.RC4Drop = RC4.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} drop The number of keystream words to drop. Default 192\n\t         */\n\t        cfg: RC4.cfg.extend({\n\t            drop: 192\n\t        }),\n\n\t        _doReset: function () {\n\t            RC4._doReset.call(this);\n\n\t            // Drop\n\t            for (var i = this.cfg.drop; i > 0; i--) {\n\t                generateKeystreamWord.call(this);\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4Drop = StreamCipher._createHelper(RC4Drop);\n\t}());\n\n\n\treturn CryptoJS.RC4;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t(c) 2012 by Cédric Mesnil. All rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\t    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\t    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t*/\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var _zl = WordArray.create([\n\t        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n\t        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n\t        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n\t        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);\n\t    var _zr = WordArray.create([\n\t        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n\t        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n\t        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n\t        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n\t        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);\n\t    var _sl = WordArray.create([\n\t         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,\n\t        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n\t        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n\t          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n\t        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);\n\t    var _sr = WordArray.create([\n\t        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n\t        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n\t        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n\t        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n\t        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);\n\n\t    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n\t    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\n\t    /**\n\t     * RIPEMD160 hash algorithm.\n\t     */\n\t    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                // Swap\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\t            // Shortcut\n\t            var H  = this._hash.words;\n\t            var hl = _hl.words;\n\t            var hr = _hr.words;\n\t            var zl = _zl.words;\n\t            var zr = _zr.words;\n\t            var sl = _sl.words;\n\t            var sr = _sr.words;\n\n\t            // Working variables\n\t            var al, bl, cl, dl, el;\n\t            var ar, br, cr, dr, er;\n\n\t            ar = al = H[0];\n\t            br = bl = H[1];\n\t            cr = cl = H[2];\n\t            dr = dl = H[3];\n\t            er = el = H[4];\n\t            // Computation\n\t            var t;\n\t            for (var i = 0; i < 80; i += 1) {\n\t                t = (al +  M[offset+zl[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f1(bl,cl,dl) + hl[0];\n\t                } else if (i<32) {\n\t\t            t +=  f2(bl,cl,dl) + hl[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(bl,cl,dl) + hl[2];\n\t                } else if (i<64) {\n\t\t            t +=  f4(bl,cl,dl) + hl[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f5(bl,cl,dl) + hl[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sl[i]);\n\t                t = (t+el)|0;\n\t                al = el;\n\t                el = dl;\n\t                dl = rotl(cl, 10);\n\t                cl = bl;\n\t                bl = t;\n\n\t                t = (ar + M[offset+zr[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f5(br,cr,dr) + hr[0];\n\t                } else if (i<32) {\n\t\t            t +=  f4(br,cr,dr) + hr[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(br,cr,dr) + hr[2];\n\t                } else if (i<64) {\n\t\t            t +=  f2(br,cr,dr) + hr[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f1(br,cr,dr) + hr[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sr[i]) ;\n\t                t = (t+er)|0;\n\t                ar = er;\n\t                er = dr;\n\t                dr = rotl(cr, 10);\n\t                cr = br;\n\t                br = t;\n\t            }\n\t            // Intermediate hash value\n\t            t    = (H[1] + cl + dr)|0;\n\t            H[1] = (H[2] + dl + er)|0;\n\t            H[2] = (H[3] + el + ar)|0;\n\t            H[3] = (H[4] + al + br)|0;\n\t            H[4] = (H[0] + bl + cr)|0;\n\t            H[0] =  t;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)\n\t            );\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 5; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                // Swap\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\n\t    function f1(x, y, z) {\n\t        return ((x) ^ (y) ^ (z));\n\n\t    }\n\n\t    function f2(x, y, z) {\n\t        return (((x)&(y)) | ((~x)&(z)));\n\t    }\n\n\t    function f3(x, y, z) {\n\t        return (((x) | (~(y))) ^ (z));\n\t    }\n\n\t    function f4(x, y, z) {\n\t        return (((x) & (z)) | ((y)&(~(z))));\n\t    }\n\n\t    function f5(x, y, z) {\n\t        return ((x) ^ ((y) |(~(z))));\n\n\t    }\n\n\t    function rotl(x,n) {\n\t        return (x<<n) | (x>>>(32-n));\n\t    }\n\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.RIPEMD160('message');\n\t     *     var hash = CryptoJS.RIPEMD160(wordArray);\n\t     */\n\t    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n\t     */\n\t    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);\n\t}(Math));\n\n\n\treturn CryptoJS.RIPEMD160;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-1 hash algorithm.\n\t     */\n\t    var SHA1 = C_algo.SHA1 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476,\n\t                0xc3d2e1f0\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\n\t            // Computation\n\t            for (var i = 0; i < 80; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t                    W[i] = (n << 1) | (n >>> 31);\n\t                }\n\n\t                var t = ((a << 5) | (a >>> 27)) + e + W[i];\n\t                if (i < 20) {\n\t                    t += ((b & c) | (~b & d)) + 0x5a827999;\n\t                } else if (i < 40) {\n\t                    t += (b ^ c ^ d) + 0x6ed9eba1;\n\t                } else if (i < 60) {\n\t                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n\t                } else /* if (i < 80) */ {\n\t                    t += (b ^ c ^ d) - 0x359d3e2a;\n\t                }\n\n\t                e = d;\n\t                d = c;\n\t                c = (b << 30) | (b >>> 2);\n\t                b = a;\n\t                a = t;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA1('message');\n\t     *     var hash = CryptoJS.SHA1(wordArray);\n\t     */\n\t    C.SHA1 = Hasher._createHelper(SHA1);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA1(message, key);\n\t     */\n\t    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t}());\n\n\n\treturn CryptoJS.SHA1;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./sha256\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./sha256\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\n\t    /**\n\t     * SHA-224 hash algorithm.\n\t     */\n\t    var SHA224 = C_algo.SHA224 = SHA256.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA256._doFinalize.call(this);\n\n\t            hash.sigBytes -= 4;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA224('message');\n\t     *     var hash = CryptoJS.SHA224(wordArray);\n\t     */\n\t    C.SHA224 = SHA256._createHelper(SHA224);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA224(message, key);\n\t     */\n\t    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);\n\t}());\n\n\n\treturn CryptoJS.SHA224;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./x64-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./x64-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var C_algo = C.algo;\n\n\t    // Constants tables\n\t    var RHO_OFFSETS = [];\n\t    var PI_INDEXES  = [];\n\t    var ROUND_CONSTANTS = [];\n\n\t    // Compute Constants\n\t    (function () {\n\t        // Compute rho offset constants\n\t        var x = 1, y = 0;\n\t        for (var t = 0; t < 24; t++) {\n\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t            var newX = y % 5;\n\t            var newY = (2 * x + 3 * y) % 5;\n\t            x = newX;\n\t            y = newY;\n\t        }\n\n\t        // Compute pi index constants\n\t        for (var x = 0; x < 5; x++) {\n\t            for (var y = 0; y < 5; y++) {\n\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t            }\n\t        }\n\n\t        // Compute round constants\n\t        var LFSR = 0x01;\n\t        for (var i = 0; i < 24; i++) {\n\t            var roundConstantMsw = 0;\n\t            var roundConstantLsw = 0;\n\n\t            for (var j = 0; j < 7; j++) {\n\t                if (LFSR & 0x01) {\n\t                    var bitPosition = (1 << j) - 1;\n\t                    if (bitPosition < 32) {\n\t                        roundConstantLsw ^= 1 << bitPosition;\n\t                    } else /* if (bitPosition >= 32) */ {\n\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t                    }\n\t                }\n\n\t                // Compute next LFSR\n\t                if (LFSR & 0x80) {\n\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t                } else {\n\t                    LFSR <<= 1;\n\t                }\n\t            }\n\n\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t        }\n\t    }());\n\n\t    // Reusable objects for temporary values\n\t    var T = [];\n\t    (function () {\n\t        for (var i = 0; i < 25; i++) {\n\t            T[i] = X64Word.create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-3 hash algorithm.\n\t     */\n\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} outputLength\n\t         *   The desired number of bits in the output hash.\n\t         *   Only values permitted are: 224, 256, 384, 512.\n\t         *   Default: 512\n\t         */\n\t        cfg: Hasher.cfg.extend({\n\t            outputLength: 512\n\t        }),\n\n\t        _doReset: function () {\n\t            var state = this._state = []\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = new X64Word.init();\n\t            }\n\n\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t            // Absorb\n\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t                // Shortcuts\n\t                var M2i  = M[offset + 2 * i];\n\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t                // Swap endian\n\t                M2i = (\n\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t                );\n\t                M2i1 = (\n\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Absorb message into state\n\t                var lane = state[i];\n\t                lane.high ^= M2i1;\n\t                lane.low  ^= M2i;\n\t            }\n\n\t            // Rounds\n\t            for (var round = 0; round < 24; round++) {\n\t                // Theta\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Mix column lanes\n\t                    var tMsw = 0, tLsw = 0;\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        tMsw ^= lane.high;\n\t                        tLsw ^= lane.low;\n\t                    }\n\n\t                    // Temporary values\n\t                    var Tx = T[x];\n\t                    Tx.high = tMsw;\n\t                    Tx.low  = tLsw;\n\t                }\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Shortcuts\n\t                    var Tx4 = T[(x + 4) % 5];\n\t                    var Tx1 = T[(x + 1) % 5];\n\t                    var Tx1Msw = Tx1.high;\n\t                    var Tx1Lsw = Tx1.low;\n\n\t                    // Mix surrounding columns\n\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        lane.high ^= tMsw;\n\t                        lane.low  ^= tLsw;\n\t                    }\n\t                }\n\n\t                // Rho Pi\n\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t                    var tMsw;\n\t                    var tLsw;\n\n\t                    // Shortcuts\n\t                    var lane = state[laneIndex];\n\t                    var laneMsw = lane.high;\n\t                    var laneLsw = lane.low;\n\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t                    // Rotate lanes\n\t                    if (rhoOffset < 32) {\n\t                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t                    } else /* if (rhoOffset >= 32) */ {\n\t                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t                    }\n\n\t                    // Transpose lanes\n\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t                    TPiLane.high = tMsw;\n\t                    TPiLane.low  = tLsw;\n\t                }\n\n\t                // Rho pi at x = y = 0\n\t                var T0 = T[0];\n\t                var state0 = state[0];\n\t                T0.high = state0.high;\n\t                T0.low  = state0.low;\n\n\t                // Chi\n\t                for (var x = 0; x < 5; x++) {\n\t                    for (var y = 0; y < 5; y++) {\n\t                        // Shortcuts\n\t                        var laneIndex = x + 5 * y;\n\t                        var lane = state[laneIndex];\n\t                        var TLane = T[laneIndex];\n\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t                        // Mix rows\n\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t                    }\n\t                }\n\n\t                // Iota\n\t                var lane = state[0];\n\t                var roundConstant = ROUND_CONSTANTS[round];\n\t                lane.high ^= roundConstant.high;\n\t                lane.low  ^= roundConstant.low;\n\t            }\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t            var blockSizeBits = this.blockSize * 32;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t            // Squeeze\n\t            var hashWords = [];\n\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t                // Shortcuts\n\t                var lane = state[i];\n\t                var laneMsw = lane.high;\n\t                var laneLsw = lane.low;\n\n\t                // Swap endian\n\t                laneMsw = (\n\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t                );\n\t                laneLsw = (\n\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Squeeze state to retrieve hash\n\t                hashWords.push(laneLsw);\n\t                hashWords.push(laneMsw);\n\t            }\n\n\t            // Return final computed hash\n\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\n\t            var state = clone._state = this._state.slice(0);\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = state[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA3('message');\n\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t     */\n\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t     */\n\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA3;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./x64-core\"), require(\"./sha512\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./x64-core\", \"./sha512\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA512 = C_algo.SHA512;\n\n\t    /**\n\t     * SHA-384 hash algorithm.\n\t     */\n\t    var SHA384 = C_algo.SHA384 = SHA512.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),\n\t                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),\n\t                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),\n\t                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA512._doFinalize.call(this);\n\n\t            hash.sigBytes -= 16;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA384('message');\n\t     *     var hash = CryptoJS.SHA384(wordArray);\n\t     */\n\t    C.SHA384 = SHA512._createHelper(SHA384);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA384(message, key);\n\t     */\n\t    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);\n\t}());\n\n\n\treturn CryptoJS.SHA384;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./x64-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./x64-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\n\t    function X64Word_create() {\n\t        return X64Word.create.apply(X64Word, arguments);\n\t    }\n\n\t    // Constants\n\t    var K = [\n\t        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),\n\t        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),\n\t        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),\n\t        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),\n\t        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),\n\t        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),\n\t        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),\n\t        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),\n\t        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),\n\t        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),\n\t        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),\n\t        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),\n\t        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),\n\t        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),\n\t        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),\n\t        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),\n\t        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),\n\t        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),\n\t        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),\n\t        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),\n\t        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),\n\t        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),\n\t        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),\n\t        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),\n\t        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),\n\t        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),\n\t        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),\n\t        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),\n\t        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),\n\t        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),\n\t        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),\n\t        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),\n\t        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),\n\t        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),\n\t        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),\n\t        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),\n\t        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),\n\t        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),\n\t        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),\n\t        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)\n\t    ];\n\n\t    // Reusable objects\n\t    var W = [];\n\t    (function () {\n\t        for (var i = 0; i < 80; i++) {\n\t            W[i] = X64Word_create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-512 hash algorithm.\n\t     */\n\t    var SHA512 = C_algo.SHA512 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),\n\t                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),\n\t                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),\n\t                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var H0 = H[0];\n\t            var H1 = H[1];\n\t            var H2 = H[2];\n\t            var H3 = H[3];\n\t            var H4 = H[4];\n\t            var H5 = H[5];\n\t            var H6 = H[6];\n\t            var H7 = H[7];\n\n\t            var H0h = H0.high;\n\t            var H0l = H0.low;\n\t            var H1h = H1.high;\n\t            var H1l = H1.low;\n\t            var H2h = H2.high;\n\t            var H2l = H2.low;\n\t            var H3h = H3.high;\n\t            var H3l = H3.low;\n\t            var H4h = H4.high;\n\t            var H4l = H4.low;\n\t            var H5h = H5.high;\n\t            var H5l = H5.low;\n\t            var H6h = H6.high;\n\t            var H6l = H6.low;\n\t            var H7h = H7.high;\n\t            var H7l = H7.low;\n\n\t            // Working variables\n\t            var ah = H0h;\n\t            var al = H0l;\n\t            var bh = H1h;\n\t            var bl = H1l;\n\t            var ch = H2h;\n\t            var cl = H2l;\n\t            var dh = H3h;\n\t            var dl = H3l;\n\t            var eh = H4h;\n\t            var el = H4l;\n\t            var fh = H5h;\n\t            var fl = H5l;\n\t            var gh = H6h;\n\t            var gl = H6l;\n\t            var hh = H7h;\n\t            var hl = H7l;\n\n\t            // Rounds\n\t            for (var i = 0; i < 80; i++) {\n\t                var Wil;\n\t                var Wih;\n\n\t                // Shortcut\n\t                var Wi = W[i];\n\n\t                // Extend message\n\t                if (i < 16) {\n\t                    Wih = Wi.high = M[offset + i * 2]     | 0;\n\t                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;\n\t                } else {\n\t                    // Gamma0\n\t                    var gamma0x  = W[i - 15];\n\t                    var gamma0xh = gamma0x.high;\n\t                    var gamma0xl = gamma0x.low;\n\t                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);\n\t                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n\n\t                    // Gamma1\n\t                    var gamma1x  = W[i - 2];\n\t                    var gamma1xh = gamma1x.high;\n\t                    var gamma1xl = gamma1x.low;\n\t                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\n\t                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n\n\t                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n\t                    var Wi7  = W[i - 7];\n\t                    var Wi7h = Wi7.high;\n\t                    var Wi7l = Wi7.low;\n\n\t                    var Wi16  = W[i - 16];\n\t                    var Wi16h = Wi16.high;\n\t                    var Wi16l = Wi16.low;\n\n\t                    Wil = gamma0l + Wi7l;\n\t                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + gamma1l;\n\t                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + Wi16l;\n\t                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n\n\t                    Wi.high = Wih;\n\t                    Wi.low  = Wil;\n\t                }\n\n\t                var chh  = (eh & fh) ^ (~eh & gh);\n\t                var chl  = (el & fl) ^ (~el & gl);\n\t                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n\t                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n\t                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n\t                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\t                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\n\t                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\n\n\t                // t1 = h + sigma1 + ch + K[i] + W[i]\n\t                var Ki  = K[i];\n\t                var Kih = Ki.high;\n\t                var Kil = Ki.low;\n\n\t                var t1l = hl + sigma1l;\n\t                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + chl;\n\t                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Kil;\n\t                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Wil;\n\t                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n\n\t                // t2 = sigma0 + maj\n\t                var t2l = sigma0l + majl;\n\t                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n\t                // Update working variables\n\t                hh = gh;\n\t                hl = gl;\n\t                gh = fh;\n\t                gl = fl;\n\t                fh = eh;\n\t                fl = el;\n\t                el = (dl + t1l) | 0;\n\t                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n\t                dh = ch;\n\t                dl = cl;\n\t                ch = bh;\n\t                cl = bl;\n\t                bh = ah;\n\t                bl = al;\n\t                al = (t1l + t2l) | 0;\n\t                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H0l = H0.low  = (H0l + al);\n\t            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\n\t            H1l = H1.low  = (H1l + bl);\n\t            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\n\t            H2l = H2.low  = (H2l + cl);\n\t            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\n\t            H3l = H3.low  = (H3l + dl);\n\t            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\n\t            H4l = H4.low  = (H4l + el);\n\t            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\n\t            H5l = H5.low  = (H5l + fl);\n\t            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\n\t            H6l = H6.low  = (H6l + gl);\n\t            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\n\t            H7l = H7.low  = (H7l + hl);\n\t            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Convert hash to 32-bit word array before returning\n\t            var hash = this._hash.toX32();\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        },\n\n\t        blockSize: 1024/32\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA512('message');\n\t     *     var hash = CryptoJS.SHA512(wordArray);\n\t     */\n\t    C.SHA512 = Hasher._createHelper(SHA512);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA512(message, key);\n\t     */\n\t    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);\n\t}());\n\n\n\treturn CryptoJS.SHA512;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./enc-base64\"), require(\"./md5\"), require(\"./evpkdf\"), require(\"./cipher-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./enc-base64\", \"./md5\", \"./evpkdf\", \"./cipher-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Permuted Choice 1 constants\n\t    var PC1 = [\n\t        57, 49, 41, 33, 25, 17, 9,  1,\n\t        58, 50, 42, 34, 26, 18, 10, 2,\n\t        59, 51, 43, 35, 27, 19, 11, 3,\n\t        60, 52, 44, 36, 63, 55, 47, 39,\n\t        31, 23, 15, 7,  62, 54, 46, 38,\n\t        30, 22, 14, 6,  61, 53, 45, 37,\n\t        29, 21, 13, 5,  28, 20, 12, 4\n\t    ];\n\n\t    // Permuted Choice 2 constants\n\t    var PC2 = [\n\t        14, 17, 11, 24, 1,  5,\n\t        3,  28, 15, 6,  21, 10,\n\t        23, 19, 12, 4,  26, 8,\n\t        16, 7,  27, 20, 13, 2,\n\t        41, 52, 31, 37, 47, 55,\n\t        30, 40, 51, 45, 33, 48,\n\t        44, 49, 39, 56, 34, 53,\n\t        46, 42, 50, 36, 29, 32\n\t    ];\n\n\t    // Cumulative bit shift constants\n\t    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n\t    // SBOXes and round permutation constants\n\t    var SBOX_P = [\n\t        {\n\t            0x0: 0x808200,\n\t            0x10000000: 0x8000,\n\t            0x20000000: 0x808002,\n\t            0x30000000: 0x2,\n\t            0x40000000: 0x200,\n\t            0x50000000: 0x808202,\n\t            0x60000000: 0x800202,\n\t            0x70000000: 0x800000,\n\t            0x80000000: 0x202,\n\t            0x90000000: 0x800200,\n\t            0xa0000000: 0x8200,\n\t            0xb0000000: 0x808000,\n\t            0xc0000000: 0x8002,\n\t            0xd0000000: 0x800002,\n\t            0xe0000000: 0x0,\n\t            0xf0000000: 0x8202,\n\t            0x8000000: 0x0,\n\t            0x18000000: 0x808202,\n\t            0x28000000: 0x8202,\n\t            0x38000000: 0x8000,\n\t            0x48000000: 0x808200,\n\t            0x58000000: 0x200,\n\t            0x68000000: 0x808002,\n\t            0x78000000: 0x2,\n\t            0x88000000: 0x800200,\n\t            0x98000000: 0x8200,\n\t            0xa8000000: 0x808000,\n\t            0xb8000000: 0x800202,\n\t            0xc8000000: 0x800002,\n\t            0xd8000000: 0x8002,\n\t            0xe8000000: 0x202,\n\t            0xf8000000: 0x800000,\n\t            0x1: 0x8000,\n\t            0x10000001: 0x2,\n\t            0x20000001: 0x808200,\n\t            0x30000001: 0x800000,\n\t            0x40000001: 0x808002,\n\t            0x50000001: 0x8200,\n\t            0x60000001: 0x200,\n\t            0x70000001: 0x800202,\n\t            0x80000001: 0x808202,\n\t            0x90000001: 0x808000,\n\t            0xa0000001: 0x800002,\n\t            0xb0000001: 0x8202,\n\t            0xc0000001: 0x202,\n\t            0xd0000001: 0x800200,\n\t            0xe0000001: 0x8002,\n\t            0xf0000001: 0x0,\n\t            0x8000001: 0x808202,\n\t            0x18000001: 0x808000,\n\t            0x28000001: 0x800000,\n\t            0x38000001: 0x200,\n\t            0x48000001: 0x8000,\n\t            0x58000001: 0x800002,\n\t            0x68000001: 0x2,\n\t            0x78000001: 0x8202,\n\t            0x88000001: 0x8002,\n\t            0x98000001: 0x800202,\n\t            0xa8000001: 0x202,\n\t            0xb8000001: 0x808200,\n\t            0xc8000001: 0x800200,\n\t            0xd8000001: 0x0,\n\t            0xe8000001: 0x8200,\n\t            0xf8000001: 0x808002\n\t        },\n\t        {\n\t            0x0: 0x40084010,\n\t            0x1000000: 0x4000,\n\t            0x2000000: 0x80000,\n\t            0x3000000: 0x40080010,\n\t            0x4000000: 0x40000010,\n\t            0x5000000: 0x40084000,\n\t            0x6000000: 0x40004000,\n\t            0x7000000: 0x10,\n\t            0x8000000: 0x84000,\n\t            0x9000000: 0x40004010,\n\t            0xa000000: 0x40000000,\n\t            0xb000000: 0x84010,\n\t            0xc000000: 0x80010,\n\t            0xd000000: 0x0,\n\t            0xe000000: 0x4010,\n\t            0xf000000: 0x40080000,\n\t            0x800000: 0x40004000,\n\t            0x1800000: 0x84010,\n\t            0x2800000: 0x10,\n\t            0x3800000: 0x40004010,\n\t            0x4800000: 0x40084010,\n\t            0x5800000: 0x40000000,\n\t            0x6800000: 0x80000,\n\t            0x7800000: 0x40080010,\n\t            0x8800000: 0x80010,\n\t            0x9800000: 0x0,\n\t            0xa800000: 0x4000,\n\t            0xb800000: 0x40080000,\n\t            0xc800000: 0x40000010,\n\t            0xd800000: 0x84000,\n\t            0xe800000: 0x40084000,\n\t            0xf800000: 0x4010,\n\t            0x10000000: 0x0,\n\t            0x11000000: 0x40080010,\n\t            0x12000000: 0x40004010,\n\t            0x13000000: 0x40084000,\n\t            0x14000000: 0x40080000,\n\t            0x15000000: 0x10,\n\t            0x16000000: 0x84010,\n\t            0x17000000: 0x4000,\n\t            0x18000000: 0x4010,\n\t            0x19000000: 0x80000,\n\t            0x1a000000: 0x80010,\n\t            0x1b000000: 0x40000010,\n\t            0x1c000000: 0x84000,\n\t            0x1d000000: 0x40004000,\n\t            0x1e000000: 0x40000000,\n\t            0x1f000000: 0x40084010,\n\t            0x10800000: 0x84010,\n\t            0x11800000: 0x80000,\n\t            0x12800000: 0x40080000,\n\t            0x13800000: 0x4000,\n\t            0x14800000: 0x40004000,\n\t            0x15800000: 0x40084010,\n\t            0x16800000: 0x10,\n\t            0x17800000: 0x40000000,\n\t            0x18800000: 0x40084000,\n\t            0x19800000: 0x40000010,\n\t            0x1a800000: 0x40004010,\n\t            0x1b800000: 0x80010,\n\t            0x1c800000: 0x0,\n\t            0x1d800000: 0x4010,\n\t            0x1e800000: 0x40080010,\n\t            0x1f800000: 0x84000\n\t        },\n\t        {\n\t            0x0: 0x104,\n\t            0x100000: 0x0,\n\t            0x200000: 0x4000100,\n\t            0x300000: 0x10104,\n\t            0x400000: 0x10004,\n\t            0x500000: 0x4000004,\n\t            0x600000: 0x4010104,\n\t            0x700000: 0x4010000,\n\t            0x800000: 0x4000000,\n\t            0x900000: 0x4010100,\n\t            0xa00000: 0x10100,\n\t            0xb00000: 0x4010004,\n\t            0xc00000: 0x4000104,\n\t            0xd00000: 0x10000,\n\t            0xe00000: 0x4,\n\t            0xf00000: 0x100,\n\t            0x80000: 0x4010100,\n\t            0x180000: 0x4010004,\n\t            0x280000: 0x0,\n\t            0x380000: 0x4000100,\n\t            0x480000: 0x4000004,\n\t            0x580000: 0x10000,\n\t            0x680000: 0x10004,\n\t            0x780000: 0x104,\n\t            0x880000: 0x4,\n\t            0x980000: 0x100,\n\t            0xa80000: 0x4010000,\n\t            0xb80000: 0x10104,\n\t            0xc80000: 0x10100,\n\t            0xd80000: 0x4000104,\n\t            0xe80000: 0x4010104,\n\t            0xf80000: 0x4000000,\n\t            0x1000000: 0x4010100,\n\t            0x1100000: 0x10004,\n\t            0x1200000: 0x10000,\n\t            0x1300000: 0x4000100,\n\t            0x1400000: 0x100,\n\t            0x1500000: 0x4010104,\n\t            0x1600000: 0x4000004,\n\t            0x1700000: 0x0,\n\t            0x1800000: 0x4000104,\n\t            0x1900000: 0x4000000,\n\t            0x1a00000: 0x4,\n\t            0x1b00000: 0x10100,\n\t            0x1c00000: 0x4010000,\n\t            0x1d00000: 0x104,\n\t            0x1e00000: 0x10104,\n\t            0x1f00000: 0x4010004,\n\t            0x1080000: 0x4000000,\n\t            0x1180000: 0x104,\n\t            0x1280000: 0x4010100,\n\t            0x1380000: 0x0,\n\t            0x1480000: 0x10004,\n\t            0x1580000: 0x4000100,\n\t            0x1680000: 0x100,\n\t            0x1780000: 0x4010004,\n\t            0x1880000: 0x10000,\n\t            0x1980000: 0x4010104,\n\t            0x1a80000: 0x10104,\n\t            0x1b80000: 0x4000004,\n\t            0x1c80000: 0x4000104,\n\t            0x1d80000: 0x4010000,\n\t            0x1e80000: 0x4,\n\t            0x1f80000: 0x10100\n\t        },\n\t        {\n\t            0x0: 0x80401000,\n\t            0x10000: 0x80001040,\n\t            0x20000: 0x401040,\n\t            0x30000: 0x80400000,\n\t            0x40000: 0x0,\n\t            0x50000: 0x401000,\n\t            0x60000: 0x80000040,\n\t            0x70000: 0x400040,\n\t            0x80000: 0x80000000,\n\t            0x90000: 0x400000,\n\t            0xa0000: 0x40,\n\t            0xb0000: 0x80001000,\n\t            0xc0000: 0x80400040,\n\t            0xd0000: 0x1040,\n\t            0xe0000: 0x1000,\n\t            0xf0000: 0x80401040,\n\t            0x8000: 0x80001040,\n\t            0x18000: 0x40,\n\t            0x28000: 0x80400040,\n\t            0x38000: 0x80001000,\n\t            0x48000: 0x401000,\n\t            0x58000: 0x80401040,\n\t            0x68000: 0x0,\n\t            0x78000: 0x80400000,\n\t            0x88000: 0x1000,\n\t            0x98000: 0x80401000,\n\t            0xa8000: 0x400000,\n\t            0xb8000: 0x1040,\n\t            0xc8000: 0x80000000,\n\t            0xd8000: 0x400040,\n\t            0xe8000: 0x401040,\n\t            0xf8000: 0x80000040,\n\t            0x100000: 0x400040,\n\t            0x110000: 0x401000,\n\t            0x120000: 0x80000040,\n\t            0x130000: 0x0,\n\t            0x140000: 0x1040,\n\t            0x150000: 0x80400040,\n\t            0x160000: 0x80401000,\n\t            0x170000: 0x80001040,\n\t            0x180000: 0x80401040,\n\t            0x190000: 0x80000000,\n\t            0x1a0000: 0x80400000,\n\t            0x1b0000: 0x401040,\n\t            0x1c0000: 0x80001000,\n\t            0x1d0000: 0x400000,\n\t            0x1e0000: 0x40,\n\t            0x1f0000: 0x1000,\n\t            0x108000: 0x80400000,\n\t            0x118000: 0x80401040,\n\t            0x128000: 0x0,\n\t            0x138000: 0x401000,\n\t            0x148000: 0x400040,\n\t            0x158000: 0x80000000,\n\t            0x168000: 0x80001040,\n\t            0x178000: 0x40,\n\t            0x188000: 0x80000040,\n\t            0x198000: 0x1000,\n\t            0x1a8000: 0x80001000,\n\t            0x1b8000: 0x80400040,\n\t            0x1c8000: 0x1040,\n\t            0x1d8000: 0x80401000,\n\t            0x1e8000: 0x400000,\n\t            0x1f8000: 0x401040\n\t        },\n\t        {\n\t            0x0: 0x80,\n\t            0x1000: 0x1040000,\n\t            0x2000: 0x40000,\n\t            0x3000: 0x20000000,\n\t            0x4000: 0x20040080,\n\t            0x5000: 0x1000080,\n\t            0x6000: 0x21000080,\n\t            0x7000: 0x40080,\n\t            0x8000: 0x1000000,\n\t            0x9000: 0x20040000,\n\t            0xa000: 0x20000080,\n\t            0xb000: 0x21040080,\n\t            0xc000: 0x21040000,\n\t            0xd000: 0x0,\n\t            0xe000: 0x1040080,\n\t            0xf000: 0x21000000,\n\t            0x800: 0x1040080,\n\t            0x1800: 0x21000080,\n\t            0x2800: 0x80,\n\t            0x3800: 0x1040000,\n\t            0x4800: 0x40000,\n\t            0x5800: 0x20040080,\n\t            0x6800: 0x21040000,\n\t            0x7800: 0x20000000,\n\t            0x8800: 0x20040000,\n\t            0x9800: 0x0,\n\t            0xa800: 0x21040080,\n\t            0xb800: 0x1000080,\n\t            0xc800: 0x20000080,\n\t            0xd800: 0x21000000,\n\t            0xe800: 0x1000000,\n\t            0xf800: 0x40080,\n\t            0x10000: 0x40000,\n\t            0x11000: 0x80,\n\t            0x12000: 0x20000000,\n\t            0x13000: 0x21000080,\n\t            0x14000: 0x1000080,\n\t            0x15000: 0x21040000,\n\t            0x16000: 0x20040080,\n\t            0x17000: 0x1000000,\n\t            0x18000: 0x21040080,\n\t            0x19000: 0x21000000,\n\t            0x1a000: 0x1040000,\n\t            0x1b000: 0x20040000,\n\t            0x1c000: 0x40080,\n\t            0x1d000: 0x20000080,\n\t            0x1e000: 0x0,\n\t            0x1f000: 0x1040080,\n\t            0x10800: 0x21000080,\n\t            0x11800: 0x1000000,\n\t            0x12800: 0x1040000,\n\t            0x13800: 0x20040080,\n\t            0x14800: 0x20000000,\n\t            0x15800: 0x1040080,\n\t            0x16800: 0x80,\n\t            0x17800: 0x21040000,\n\t            0x18800: 0x40080,\n\t            0x19800: 0x21040080,\n\t            0x1a800: 0x0,\n\t            0x1b800: 0x21000000,\n\t            0x1c800: 0x1000080,\n\t            0x1d800: 0x40000,\n\t            0x1e800: 0x20040000,\n\t            0x1f800: 0x20000080\n\t        },\n\t        {\n\t            0x0: 0x10000008,\n\t            0x100: 0x2000,\n\t            0x200: 0x10200000,\n\t            0x300: 0x10202008,\n\t            0x400: 0x10002000,\n\t            0x500: 0x200000,\n\t            0x600: 0x200008,\n\t            0x700: 0x10000000,\n\t            0x800: 0x0,\n\t            0x900: 0x10002008,\n\t            0xa00: 0x202000,\n\t            0xb00: 0x8,\n\t            0xc00: 0x10200008,\n\t            0xd00: 0x202008,\n\t            0xe00: 0x2008,\n\t            0xf00: 0x10202000,\n\t            0x80: 0x10200000,\n\t            0x180: 0x10202008,\n\t            0x280: 0x8,\n\t            0x380: 0x200000,\n\t            0x480: 0x202008,\n\t            0x580: 0x10000008,\n\t            0x680: 0x10002000,\n\t            0x780: 0x2008,\n\t            0x880: 0x200008,\n\t            0x980: 0x2000,\n\t            0xa80: 0x10002008,\n\t            0xb80: 0x10200008,\n\t            0xc80: 0x0,\n\t            0xd80: 0x10202000,\n\t            0xe80: 0x202000,\n\t            0xf80: 0x10000000,\n\t            0x1000: 0x10002000,\n\t            0x1100: 0x10200008,\n\t            0x1200: 0x10202008,\n\t            0x1300: 0x2008,\n\t            0x1400: 0x200000,\n\t            0x1500: 0x10000000,\n\t            0x1600: 0x10000008,\n\t            0x1700: 0x202000,\n\t            0x1800: 0x202008,\n\t            0x1900: 0x0,\n\t            0x1a00: 0x8,\n\t            0x1b00: 0x10200000,\n\t            0x1c00: 0x2000,\n\t            0x1d00: 0x10002008,\n\t            0x1e00: 0x10202000,\n\t            0x1f00: 0x200008,\n\t            0x1080: 0x8,\n\t            0x1180: 0x202000,\n\t            0x1280: 0x200000,\n\t            0x1380: 0x10000008,\n\t            0x1480: 0x10002000,\n\t            0x1580: 0x2008,\n\t            0x1680: 0x10202008,\n\t            0x1780: 0x10200000,\n\t            0x1880: 0x10202000,\n\t            0x1980: 0x10200008,\n\t            0x1a80: 0x2000,\n\t            0x1b80: 0x202008,\n\t            0x1c80: 0x200008,\n\t            0x1d80: 0x0,\n\t            0x1e80: 0x10000000,\n\t            0x1f80: 0x10002008\n\t        },\n\t        {\n\t            0x0: 0x100000,\n\t            0x10: 0x2000401,\n\t            0x20: 0x400,\n\t            0x30: 0x100401,\n\t            0x40: 0x2100401,\n\t            0x50: 0x0,\n\t            0x60: 0x1,\n\t            0x70: 0x2100001,\n\t            0x80: 0x2000400,\n\t            0x90: 0x100001,\n\t            0xa0: 0x2000001,\n\t            0xb0: 0x2100400,\n\t            0xc0: 0x2100000,\n\t            0xd0: 0x401,\n\t            0xe0: 0x100400,\n\t            0xf0: 0x2000000,\n\t            0x8: 0x2100001,\n\t            0x18: 0x0,\n\t            0x28: 0x2000401,\n\t            0x38: 0x2100400,\n\t            0x48: 0x100000,\n\t            0x58: 0x2000001,\n\t            0x68: 0x2000000,\n\t            0x78: 0x401,\n\t            0x88: 0x100401,\n\t            0x98: 0x2000400,\n\t            0xa8: 0x2100000,\n\t            0xb8: 0x100001,\n\t            0xc8: 0x400,\n\t            0xd8: 0x2100401,\n\t            0xe8: 0x1,\n\t            0xf8: 0x100400,\n\t            0x100: 0x2000000,\n\t            0x110: 0x100000,\n\t            0x120: 0x2000401,\n\t            0x130: 0x2100001,\n\t            0x140: 0x100001,\n\t            0x150: 0x2000400,\n\t            0x160: 0x2100400,\n\t            0x170: 0x100401,\n\t            0x180: 0x401,\n\t            0x190: 0x2100401,\n\t            0x1a0: 0x100400,\n\t            0x1b0: 0x1,\n\t            0x1c0: 0x0,\n\t            0x1d0: 0x2100000,\n\t            0x1e0: 0x2000001,\n\t            0x1f0: 0x400,\n\t            0x108: 0x100400,\n\t            0x118: 0x2000401,\n\t            0x128: 0x2100001,\n\t            0x138: 0x1,\n\t            0x148: 0x2000000,\n\t            0x158: 0x100000,\n\t            0x168: 0x401,\n\t            0x178: 0x2100400,\n\t            0x188: 0x2000001,\n\t            0x198: 0x2100000,\n\t            0x1a8: 0x0,\n\t            0x1b8: 0x2100401,\n\t            0x1c8: 0x100401,\n\t            0x1d8: 0x400,\n\t            0x1e8: 0x2000400,\n\t            0x1f8: 0x100001\n\t        },\n\t        {\n\t            0x0: 0x8000820,\n\t            0x1: 0x20000,\n\t            0x2: 0x8000000,\n\t            0x3: 0x20,\n\t            0x4: 0x20020,\n\t            0x5: 0x8020820,\n\t            0x6: 0x8020800,\n\t            0x7: 0x800,\n\t            0x8: 0x8020000,\n\t            0x9: 0x8000800,\n\t            0xa: 0x20800,\n\t            0xb: 0x8020020,\n\t            0xc: 0x820,\n\t            0xd: 0x0,\n\t            0xe: 0x8000020,\n\t            0xf: 0x20820,\n\t            0x80000000: 0x800,\n\t            0x80000001: 0x8020820,\n\t            0x80000002: 0x8000820,\n\t            0x80000003: 0x8000000,\n\t            0x80000004: 0x8020000,\n\t            0x80000005: 0x20800,\n\t            0x80000006: 0x20820,\n\t            0x80000007: 0x20,\n\t            0x80000008: 0x8000020,\n\t            0x80000009: 0x820,\n\t            0x8000000a: 0x20020,\n\t            0x8000000b: 0x8020800,\n\t            0x8000000c: 0x0,\n\t            0x8000000d: 0x8020020,\n\t            0x8000000e: 0x8000800,\n\t            0x8000000f: 0x20000,\n\t            0x10: 0x20820,\n\t            0x11: 0x8020800,\n\t            0x12: 0x20,\n\t            0x13: 0x800,\n\t            0x14: 0x8000800,\n\t            0x15: 0x8000020,\n\t            0x16: 0x8020020,\n\t            0x17: 0x20000,\n\t            0x18: 0x0,\n\t            0x19: 0x20020,\n\t            0x1a: 0x8020000,\n\t            0x1b: 0x8000820,\n\t            0x1c: 0x8020820,\n\t            0x1d: 0x20800,\n\t            0x1e: 0x820,\n\t            0x1f: 0x8000000,\n\t            0x80000010: 0x20000,\n\t            0x80000011: 0x800,\n\t            0x80000012: 0x8020020,\n\t            0x80000013: 0x20820,\n\t            0x80000014: 0x20,\n\t            0x80000015: 0x8020000,\n\t            0x80000016: 0x8000000,\n\t            0x80000017: 0x8000820,\n\t            0x80000018: 0x8020820,\n\t            0x80000019: 0x8000020,\n\t            0x8000001a: 0x8000800,\n\t            0x8000001b: 0x0,\n\t            0x8000001c: 0x20800,\n\t            0x8000001d: 0x820,\n\t            0x8000001e: 0x20020,\n\t            0x8000001f: 0x8020800\n\t        }\n\t    ];\n\n\t    // Masks that select the SBOX input\n\t    var SBOX_MASK = [\n\t        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\n\t        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f\n\t    ];\n\n\t    /**\n\t     * DES block cipher algorithm.\n\t     */\n\t    var DES = C_algo.DES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\n\t            // Select 56 bits according to PC1\n\t            var keyBits = [];\n\t            for (var i = 0; i < 56; i++) {\n\t                var keyBitPos = PC1[i] - 1;\n\t                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;\n\t            }\n\n\t            // Assemble 16 subkeys\n\t            var subKeys = this._subKeys = [];\n\t            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {\n\t                // Create subkey\n\t                var subKey = subKeys[nSubKey] = [];\n\n\t                // Shortcut\n\t                var bitShift = BIT_SHIFTS[nSubKey];\n\n\t                // Select 48 bits according to PC2\n\t                for (var i = 0; i < 24; i++) {\n\t                    // Select from the left 28 key bits\n\t                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);\n\n\t                    // Select from the right 28 key bits\n\t                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);\n\t                }\n\n\t                // Since each subkey is applied to an expanded 32-bit input,\n\t                // the subkey can be broken into 8 values scaled to 32-bits,\n\t                // which allows the key to be used without expansion\n\t                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\n\t                for (var i = 1; i < 7; i++) {\n\t                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);\n\t                }\n\t                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\n\t            }\n\n\t            // Compute inverse subkeys\n\t            var invSubKeys = this._invSubKeys = [];\n\t            for (var i = 0; i < 16; i++) {\n\t                invSubKeys[i] = subKeys[15 - i];\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._subKeys);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._invSubKeys);\n\t        },\n\n\t        _doCryptBlock: function (M, offset, subKeys) {\n\t            // Get input\n\t            this._lBlock = M[offset];\n\t            this._rBlock = M[offset + 1];\n\n\t            // Initial permutation\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeLR.call(this, 1,  0x55555555);\n\n\t            // Rounds\n\t            for (var round = 0; round < 16; round++) {\n\t                // Shortcuts\n\t                var subKey = subKeys[round];\n\t                var lBlock = this._lBlock;\n\t                var rBlock = this._rBlock;\n\n\t                // Feistel function\n\t                var f = 0;\n\t                for (var i = 0; i < 8; i++) {\n\t                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n\t                }\n\t                this._lBlock = rBlock;\n\t                this._rBlock = lBlock ^ f;\n\t            }\n\n\t            // Undo swap from last round\n\t            var t = this._lBlock;\n\t            this._lBlock = this._rBlock;\n\t            this._rBlock = t;\n\n\t            // Final permutation\n\t            exchangeLR.call(this, 1,  0x55555555);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\n\t            // Set output\n\t            M[offset] = this._lBlock;\n\t            M[offset + 1] = this._rBlock;\n\t        },\n\n\t        keySize: 64/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    // Swap bits across the left and right words\n\t    function exchangeLR(offset, mask) {\n\t        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\n\t        this._rBlock ^= t;\n\t        this._lBlock ^= t << offset;\n\t    }\n\n\t    function exchangeRL(offset, mask) {\n\t        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\n\t        this._lBlock ^= t;\n\t        this._rBlock ^= t << offset;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.DES = BlockCipher._createHelper(DES);\n\n\t    /**\n\t     * Triple-DES block cipher algorithm.\n\t     */\n\t    var TripleDES = C_algo.TripleDES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            // Make sure the key length is valid (64, 128 or >= 192 bit)\n\t            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {\n\t                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');\n\t            }\n\n\t            // Extend the key according to the keying options defined in 3DES standard\n\t            var key1 = keyWords.slice(0, 2);\n\t            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);\n\t            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);\n\n\t            // Create DES instances\n\t            this._des1 = DES.createEncryptor(WordArray.create(key1));\n\t            this._des2 = DES.createEncryptor(WordArray.create(key2));\n\t            this._des3 = DES.createEncryptor(WordArray.create(key3));\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._des1.encryptBlock(M, offset);\n\t            this._des2.decryptBlock(M, offset);\n\t            this._des3.encryptBlock(M, offset);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._des3.decryptBlock(M, offset);\n\t            this._des2.encryptBlock(M, offset);\n\t            this._des1.decryptBlock(M, offset);\n\t        },\n\n\t        keySize: 192/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.TripleDES = BlockCipher._createHelper(TripleDES);\n\t}());\n\n\n\treturn CryptoJS.TripleDES;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var X32WordArray = C_lib.WordArray;\n\n\t    /**\n\t     * x64 namespace.\n\t     */\n\t    var C_x64 = C.x64 = {};\n\n\t    /**\n\t     * A 64-bit word.\n\t     */\n\t    var X64Word = C_x64.Word = Base.extend({\n\t        /**\n\t         * Initializes a newly created 64-bit word.\n\t         *\n\t         * @param {number} high The high 32 bits.\n\t         * @param {number} low The low 32 bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n\t         */\n\t        init: function (high, low) {\n\t            this.high = high;\n\t            this.low = low;\n\t        }\n\n\t        /**\n\t         * Bitwise NOTs this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after negating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var negated = x64Word.not();\n\t         */\n\t        // not: function () {\n\t            // var high = ~this.high;\n\t            // var low = ~this.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ANDs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to AND with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ANDing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var anded = x64Word.and(anotherX64Word);\n\t         */\n\t        // and: function (word) {\n\t            // var high = this.high & word.high;\n\t            // var low = this.low & word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to OR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var ored = x64Word.or(anotherX64Word);\n\t         */\n\t        // or: function (word) {\n\t            // var high = this.high | word.high;\n\t            // var low = this.low | word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise XORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to XOR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after XORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var xored = x64Word.xor(anotherX64Word);\n\t         */\n\t        // xor: function (word) {\n\t            // var high = this.high ^ word.high;\n\t            // var low = this.low ^ word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftL(25);\n\t         */\n\t        // shiftL: function (n) {\n\t            // if (n < 32) {\n\t                // var high = (this.high << n) | (this.low >>> (32 - n));\n\t                // var low = this.low << n;\n\t            // } else {\n\t                // var high = this.low << (n - 32);\n\t                // var low = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftR(7);\n\t         */\n\t        // shiftR: function (n) {\n\t            // if (n < 32) {\n\t                // var low = (this.low >>> n) | (this.high << (32 - n));\n\t                // var high = this.high >>> n;\n\t            // } else {\n\t                // var low = this.high >>> (n - 32);\n\t                // var high = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotL(25);\n\t         */\n\t        // rotL: function (n) {\n\t            // return this.shiftL(n).or(this.shiftR(64 - n));\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotR(7);\n\t         */\n\t        // rotR: function (n) {\n\t            // return this.shiftR(n).or(this.shiftL(64 - n));\n\t        // },\n\n\t        /**\n\t         * Adds this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to add with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after adding.\n\t         *\n\t         * @example\n\t         *\n\t         *     var added = x64Word.add(anotherX64Word);\n\t         */\n\t        // add: function (word) {\n\t            // var low = (this.low + word.low) | 0;\n\t            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;\n\t            // var high = (this.high + word.high + carry) | 0;\n\n\t            // return X64Word.create(high, low);\n\t        // }\n\t    });\n\n\t    /**\n\t     * An array of 64-bit words.\n\t     *\n\t     * @property {Array} words The array of CryptoJS.x64.Word objects.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var X64WordArray = C_x64.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create();\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ]);\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ], 10);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 8;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this 64-bit word array to a 32-bit word array.\n\t         *\n\t         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x32WordArray = x64WordArray.toX32();\n\t         */\n\t        toX32: function () {\n\t            // Shortcuts\n\t            var x64Words = this.words;\n\t            var x64WordsLength = x64Words.length;\n\n\t            // Convert\n\t            var x32Words = [];\n\t            for (var i = 0; i < x64WordsLength; i++) {\n\t                var x64Word = x64Words[i];\n\t                x32Words.push(x64Word.high);\n\t                x32Words.push(x64Word.low);\n\t            }\n\n\t            return X32WordArray.create(x32Words, this.sigBytes);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {X64WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = x64WordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\n\t            // Clone \"words\" array\n\t            var words = clone.words = this.words.slice(0);\n\n\t            // Clone each X64Word object\n\t            var wordsLength = words.length;\n\t            for (var i = 0; i < wordsLength; i++) {\n\t                words[i] = words[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\t}());\n\n\n\treturn CryptoJS;\n\n}));","// Top level file is just a mixin of submodules & constants\n'use strict';\n\nconst { Deflate, deflate, deflateRaw, gzip } = require('./lib/deflate');\n\nconst { Inflate, inflate, inflateRaw, ungzip } = require('./lib/inflate');\n\nconst constants = require('./lib/zlib/constants');\n\nmodule.exports.Deflate = Deflate;\nmodule.exports.deflate = deflate;\nmodule.exports.deflateRaw = deflateRaw;\nmodule.exports.gzip = gzip;\nmodule.exports.Inflate = Inflate;\nmodule.exports.inflate = inflate;\nmodule.exports.inflateRaw = inflateRaw;\nmodule.exports.ungzip = ungzip;\nmodule.exports.constants = constants;\n","'use strict';\n\n\nconst zlib_deflate = require('./zlib/deflate');\nconst utils        = require('./utils/common');\nconst strings      = require('./utils/strings');\nconst msg          = require('./zlib/messages');\nconst ZStream      = require('./zlib/zstream');\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED\n} = require('./zlib/constants');\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  let status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = zlib_deflate.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = zlib_deflate.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    this.result = utils.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  const deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nmodule.exports.Deflate = Deflate;\nmodule.exports.deflate = deflate;\nmodule.exports.deflateRaw = deflateRaw;\nmodule.exports.gzip = gzip;\nmodule.exports.constants = require('./zlib/constants');\n","'use strict';\n\n\nconst zlib_inflate = require('./zlib/inflate');\nconst utils        = require('./utils/common');\nconst strings      = require('./utils/strings');\nconst msg          = require('./zlib/messages');\nconst ZStream      = require('./zlib/zstream');\nconst GZheader     = require('./zlib/gzheader');\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n} = require('./zlib/constants');\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  this.options = utils.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  let status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK) {\n        status = zlib_inflate.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      zlib_inflate.inflateReset(strm);\n      status = zlib_inflate.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END) {\n      status = zlib_inflate.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err) {\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  const inflator = new Inflate(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || msg[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nmodule.exports.Inflate = Inflate;\nmodule.exports.inflate = inflate;\nmodule.exports.inflateRaw = inflateRaw;\nmodule.exports.ungzip = inflate;\nmodule.exports.constants = require('./zlib/constants');\n","'use strict';\n\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nmodule.exports.assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nmodule.exports.flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n","// String encode/decode helpers\n'use strict';\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nmodule.exports.string2buf = (str) => {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nmodule.exports.buf2string = (buf, max) => {\n  const len = max || buf.length;\n\n  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n\n  let i, out;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nmodule.exports.utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require('./trees');\nconst adler32 = require('./adler32');\nconst crc32   = require('./crc32');\nconst msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,\n  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,\n  Z_DEFAULT_COMPRESSION,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,\n  Z_UNKNOWN,\n  Z_DEFLATED\n} = require('./constants');\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE = 42;\nconst EXTRA_STATE = 69;\nconst NAME_STATE = 73;\nconst COMMENT_STATE = 91;\nconst HCRC_STATE = 103;\nconst BUSY_STATE = 113;\nconst FINISH_STATE = 666;\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = msg[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  let max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    const max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n};\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  _tr_init(s);\n  return Z_OK;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n};\n\n\nconst deflate = (strm, flush) => {\n\n  let beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      let level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  const status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n};\n\n\nmodule.exports.deflateInit = deflateInit;\nmodule.exports.deflateInit2 = deflateInit2;\nmodule.exports.deflateReset = deflateReset;\nmodule.exports.deflateResetKeep = deflateResetKeep;\nmodule.exports.deflateSetHeader = deflateSetHeader;\nmodule.exports.deflate = deflate;\nmodule.exports.deflateEnd = deflateEnd;\nmodule.exports.deflateSetDictionary = deflateSetDictionary;\nmodule.exports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD = 30;       /* got a data error -- remain here until reset */\nconst TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32       = require('./adler32');\nconst crc32         = require('./crc32');\nconst inflate_fast  = require('./inffast');\nconst inflate_table = require('./inftrees');\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH, Z_BLOCK, Z_TREES,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR,\n  Z_DEFLATED\n} = require('./constants');\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 1;       /* i: waiting for magic header */\nconst    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 3;       /* i: waiting for modification time (gzip) */\nconst    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 7;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 9;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 10;    /* i: waiting for dictionary check value */\nconst    DICT = 11;      /* waiting for inflateSetDictionary() call */\nconst        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 14;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 18;   /* i: waiting for code length code lengths */\nconst        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nconst            LEN = 21;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 22;    /* i: waiting for length extra bits */\nconst            DIST = 23;      /* i: waiting for distance code */\nconst            DISTEXT = 24;   /* i: waiting for distance extra bits */\nconst            MATCH = 25;     /* o: waiting for output space to copy string */\nconst            LIT = 26;       /* o: waiting for output space to write literal */\nconst    CHECK = 27;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 29;      /* finished check, done -- remain here until reset */\nconst    BAD = 30;       /* got a data error -- remain here until reset */\nconst    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n};\n\n\nmodule.exports.inflateReset = inflateReset;\nmodule.exports.inflateReset2 = inflateReset2;\nmodule.exports.inflateResetKeep = inflateResetKeep;\nmodule.exports.inflateInit = inflateInit;\nmodule.exports.inflateInit2 = inflateInit2;\nmodule.exports.inflate = inflate;\nmodule.exports.inflateEnd = inflateEnd;\nmodule.exports.inflateGetHeader = inflateGetHeader;\nmodule.exports.inflateSetDictionary = inflateSetDictionary;\nmodule.exports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n  let base_index = 0;\n//  let shoextra;    /* extra bits table to use */\n  let end;                    /* use base and extra for symbol > end */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n  let extra_index = 0;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nmodule.exports = inflate_table;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH    = 3;\nconst MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES       = 30;\n/* number of distance codes */\n\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nconst MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) =>\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) =>\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nconst copy_block = (s, buf, len, header) =>\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n  s.pending += len;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) =>\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) =>\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let lx = 0;         /* running index in l_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) =>\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) =>\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) =>\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) =>\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let black_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block = (s, buf, stored_len, last) =>\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nconst _tr_flush_block = (s, buf, stored_len, last) =>\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally = (s, dist, lc) =>\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //let out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n};\n\nmodule.exports._tr_init  = _tr_init;\nmodule.exports._tr_stored_block = _tr_stored_block;\nmodule.exports._tr_flush_block  = _tr_flush_block;\nmodule.exports._tr_tally = _tr_tally;\nmodule.exports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","/**\n * @licstart The following is the entire license notice for the\n * Javascript code in this page\n *\n * Copyright 2021 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * Javascript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"pdfjs-dist/build/pdf\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pdfjs-dist/build/pdf\"] = factory();\n\telse\n\t\troot[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory();\n})(this, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.LinkTarget = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;\nexports.addLinkAttributes = addLinkAttributes;\nexports.deprecated = deprecated;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\nexports.getXfaPageViewport = getXfaPageViewport;\nexports.isDataScheme = isDataScheme;\nexports.isPdfFile = isPdfFile;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _base_factory = __w_pdfjs_require__(5);\n\nconst DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nconst PixelsPerInch = {\n  CSS: 96.0,\n  PDF: 72.0,\n\n  get PDF_TO_CSS_UNITS() {\n    return (0, _util.shadow)(this, \"PDF_TO_CSS_UNITS\", this.CSS / this.PDF);\n  }\n\n};\nexports.PixelsPerInch = PixelsPerInch;\n\nclass DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document\n  } = {}) {\n    super();\n    this._document = ownerDocument;\n  }\n\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n\n}\n\nexports.DOMCanvasFactory = DOMCanvasFactory;\n\nasync function fetchData(url, asTypedArray = false) {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n\n    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n  }\n\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n\n    if (asTypedArray) {\n      request.responseType = \"arraybuffer\";\n    }\n\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n\n      if (request.status === 200 || request.status === 0) {\n        let data;\n\n        if (asTypedArray && request.response) {\n          data = new Uint8Array(request.response);\n        } else if (!asTypedArray && request.responseText) {\n          data = (0, _util.stringToBytes)(request.responseText);\n        }\n\n        if (data) {\n          resolve(data);\n          return;\n        }\n      }\n\n      reject(new Error(request.statusText));\n    };\n\n    request.send(null);\n  });\n}\n\nclass DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url, this.isCompressed).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n\n}\n\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\nclass DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url, true);\n  }\n\n}\n\nexports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n\nclass DOMSVGFactory extends _base_factory.BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n\n}\n\nexports.DOMSVGFactory = DOMSVGFactory;\n\nclass PageViewport {\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n\n    if (rotation < 0) {\n      rotation += 360;\n    }\n\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  convertToViewportPoint(x, y) {\n    return _util.Util.applyTransform([x, y], this.transform);\n  }\n\n  convertToViewportRectangle(rect) {\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n\n  convertToPdfPoint(x, y) {\n    return _util.Util.applyInverseTransform([x, y], this.transform);\n  }\n\n}\n\nexports.PageViewport = PageViewport;\n\nclass RenderingCancelledException extends _util.BaseException {\n  constructor(msg, type) {\n    super(msg, \"RenderingCancelledException\");\n    this.type = type;\n  }\n\n}\n\nexports.RenderingCancelledException = RenderingCancelledException;\nconst LinkTarget = {\n  NONE: 0,\n  SELF: 1,\n  BLANK: 2,\n  PARENT: 3,\n  TOP: 4\n};\nexports.LinkTarget = LinkTarget;\n\nfunction addLinkAttributes(link, {\n  url,\n  target,\n  rel,\n  enabled = true\n} = {}) {\n  (0, _util.assert)(url && typeof url === \"string\", 'addLinkAttributes: A valid \"url\" parameter must provided.');\n  const urlNullRemoved = (0, _util.removeNullCharacters)(url);\n\n  if (enabled) {\n    link.href = link.title = urlNullRemoved;\n  } else {\n    link.href = \"\";\n    link.title = `Disabled: ${urlNullRemoved}`;\n\n    link.onclick = () => {\n      return false;\n    };\n  }\n\n  let targetStr = \"\";\n\n  switch (target) {\n    case LinkTarget.NONE:\n      break;\n\n    case LinkTarget.SELF:\n      targetStr = \"_self\";\n      break;\n\n    case LinkTarget.BLANK:\n      targetStr = \"_blank\";\n      break;\n\n    case LinkTarget.PARENT:\n      targetStr = \"_parent\";\n      break;\n\n    case LinkTarget.TOP:\n      targetStr = \"_top\";\n      break;\n  }\n\n  link.target = targetStr;\n  link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\n}\n\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\n\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\n\nfunction getFilenameFromUrl(url) {\n  const anchor = url.indexOf(\"#\");\n  const query = url.indexOf(\"?\");\n  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n}\n\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n\n  if (isDataScheme(url)) {\n    (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch (ex) {}\n    }\n  }\n\n  return suggestedFilename || defaultFilename;\n}\n\nclass StatTimer {\n  constructor() {\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  time(name) {\n    if (name in this.started) {\n      (0, _util.warn)(`Timer is already running for ${name}`);\n    }\n\n    this.started[name] = Date.now();\n  }\n\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      (0, _util.warn)(`Timer has not been started for ${name}`);\n    }\n\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n\n    for (const time of this.times) {\n      const name = time.name;\n\n      if (name.length > longest) {\n        longest = name.length;\n      }\n    }\n\n    for (const time of this.times) {\n      const duration = time.end - time.start;\n      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n    }\n\n    return outBuf.join(\"\");\n  }\n\n}\n\nexports.StatTimer = StatTimer;\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch (ex) {\n    return false;\n  }\n}\n\nfunction loadScript(src, removeScriptElement = false) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = src;\n\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n\n      resolve(evt);\n    };\n\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n\n    (document.head || document.documentElement).appendChild(script);\n  });\n}\n\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\n\nlet pdfDateStringRegex;\n\nclass PDFDateString {\n  static toDateObject(input) {\n    if (!input || !(0, _util.isString)(input)) {\n      return null;\n    }\n\n    if (!pdfDateStringRegex) {\n      pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    }\n\n    const matches = pdfDateStringRegex.exec(input);\n\n    if (!matches) {\n      return null;\n    }\n\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n\n}\n\nexports.PDFDateString = PDFDateString;\n\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation\n  });\n}\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\nexports.arrayByteLength = arrayByteLength;\nexports.arraysToBytes = arraysToBytes;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createObjectURL = createObjectURL;\nexports.createPromiseCapability = createPromiseCapability;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.escapeString = escapeString;\nexports.getModificationDate = getModificationDate;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isAscii = isAscii;\nexports.isBool = isBool;\nexports.isNum = isNum;\nexports.isSameOrigin = isSameOrigin;\nexports.isString = isString;\nexports.objectFromMap = objectFromMap;\nexports.objectSize = objectSize;\nexports.removeNullCharacters = removeNullCharacters;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF16BEString = stringToUTF16BEString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.unreachable = unreachable;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\n\n__w_pdfjs_require__(3);\n\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100\n};\nexports.RenderingIntentFlag = RenderingIntentFlag;\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nexports.AnnotationMode = AnnotationMode;\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nconst AnnotationStateModelType = {\n  MARKED: \"Marked\",\n  REVIEW: \"Review\"\n};\nexports.AnnotationStateModelType = AnnotationStateModelType;\nconst AnnotationMarkedState = {\n  MARKED: \"Marked\",\n  UNMARKED: \"Unmarked\"\n};\nexports.AnnotationMarkedState = AnnotationMarkedState;\nconst AnnotationReviewState = {\n  ACCEPTED: \"Accepted\",\n  REJECTED: \"Rejected\",\n  CANCELLED: \"Cancelled\",\n  COMPLETED: \"Completed\",\n  NONE: \"None\"\n};\nexports.AnnotationReviewState = AnnotationReviewState;\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nexports.AnnotationActionEventType = AnnotationActionEventType;\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nexports.DocumentActionEventType = DocumentActionEventType;\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nexports.PageActionEventType = PageActionEventType;\nconst StreamType = {\n  UNKNOWN: \"UNKNOWN\",\n  FLATE: \"FLATE\",\n  LZW: \"LZW\",\n  DCT: \"DCT\",\n  JPX: \"JPX\",\n  JBIG: \"JBIG\",\n  A85: \"A85\",\n  AHX: \"AHX\",\n  CCF: \"CCF\",\n  RLX: \"RLX\"\n};\nexports.StreamType = StreamType;\nconst FontType = {\n  UNKNOWN: \"UNKNOWN\",\n  TYPE1: \"TYPE1\",\n  TYPE1STANDARD: \"TYPE1STANDARD\",\n  TYPE1C: \"TYPE1C\",\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n  TRUETYPE: \"TRUETYPE\",\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\n  TYPE3: \"TYPE3\",\n  OPENTYPE: \"OPENTYPE\",\n  TYPE0: \"TYPE0\",\n  MMTYPE1: \"MMTYPE1\"\n};\nexports.FontType = FontType;\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2\n};\nexports.CMapCompressionType = CMapCompressionType;\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nconst UNSUPPORTED_FEATURES = {\n  unknown: \"unknown\",\n  forms: \"forms\",\n  javaScript: \"javaScript\",\n  signatures: \"signatures\",\n  smask: \"smask\",\n  shadingPattern: \"shadingPattern\",\n  font: \"font\",\n  errorTilingPattern: \"errorTilingPattern\",\n  errorExtGState: \"errorExtGState\",\n  errorXObject: \"errorXObject\",\n  errorFontLoadType3: \"errorFontLoadType3\",\n  errorFontState: \"errorFontState\",\n  errorFontMissing: \"errorFontMissing\",\n  errorFontTranslate: \"errorFontTranslate\",\n  errorColorSpace: \"errorColorSpace\",\n  errorOperatorList: \"errorOperatorList\",\n  errorFontToUnicode: \"errorFontToUnicode\",\n  errorFontLoadNative: \"errorFontLoadNative\",\n  errorFontBuildPath: \"errorFontBuildPath\",\n  errorFontGetPath: \"errorFontGetPath\",\n  errorMarkedContent: \"errorMarkedContent\",\n  errorContentSubStream: \"errorContentSubStream\"\n};\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nlet verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\n\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\nfunction isSameOrigin(baseUrl, otherUrl) {\n  let base;\n\n  try {\n    base = new URL(baseUrl);\n\n    if (!base.origin || base.origin === \"null\") {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  const other = new URL(otherUrl, base);\n  return base.origin === other.origin;\n}\n\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n\n  switch (url.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n\n        if (dots && dots.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch (ex) {}\n      }\n    }\n\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {}\n\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: true,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\n\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n\n    this.message = message;\n    this.name = name;\n  }\n\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\n\nexports.BaseException = BaseException;\n\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n\n}\n\nexports.PasswordException = PasswordException;\n\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n\n}\n\nexports.UnknownErrorException = UnknownErrorException;\n\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n\n}\n\nexports.InvalidPDFException = InvalidPDFException;\n\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n\n}\n\nexports.MissingPDFException = MissingPDFException;\n\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n\n}\n\nexports.UnexpectedResponseException = UnexpectedResponseException;\n\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n\n}\n\nexports.FormatError = FormatError;\n\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n\n}\n\nexports.AbortException = AbortException;\nconst NullCharactersRegExp = /\\x00+/g;\nconst InvisibleCharactersRegExp = /[\\x01-\\x1F]/g;\n\nfunction removeNullCharacters(str, replaceInvisible = false) {\n  if (typeof str !== \"string\") {\n    warn(\"The argument for removeNullCharacters must be a string.\");\n    return str;\n  }\n\n  if (replaceInvisible) {\n    str = str.replace(InvisibleCharactersRegExp, \" \");\n  }\n\n  return str.replace(NullCharactersRegExp, \"\");\n}\n\nfunction bytesToString(bytes) {\n  assert(bytes !== null && typeof bytes === \"object\" && bytes.length !== undefined, \"Invalid argument for bytesToString\");\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  const strBuf = [];\n\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction stringToBytes(str) {\n  assert(typeof str === \"string\", \"Invalid argument for stringToBytes\");\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return bytes;\n}\n\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n\n  assert(arr.byteLength !== undefined, \"arrayByteLength - invalid argument.\");\n  return arr.byteLength;\n}\n\nfunction arraysToBytes(arr) {\n  const length = arr.length;\n\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n\n  let resultLength = 0;\n\n  for (let i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n\n  let pos = 0;\n  const data = new Uint8Array(resultLength);\n\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === \"string\") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n\n    const itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n\n  return data;\n}\n\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\n\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\n\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\n\nconst IsLittleEndianCached = {\n  get value() {\n    return shadow(this, \"value\", isLittleEndian());\n  }\n\n};\nexports.IsLittleEndianCached = IsLittleEndianCached;\n\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst IsEvalSupportedCached = {\n  get value() {\n    return shadow(this, \"value\", isEvalSupported());\n  }\n\n};\nexports.IsEvalSupportedCached = IsEvalSupportedCached;\nconst hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\n\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = Util.applyTransform(r, m);\n    const p2 = Util.applyTransform(r.slice(2, 4), m);\n    const p3 = Util.applyTransform([r[0], r[3]], m);\n    const p4 = Util.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n\n  static apply3dTransform(m, v) {\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n  }\n\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n\n    return r;\n  }\n\n  static intersect(rect1, rect2) {\n    function compare(a, b) {\n      return a - b;\n    }\n\n    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n    const result = [];\n    rect1 = Util.normalizeRect(rect1);\n    rect2 = Util.normalizeRect(rect2);\n\n    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n      result[0] = orderedX[1];\n      result[2] = orderedX[2];\n    } else {\n      return null;\n    }\n\n    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n      result[1] = orderedY[1];\n      result[3] = orderedY[2];\n    } else {\n      return null;\n    }\n\n    return result;\n  }\n\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const tvalues = [],\n          bounds = [[], []];\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n\n    for (let i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n\n        t = -c / b;\n\n        if (0 < t && t < 1) {\n          tvalues.push(t);\n        }\n\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n\n      if (b2ac < 0) {\n        continue;\n      }\n\n      t1 = (-b + sqrtb2ac) / (2 * a);\n\n      if (0 < t1 && t1 < 1) {\n        tvalues.push(t1);\n      }\n\n      t2 = (-b - sqrtb2ac) / (2 * a);\n\n      if (0 < t2 && t2 < 1) {\n        tvalues.push(t2);\n      }\n    }\n\n    let j = tvalues.length,\n        mt;\n    const jlen = j;\n\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n    }\n\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];\n  }\n\n}\n\nexports.Util = Util;\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\n\nfunction stringToPDFString(str) {\n  const length = str.length,\n        strBuf = [];\n\n  if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n    for (let i = 2; i < length; i += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\n    }\n  } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n    for (let i = 2; i < length; i += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));\n    }\n  } else {\n    for (let i = 0; i < length; ++i) {\n      const code = PDFStringTranslateTable[str.charCodeAt(i)];\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction escapeString(str) {\n  return str.replace(/([()\\\\\\n\\r])/g, match => {\n    if (match === \"\\n\") {\n      return \"\\\\n\";\n    } else if (match === \"\\r\") {\n      return \"\\\\r\";\n    }\n\n    return `\\\\${match}`;\n  });\n}\n\nfunction isAscii(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\nfunction stringToUTF16BEString(str) {\n  const buf = [\"\\xFE\\xFF\"];\n\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));\n  }\n\n  return buf.join(\"\");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isBool(v) {\n  return typeof v === \"boolean\";\n}\n\nfunction isNum(v) {\n  return typeof v === \"number\";\n}\n\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getModificationDate(date = new Date()) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\n\nfunction createPromiseCapability() {\n  const capability = Object.create(null);\n  let isSettled = false;\n  Object.defineProperty(capability, \"settled\", {\n    get() {\n      return isSettled;\n    }\n\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\nfunction createObjectURL(data, contentType = \"\", forceDataSchema = false) {\n  if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n    return URL.createObjectURL(new Blob([data], {\n      type: contentType\n    }));\n  }\n\n  const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  let buffer = `data:${contentType};base64,`;\n\n  for (let i = 0, ii = data.length; i < ii; i += 3) {\n    const b1 = data[i] & 0xff;\n    const b2 = data[i + 1] & 0xff;\n    const b3 = data[i + 2] & 0xff;\n    const d1 = b1 >> 2,\n          d2 = (b1 & 3) << 4 | b2 >> 4;\n    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n    const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n  }\n\n  return buffer;\n}\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\n\nvar _is_node = __w_pdfjs_require__(4);\n\n;\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isNodeJS = void 0;\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    const canvas = this._createCanvas(width, height);\n\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\")\n    };\n  }\n\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n\n  _createCanvas(width, height) {\n    (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n  }\n\n}\n\nexports.BaseCanvasFactory = BaseCanvasFactory;\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = false\n  }) {\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n    }\n\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n\n  _fetchData(url, compressionType) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    if (this.constructor === BaseStandardFontDataFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n  }\n\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n    }\n\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetchData(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n\n  _fetchData(url) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n\nclass BaseSVGFactory {\n  constructor() {\n    if (this.constructor === BaseSVGFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n\n    const svg = this._createSVG(\"svg:svg\");\n\n    svg.setAttribute(\"version\", \"1.1\");\n    svg.setAttribute(\"width\", `${width}px`);\n    svg.setAttribute(\"height\", `${height}px`);\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n\n    return this._createSVG(type);\n  }\n\n  _createSVG(type) {\n    (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n  }\n\n}\n\nexports.BaseSVGFactory = BaseSVGFactory;\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.build = exports.RenderTask = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\nexports.getDocument = getDocument;\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\nexports.version = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _font_loader = __w_pdfjs_require__(7);\n\nvar _node_utils = __w_pdfjs_require__(8);\n\nvar _annotation_storage = __w_pdfjs_require__(9);\n\nvar _canvas = __w_pdfjs_require__(10);\n\nvar _worker_options = __w_pdfjs_require__(12);\n\nvar _is_node = __w_pdfjs_require__(4);\n\nvar _message_handler = __w_pdfjs_require__(13);\n\nvar _metadata = __w_pdfjs_require__(14);\n\nvar _optional_content_config = __w_pdfjs_require__(15);\n\nvar _transport_stream = __w_pdfjs_require__(16);\n\nvar _xfa_text = __w_pdfjs_require__(17);\n\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\nconst DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\nconst DefaultStandardFontDataFactory = _is_node.isNodeJS ? _node_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\nexports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\nlet createPDFNetworkStream;\n\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\nfunction getDocument(src) {\n  const task = new PDFDocumentLoadingTask();\n  let source;\n\n  if (typeof src === \"string\" || src instanceof URL) {\n    source = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    source = {\n      data: src\n    };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = {\n      range: src\n    };\n  } else {\n    if (typeof src !== \"object\") {\n      throw new Error(\"Invalid parameter in getDocument, \" + \"need either string, URL, Uint8Array, or parameter object.\");\n    }\n\n    if (!src.url && !src.data && !src.range) {\n      throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n    }\n\n    source = src;\n  }\n\n  const params = Object.create(null);\n  let rangeTransport = null,\n      worker = null;\n\n  for (const key in source) {\n    const value = source[key];\n\n    switch (key) {\n      case \"url\":\n        if (typeof window !== \"undefined\") {\n          try {\n            params[key] = new URL(value, window.location).href;\n            continue;\n          } catch (ex) {\n            (0, _util.warn)(`Cannot create valid URL: \"${ex}\".`);\n          }\n        } else if (typeof value === \"string\" || value instanceof URL) {\n          params[key] = value.toString();\n          continue;\n        }\n\n        throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n\n      case \"range\":\n        rangeTransport = value;\n        continue;\n\n      case \"worker\":\n        worker = value;\n        continue;\n\n      case \"data\":\n        if (_is_node.isNodeJS && typeof Buffer !== \"undefined\" && value instanceof Buffer) {\n          params[key] = new Uint8Array(value);\n        } else if (value instanceof Uint8Array) {\n          break;\n        } else if (typeof value === \"string\") {\n          params[key] = (0, _util.stringToBytes)(value);\n        } else if (typeof value === \"object\" && value !== null && !isNaN(value.length)) {\n          params[key] = new Uint8Array(value);\n        } else if ((0, _util.isArrayBuffer)(value)) {\n          params[key] = new Uint8Array(value);\n        } else {\n          throw new Error(\"Invalid PDF binary data: either typed array, \" + \"string, or array-like object is expected in the data property.\");\n        }\n\n        continue;\n    }\n\n    params[key] = value;\n  }\n\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n  params.enableXfa = params.enableXfa === true;\n\n  if (typeof params.docBaseUrl !== \"string\" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {\n    params.docBaseUrl = null;\n  }\n\n  if (!Number.isInteger(params.maxImageSize)) {\n    params.maxImageSize = -1;\n  }\n\n  if (typeof params.useWorkerFetch !== \"boolean\") {\n    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;\n  }\n\n  if (typeof params.isEvalSupported !== \"boolean\") {\n    params.isEvalSupported = true;\n  }\n\n  if (typeof params.disableFontFace !== \"boolean\") {\n    params.disableFontFace = _is_node.isNodeJS;\n  }\n\n  if (typeof params.useSystemFonts !== \"boolean\") {\n    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;\n  }\n\n  if (typeof params.ownerDocument === \"undefined\") {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== \"boolean\") {\n    params.disableRange = false;\n  }\n\n  if (typeof params.disableStream !== \"boolean\") {\n    params.disableStream = false;\n  }\n\n  if (typeof params.disableAutoFetch !== \"boolean\") {\n    params.disableAutoFetch = false;\n  }\n\n  (0, _util.setVerbosityLevel)(params.verbosity);\n\n  if (!worker) {\n    const workerParams = {\n      verbosity: params.verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n\n  const docId = task.docId;\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n\n    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n    const networkStreamPromise = new Promise(function (resolve) {\n      let networkStream;\n\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length: params.length,\n          initialData: params.initialData,\n          progressiveDone: params.progressiveDone,\n          contentDispositionFilename: params.contentDispositionFilename,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        }, rangeTransport);\n      } else if (!params.data) {\n        networkStream = createPDFNetworkStream({\n          url: params.url,\n          length: params.length,\n          httpHeaders: params.httpHeaders,\n          withCredentials: params.withCredentials,\n          rangeChunkSize: params.rangeChunkSize,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        });\n      }\n\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, params);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\n\nasync function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;\n  }\n\n  const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n    docId,\n    apiVersion: '2.12.313',\n    source: {\n      data: source.data,\n      url: source.url,\n      password: source.password,\n      disableAutoFetch: source.disableAutoFetch,\n      rangeChunkSize: source.rangeChunkSize,\n      length: source.length\n    },\n    maxImageSize: source.maxImageSize,\n    disableFontFace: source.disableFontFace,\n    docBaseUrl: source.docBaseUrl,\n    ignoreErrors: source.ignoreErrors,\n    isEvalSupported: source.isEvalSupported,\n    fontExtraProperties: source.fontExtraProperties,\n    enableXfa: source.enableXfa,\n    useSystemFonts: source.useSystemFonts,\n    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,\n    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null\n  });\n\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  return workerId;\n}\n\nclass PDFDocumentLoadingTask {\n  static get idCounters() {\n    return (0, _util.shadow)(this, \"idCounters\", {\n      doc: 0\n    });\n  }\n\n  constructor() {\n    this._capability = (0, _util.createPromiseCapability)();\n    this._transport = null;\n    this._worker = null;\n    this.docId = `d${PDFDocumentLoadingTask.idCounters.doc++}`;\n    this.destroyed = false;\n    this.onPassword = null;\n    this.onProgress = null;\n    this.onUnsupportedFeature = null;\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  async destroy() {\n    this.destroyed = true;\n    await this._transport?.destroy();\n    this._transport = null;\n\n    if (this._worker) {\n      this._worker.destroy();\n\n      this._worker = null;\n    }\n  }\n\n}\n\nexports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n\nclass PDFDataRangeTransport {\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = (0, _util.createPromiseCapability)();\n  }\n\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n\n  requestDataRange(begin, end) {\n    (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n\n  abort() {}\n\n}\n\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\n\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n    Object.defineProperty(this, \"fingerprint\", {\n      get() {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.fingerprint`, \" + \"please use `PDFDocumentProxy.fingerprints` instead.\");\n        return this.fingerprints[0];\n      }\n\n    });\n    Object.defineProperty(this, \"getStats\", {\n      value: async () => {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getStats`, \" + \"please use the `PDFDocumentProxy.stats`-getter instead.\");\n        return this.stats || {\n          streamTypes: {},\n          fontTypes: {}\n        };\n      }\n    });\n  }\n\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n\n  get stats() {\n    return this._transport.stats;\n  }\n\n  get isPureXfa() {\n    return !!this._transport._htmlForXfa;\n  }\n\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n\n  getJavaScript() {\n    return this._transport.getJavaScript();\n  }\n\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n\n  getOutline() {\n    return this._transport.getOutline();\n  }\n\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n\n  getData() {\n    return this._transport.getData();\n  }\n\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n\n  saveDocument() {\n    if (this._transport.annotationStorage.size <= 0) {\n      (0, _display_utils.deprecated)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n\n    return this._transport.saveDocument();\n  }\n\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n\n}\n\nexports.PDFDocumentProxy = PDFDocumentProxy;\n\nclass PDFPageProxy {\n  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this._annotationPromises = new Map();\n    this.destroyed = false;\n  }\n\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n\n  get ref() {\n    return this._pageInfo.ref;\n  }\n\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n\n  get view() {\n    return this._pageInfo.view;\n  }\n\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new _display_utils.PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const intentArgs = this._transport.getRenderingIntent(intent);\n\n    let promise = this._annotationPromises.get(intentArgs.cacheKey);\n\n    if (!promise) {\n      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n\n      this._annotationPromises.set(intentArgs.cacheKey, promise);\n\n      promise = promise.then(annotations => {\n        for (const annotation of annotations) {\n          if (annotation.titleObj !== undefined) {\n            Object.defineProperty(annotation, \"title\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`title`-property on annotation, please use `titleObj` instead.\");\n                return annotation.titleObj.str;\n              }\n\n            });\n          }\n\n          if (annotation.contentsObj !== undefined) {\n            Object.defineProperty(annotation, \"contents\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`contents`-property on annotation, please use `contentsObj` instead.\");\n                return annotation.contentsObj.str;\n              }\n\n            });\n          }\n        }\n\n        return annotations;\n      });\n    }\n\n    return promise;\n  }\n\n  getJSActions() {\n    return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);\n  }\n\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n\n  render({\n    canvasContext,\n    viewport,\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    transform = null,\n    imageLayer = null,\n    canvasFactory = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null\n  }) {\n    if (arguments[0]?.renderInteractiveForms !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `renderInteractiveForms`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_FORMS;\n      }\n    }\n\n    if (arguments[0]?.includeAnnotationStorage !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `includeAnnotationStorage`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;\n      }\n    }\n\n    if (this._stats) {\n      this._stats.time(\"Overall\");\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode);\n\n    this.pendingCleanup = false;\n\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n\n    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n      ownerDocument: this._ownerDocument\n    });\n    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n\n      if (this.cleanupAfterRender || intentPrint) {\n        this.pendingCleanup = true;\n      }\n\n      this._tryCleanup();\n\n      if (error) {\n        internalRenderTask.capability.reject(error);\n\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n\n        this._stats.timeEnd(\"Overall\");\n      }\n    };\n\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        imageLayer,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: canvasFactoryInstance,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.pendingCleanup) {\n        complete();\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.time(\"Rendering\");\n      }\n\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    let opListTask;\n\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    return intentState.opListReadCapability.promise;\n  }\n\n  streamTextContent({\n    normalizeWhitespace = false,\n    disableCombineTextItems = false,\n    includeMarkedContent = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      normalizeWhitespace: normalizeWhitespace === true,\n      combineTextItems: disableCombineTextItems !== true,\n      includeMarkedContent: includeMarkedContent === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n\n      size(textContent) {\n        return textContent.items.length;\n      }\n\n    });\n  }\n\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => {\n        return _xfa_text.XfaText.textContent(xfa);\n      });\n    }\n\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null)\n      };\n      pump();\n    });\n  }\n\n  getStructTree() {\n    return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);\n  }\n\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n\n    this.objs.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n    this.pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n\n  cleanup(resetStats = false) {\n    this.pendingCleanup = true;\n    return this._tryCleanup(resetStats);\n  }\n\n  _tryCleanup(resetStats = false) {\n    if (!this.pendingCleanup) {\n      return false;\n    }\n\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n\n    this._intentStates.clear();\n\n    this.objs.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n\n    if (resetStats && this._stats) {\n      this._stats = new _display_utils.StatTimer();\n    }\n\n    this.pendingCleanup = false;\n    return true;\n  }\n\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n\n    if (!intentState) {\n      return;\n    }\n\n    if (this._stats) {\n      this._stats.timeEnd(\"Page Request\");\n    }\n\n    if (intentState.displayReadyCapability) {\n      intentState.displayReadyCapability.resolve(transparency);\n    }\n  }\n\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n\n    if (operatorListChunk.lastChunk) {\n      this._tryCleanup();\n    }\n  }\n\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey\n  }) {\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null\n    });\n\n    const reader = readableStream.getReader();\n\n    const intentState = this._intentStates.get(cacheKey);\n\n    intentState.streamReader = reader;\n\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        this._renderPageChunk(value, intentState);\n\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n\n          this._tryCleanup();\n        }\n\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n\n    pump();\n  }\n\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n\n      if (reason instanceof _display_utils.RenderingCancelledException) {\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n\n          intentState.streamReaderCancelTimeout = null;\n        }, RENDERING_CANCELLED_TIMEOUT);\n        return;\n      }\n    }\n\n    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n\n    if (this._transport.destroyed) {\n      return;\n    }\n\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n\n        break;\n      }\n    }\n\n    this.cleanup();\n  }\n\n  get stats() {\n    return this._stats;\n  }\n\n}\n\nexports.PDFPageProxy = PDFPageProxy;\n\nclass LoopbackPort {\n  constructor() {\n    this._listeners = [];\n    this._deferred = Promise.resolve();\n  }\n\n  postMessage(obj, transfers) {\n    function cloneValue(object) {\n      if (globalThis.structuredClone) {\n        return globalThis.structuredClone(object, transfers);\n      }\n\n      function fallbackCloneValue(value) {\n        if (typeof value === \"function\" || typeof value === \"symbol\" || value instanceof URL) {\n          throw new Error(`LoopbackPort.postMessage - cannot clone: ${value?.toString()}`);\n        }\n\n        if (typeof value !== \"object\" || value === null) {\n          return value;\n        }\n\n        if (cloned.has(value)) {\n          return cloned.get(value);\n        }\n\n        let buffer, result;\n\n        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\n          if (transfers?.includes(buffer)) {\n            result = new value.constructor(buffer, value.byteOffset, value.byteLength);\n          } else {\n            result = new value.constructor(value);\n          }\n\n          cloned.set(value, result);\n          return result;\n        }\n\n        if (value instanceof Map) {\n          result = new Map();\n          cloned.set(value, result);\n\n          for (const [key, val] of value) {\n            result.set(key, fallbackCloneValue(val));\n          }\n\n          return result;\n        }\n\n        if (value instanceof Set) {\n          result = new Set();\n          cloned.set(value, result);\n\n          for (const val of value) {\n            result.add(fallbackCloneValue(val));\n          }\n\n          return result;\n        }\n\n        result = Array.isArray(value) ? [] : Object.create(null);\n        cloned.set(value, result);\n\n        for (const i in value) {\n          let desc,\n              p = value;\n\n          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\n            p = Object.getPrototypeOf(p);\n          }\n\n          if (typeof desc.value === \"undefined\") {\n            continue;\n          }\n\n          if (typeof desc.value === \"function\" && !value.hasOwnProperty?.(i)) {\n            continue;\n          }\n\n          result[i] = fallbackCloneValue(desc.value);\n        }\n\n        return result;\n      }\n\n      const cloned = new WeakMap();\n      return fallbackCloneValue(object);\n    }\n\n    const event = {\n      data: cloneValue(obj)\n    };\n\n    this._deferred.then(() => {\n      for (const listener of this._listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n\n  addEventListener(name, listener) {\n    this._listeners.push(listener);\n  }\n\n  removeEventListener(name, listener) {\n    const i = this._listeners.indexOf(listener);\n\n    this._listeners.splice(i, 1);\n  }\n\n  terminate() {\n    this._listeners.length = 0;\n  }\n\n}\n\nexports.LoopbackPort = LoopbackPort;\nconst PDFWorkerUtil = {\n  isWorkerDisabled: false,\n  fallbackWorkerSrc: null,\n  fakeWorkerId: 0\n};\n{\n  if (_is_node.isNodeJS && typeof require === \"function\") {\n    PDFWorkerUtil.isWorkerDisabled = true;\n    PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if (typeof document === \"object\") {\n    const pdfjsFilePath = document?.currentScript?.src;\n\n    if (pdfjsFilePath) {\n      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n\n  PDFWorkerUtil.createCDNWrapper = function (url) {\n    const wrapper = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([wrapper]));\n  };\n}\n\nclass PDFWorker {\n  static get _workerPorts() {\n    return (0, _util.shadow)(this, \"_workerPorts\", new WeakMap());\n  }\n\n  constructor({\n    name = null,\n    port = null,\n    verbosity = (0, _util.getVerbosityLevel)()\n  } = {}) {\n    if (port && PDFWorker._workerPorts.has(port)) {\n      throw new Error(\"Cannot use more than one PDFWorker per port.\");\n    }\n\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    this._readyCapability = (0, _util.createPromiseCapability)();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n\n    if (port) {\n      PDFWorker._workerPorts.set(port, this);\n\n      this._initializeFromPort(port);\n\n      return;\n    }\n\n    this._initialize();\n  }\n\n  get promise() {\n    return this._readyCapability.promise;\n  }\n\n  get port() {\n    return this._port;\n  }\n\n  get messageHandler() {\n    return this._messageHandler;\n  }\n\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n\n    this._messageHandler.on(\"ready\", function () {});\n\n    this._readyCapability.resolve();\n  }\n\n  _initialize() {\n    if (typeof Worker !== \"undefined\" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n      let workerSrc = PDFWorker.workerSrc;\n\n      try {\n        if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\n          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n        }\n\n        const worker = new Worker(workerSrc);\n        const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n\n        const terminateEarly = () => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          messageHandler.destroy();\n          worker.terminate();\n\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          } else {\n            this._setupFakeWorker();\n          }\n        };\n\n        const onWorkerError = () => {\n          if (!this._webWorker) {\n            terminateEarly();\n          }\n        };\n\n        worker.addEventListener(\"error\", onWorkerError);\n        messageHandler.on(\"test\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          if (data) {\n            this._messageHandler = messageHandler;\n            this._port = worker;\n            this._webWorker = worker;\n\n            this._readyCapability.resolve();\n\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity\n            });\n          } else {\n            this._setupFakeWorker();\n\n            messageHandler.destroy();\n            worker.terminate();\n          }\n        });\n        messageHandler.on(\"ready\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          try {\n            sendTest();\n          } catch (e) {\n            this._setupFakeWorker();\n          }\n        });\n\n        const sendTest = () => {\n          const testObj = new Uint8Array([255]);\n\n          try {\n            messageHandler.send(\"test\", testObj, [testObj.buffer]);\n          } catch (ex) {\n            (0, _util.warn)(\"Cannot use postMessage transfers.\");\n            testObj[0] = 0;\n            messageHandler.send(\"test\", testObj);\n          }\n        };\n\n        sendTest();\n        return;\n      } catch (e) {\n        (0, _util.info)(\"The worker has been disabled.\");\n      }\n    }\n\n    this._setupFakeWorker();\n  }\n\n  _setupFakeWorker() {\n    if (!PDFWorkerUtil.isWorkerDisabled) {\n      (0, _util.warn)(\"Setting up fake worker.\");\n      PDFWorkerUtil.isWorkerDisabled = true;\n    }\n\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n\n        return;\n      }\n\n      const port = new LoopbackPort();\n      this._port = port;\n      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n      const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n      this._messageHandler = messageHandler;\n\n      this._readyCapability.resolve();\n\n      messageHandler.send(\"configure\", {\n        verbosity: this.verbosity\n      });\n    }).catch(reason => {\n      this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n\n  destroy() {\n    this.destroyed = true;\n\n    if (this._webWorker) {\n      this._webWorker.terminate();\n\n      this._webWorker = null;\n    }\n\n    PDFWorker._workerPorts.delete(this._port);\n\n    this._port = null;\n\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n\n      this._messageHandler = null;\n    }\n  }\n\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n\n    if (this._workerPorts.has(params.port)) {\n      return this._workerPorts.get(params.port);\n    }\n\n    return new PDFWorker(params);\n  }\n\n  static get workerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n\n    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n      if (!_is_node.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n\n      return PDFWorkerUtil.fallbackWorkerSrc;\n    }\n\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n\n  static get _mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch (ex) {\n      return null;\n    }\n  }\n\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n\n      if (mainWorkerMessageHandler) {\n        return mainWorkerMessageHandler;\n      }\n\n      if (_is_node.isNodeJS && typeof require === \"function\") {\n        const worker = eval(\"require\")(this.workerSrc);\n        return worker.WorkerMessageHandler;\n      }\n\n      await (0, _display_utils.loadScript)(this.workerSrc);\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n\n    return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n\n}\n\nexports.PDFWorker = PDFWorker;\n{\n  PDFWorker.getWorkerSrc = function () {\n    (0, _display_utils.deprecated)(\"`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.\");\n    return this.workerSrc;\n  };\n}\n\nclass WorkerTransport {\n  #docStats = null;\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #metadataPromise = null;\n\n  constructor(messageHandler, loadingTask, networkStream, params) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this._params = params;\n\n    if (!params.useWorkerFetch) {\n      this.CMapReaderFactory = new params.CMapReaderFactory({\n        baseUrl: params.cMapUrl,\n        isCompressed: params.cMapPacked\n      });\n      this.StandardFontDataFactory = new params.StandardFontDataFactory({\n        baseUrl: params.standardFontDataUrl\n      });\n    }\n\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n    this.setupMessageHandler();\n  }\n\n  get annotationStorage() {\n    return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n  }\n\n  get stats() {\n    return this.#docStats;\n  }\n\n  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, isOpList = false) {\n    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n    let lastModified = \"\";\n\n    switch (intent) {\n      case \"any\":\n        renderingIntent = _util.RenderingIntentFlag.ANY;\n        break;\n\n      case \"display\":\n        break;\n\n      case \"print\":\n        renderingIntent = _util.RenderingIntentFlag.PRINT;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n\n    switch (annotationMode) {\n      case _util.AnnotationMode.DISABLE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n\n      case _util.AnnotationMode.ENABLE:\n        break;\n\n      case _util.AnnotationMode.ENABLE_FORMS:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n\n      case _util.AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        lastModified = this.annotationStorage.lastModified;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n\n    if (isOpList) {\n      renderingIntent += _util.RenderingIntentFlag.OPLIST;\n    }\n\n    return {\n      renderingIntent,\n      cacheKey: `${renderingIntent}_${lastModified}`\n    };\n  }\n\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n\n    this.destroyed = true;\n    this.destroyCapability = (0, _util.createPromiseCapability)();\n\n    if (this._passwordCapability) {\n      this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    }\n\n    const waitOn = [];\n\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#metadataPromise = null;\n      this._getFieldObjectsPromise = null;\n      this._hasJSActionsPromise = null;\n\n      if (this._networkStream) {\n        this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", data => {\n      const headersCapability = (0, _util.createPromiseCapability)();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress) {\n            loadingTask.onProgress?.(this._lastProgress);\n          }\n\n          fullReader.onProgress = evt => {\n            loadingTask.onProgress?.({\n              loaded: evt.loaded,\n              total: evt.total\n            });\n          };\n        }\n\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength\n        });\n      }, headersCapability.reject);\n      return headersCapability.promise;\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new _util.PasswordException(ex.message, ex.code);\n          break;\n\n        case \"InvalidPDFException\":\n          reason = new _util.InvalidPDFException(ex.message);\n          break;\n\n        case \"MissingPDFException\":\n          reason = new _util.MissingPDFException(ex.message);\n          break;\n\n        case \"UnexpectedResponseException\":\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n          break;\n\n        case \"UnknownErrorException\":\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\n          break;\n\n        default:\n          (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n      }\n\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this._passwordCapability = (0, _util.createPromiseCapability)();\n\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          this._passwordCapability.resolve({\n            password\n          });\n        };\n\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this._passwordCapability.reject(ex);\n        }\n      } else {\n        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n      }\n\n      return this._passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const page = this.#pageCache.get(data.pageIndex);\n\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Font\":\n          const params = this._params;\n\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n\n          let fontRegistry = null;\n\n          if (params.pdfBug && globalThis.FontInspector?.enabled) {\n            fontRegistry = {\n              registerFont(font, url) {\n                globalThis.FontInspector.fontAdded(font, url);\n              }\n\n            };\n          }\n\n          const font = new _font_loader.FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n            fontRegistry\n          });\n          this.fontLoader.bind(font).catch(reason => {\n            return messageHandler.sendWithPromise(\"FontFallback\", {\n              id\n            });\n          }).finally(() => {\n            if (!params.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n\n        case \"FontPath\":\n        case \"Image\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const pageProxy = this.#pageCache.get(pageIndex);\n\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n          const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n          if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {\n            pageProxy.cleanupAfterRender = true;\n          }\n\n          break;\n\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"DocStats\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      this.#docStats = Object.freeze({\n        streamTypes: Object.freeze(data.streamTypes),\n        fontTypes: Object.freeze(data.fontTypes)\n      });\n    });\n    messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n    messageHandler.on(\"FetchBuiltInCMap\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.CMapReaderFactory) {\n        return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.CMapReaderFactory.fetch(data);\n    });\n    messageHandler.on(\"FetchStandardFontData\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.StandardFontDataFactory) {\n        return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.StandardFontDataFactory.fetch(data);\n    });\n  }\n\n  _onUnsupportedFeature({\n    featureId\n  }) {\n    if (this.destroyed) {\n      return;\n    }\n\n    this.loadingTask.onUnsupportedFeature?.(featureId);\n  }\n\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request\"));\n    }\n\n    const pageIndex = pageNumber - 1,\n          cachedPromise = this.#pagePromises.get(pageIndex);\n\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n\n  getPageIndex(ref) {\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      ref\n    });\n  }\n\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n\n  saveDocument() {\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: this.annotationStorage.serializable,\n      filename: this._fullReader?.filename ?? null\n    }).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n\n  getFieldObjects() {\n    return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\n  }\n\n  hasJSActions() {\n    return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(\"HasJSActions\", null);\n  }\n\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n\n  getJavaScript() {\n    return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n  }\n\n  getDocJSActions() {\n    return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n  }\n\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n\n  getOptionalContentConfig() {\n    return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n      return new _optional_content_config.OptionalContentConfig(results);\n    });\n  }\n\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n\n  getMetadata() {\n    return this.#metadataPromise ||= this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => {\n      return {\n        info: results[0],\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n        contentDispositionFilename: this._fullReader?.filename ?? null,\n        contentLength: this._fullReader?.contentLength ?? null\n      };\n    });\n  }\n\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n\n  async startCleanup(keepLoadedFonts = false) {\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n\n    if (this.destroyed) {\n      return;\n    }\n\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n\n    this.commonObjs.clear();\n\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n\n    this.#metadataPromise = null;\n    this._getFieldObjectsPromise = null;\n    this._hasJSActionsPromise = null;\n  }\n\n  get loadingParams() {\n    const params = this._params;\n    return (0, _util.shadow)(this, \"loadingParams\", {\n      disableAutoFetch: params.disableAutoFetch,\n      enableXfa: params.enableXfa\n    });\n  }\n\n}\n\nclass PDFObjects {\n  constructor() {\n    this._objs = Object.create(null);\n  }\n\n  _ensureObj(objId) {\n    if (this._objs[objId]) {\n      return this._objs[objId];\n    }\n\n    return this._objs[objId] = {\n      capability: (0, _util.createPromiseCapability)(),\n      data: null,\n      resolved: false\n    };\n  }\n\n  get(objId, callback = null) {\n    if (callback) {\n      this._ensureObj(objId).capability.promise.then(callback);\n\n      return null;\n    }\n\n    const obj = this._objs[objId];\n\n    if (!obj || !obj.resolved) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n\n    return obj.data;\n  }\n\n  has(objId) {\n    const obj = this._objs[objId];\n    return obj?.resolved || false;\n  }\n\n  resolve(objId, data) {\n    const obj = this._ensureObj(objId);\n\n    obj.resolved = true;\n    obj.data = data;\n    obj.capability.resolve(data);\n  }\n\n  clear() {\n    this._objs = Object.create(null);\n  }\n\n}\n\nclass RenderTask {\n  constructor(internalRenderTask) {\n    this._internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n\n  get promise() {\n    return this._internalRenderTask.capability.promise;\n  }\n\n  cancel() {\n    this._internalRenderTask.cancel();\n  }\n\n}\n\nexports.RenderTask = RenderTask;\n\nclass InternalRenderTask {\n  static get canvasInUse() {\n    return (0, _util.shadow)(this, \"canvasInUse\", new WeakSet());\n  }\n\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this._pdfBug = pdfBug;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = (0, _util.createPromiseCapability)();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this._canvas) {\n      if (InternalRenderTask.canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n\n      InternalRenderTask.canvasInUse.add(this._canvas);\n    }\n\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n\n    const {\n      canvasContext,\n      viewport,\n      transform,\n      imageLayer,\n      background\n    } = this.params;\n    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n\n    if (this.graphicsReadyCallback) {\n      this.graphicsReadyCallback();\n    }\n  }\n\n  cancel(error = null) {\n    this.running = false;\n    this.cancelled = true;\n\n    if (this.gfx) {\n      this.gfx.endDrawing();\n    }\n\n    if (this._canvas) {\n      InternalRenderTask.canvasInUse.delete(this._canvas);\n    }\n\n    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\"));\n  }\n\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      if (!this.graphicsReadyCallback) {\n        this.graphicsReadyCallback = this._continueBound;\n      }\n\n      return;\n    }\n\n    if (this.stepper) {\n      this.stepper.updateOperatorList(this.operatorList);\n    }\n\n    if (this.running) {\n      return;\n    }\n\n    this._continue();\n  }\n\n  _continue() {\n    this.running = true;\n\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      window.requestAnimationFrame(() => {\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n\n        if (this._canvas) {\n          InternalRenderTask.canvasInUse.delete(this._canvas);\n        }\n\n        this.callback();\n      }\n    }\n  }\n\n}\n\nconst version = '2.12.313';\nexports.version = version;\nconst build = 'a2ae56f39';\nexports.build = build;\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FontLoader = exports.FontFaceObject = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass BaseFontLoader {\n  constructor({\n    docId,\n    onUnsupportedFeature,\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    if (this.constructor === BaseFontLoader) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n    }\n\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n    this.nativeFontFaces = [];\n    this.styleElement = null;\n  }\n\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.push(nativeFontFace);\n\n    this._document.fonts.add(nativeFontFace);\n  }\n\n  insertRule(rule) {\n    let styleElement = this.styleElement;\n\n    if (!styleElement) {\n      styleElement = this.styleElement = this._document.createElement(\"style\");\n      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n\n      this._document.documentElement.getElementsByTagName(\"head\")[0].appendChild(styleElement);\n    }\n\n    const styleSheet = styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n\n    this.nativeFontFaces.length = 0;\n\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n\n  async bind(font) {\n    if (font.attached || font.missingFile) {\n      return;\n    }\n\n    font.attached = true;\n\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          this._onUnsupportedFeature({\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n          });\n\n          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n\n      return;\n    }\n\n    const rule = font.createFontFaceRule();\n\n    if (rule) {\n      this.insertRule(rule);\n\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n\n        this._prepareFontLoadEvent([rule], [font], request);\n      });\n    }\n  }\n\n  _queueLoadingCallback(callback) {\n    (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n  }\n\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n\n  get isSyncFontLoadingSupported() {\n    (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n  }\n\n  get _loadTestFont() {\n    (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n  }\n\n  _prepareFontLoadEvent(rules, fontsToLoad, request) {\n    (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n  }\n\n}\n\nlet FontLoader;\nexports.FontLoader = FontLoader;\n{\n  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\n    constructor(params) {\n      super(params);\n      this.loadingContext = {\n        requests: [],\n        nextRequestId: 0\n      };\n      this.loadTestFontId = 0;\n    }\n\n    get isSyncFontLoadingSupported() {\n      let supported = false;\n\n      if (typeof navigator === \"undefined\") {\n        supported = true;\n      } else {\n        const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n        if (m?.[1] >= 14) {\n          supported = true;\n        }\n      }\n\n      return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n    }\n\n    _queueLoadingCallback(callback) {\n      function completeRequest() {\n        (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n        request.done = true;\n\n        while (context.requests.length > 0 && context.requests[0].done) {\n          const otherRequest = context.requests.shift();\n          setTimeout(otherRequest.callback, 0);\n        }\n      }\n\n      const context = this.loadingContext;\n      const request = {\n        id: `pdfjs-font-loading-${context.nextRequestId++}`,\n        done: false,\n        complete: completeRequest,\n        callback\n      };\n      context.requests.push(request);\n      return request;\n    }\n\n    get _loadTestFont() {\n      const getLoadTestFont = function () {\n        return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n      };\n\n      return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n    }\n\n    _prepareFontLoadEvent(rules, fonts, request) {\n      function int32(data, offset) {\n        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n      }\n\n      function spliceString(s, offset, remove, insert) {\n        const chunk1 = s.substring(0, offset);\n        const chunk2 = s.substring(offset + remove);\n        return chunk1 + insert + chunk2;\n      }\n\n      let i, ii;\n\n      const canvas = this._document.createElement(\"canvas\");\n\n      canvas.width = 1;\n      canvas.height = 1;\n      const ctx = canvas.getContext(\"2d\");\n      let called = 0;\n\n      function isFontReady(name, callback) {\n        called++;\n\n        if (called > 30) {\n          (0, _util.warn)(\"Load test font never loaded.\");\n          callback();\n          return;\n        }\n\n        ctx.font = \"30px \" + name;\n        ctx.fillText(\".\", 0, 20);\n        const imageData = ctx.getImageData(0, 0, 1, 1);\n\n        if (imageData.data[3] > 0) {\n          callback();\n          return;\n        }\n\n        setTimeout(isFontReady.bind(null, name, callback));\n      }\n\n      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n      let data = this._loadTestFont;\n      const COMMENT_OFFSET = 976;\n      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n      const CFF_CHECKSUM_OFFSET = 16;\n      const XXXX_VALUE = 0x58585858;\n      let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n      }\n\n      if (i < loadTestFontId.length) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n      }\n\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n      const url = `url(data:font/opentype;base64,${btoa(data)});`;\n      const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n      this.insertRule(rule);\n      const names = [];\n\n      for (const font of fonts) {\n        names.push(font.loadedName);\n      }\n\n      names.push(loadTestFontId);\n\n      const div = this._document.createElement(\"div\");\n\n      div.style.visibility = \"hidden\";\n      div.style.width = div.style.height = \"10px\";\n      div.style.position = \"absolute\";\n      div.style.top = div.style.left = \"0px\";\n\n      for (const name of names) {\n        const span = this._document.createElement(\"span\");\n\n        span.textContent = \"Hi\";\n        span.style.fontFamily = name;\n        div.appendChild(span);\n      }\n\n      this._document.body.appendChild(div);\n\n      isFontReady(loadTestFontId, () => {\n        div.remove();\n        request.complete();\n      });\n    }\n\n  };\n}\n\nclass FontFaceObject {\n  constructor(translatedData, {\n    isEvalSupported = true,\n    disableFontFace = false,\n    ignoreErrors = false,\n    onUnsupportedFeature,\n    fontRegistry = null\n  }) {\n    this.compiledGlyphs = Object.create(null);\n\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    let nativeFontFace;\n\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this);\n    }\n\n    return nativeFontFace;\n  }\n\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    const data = (0, _util.bytesToString)(this.data);\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    let rule;\n\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this, url);\n    }\n\n    return rule;\n  }\n\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n\n    let cmds;\n\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n\n      this._onUnsupportedFeature({\n        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n      });\n\n      (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n\n    if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\n      const jsBuf = [];\n\n      for (const current of cmds) {\n        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n      }\n\n      return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n    }\n\n    return this.compiledGlyphs[character] = function (c, size) {\n      for (const current of cmds) {\n        if (current.cmd === \"scale\") {\n          current.args = [size, -size];\n        }\n\n        c[current.cmd].apply(c, current.args);\n      }\n    };\n  }\n\n}\n\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\n\nvar _base_factory = __w_pdfjs_require__(5);\n\nvar _is_node = __w_pdfjs_require__(4);\n\nvar _util = __w_pdfjs_require__(2);\n\nlet NodeCanvasFactory = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: NodeCanvasFactory\");\n  }\n\n};\nexports.NodeCanvasFactory = NodeCanvasFactory;\nlet NodeCMapReaderFactory = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: NodeCMapReaderFactory\");\n  }\n\n};\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\nlet NodeStandardFontDataFactory = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: NodeStandardFontDataFactory\");\n  }\n\n};\nexports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n\nif (_is_node.isNodeJS) {\n  const fetchData = function (url) {\n    return new Promise((resolve, reject) => {\n      const fs = require(\"fs\");\n\n      fs.readFile(url, (error, data) => {\n        if (error || !data) {\n          reject(new Error(error));\n          return;\n        }\n\n        resolve(new Uint8Array(data));\n      });\n    });\n  };\n\n  exports.NodeCanvasFactory = NodeCanvasFactory = class extends _base_factory.BaseCanvasFactory {\n    _createCanvas(width, height) {\n      const Canvas = require(\"canvas\");\n\n      return Canvas.createCanvas(width, height);\n    }\n\n  };\n  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _base_factory.BaseCMapReaderFactory {\n    _fetchData(url, compressionType) {\n      return fetchData(url).then(data => {\n        return {\n          cMapData: data,\n          compressionType\n        };\n      });\n    }\n\n  };\n  exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory = class extends _base_factory.BaseStandardFontDataFactory {\n    _fetchData(url) {\n      return fetchData(url);\n    }\n\n  };\n}\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationStorage = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass AnnotationStorage {\n  constructor() {\n    this._storage = new Map();\n    this._timeStamp = Date.now();\n    this._modified = false;\n    this.onSetModified = null;\n    this.onResetModified = null;\n  }\n\n  getValue(key, defaultValue) {\n    const value = this._storage.get(key);\n\n    if (value === undefined) {\n      return defaultValue;\n    }\n\n    return Object.assign(defaultValue, value);\n  }\n\n  setValue(key, value) {\n    const obj = this._storage.get(key);\n\n    let modified = false;\n\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n\n      this._storage.set(key, value);\n    }\n\n    if (modified) {\n      this._timeStamp = Date.now();\n\n      this._setModified();\n    }\n  }\n\n  getAll() {\n    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;\n  }\n\n  get size() {\n    return this._storage.size;\n  }\n\n  _setModified() {\n    if (!this._modified) {\n      this._modified = true;\n\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n\n  resetModified() {\n    if (this._modified) {\n      this._modified = false;\n\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n\n  get serializable() {\n    return this._storage.size > 0 ? this._storage : null;\n  }\n\n  get lastModified() {\n    return this._timeStamp.toString();\n  }\n\n}\n\nexports.AnnotationStorage = AnnotationStorage;\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanvasGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _pattern_helper = __w_pdfjs_require__(11);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst MAX_GROUP_SIZE = 4096;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst COMPILE_TYPE3_GLYPHS = true;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nconst LINEWIDTH_SCALE_FACTOR = 1.000001;\n\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n\n  ctx.save = function ctxSave() {\n    destCtx.save();\n\n    this.__originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n\n    this.__originalRestore();\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n\n    this.__originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n\n    this.__originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n\n    this.__originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n\n    this.__originalRotate(angle);\n  };\n\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n\n    this.__originalClip(rule);\n  };\n\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n\n    this.__originalMoveTo(x, y);\n  };\n\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n\n    this.__originalLineTo(x, y);\n  };\n\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n\n    this.__originalRect(x, y, width, height);\n  };\n\n  ctx.closePath = function () {\n    destCtx.closePath();\n\n    this.__originalClosePath();\n  };\n\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n\n    this.__originalBeginPath();\n  };\n}\n\nfunction addContextCurrentTransform(ctx) {\n  if (ctx.mozCurrentTransform) {\n    return;\n  }\n\n  ctx._originalSave = ctx.save;\n  ctx._originalRestore = ctx.restore;\n  ctx._originalRotate = ctx.rotate;\n  ctx._originalScale = ctx.scale;\n  ctx._originalTranslate = ctx.translate;\n  ctx._originalTransform = ctx.transform;\n  ctx._originalSetTransform = ctx.setTransform;\n  ctx._originalResetTransform = ctx.resetTransform;\n  ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n  ctx._transformStack = [];\n\n  try {\n    const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), \"lineWidth\");\n    ctx._setLineWidth = desc.set;\n    ctx._getLineWidth = desc.get;\n    Object.defineProperty(ctx, \"lineWidth\", {\n      set: function setLineWidth(width) {\n        this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);\n      },\n      get: function getLineWidth() {\n        return this._getLineWidth();\n      }\n    });\n  } catch (_) {}\n\n  Object.defineProperty(ctx, \"mozCurrentTransform\", {\n    get: function getCurrentTransform() {\n      return this._transformMatrix;\n    }\n  });\n  Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\n    get: function getCurrentTransformInverse() {\n      const [a, b, c, d, e, f] = this._transformMatrix;\n      const ad_bc = a * d - b * c;\n      const bc_ad = b * c - a * d;\n      return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n    }\n  });\n\n  ctx.save = function ctxSave() {\n    const old = this._transformMatrix;\n\n    this._transformStack.push(old);\n\n    this._transformMatrix = old.slice(0, 6);\n\n    this._originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    const prev = this._transformStack.pop();\n\n    if (prev) {\n      this._transformMatrix = prev;\n\n      this._originalRestore();\n    }\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    const m = this._transformMatrix;\n    m[4] = m[0] * x + m[2] * y + m[4];\n    m[5] = m[1] * x + m[3] * y + m[5];\n\n    this._originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    const m = this._transformMatrix;\n    m[0] *= x;\n    m[1] *= x;\n    m[2] *= y;\n    m[3] *= y;\n\n    this._originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    const m = this._transformMatrix;\n    this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n\n    ctx._originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    this._transformMatrix = [a, b, c, d, e, f];\n\n    ctx._originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    this._transformMatrix = [1, 0, 0, 1, 0, 0];\n\n    ctx._originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    const cosValue = Math.cos(angle);\n    const sinValue = Math.sin(angle);\n    const m = this._transformMatrix;\n    this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n\n    this._originalRotate(angle);\n  };\n}\n\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  getCanvas(id, width, height, trackTransform) {\n    let canvasEntry;\n\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n\n    if (trackTransform) {\n      addContextCurrentTransform(canvasEntry.context);\n    }\n\n    return canvasEntry;\n  }\n\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n\n}\n\nfunction compileType3Glyph(imgData) {\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  const width = imgData.width,\n        height = imgData.height,\n        width1 = width + 1;\n  let i, ii, j, j0;\n  const points = new Uint8Array(width1 * (height + 1));\n  const lineSize = width + 7 & ~7,\n        data0 = imgData.data;\n  const data = new Uint8Array(lineSize * height);\n  let pos = 0;\n\n  for (i = 0, ii = data0.length; i < ii; i++) {\n    const elem = data0[i];\n    let mask = 128;\n\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  let count = 0;\n  pos = 0;\n\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const outlines = [];\n\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n\n    while (p < end && !points[p]) {\n      p++;\n    }\n\n    if (p === end) {\n      continue;\n    }\n\n    const coords = [p % width1, i];\n    const p0 = p;\n    let type = points[p];\n\n    do {\n      const step = steps[type];\n\n      do {\n        p += step;\n      } while (!points[p]);\n\n      const pp = points[p];\n\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n\n      coords.push(p % width1, p / width1 | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n\n    outlines.push(coords);\n    --i;\n  }\n\n  const drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.beginPath();\n\n    for (let k = 0, kk = outlines.length; k < kk; k++) {\n      const o = outlines[k];\n      c.moveTo(o[0], o[1]);\n\n      for (let l = 2, ll = o.length; l < ll; l += 2) {\n        c.lineTo(o[l], o[l + 1]);\n      }\n    }\n\n    c.fill();\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nclass CanvasExtraState {\n  constructor(width, height) {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = null;\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  updatePathMinMax(transform, x, y) {\n    [x, y] = _util.Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3) {\n    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n\n    this.updatePathMinMax(transform, box[0], box[1]);\n    this.updatePathMinMax(transform, box[2], box[3]);\n  }\n\n  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n\n    if (pathType === _pattern_helper.PathType.STROKE) {\n      if (!transform) {\n        (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n      }\n\n      const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n      const xStrokePad = scale[0] * this.lineWidth / 2;\n      const yStrokePad = scale[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n\n    return box;\n  }\n\n  updateClipFromPath() {\n    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n\n  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n\n}\n\nfunction putBinaryImageData(ctx, imgData, transferMaps = null) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n      destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n  if (transferMaps) {\n    switch (transferMaps.length) {\n      case 1:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[0];\n        transferMapBlue = transferMaps[0];\n        transferMapGray = transferMaps[0];\n        break;\n\n      case 4:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[1];\n        transferMapBlue = transferMaps[2];\n        transferMapGray = transferMaps[3];\n        break;\n    }\n  }\n\n  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    let white = 0xffffffff;\n    let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n\n    if (transferMapGray) {\n      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n        [white, black] = [black, white];\n      }\n    }\n\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n\n      destPos = 0;\n\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < destPos; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\n\nfunction putBinaryImageMask(ctx, imgData) {\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    let destPos = 3;\n\n    for (let j = 0; j < thisChunkHeight; j++) {\n      let elem,\n          mask = 0;\n\n      for (let k = 0; k < width; k++) {\n        if (!mask) {\n          elem = src[srcPos++];\n          mask = 128;\n        }\n\n        dest[destPos] = elem & mask ? 0 : 255;\n        destPos += 4;\n        mask >>= 1;\n      }\n    }\n\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\n\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n\n  for (let i = 0, ii = properties.length; i < ii; i++) {\n    const property = properties[i];\n\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\n\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = \"#000000\";\n  ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n}\n\nfunction composeSMaskBackdrop(bytes, r0, g0, b0) {\n  const length = bytes.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = bytes[i];\n\n    if (alpha === 0) {\n      bytes[i - 3] = r0;\n      bytes[i - 2] = g0;\n      bytes[i - 1] = b0;\n    } else if (alpha < 255) {\n      const alpha_ = 255 - alpha;\n      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n    }\n  }\n}\n\nfunction composeSMaskAlpha(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  const scale = 1 / 255;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n    layerData[i] = layerData[i] * alpha * scale | 0;\n  }\n}\n\nfunction composeSMaskLuminosity(maskData, layerData, transferMap) {\n  const length = maskData.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n  }\n}\n\nfunction genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n  const hasBackdrop = !!backdrop;\n  const r0 = hasBackdrop ? backdrop[0] : 0;\n  const g0 = hasBackdrop ? backdrop[1] : 0;\n  const b0 = hasBackdrop ? backdrop[2] : 0;\n  let composeFn;\n\n  if (subtype === \"Luminosity\") {\n    composeFn = composeSMaskLuminosity;\n  } else {\n    composeFn = composeSMaskAlpha;\n  }\n\n  const PIXELS_TO_PROCESS = 1048576;\n  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n  for (let row = 0; row < height; row += chunkSize) {\n    const chunkHeight = Math.min(chunkSize, height - row);\n    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n\n    if (hasBackdrop) {\n      composeSMaskBackdrop(maskData.data, r0, g0, b0);\n    }\n\n    composeFn(maskData.data, layerData.data, transferMap);\n    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n  }\n}\n\nfunction composeSMask(ctx, smask, layerCtx, layerBox) {\n  const layerOffsetX = layerBox[0];\n  const layerOffsetY = layerBox[1];\n  const layerWidth = layerBox[2] - layerOffsetX;\n  const layerHeight = layerBox[3] - layerOffsetY;\n\n  if (layerWidth === 0 || layerHeight === 0) {\n    return;\n  }\n\n  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n  ctx.save();\n  ctx.globalAlpha = 1;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.drawImage(layerCtx.canvas, 0, 0);\n  ctx.restore();\n}\n\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n\n  if (interpolate !== undefined) {\n    return interpolate;\n  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n    return true;\n  }\n\n  return false;\n}\n\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\n\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n\n    if (canvasCtx) {\n      addContextCurrentTransform(canvasCtx);\n    }\n\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    this.ctx.save();\n    this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.restore();\n\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height, true);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n    }\n\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n\n    if (transform) {\n      this.ctx.transform.apply(this.ctx, transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n\n    this.ctx.transform.apply(this.ctx, viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = this.ctx.mozCurrentTransform.slice();\n    this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);\n\n    if (this.imageLayer) {\n      this.imageLayer.beginLayout();\n    }\n  }\n\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n\n    if (argsArrayLen === i) {\n      return i;\n    }\n\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n\n      fnId = fnArray[i];\n\n      if (fnId !== _util.OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n\n      i++;\n\n      if (i === argsArrayLen) {\n        return i;\n      }\n\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n\n        steps = 0;\n      }\n    }\n  }\n\n  endDrawing() {\n    while (this.stateStack.length || this.current.activeSMask !== null) {\n      this.restore();\n    }\n\n    this.ctx.restore();\n\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n\n    if (this.imageLayer) {\n      this.imageLayer.endLayout();\n    }\n  }\n\n  _scaleImage(img, inverseTransform) {\n    const width = img.width;\n    const height = img.height;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n        paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n          newHeight = paintHeight;\n\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = Math.ceil(paintHeight / 2);\n        heightScale /= paintHeight / newHeight;\n      }\n\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const width = img.width,\n          height = img.height;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n    const maskCtx = maskCanvas.context;\n    putBinaryImageMask(maskCtx, img);\n    const objToCanvas = ctx.mozCurrentTransform;\n\n    let maskToCanvas = _util.Util.transform(objToCanvas, [1 / width, 0, 0, -1 / height, 0, 0]);\n\n    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n\n    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n\n    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n\n    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n\n    const drawnWidth = Math.ceil(rect[2] - rect[0]);\n    const drawnHeight = Math.ceil(rect[3] - rect[1]);\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight, true);\n    const fillCtx = fillCanvas.context;\n    const offsetX = Math.min(cord1[0], cord2[0]);\n    const offsetY = Math.min(cord1[1], cord2[1]);\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform.apply(fillCtx, maskToCanvas);\n\n    const scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);\n\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);\n    fillCtx.drawImage(scaled.img, 0, 0, scaled.img.width, scaled.img.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n\n    const inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);\n\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n\n  setLineWidth(width) {\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n\n  setRenderingIntent(intent) {}\n\n  setFlatness(flatness) {}\n\n  setGState(states) {\n    for (let i = 0, ii = states.length; i < ii; i++) {\n      const state = states[i];\n      const key = state[0];\n      const value = state[1];\n\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n\n        case \"CA\":\n          this.current.strokeAlpha = state[1];\n          break;\n\n        case \"ca\":\n          this.current.fillAlpha = state[1];\n          this.ctx.globalAlpha = state[1];\n          break;\n\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n\n        case \"TR\":\n          this.current.transferMaps = value;\n      }\n    }\n  }\n\n  checkSMaskState() {\n    const inSMaskMode = !!this.suspendedCtx;\n\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n\n  beginSMaskMode() {\n    if (this.suspendedCtx) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n  }\n\n  endSMaskMode() {\n    if (!this.suspendedCtx) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n\n    this.ctx._removeMirroring();\n\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.current.activeSMask = null;\n    this.suspendedCtx = null;\n  }\n\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n\n  save() {\n    this.ctx.save();\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n\n  restore() {\n    if (this.stateStack.length === 0 && this.current.activeSMask) {\n      this.endSMaskMode();\n    }\n\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n      this.ctx.restore();\n      this.checkSMaskState();\n      this.pendingClip = null;\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  constructPath(ops, args) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n        y = current.y;\n    let startX, startY;\n\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, xw, yh);\n          ctx.closePath();\n          break;\n\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          break;\n\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          break;\n\n        case _util.OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          j += 6;\n          break;\n\n        case _util.OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n\n        case _util.OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], x, y, x, y);\n          j += 4;\n          break;\n\n        case _util.OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n\n    current.setCurrentPoint(x, y);\n  }\n\n  closePath() {\n    this.ctx.closePath();\n  }\n\n  stroke(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        const lineWidth = this.getSinglePixelWidth();\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);\n        ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n        ctx.stroke();\n        ctx.restore();\n      } else {\n        const lineWidth = this.getSinglePixelWidth();\n\n        if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {\n          ctx.save();\n          ctx.resetTransform();\n          ctx.lineWidth = Math.round(this._combinedScaleFactor);\n          ctx.stroke();\n          ctx.restore();\n        } else {\n          ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n          ctx.stroke();\n        }\n      }\n    }\n\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n\n  fill(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);\n      needRestore = true;\n    }\n\n    const intersect = this.current.getClippedPathBoundingBox();\n\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n\n    if (needRestore) {\n      ctx.restore();\n    }\n\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n    this.consumePath();\n  }\n\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n\n  endPath() {\n    this.consumePath();\n  }\n\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n\n  beginText() {\n    this.current.textMatrix = _util.IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n\n    ctx.save();\n    ctx.beginPath();\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      ctx.setTransform.apply(ctx, path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n    }\n\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n\n    if (fontObj.isType3Font) {\n      return;\n    }\n\n    const name = fontObj.loadedName || \"sans-serif\";\n    let bold = \"normal\";\n\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    const typeface = `\"${name}\", ${fontObj.fallbackName}`;\n    let browserFontSize = size;\n\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n\n  paintChar(character, x, y, patternTransform, resetLineWidthToOne) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    let addToPath;\n\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n\n      if (patternTransform) {\n        ctx.setTransform.apply(ctx, patternTransform);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fill();\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (resetLineWidthToOne) {\n          ctx.resetTransform();\n          ctx.lineWidth = Math.round(this._combinedScaleFactor);\n        }\n\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (resetLineWidthToOne) {\n          ctx.save();\n          ctx.moveTo(x, y);\n          ctx.resetTransform();\n          ctx.lineWidth = Math.round(this._combinedScaleFactor);\n          ctx.strokeText(character, 0, 0);\n          ctx.restore();\n        } else {\n          ctx.strokeText(character, x, y);\n        }\n      }\n    }\n\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n      paths.push({\n        transform: ctx.mozCurrentTransform,\n        x,\n        y,\n        fontSize,\n        addToPath\n      });\n    }\n  }\n\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n\n    return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n\n    const fontSize = current.fontSize;\n\n    if (fontSize === 0) {\n      return undefined;\n    }\n\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    ctx.transform.apply(ctx, current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n\n    let patternTransform;\n\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);\n      patternTransform = ctx.mozCurrentTransform;\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n\n    let lineWidth = current.lineWidth;\n    let resetLineWidthToOne = false;\n    const scale = current.textMatrixScale;\n\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        this._cachedGetSinglePixelWidth = null;\n        lineWidth = this.getSinglePixelWidth();\n        resetLineWidthToOne = lineWidth < 0;\n      }\n    } else {\n      lineWidth /= scale;\n    }\n\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n\n    ctx.lineWidth = lineWidth;\n    let x = 0,\n        i;\n\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n\n      if ((0, _util.isNum)(glyph)) {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n\n      if (font.remeasure && width > 0) {\n        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);\n\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);\n          }\n        }\n      }\n\n      let charWidth;\n\n      if (vertical) {\n        charWidth = width * widthAdvanceScale - spacing * fontDirection;\n      } else {\n        charWidth = width * widthAdvanceScale + spacing * fontDirection;\n      }\n\n      x += charWidth;\n\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n\n  showType3Text(glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    ctx.transform.apply(ctx, current.textMatrix);\n    ctx.translate(current.x, current.y);\n    ctx.scale(textHScale, fontDirection);\n\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n\n      if ((0, _util.isNum)(glyph)) {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n      if (!operatorList) {\n        (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform.apply(ctx, fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n\n      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n      width = transformed[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n\n    ctx.restore();\n    this.processingType3 = null;\n  }\n\n  setCharWidth(xWidth, yWidth) {}\n\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.clip();\n    this.endPath();\n  }\n\n  getColorN_Pattern(IR) {\n    let pattern;\n\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => {\n          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);\n        }\n      };\n      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n\n    return pattern;\n  }\n\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n\n  setStrokeRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.strokeStyle = color;\n    this.current.strokeColor = color;\n  }\n\n  setFillRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.fillStyle = color;\n    this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n\n  _getPattern(objId, matrix = null) {\n    let pattern;\n\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n\n    return pattern;\n  }\n\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    this.save();\n\n    const pattern = this._getPattern(objId);\n\n    ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);\n    const inv = ctx.mozCurrentTransformInverse;\n\n    if (inv) {\n      const canvas = ctx.canvas;\n      const width = canvas.width;\n      const height = canvas.height;\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n\n  beginInlineImage() {\n    (0, _util.unreachable)(\"Should not call beginInlineImage\");\n  }\n\n  beginImageData() {\n    (0, _util.unreachable)(\"Should not call beginImageData\");\n  }\n\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform.apply(this, matrix);\n    }\n\n    this.baseTransform = this.ctx.mozCurrentTransform;\n\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[0], bbox[1]);\n      this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[2], bbox[3]);\n      this.clip();\n      this.endPath();\n    }\n  }\n\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n    const suspendedCtx = this.suspendedCtx;\n\n    if (this.current.activeSMask) {\n      this.suspendedCtx = null;\n      this.current.activeSMask = null;\n    }\n\n    const currentCtx = this.ctx;\n\n    if (!group.isolated) {\n      (0, _util.info)(\"TODO: Support non-isolated groups.\");\n    }\n\n    if (group.knockout) {\n      (0, _util.warn)(\"Knockout groups not supported.\");\n    }\n\n    const currentTransform = currentCtx.mozCurrentTransform;\n\n    if (group.matrix) {\n      currentCtx.transform.apply(currentCtx, group.matrix);\n    }\n\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n\n    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    let scaleX = 1,\n        scaleY = 1;\n\n    if (drawnWidth > MAX_GROUP_SIZE) {\n      scaleX = drawnWidth / MAX_GROUP_SIZE;\n      drawnWidth = MAX_GROUP_SIZE;\n    }\n\n    if (drawnHeight > MAX_GROUP_SIZE) {\n      scaleY = drawnHeight / MAX_GROUP_SIZE;\n      drawnHeight = MAX_GROUP_SIZE;\n    }\n\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.scale(1 / scaleX, 1 / scaleY);\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform.apply(groupCtx, currentTransform);\n\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        scaleX,\n        scaleY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    } else {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.scale(scaleX, scaleY);\n      currentCtx.save();\n    }\n\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push({\n      ctx: currentCtx,\n      suspendedCtx\n    });\n    this.groupLevel++;\n  }\n\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const {\n      ctx,\n      suspendedCtx\n    } = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n\n    if (suspendedCtx) {\n      this.suspendedCtx = suspendedCtx;\n    }\n\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = this.ctx.mozCurrentTransform;\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform.apply(this.ctx, currentMtx);\n\n      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n\n  beginAnnotations() {\n    this.save();\n\n    if (this.baseTransform) {\n      this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n    }\n  }\n\n  endAnnotations() {\n    this.restore();\n  }\n\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.save();\n\n    if (Array.isArray(rect) && rect.length === 4) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n\n        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform);\n\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        canvas.style.width = `calc(${width}px * var(--viewport-scale-factor))`;\n        canvas.style.height = `calc(${height}px * var(--viewport-scale-factor))`;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        addContextCurrentTransform(this.ctx);\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n    }\n\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform.apply(this, transform);\n    this.transform.apply(this, matrix);\n  }\n\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n\n    this.restore();\n  }\n\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const width = img.width,\n          height = img.height;\n    const glyph = this.processingType3;\n\n    if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n      if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n        glyph.compiled = compileType3Glyph({\n          data: img.data,\n          width,\n          height\n        });\n      } else {\n        glyph.compiled = null;\n      }\n    }\n\n    if (glyph?.compiled) {\n      glyph.compiled(ctx);\n      return;\n    }\n\n    const mask = this._createMaskCanvas(img);\n\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = ctx.mozCurrentTransform;\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n\n    const mask = this._createMaskCanvas(imgData);\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n\n      const [x, y] = _util.Util.applyTransform([0, 0], trans);\n\n      ctx.drawImage(mask.canvas, x, y);\n    }\n\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n\n    for (let i = 0, ii = images.length; i < ii; i++) {\n      const image = images[i];\n      const width = image.width,\n            height = image.height;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, image);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform.apply(ctx, image.transform);\n      ctx.scale(1, -1);\n      ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    this.paintInlineImageXObject(imgData);\n  }\n\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save();\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n\n    if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n      imgToPaint = tmpCanvas.canvas;\n    }\n\n    const scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);\n\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);\n    ctx.drawImage(scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n\n    if (this.imageLayer) {\n      const position = this.getCanvasPosition(0, -height);\n      this.imageLayer.appendImage({\n        imgData,\n        left: position[0],\n        top: position[1],\n        width: width / ctx.mozCurrentTransformInverse[0],\n        height: height / ctx.mozCurrentTransformInverse[3]\n      });\n    }\n\n    this.compose();\n    this.restore();\n  }\n\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const w = imgData.width;\n    const h = imgData.height;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n    const tmpCtx = tmpCanvas.context;\n    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n    for (let i = 0, ii = map.length; i < ii; i++) {\n      const entry = map[i];\n      ctx.save();\n      ctx.transform.apply(ctx, entry.transform);\n      ctx.scale(1, -1);\n      ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n      if (this.imageLayer) {\n        const position = this.getCanvasPosition(entry.x, entry.y);\n        this.imageLayer.appendImage({\n          imgData,\n          left: position[0],\n          top: position[1],\n          width: w,\n          height: h\n        });\n      }\n\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n\n  markPoint(tag) {}\n\n  markPointProps(tag, properties) {}\n\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n\n    this.contentVisible = this.isContentVisible();\n  }\n\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n\n  beginCompat() {}\n\n  endCompat() {}\n\n  consumePath(clipBox) {\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n\n    const ctx = this.ctx;\n\n    if (this.pendingClip) {\n      if (this.pendingClip === EO_CLIP) {\n        ctx.clip(\"evenodd\");\n      } else {\n        ctx.clip();\n      }\n\n      this.pendingClip = null;\n    }\n\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n\n  getSinglePixelWidth() {\n    if (this._cachedGetSinglePixelWidth === null) {\n      const m = this.ctx.mozCurrentTransform;\n      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n      const sqNorm1 = m[0] ** 2 + m[2] ** 2;\n      const sqNorm2 = m[1] ** 2 + m[3] ** 2;\n      const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;\n\n      if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {\n        this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);\n      } else if (absDet > Number.EPSILON) {\n        this._cachedGetSinglePixelWidth = pixelHeight;\n      } else {\n        this._cachedGetSinglePixelWidth = 1;\n      }\n    }\n\n    return this._cachedGetSinglePixelWidth;\n  }\n\n  getCanvasPosition(x, y) {\n    const transform = this.ctx.mozCurrentTransform;\n    return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n  }\n\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.CanvasGraphics = CanvasGraphics;\n\nfor (const op in _util.OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TilingPattern = exports.PathType = void 0;\nexports.getShadingPattern = getShadingPattern;\n\nvar _util = __w_pdfjs_require__(2);\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nexports.PathType = PathType;\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || typeof Path2D === \"undefined\") {\n    return;\n  }\n\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nclass BaseShadingPattern {\n  constructor() {\n    if (this.constructor === BaseShadingPattern) {\n      (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n    }\n  }\n\n  getPattern() {\n    (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n  }\n\n}\n\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n\n  _createGradient(ctx) {\n    let grad;\n\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n\n    return grad;\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform.apply(tmpCtx, owner.baseTransform);\n\n      if (this.matrix) {\n        tmpCtx.transform.apply(tmpCtx, this.matrix);\n      }\n\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n\n      try {\n        pattern.setTransform(domMatrix);\n      } catch (ex) {\n        (0, _util.warn)(`RadialAxialShadingPattern.getPattern: \"${ex?.message}\".`);\n      }\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n\n    return pattern;\n  }\n\n}\n\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n        colors = context.colors;\n  const bytes = data.data,\n        rowSize = data.width * 4;\n  let tmp;\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n  if (y1 >= y3) {\n    return;\n  }\n\n  const c1r = colors[c1],\n        c1g = colors[c1 + 1],\n        c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n        c2g = colors[c2 + 1],\n        c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n        c3g = colors[c3 + 1],\n        c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n        maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      let k;\n\n      if (y < y1) {\n        k = 0;\n      } else {\n        k = (y1 - y) / (y1 - y2);\n      }\n\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n\n    let k;\n\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\n\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n\n      break;\n\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\n\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n\n    if (backgroundColor) {\n      const bytes = data.data;\n\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n\n    if (pathType === PathType.SHADING) {\n      scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n    } else {\n      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n      if (this.matrix) {\n        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform.apply(ctx, owner.baseTransform);\n\n      if (this.matrix) {\n        ctx.transform.apply(ctx, this.matrix);\n      }\n    }\n\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n\n}\n\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n\n}\n\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\n\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\n\nclass TilingPattern {\n  static get MAX_PATTERN_SIZE() {\n    return (0, _util.shadow)(this, \"MAX_PATTERN_SIZE\", 3000);\n  }\n\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n\n  createPatternCanvas(owner) {\n    const operatorList = this.operatorList;\n    const bbox = this.bbox;\n    const xstep = this.xstep;\n    const ystep = this.ystep;\n    const paintType = this.paintType;\n    const tilingType = this.tilingType;\n    const color = this.color;\n    const canvasGraphicsFactory = this.canvasGraphicsFactory;\n    (0, _util.info)(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n          y0 = bbox[1],\n          x1 = bbox[2],\n          y1 = bbox[3];\n\n    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    let adjustedX0 = x0;\n    let adjustedY0 = y0;\n    let adjustedX1 = x1;\n    let adjustedY1 = y1;\n\n    if (x0 < 0) {\n      adjustedX0 = 0;\n      adjustedX1 += Math.abs(x0);\n    }\n\n    if (y0 < 0) {\n      adjustedY0 = 0;\n      adjustedY1 += Math.abs(y0);\n    }\n\n    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n    graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: adjustedX0,\n      offsetY: adjustedY0\n    };\n  }\n\n  getSizeAndScale(step, realOutputSize, scale) {\n    step = Math.abs(step);\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n\n    return {\n      scale,\n      size\n    };\n  }\n\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.clip();\n    graphics.endPath();\n  }\n\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n          current = graphics.current;\n\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n\n      case PaintType.UNCOLORED:\n        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n\n      default:\n        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n\n    if (pathType !== PathType.SHADING) {\n      matrix = _util.Util.transform(matrix, owner.baseTransform);\n\n      if (this.matrix) {\n        matrix = _util.Util.transform(matrix, this.matrix);\n      }\n    }\n\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n\n    try {\n      pattern.setTransform(domMatrix);\n    } catch (ex) {\n      (0, _util.warn)(`TilingPattern.getPattern: \"${ex?.message}\".`);\n    }\n\n    return pattern;\n  }\n\n}\n\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GlobalWorkerOptions = void 0;\nconst GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MessageHandler = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\n\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    (0, _util.warn)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    return reason;\n  }\n\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n\n    case \"PasswordException\":\n      return new _util.PasswordException(reason.message, reason.code);\n\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n\n      if (data.stream) {\n        this._processStreamMessage(data);\n\n        return;\n      }\n\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n\n        delete this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n\n        return;\n      }\n\n      const action = this.actionHandler[data.action];\n\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n\n      if (data.streamId) {\n        this._createStreamSink(data);\n\n        return;\n      }\n\n      action(data.data);\n    };\n\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n\n    ah[actionName] = handler;\n  }\n\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = (0, _util.createPromiseCapability)();\n    this.callbackCapabilities[callbackId] = capability;\n\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n\n    return capability.promise;\n  }\n\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n          sourceName = this.sourceName,\n          targetName = this.targetName,\n          comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n\n  _createStreamSink(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const self = this,\n          action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = (0, _util.createPromiseCapability)();\n          this.ready = this.sinkCapability.promise;\n        }\n\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n\n      error(reason) {\n        (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n\n      sinkCapability: (0, _util.createPromiseCapability)(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n\n  _processStreamMessage(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n          streamSink = this.streamSinks[streamId];\n\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull && streamSink.onPull());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n\n      case StreamKind.ENQUEUE:\n        (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.controller.enqueue(data.chunk);\n        break;\n\n      case StreamKind.CLOSE:\n        (0, _util.assert)(streamController, \"close should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.isClosed = true;\n        streamController.controller.close();\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.ERROR:\n        (0, _util.assert)(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n\n  async _deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);\n    delete this.streamControllers[streamId];\n  }\n\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n}\n\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Metadata = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass Metadata {\n  #metadataMap;\n  #data;\n\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n\n  getRaw() {\n    return this.#data;\n  }\n\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n\n  getAll() {\n    return (0, _util.objectFromMap)(this.#metadataMap);\n  }\n\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n\n}\n\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.OptionalContentConfig = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass OptionalContentGroup {\n  constructor(name, intent) {\n    this.visible = true;\n    this.name = name;\n    this.intent = intent;\n  }\n\n}\n\nclass OptionalContentConfig {\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n    this._order = null;\n    this._groups = new Map();\n\n    if (data === null) {\n      return;\n    }\n\n    this.name = data.name;\n    this.creator = data.creator;\n    this._order = data.order;\n\n    for (const group of data.groups) {\n      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n    }\n\n    if (data.baseState === \"OFF\") {\n      for (const group of this._groups) {\n        group.visible = false;\n      }\n    }\n\n    for (const on of data.on) {\n      this._groups.get(on).visible = true;\n    }\n\n    for (const off of data.off) {\n      this._groups.get(off).visible = false;\n    }\n  }\n\n  _evaluateVisibilityExpression(array) {\n    const length = array.length;\n\n    if (length < 2) {\n      return true;\n    }\n\n    const operator = array[0];\n\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n\n      if (Array.isArray(element)) {\n        state = this._evaluateVisibilityExpression(element);\n      } else if (this._groups.has(element)) {\n        state = this._groups.get(element).visible;\n      } else {\n        (0, _util.warn)(`Optional content group not found: ${element}`);\n        return true;\n      }\n\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n\n          break;\n\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n\n          break;\n\n        case \"Not\":\n          return !state;\n\n        default:\n          return true;\n      }\n    }\n\n    return operator === \"And\";\n  }\n\n  isVisible(group) {\n    if (this._groups.size === 0) {\n      return true;\n    }\n\n    if (!group) {\n      (0, _util.warn)(\"Optional content group not defined.\");\n      return true;\n    }\n\n    if (group.type === \"OCG\") {\n      if (!this._groups.has(group.id)) {\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n\n      return this._groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this._evaluateVisibilityExpression(group.expression);\n      }\n\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this._groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this._groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this._groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this._groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\n    return true;\n  }\n\n  setVisibility(id, visible = true) {\n    if (!this._groups.has(id)) {\n      (0, _util.warn)(`Optional content group not found: ${id}`);\n      return;\n    }\n\n    this._groups.get(id).visible = !!visible;\n  }\n\n  getOrder() {\n    if (!this._groups.size) {\n      return null;\n    }\n\n    if (this._order) {\n      return this._order.slice();\n    }\n\n    return Array.from(this._groups.keys());\n  }\n\n  getGroups() {\n    return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;\n  }\n\n  getGroup(id) {\n    return this._groups.get(id) || null;\n  }\n\n}\n\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFDataTransportStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nclass PDFDataTransportStream {\n  constructor(params, pdfDataRangeTransport) {\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    this._contentDispositionFilename = params.contentDispositionFilename || null;\n    const initialData = params.initialData;\n\n    if (initialData?.length > 0) {\n      const buffer = new Uint8Array(initialData).buffer;\n\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _onReceiveData(args) {\n    const buffer = new Uint8Array(args.chunk).buffer;\n\n    if (args.begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== args.begin) {\n          return false;\n        }\n\n        rangeReader._enqueue(buffer);\n\n        return true;\n      });\n\n      (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      const firstReader = this._rangeReaders[0];\n\n      if (firstReader?.onProgress) {\n        firstReader.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    } else {\n      const fullReader = this._fullRequestReader;\n\n      if (fullReader?.onProgress) {\n        fullReader.onProgress({\n          loaded: evt.loaded,\n          total: evt.total\n        });\n      }\n    }\n  }\n\n  _onProgressiveDone() {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.progressiveDone();\n    }\n\n    this._progressiveDone = true;\n  }\n\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n    this._rangeReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n\n    this._pdfDataRangeTransport.abort();\n  }\n\n}\n\nexports.PDFDataTransportStream = PDFDataTransportStream;\n\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n\n    this._loaded += chunk.byteLength;\n  }\n\n  get headersReady() {\n    return this._headersReady;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n\n    this._done = true;\n  }\n\n}\n\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n\n      this._requests.length = 0;\n    }\n\n    this._done = true;\n\n    this._stream._removeRangeReader(this);\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._stream._removeRangeReader(this);\n  }\n\n}\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaText = void 0;\n\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n\n      let str = null;\n      const name = node.name;\n\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n\n      if (!node.children) {\n        return;\n      }\n\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n\n    walk(xfa);\n    return output;\n  }\n\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n\n}\n\nexports.XfaText = XfaText;\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationLayer = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _annotation_storage = __w_pdfjs_require__(9);\n\nvar _scripting_utils = __w_pdfjs_require__(19);\n\nvar _xfa_layer = __w_pdfjs_require__(20);\n\nconst DEFAULT_TAB_INDEX = 1000;\nconst GetElementsByNameSet = new WeakSet();\n\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n\n    switch (subtype) {\n      case _util.AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n\n      case _util.AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n\n      case _util.AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n\n            return new PushButtonWidgetAnnotationElement(parameters);\n\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n        }\n\n        return new WidgetAnnotationElement(parameters);\n\n      case _util.AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n\n      case _util.AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n\n      case _util.AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n\n      case _util.AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n\n      case _util.AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n\n      case _util.AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n\n      case _util.AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n\n      case _util.AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n\n      case _util.AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n\n      case _util.AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n\n      case _util.AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n\n}\n\nclass AnnotationElement {\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this._mouseState = parameters.mouseState;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n\n    if (createQuadrilaterals) {\n      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n    }\n  }\n\n  _createContainer(ignoreBorder = false) {\n    const data = this.data,\n          page = this.page,\n          viewport = this.viewport;\n    const container = document.createElement(\"section\");\n    let width = data.rect[2] - data.rect[0];\n    let height = data.rect[3] - data.rect[1];\n    container.setAttribute(\"data-annotation-id\", data.id);\n\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n    if (data.hasOwnCanvas) {\n      const transform = viewport.transform.slice();\n\n      const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(transform);\n\n      width = Math.ceil(width * scaleX);\n      height = Math.ceil(height * scaleY);\n      rect[0] *= scaleX;\n      rect[1] *= scaleY;\n\n      for (let i = 0; i < 4; i++) {\n        transform[i] = Math.sign(transform[i]);\n      }\n\n      container.style.transform = `matrix(${transform.join(\",\")})`;\n    } else {\n      container.style.transform = `matrix(${viewport.transform.join(\",\")})`;\n    }\n\n    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;\n\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n\n      if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\n        width -= 2 * data.borderStyle.width;\n        height -= 2 * data.borderStyle.width;\n      }\n\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `${horizontalRadius}px / ${verticalRadius}px`;\n        container.style.borderRadius = radius;\n      }\n\n      switch (data.borderStyle.style) {\n        case _util.AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = \"solid\";\n          break;\n\n        case _util.AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = \"dashed\";\n          break;\n\n        case _util.AnnotationBorderStyleType.BEVELED:\n          (0, _util.warn)(\"Unimplemented border style: beveled\");\n          break;\n\n        case _util.AnnotationBorderStyleType.INSET:\n          (0, _util.warn)(\"Unimplemented border style: inset\");\n          break;\n\n        case _util.AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = \"solid\";\n          break;\n\n        default:\n          break;\n      }\n\n      const borderColor = data.borderColor || data.color || null;\n\n      if (borderColor) {\n        container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n      } else {\n        container.style.borderWidth = 0;\n      }\n    }\n\n    container.style.left = `${rect[0]}px`;\n    container.style.top = `${rect[1]}px`;\n\n    if (data.hasOwnCanvas) {\n      container.style.width = container.style.height = \"auto\";\n    } else {\n      container.style.width = `${width}px`;\n      container.style.height = `${height}px`;\n    }\n\n    return container;\n  }\n\n  _createQuadrilaterals(ignoreBorder = false) {\n    if (!this.data.quadPoints) {\n      return null;\n    }\n\n    const quadrilaterals = [];\n    const savedRect = this.data.rect;\n\n    for (const quadPoint of this.data.quadPoints) {\n      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n      quadrilaterals.push(this._createContainer(ignoreBorder));\n    }\n\n    this.data.rect = savedRect;\n    return quadrilaterals;\n  }\n\n  _createPopup(trigger, data) {\n    let container = this.container;\n\n    if (this.quadrilaterals) {\n      trigger = trigger || this.quadrilaterals;\n      container = this.quadrilaterals[0];\n    }\n\n    if (!trigger) {\n      trigger = document.createElement(\"div\");\n      trigger.style.height = container.style.height;\n      trigger.style.width = container.style.width;\n      container.appendChild(trigger);\n    }\n\n    const popupElement = new PopupElement({\n      container,\n      trigger,\n      color: data.color,\n      titleObj: data.titleObj,\n      modificationDate: data.modificationDate,\n      contentsObj: data.contentsObj,\n      richText: data.richText,\n      hideWrapper: true\n    });\n    const popup = popupElement.render();\n    popup.style.left = container.style.width;\n    container.appendChild(popup);\n  }\n\n  _renderQuadrilaterals(className) {\n    for (const quadrilateral of this.quadrilaterals) {\n      quadrilateral.className = className;\n    }\n\n    return this.quadrilaterals;\n  }\n\n  render() {\n    (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n  }\n\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n\n          if (id === skipId) {\n            continue;\n          }\n\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.getElementById(id);\n\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n\n      return fields;\n    }\n\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        id,\n        exportValue\n      } = domElement;\n\n      if (id === skipId) {\n        continue;\n      }\n\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n\n    return fields;\n  }\n\n  static get platform() {\n    const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n    return (0, _util.shadow)(this, \"platform\", {\n      isWin: platform.includes(\"Win\"),\n      isMac: platform.includes(\"Mac\")\n    });\n  }\n\n}\n\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions[\"Mouse Up\"] || parameters.data.actions[\"Mouse Down\"]));\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n\n    if (data.url) {\n      if (!linkService.addLinkAttributes) {\n        (0, _util.warn)(\"LinkAnnotationElement.render - missing `addLinkAttributes`-method on the `linkService`-instance.\");\n      }\n\n      linkService.addLinkAttributes?.(link, data.url, data.newWindow);\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n    } else {\n      let hasClickAction = false;\n\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        hasClickAction = true;\n\n        this._bindJSAction(link, data);\n      }\n\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n      } else if (!hasClickAction) {\n        this._bindLink(link, \"\");\n      }\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => {\n        const linkElement = index === 0 ? link : link.cloneNode();\n        quadrilateral.appendChild(linkElement);\n        return quadrilateral;\n      });\n    }\n\n    this.container.className = \"linkAnnotation\";\n    this.container.appendChild(link);\n    return this.container;\n  }\n\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n\n      return false;\n    };\n\n    if (destination || destination === \"\") {\n      link.className = \"internalLink\";\n    }\n  }\n\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n\n    link.className = \"internalLink\";\n  }\n\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n\n      if (!jsName) {\n        continue;\n      }\n\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n\n    link.className = \"internalLink\";\n  }\n\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n\n    link.className = \"internalLink\";\n\n    if (!this._fieldObjects) {\n      (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n\n      return;\n    }\n\n    link.onclick = () => {\n      if (otherClickAction) {\n        otherClickAction();\n      }\n\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n\n      const storage = this.annotationStorage;\n      const allIds = [];\n\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value,\n                valueAsString: value\n              });\n              break;\n            }\n\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          default:\n            continue;\n        }\n\n        const domElement = document.getElementById(id);\n\n        if (!domElement || !GetElementsByNameSet.has(domElement)) {\n          continue;\n        }\n\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n\n      return false;\n    };\n  }\n\n}\n\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    this.container.className = \"textAnnotation\";\n    const image = document.createElement(\"img\");\n    image.style.height = this.container.style.height;\n    image.style.width = this.container.style.width;\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.alt = \"[{{type}} Annotation]\";\n    image.dataset.l10nId = \"text_annotation_type\";\n    image.dataset.l10nArgs = JSON.stringify({\n      type: this.data.name\n    });\n\n    if (!this.data.hasPopup) {\n      this._createPopup(image, this.data);\n    }\n\n    this.container.appendChild(image);\n    return this.container;\n  }\n\n}\n\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    if (this.data.alternativeText) {\n      this.container.title = this.data.alternativeText;\n    }\n\n    return this.container;\n  }\n\n  _getKeyModifier(event) {\n    const {\n      isWin,\n      isMac\n    } = AnnotationElement.platform;\n    return isWin && event.ctrlKey || isMac && event.metaKey;\n  }\n\n  _setEventListener(element, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: event.target.checked\n          }\n        });\n      });\n    }\n  }\n\n  _setEventListeners(element, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        this._setEventListener(element, baseName, eventName, getter);\n      }\n    }\n  }\n\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n  }\n\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));\n    };\n\n    const commonActions = {\n      display: event => {\n        const hidden = event.detail.display % 2 === 1;\n        event.target.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden,\n          print: event.detail.display === 0 || event.detail.display === 3\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          print: event.detail.print\n        });\n      },\n      hidden: event => {\n        event.target.style.visibility = event.detail.hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden: event.detail.hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        if (event.detail.readonly) {\n          event.target.setAttribute(\"readonly\", \"\");\n        } else {\n          event.target.removeAttribute(\"readonly\");\n        }\n      },\n      required: event => {\n        if (event.detail.required) {\n          event.target.setAttribute(\"required\", \"\");\n        } else {\n          event.target.removeAttribute(\"required\");\n        }\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      }\n    };\n\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n\n      if (action) {\n        action(jsEvent);\n      }\n    }\n  }\n\n}\n\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.className = \"textWidgetAnnotation\";\n    let element = null;\n\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue,\n        valueAsString: this.data.fieldValue\n      });\n      const textContent = storedData.valueAsString || storedData.value || \"\";\n      const elementData = {\n        userValue: null,\n        formattedValue: null,\n        beforeInputSelectionRange: null,\n        beforeInputValue: null\n      };\n\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = textContent;\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", textContent);\n      }\n\n      GetElementsByNameSet.add(element);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n      elementData.userValue = textContent;\n      element.setAttribute(\"id\", id);\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue || \"\";\n        element.value = elementData.userValue = defaultValue;\n        delete elementData.formattedValue;\n      });\n\n      let blurListener = event => {\n        if (elementData.formattedValue) {\n          event.target.value = elementData.formattedValue;\n        }\n\n        event.target.scrollLeft = 0;\n        elementData.beforeInputSelectionRange = null;\n      };\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.userValue) {\n            event.target.value = elementData.userValue;\n          }\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value || \"\";\n              storage.setValue(id, {\n                value: elementData.userValue.toString()\n              });\n\n              if (!elementData.formattedValue) {\n                event.target.value = elementData.userValue;\n              }\n            },\n\n            valueAsString(event) {\n              elementData.formattedValue = event.detail.valueAsString || \"\";\n\n              if (event.target !== document.activeElement) {\n                event.target.value = elementData.formattedValue;\n              }\n\n              storage.setValue(id, {\n                formattedValue: elementData.formattedValue\n              });\n            },\n\n            selRange(event) {\n              const [selStart, selEnd] = event.detail.selRange;\n\n              if (selStart >= 0 && selEnd < event.target.value.length) {\n                event.target.setSelectionRange(selStart, selEnd);\n              }\n            }\n\n          };\n\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          elementData.beforeInputValue = event.target.value;\n          let commitKey = -1;\n\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\") {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            commitKey = 3;\n          }\n\n          if (commitKey === -1) {\n            return;\n          }\n\n          elementData.userValue = event.target.value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value: event.target.value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          if (this._mouseState.isDown) {\n            elementData.userValue = event.target.value;\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value: event.target.value,\n                willCommit: true,\n                commitKey: 1,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n\n          _blurListener(event);\n        });\n        element.addEventListener(\"mousedown\", event => {\n          elementData.beforeInputValue = event.target.value;\n          elementData.beforeInputSelectionRange = null;\n        });\n        element.addEventListener(\"keyup\", event => {\n          if (event.target.selectionStart === event.target.selectionEnd) {\n            elementData.beforeInputSelectionRange = null;\n          }\n        });\n        element.addEventListener(\"select\", event => {\n          elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];\n        });\n\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"input\", event => {\n            let selStart = -1;\n            let selEnd = -1;\n\n            if (elementData.beforeInputSelectionRange) {\n              [selStart, selEnd] = elementData.beforeInputSelectionRange;\n            }\n\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value: elementData.beforeInputValue,\n                change: event.data,\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n\n        this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n\n      if (this.data.maxLen !== null) {\n        element.maxLength = this.data.maxLen;\n      }\n\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / this.data.maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n    }\n\n    this._setTextStyle(element);\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontSize,\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const style = element.style;\n\n    if (fontSize) {\n      style.fontSize = `${fontSize}px`;\n    }\n\n    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n\n}\n\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    this.container.className = \"buttonWidgetAnnotation checkBox\";\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.disabled = data.readOnly;\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.setAttribute(\"id\", id);\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n}\n\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"buttonWidgetAnnotation radioButton\";\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.disabled = data.readOnly;\n    element.type = \"radio\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.setAttribute(\"id\", id);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n}\n\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n\n  render() {\n    const container = super.render();\n    container.className = \"buttonWidgetAnnotation pushButton\";\n\n    if (this.data.alternativeText) {\n      container.title = this.data.alternativeText;\n    }\n\n    return container;\n  }\n\n}\n\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"choiceWidgetAnnotation\";\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    storage.getValue(id, {\n      value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined\n    });\n    let {\n      fontSize\n    } = this.data.defaultAppearanceData;\n\n    if (!fontSize) {\n      fontSize = 9;\n    }\n\n    const fontSizeStyle = `calc(${fontSize}px * var(--zoom-factor))`;\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.disabled = this.data.readOnly;\n    selectElement.name = this.data.fieldName;\n    selectElement.setAttribute(\"id\", id);\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n    selectElement.style.fontSize = `${fontSize}px`;\n\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n\n      if (this.data.combo) {\n        optionElement.style.fontSize = fontSizeStyle;\n      }\n\n      if (this.data.fieldValue.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n      }\n\n      selectElement.appendChild(optionElement);\n    }\n\n    const getValue = (event, isExport) => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const options = event.target.options;\n\n      if (!event.target.multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => {\n        return {\n          displayValue: option.textContent,\n          exportValue: option.value\n        };\n      });\n    };\n\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n          },\n\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            selectElement.insertBefore(optionElement, selectElement.children[index]);\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          items(event) {\n            const {\n              items\n            } = event.detail;\n\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.appendChild(optionElement);\n            }\n\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(event, true);\n        const value = getValue(event, false);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value,\n            changeEx: exportValue,\n            willCommit: true,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n\n      this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"]], event => event.target.checked);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(event)\n        });\n      });\n    }\n\n    this._setBackgroundColor(selectElement);\n\n    this.container.appendChild(selectElement);\n    return this.container;\n  }\n\n}\n\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    const IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n    this.container.className = \"popupAnnotation\";\n\n    if (IGNORE_TYPES.includes(this.data.parentType)) {\n      return this.container;\n    }\n\n    const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\n    const parentElements = this.layer.querySelectorAll(selector);\n\n    if (parentElements.length === 0) {\n      return this.container;\n    }\n\n    const popup = new PopupElement({\n      container: this.container,\n      trigger: Array.from(parentElements),\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText\n    });\n    const page = this.page;\n\n    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n\n    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n    const popupTop = rect[1];\n    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;\n    this.container.style.left = `${popupLeft}px`;\n    this.container.style.top = `${popupTop}px`;\n    this.container.appendChild(popup.render());\n    return this.container;\n  }\n\n}\n\nclass PopupElement {\n  constructor(parameters) {\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.titleObj = parameters.titleObj;\n    this.modificationDate = parameters.modificationDate;\n    this.contentsObj = parameters.contentsObj;\n    this.richText = parameters.richText;\n    this.hideWrapper = parameters.hideWrapper || false;\n    this.pinned = false;\n  }\n\n  render() {\n    const BACKGROUND_ENLIGHT = 0.7;\n    const wrapper = document.createElement(\"div\");\n    wrapper.className = \"popupWrapper\";\n    this.hideElement = this.hideWrapper ? wrapper : this.container;\n    this.hideElement.hidden = true;\n    const popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    const color = this.color;\n\n    if (color) {\n      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n    }\n\n    const title = document.createElement(\"h1\");\n    title.dir = this.titleObj.dir;\n    title.textContent = this.titleObj.str;\n    popup.appendChild(title);\n\n    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n    if (dateObject) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.className = \"popupDate\";\n      modificationDate.textContent = \"{{date}}, {{time}}\";\n      modificationDate.dataset.l10nId = \"annotation_date_string\";\n      modificationDate.dataset.l10nArgs = JSON.stringify({\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString()\n      });\n      popup.appendChild(modificationDate);\n    }\n\n    if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {\n      _xfa_layer.XfaLayer.render({\n        xfaHtml: this.richText.html,\n        intent: \"richText\",\n        div: popup\n      });\n\n      popup.lastChild.className = \"richText popupContent\";\n    } else {\n      const contents = this._formatContents(this.contentsObj);\n\n      popup.appendChild(contents);\n    }\n\n    if (!Array.isArray(this.trigger)) {\n      this.trigger = [this.trigger];\n    }\n\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this._toggle.bind(this));\n      element.addEventListener(\"mouseover\", this._show.bind(this, false));\n      element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n    }\n\n    popup.addEventListener(\"click\", this._hide.bind(this, true));\n    wrapper.appendChild(popup);\n    return wrapper;\n  }\n\n  _formatContents({\n    str,\n    dir\n  }) {\n    const p = document.createElement(\"p\");\n    p.className = \"popupContent\";\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.appendChild(document.createTextNode(line));\n\n      if (i < ii - 1) {\n        p.appendChild(document.createElement(\"br\"));\n      }\n    }\n\n    return p;\n  }\n\n  _toggle() {\n    if (this.pinned) {\n      this._hide(true);\n    } else {\n      this._show(true);\n    }\n  }\n\n  _show(pin = false) {\n    if (pin) {\n      this.pinned = true;\n    }\n\n    if (this.hideElement.hidden) {\n      this.hideElement.hidden = false;\n      this.container.style.zIndex += 1;\n    }\n  }\n\n  _hide(unpin = true) {\n    if (unpin) {\n      this.pinned = false;\n    }\n\n    if (!this.hideElement.hidden && !this.pinned) {\n      this.hideElement.hidden = true;\n      this.container.style.zIndex -= 1;\n    }\n  }\n\n}\n\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"freeTextAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass LineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"lineAnnotation\";\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    const line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(line);\n    this.container.append(svg);\n\n    this._createPopup(line, data);\n\n    return this.container;\n  }\n\n}\n\nclass SquareAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"squareAnnotation\";\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    const borderWidth = data.borderStyle.width;\n    const square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(square);\n    this.container.append(svg);\n\n    this._createPopup(square, data);\n\n    return this.container;\n  }\n\n}\n\nclass CircleAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"circleAnnotation\";\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(circle);\n    this.container.append(svg);\n\n    this._createPopup(circle, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolylineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    let points = [];\n\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + \",\" + y);\n    }\n\n    points = points.join(\" \");\n    const polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(polyline);\n    this.container.append(svg);\n\n    this._createPopup(polyline, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n\n}\n\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"caretAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass InkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n\n    for (const inkList of data.inkLists) {\n      let points = [];\n\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n\n      this._createPopup(polyline, data);\n\n      svg.appendChild(polyline);\n    }\n\n    this.container.append(svg);\n    return this.container;\n  }\n\n}\n\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"highlightAnnotation\");\n    }\n\n    this.container.className = \"highlightAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"underlineAnnotation\");\n    }\n\n    this.container.className = \"underlineAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"squigglyAnnotation\");\n    }\n\n    this.container.className = \"squigglyAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n    }\n\n    this.container.className = \"strikeoutAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"stampAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      filename,\n      content\n    } = this.data.file;\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n    this.content = content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      id: (0, _util.stringToPDFString)(filename),\n      filename,\n      content\n    });\n  }\n\n  render() {\n    this.container.className = \"fileAttachmentAnnotation\";\n    const trigger = document.createElement(\"div\");\n    trigger.style.height = this.container.style.height;\n    trigger.style.width = this.container.style.width;\n    trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n    if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {\n      this._createPopup(trigger, this.data);\n    }\n\n    this.container.appendChild(trigger);\n    return this.container;\n  }\n\n  _download() {\n    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n  }\n\n}\n\nclass AnnotationLayer {\n  static render(parameters) {\n    const sortedAnnotations = [],\n          popupAnnotations = [];\n\n    for (const data of parameters.annotations) {\n      if (!data) {\n        continue;\n      }\n\n      if (data.annotationType === _util.AnnotationType.POPUP) {\n        popupAnnotations.push(data);\n        continue;\n      }\n\n      sortedAnnotations.push(data);\n    }\n\n    if (popupAnnotations.length) {\n      sortedAnnotations.push(...popupAnnotations);\n    }\n\n    const div = parameters.div;\n\n    for (const data of sortedAnnotations) {\n      const element = AnnotationElementFactory.create({\n        data,\n        layer: div,\n        page: parameters.page,\n        viewport: parameters.viewport,\n        linkService: parameters.linkService,\n        downloadManager: parameters.downloadManager,\n        imageResourcesPath: parameters.imageResourcesPath || \"\",\n        renderForms: parameters.renderForms !== false,\n        svgFactory: new _display_utils.DOMSVGFactory(),\n        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\n        enableScripting: parameters.enableScripting,\n        hasJSActions: parameters.hasJSActions,\n        fieldObjects: parameters.fieldObjects,\n        mouseState: parameters.mouseState || {\n          isDown: false\n        }\n      });\n\n      if (element.isRenderable) {\n        const rendered = element.render();\n\n        if (data.hidden) {\n          rendered.style.visibility = \"hidden\";\n        }\n\n        if (Array.isArray(rendered)) {\n          for (const renderedElement of rendered) {\n            div.appendChild(renderedElement);\n          }\n        } else {\n          if (element instanceof PopupAnnotationElement) {\n            div.prepend(rendered);\n          } else {\n            div.appendChild(rendered);\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);\n  }\n\n  static update(parameters) {\n    const {\n      page,\n      viewport,\n      annotations,\n      annotationCanvasMap,\n      div\n    } = parameters;\n    const transform = viewport.transform;\n    const matrix = `matrix(${transform.join(\",\")})`;\n    let scale, ownMatrix;\n\n    for (const data of annotations) {\n      const elements = div.querySelectorAll(`[data-annotation-id=\"${data.id}\"]`);\n\n      if (elements) {\n        for (const element of elements) {\n          if (data.hasOwnCanvas) {\n            const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n            if (!ownMatrix) {\n              scale = Math.abs(transform[0] || transform[1]);\n              const ownTransform = transform.slice();\n\n              for (let i = 0; i < 4; i++) {\n                ownTransform[i] = Math.sign(ownTransform[i]);\n              }\n\n              ownMatrix = `matrix(${ownTransform.join(\",\")})`;\n            }\n\n            const left = rect[0] * scale;\n            const top = rect[1] * scale;\n            element.style.left = `${left}px`;\n            element.style.top = `${top}px`;\n            element.style.transformOrigin = `${-left}px ${-top}px`;\n            element.style.transform = ownMatrix;\n          } else {\n            element.style.transform = matrix;\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, annotationCanvasMap);\n    div.hidden = false;\n  }\n\n  static #setAnnotationCanvasMap(div, annotationCanvasMap) {\n    if (!annotationCanvasMap) {\n      return;\n    }\n\n    for (const [id, canvas] of annotationCanvasMap) {\n      const element = div.querySelector(`[data-annotation-id=\"${id}\"]`);\n\n      if (!element) {\n        continue;\n      }\n\n      const {\n        firstChild\n      } = element;\n\n      if (firstChild.nodeName === \"CANVAS\") {\n        element.replaceChild(canvas, firstChild);\n      } else {\n        element.insertBefore(canvas, firstChild);\n      }\n    }\n\n    annotationCanvasMap.clear();\n  }\n\n}\n\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\n\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\n\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n\n  static RGB_HTML([r, g, b]) {\n    const R = makeColorComp(r);\n    const G = makeColorComp(g);\n    const B = makeColorComp(b);\n    return `#${R}${G}${B}`;\n  }\n\n  static T_HTML() {\n    return \"#00000000\";\n  }\n\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n\n  static CMYK_HTML(components) {\n    return this.RGB_HTML(this.CMYK_RGB(components));\n  }\n\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n\n}\n\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 20 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaLayer = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _xfa_text = __w_pdfjs_require__(17);\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n\n        if (intent === \"print\") {\n          break;\n        }\n\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n\n        break;\n\n      case \"select\":\n        if (storedData.value !== null) {\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            }\n          }\n        }\n\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined || key === \"dataId\") {\n        continue;\n      }\n\n      if (key !== \"style\") {\n        if (key === \"textContent\") {\n          html.textContent = value;\n        } else if (key === \"class\") {\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n        } else {\n          if (isHTMLAnchorElement && (key === \"href\" || key === \"newWindow\")) {\n            continue;\n          }\n\n          html.setAttribute(key, value);\n        }\n      } else {\n        Object.assign(html.style, value);\n      }\n    }\n\n    if (isHTMLAnchorElement) {\n      if (!linkService.addLinkAttributes) {\n        (0, _util.warn)(\"XfaLayer.setAttribute - missing `addLinkAttributes`-method on the `linkService`-instance.\");\n      }\n\n      linkService.addLinkAttributes?.(html, attributes.href, attributes.newWindow);\n    }\n\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n\n    const stack = [[root, -1, rootHtml]];\n    const rootDiv = parameters.div;\n    rootDiv.appendChild(rootHtml);\n\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n\n    if (intent !== \"richText\") {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n\n    const textDivs = [];\n\n    while (stack.length > 0) {\n      const [parent, i, html] = stack[stack.length - 1];\n\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n\n      const child = parent.children[++stack[stack.length - 1][1]];\n\n      if (child === null) {\n        continue;\n      }\n\n      const {\n        name\n      } = child;\n\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.appendChild(node);\n        continue;\n      }\n\n      let childHtml;\n\n      if (child?.attributes?.xmlns) {\n        childHtml = document.createElementNS(child.attributes.xmlns, name);\n      } else {\n        childHtml = document.createElement(name);\n      }\n\n      html.appendChild(childHtml);\n\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n\n      if (child.children && child.children.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n\n        if (_xfa_text.XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n\n        childHtml.appendChild(node);\n      }\n    }\n\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n\n    return {\n      textDivs\n    };\n  }\n\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n\n}\n\nexports.XfaLayer = XfaLayer;\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.renderTextLayer = renderTextLayer;\n\nvar _util = __w_pdfjs_require__(2);\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nconst ascentCache = new Map();\nconst AllWhitespaceRegexp = /^\\s+$/g;\n\nfunction getAscent(fontFamily, ctx) {\n  const cachedAscent = ascentCache.get(fontFamily);\n\n  if (cachedAscent) {\n    return cachedAscent;\n  }\n\n  ctx.save();\n  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n  const metrics = ctx.measureText(\"\");\n  let ascent = metrics.fontBoundingBoxAscent;\n  let descent = Math.abs(metrics.fontBoundingBoxDescent);\n\n  if (ascent) {\n    ctx.restore();\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ctx.strokeStyle = \"red\";\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"g\", 0, 0);\n  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  descent = 0;\n\n  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n    if (pixels[i] > 0) {\n      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  ascent = 0;\n\n  for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n    if (pixels[i] > 0) {\n      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.restore();\n\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n  return DEFAULT_FONT_ASCENT;\n}\n\nfunction appendText(task, geom, styles, ctx) {\n  const textDiv = document.createElement(\"span\");\n  const textDivProperties = task._enhanceTextSelection ? {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    originalTransform: null,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    paddingRight: 0,\n    paddingTop: 0,\n    scale: 1\n  } : {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL\n  };\n\n  task._textDivs.push(textDiv);\n\n  const tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n  let angle = Math.atan2(tx[1], tx[0]);\n  const style = styles[geom.fontName];\n\n  if (style.vertical) {\n    angle += Math.PI / 2;\n  }\n\n  const fontHeight = Math.hypot(tx[2], tx[3]);\n  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);\n  let left, top;\n\n  if (angle === 0) {\n    left = tx[4];\n    top = tx[5] - fontAscent;\n  } else {\n    left = tx[4] + fontAscent * Math.sin(angle);\n    top = tx[5] - fontAscent * Math.cos(angle);\n  }\n\n  textDiv.style.left = `${left}px`;\n  textDiv.style.top = `${top}px`;\n  textDiv.style.fontSize = `${fontHeight}px`;\n  textDiv.style.fontFamily = style.fontFamily;\n  textDiv.setAttribute(\"role\", \"presentation\");\n  textDiv.textContent = geom.str;\n  textDiv.dir = geom.dir;\n\n  if (task._fontInspectorEnabled) {\n    textDiv.dataset.fontName = geom.fontName;\n  }\n\n  if (angle !== 0) {\n    textDivProperties.angle = angle * (180 / Math.PI);\n  }\n\n  let shouldScaleText = false;\n\n  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {\n    shouldScaleText = true;\n  } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n    const absScaleX = Math.abs(geom.transform[0]),\n          absScaleY = Math.abs(geom.transform[3]);\n\n    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n      shouldScaleText = true;\n    }\n  }\n\n  if (shouldScaleText) {\n    if (style.vertical) {\n      textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n    } else {\n      textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n    }\n  }\n\n  task._textDivProperties.set(textDiv, textDivProperties);\n\n  if (task._textContentStream) {\n    task._layoutText(textDiv);\n  }\n\n  if (task._enhanceTextSelection && textDivProperties.hasText) {\n    let angleCos = 1,\n        angleSin = 0;\n\n    if (angle !== 0) {\n      angleCos = Math.cos(angle);\n      angleSin = Math.sin(angle);\n    }\n\n    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n    const divHeight = fontHeight;\n    let m, b;\n\n    if (angle !== 0) {\n      m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n    } else {\n      b = [left, top, left + divWidth, top + divHeight];\n    }\n\n    task._bounds.push({\n      left: b[0],\n      top: b[1],\n      right: b[2],\n      bottom: b[3],\n      div: textDiv,\n      size: [divWidth, divHeight],\n      m\n    });\n  }\n}\n\nfunction render(task) {\n  if (task._canceled) {\n    return;\n  }\n\n  const textDivs = task._textDivs;\n  const capability = task._capability;\n  const textDivsLength = textDivs.length;\n\n  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n    task._renderingDone = true;\n    capability.resolve();\n    return;\n  }\n\n  if (!task._textContentStream) {\n    for (let i = 0; i < textDivsLength; i++) {\n      task._layoutText(textDivs[i]);\n    }\n  }\n\n  task._renderingDone = true;\n  capability.resolve();\n}\n\nfunction findPositiveMin(ts, offset, count) {\n  let result = 0;\n\n  for (let i = 0; i < count; i++) {\n    const t = ts[offset++];\n\n    if (t > 0) {\n      result = result ? Math.min(t, result) : t;\n    }\n  }\n\n  return result;\n}\n\nfunction expand(task) {\n  const bounds = task._bounds;\n  const viewport = task._viewport;\n  const expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n  for (let i = 0; i < expanded.length; i++) {\n    const div = bounds[i].div;\n\n    const divProperties = task._textDivProperties.get(div);\n\n    if (divProperties.angle === 0) {\n      divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n      divProperties.paddingTop = bounds[i].top - expanded[i].top;\n      divProperties.paddingRight = expanded[i].right - bounds[i].right;\n      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n      task._textDivProperties.set(div, divProperties);\n\n      continue;\n    }\n\n    const e = expanded[i],\n          b = bounds[i];\n    const m = b.m,\n          c = m[0],\n          s = m[1];\n    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n    const ts = new Float64Array(64);\n\n    for (let j = 0, jj = points.length; j < jj; j++) {\n      const t = _util.Util.applyTransform(points[j], m);\n\n      ts[j + 0] = c && (e.left - t[0]) / c;\n      ts[j + 4] = s && (e.top - t[1]) / s;\n      ts[j + 8] = c && (e.right - t[0]) / c;\n      ts[j + 12] = s && (e.bottom - t[1]) / s;\n      ts[j + 16] = s && (e.left - t[0]) / -s;\n      ts[j + 20] = c && (e.top - t[1]) / c;\n      ts[j + 24] = s && (e.right - t[0]) / -s;\n      ts[j + 28] = c && (e.bottom - t[1]) / c;\n      ts[j + 32] = c && (e.left - t[0]) / -c;\n      ts[j + 36] = s && (e.top - t[1]) / -s;\n      ts[j + 40] = c && (e.right - t[0]) / -c;\n      ts[j + 44] = s && (e.bottom - t[1]) / -s;\n      ts[j + 48] = s && (e.left - t[0]) / s;\n      ts[j + 52] = c && (e.top - t[1]) / -c;\n      ts[j + 56] = s && (e.right - t[0]) / s;\n      ts[j + 60] = c && (e.bottom - t[1]) / -c;\n    }\n\n    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n    task._textDivProperties.set(div, divProperties);\n  }\n}\n\nfunction expandBounds(width, height, boxes) {\n  const bounds = boxes.map(function (box, i) {\n    return {\n      x1: box.left,\n      y1: box.top,\n      x2: box.right,\n      y2: box.bottom,\n      index: i,\n      x1New: undefined,\n      x2New: undefined\n    };\n  });\n  expandBoundsLTR(width, bounds);\n  const expanded = new Array(boxes.length);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i] = {\n      left: b.x1New,\n      top: 0,\n      right: b.x2New,\n      bottom: 0\n    };\n  }\n\n  boxes.map(function (box, i) {\n    const e = expanded[i],\n          b = bounds[i];\n    b.x1 = box.top;\n    b.y1 = width - e.right;\n    b.x2 = box.bottom;\n    b.y2 = width - e.left;\n    b.index = i;\n    b.x1New = undefined;\n    b.x2New = undefined;\n  });\n  expandBoundsLTR(height, bounds);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i].top = b.x1New;\n    expanded[i].bottom = b.x2New;\n  }\n\n  return expanded;\n}\n\nfunction expandBoundsLTR(width, bounds) {\n  bounds.sort(function (a, b) {\n    return a.x1 - b.x1 || a.index - b.index;\n  });\n  const fakeBoundary = {\n    x1: -Infinity,\n    y1: -Infinity,\n    x2: 0,\n    y2: Infinity,\n    index: -1,\n    x1New: 0,\n    x2New: 0\n  };\n  const horizon = [{\n    start: -Infinity,\n    end: Infinity,\n    boundary: fakeBoundary\n  }];\n\n  for (const boundary of bounds) {\n    let i = 0;\n\n    while (i < horizon.length && horizon[i].end <= boundary.y1) {\n      i++;\n    }\n\n    let j = horizon.length - 1;\n\n    while (j >= 0 && horizon[j].start >= boundary.y2) {\n      j--;\n    }\n\n    let horizonPart, affectedBoundary;\n    let q,\n        k,\n        maxXNew = -Infinity;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      let xNew;\n\n      if (affectedBoundary.x2 > boundary.x1) {\n        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n      } else if (affectedBoundary.x2New === undefined) {\n        xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n      } else {\n        xNew = affectedBoundary.x2New;\n      }\n\n      if (xNew > maxXNew) {\n        maxXNew = xNew;\n      }\n    }\n\n    boundary.x1New = maxXNew;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New === undefined) {\n        if (affectedBoundary.x2 > boundary.x1) {\n          if (affectedBoundary.index > boundary.index) {\n            affectedBoundary.x2New = affectedBoundary.x2;\n          }\n        } else {\n          affectedBoundary.x2New = maxXNew;\n        }\n      } else if (affectedBoundary.x2New > maxXNew) {\n        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n      }\n    }\n\n    const changedHorizon = [];\n    let lastBoundary = null;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n      if (lastBoundary === useBoundary) {\n        changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n      } else {\n        changedHorizon.push({\n          start: horizonPart.start,\n          end: horizonPart.end,\n          boundary: useBoundary\n        });\n        lastBoundary = useBoundary;\n      }\n    }\n\n    if (horizon[i].start < boundary.y1) {\n      changedHorizon[0].start = boundary.y1;\n      changedHorizon.unshift({\n        start: horizon[i].start,\n        end: boundary.y1,\n        boundary: horizon[i].boundary\n      });\n    }\n\n    if (boundary.y2 < horizon[j].end) {\n      changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n      changedHorizon.push({\n        start: boundary.y2,\n        end: horizon[j].end,\n        boundary: horizon[j].boundary\n      });\n    }\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New !== undefined) {\n        continue;\n      }\n\n      let used = false;\n\n      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = 0; !used && k < changedHorizon.length; k++) {\n        used = changedHorizon[k].boundary === affectedBoundary;\n      }\n\n      if (!used) {\n        affectedBoundary.x2New = maxXNew;\n      }\n    }\n\n    Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\n  }\n\n  for (const horizonPart of horizon) {\n    const affectedBoundary = horizonPart.boundary;\n\n    if (affectedBoundary.x2New === undefined) {\n      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n    }\n  }\n}\n\nclass TextLayerRenderTask {\n  constructor({\n    textContent,\n    textContentStream,\n    container,\n    viewport,\n    textDivs,\n    textContentItemsStr,\n    enhanceTextSelection\n  }) {\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = (0, _util.createPromiseCapability)();\n    this._renderTimer = null;\n    this._bounds = [];\n\n    this._capability.promise.finally(() => {\n      if (!this._enhanceTextSelection) {\n        this._textDivProperties = null;\n      }\n\n      if (this._layoutTextCtx) {\n        this._layoutTextCtx.canvas.width = 0;\n        this._layoutTextCtx.canvas.height = 0;\n        this._layoutTextCtx = null;\n      }\n    }).catch(() => {});\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  cancel() {\n    this._canceled = true;\n\n    if (this._reader) {\n      this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {});\n\n      this._reader = null;\n    }\n\n    if (this._renderTimer !== null) {\n      clearTimeout(this._renderTimer);\n      this._renderTimer = null;\n    }\n\n    this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n  }\n\n  _processItems(items, styleCache) {\n    for (let i = 0, len = items.length; i < len; i++) {\n      if (items[i].str === undefined) {\n        if (items[i].type === \"beginMarkedContentProps\" || items[i].type === \"beginMarkedContent\") {\n          const parent = this._container;\n          this._container = document.createElement(\"span\");\n\n          this._container.classList.add(\"markedContent\");\n\n          if (items[i].id !== null) {\n            this._container.setAttribute(\"id\", `${items[i].id}`);\n          }\n\n          parent.appendChild(this._container);\n        } else if (items[i].type === \"endMarkedContent\") {\n          this._container = this._container.parentNode;\n        }\n\n        continue;\n      }\n\n      this._textContentItemsStr.push(items[i].str);\n\n      appendText(this, items[i], styleCache, this._layoutTextCtx);\n    }\n  }\n\n  _layoutText(textDiv) {\n    const textDivProperties = this._textDivProperties.get(textDiv);\n\n    let transform = \"\";\n\n    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {\n      const {\n        fontSize,\n        fontFamily\n      } = textDiv.style;\n\n      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n        this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;\n        this._layoutTextLastFontSize = fontSize;\n        this._layoutTextLastFontFamily = fontFamily;\n      }\n\n      const {\n        width\n      } = this._layoutTextCtx.measureText(textDiv.textContent);\n\n      if (width > 0) {\n        const scale = textDivProperties.canvasWidth / width;\n\n        if (this._enhanceTextSelection) {\n          textDivProperties.scale = scale;\n        }\n\n        transform = `scaleX(${scale})`;\n      }\n    }\n\n    if (textDivProperties.angle !== 0) {\n      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n    }\n\n    if (transform.length > 0) {\n      if (this._enhanceTextSelection) {\n        textDivProperties.originalTransform = transform;\n      }\n\n      textDiv.style.transform = transform;\n    }\n\n    if (textDivProperties.hasText) {\n      this._container.appendChild(textDiv);\n    }\n\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n\n      this._container.appendChild(br);\n    }\n  }\n\n  _render(timeout = 0) {\n    const capability = (0, _util.createPromiseCapability)();\n    let styleCache = Object.create(null);\n\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.height = canvas.width = DEFAULT_FONT_SIZE;\n    canvas.mozOpaque = true;\n    this._layoutTextCtx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n\n    if (this._textContent) {\n      const textItems = this._textContent.items;\n      const textStyles = this._textContent.styles;\n\n      this._processItems(textItems, textStyles);\n\n      capability.resolve();\n    } else if (this._textContentStream) {\n      const pump = () => {\n        this._reader.read().then(({\n          value,\n          done\n        }) => {\n          if (done) {\n            capability.resolve();\n            return;\n          }\n\n          Object.assign(styleCache, value.styles);\n\n          this._processItems(value.items, styleCache);\n\n          pump();\n        }, capability.reject);\n      };\n\n      this._reader = this._textContentStream.getReader();\n      pump();\n    } else {\n      throw new Error('Neither \"textContent\" nor \"textContentStream\" parameters specified.');\n    }\n\n    capability.promise.then(() => {\n      styleCache = null;\n\n      if (!timeout) {\n        render(this);\n      } else {\n        this._renderTimer = setTimeout(() => {\n          render(this);\n          this._renderTimer = null;\n        }, timeout);\n      }\n    }, this._capability.reject);\n  }\n\n  expandTextDivs(expandDivs = false) {\n    if (!this._enhanceTextSelection || !this._renderingDone) {\n      return;\n    }\n\n    if (this._bounds !== null) {\n      expand(this);\n      this._bounds = null;\n    }\n\n    const transformBuf = [],\n          paddingBuf = [];\n\n    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\n      const div = this._textDivs[i];\n\n      const divProps = this._textDivProperties.get(div);\n\n      if (!divProps.hasText) {\n        continue;\n      }\n\n      if (expandDivs) {\n        transformBuf.length = 0;\n        paddingBuf.length = 0;\n\n        if (divProps.originalTransform) {\n          transformBuf.push(divProps.originalTransform);\n        }\n\n        if (divProps.paddingTop > 0) {\n          paddingBuf.push(`${divProps.paddingTop}px`);\n          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingRight > 0) {\n          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingBottom > 0) {\n          paddingBuf.push(`${divProps.paddingBottom}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingLeft > 0) {\n          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        div.style.padding = paddingBuf.join(\" \");\n\n        if (transformBuf.length) {\n          div.style.transform = transformBuf.join(\" \");\n        }\n      } else {\n        div.style.padding = null;\n        div.style.transform = divProps.originalTransform;\n      }\n    }\n  }\n\n}\n\nfunction renderTextLayer(renderParameters) {\n  const task = new TextLayerRenderTask({\n    textContent: renderParameters.textContent,\n    textContentStream: renderParameters.textContentStream,\n    container: renderParameters.container,\n    viewport: renderParameters.viewport,\n    textDivs: renderParameters.textDivs,\n    textContentItemsStr: renderParameters.textContentItemsStr,\n    enhanceTextSelection: renderParameters.enhanceTextSelection\n  });\n\n  task._render(renderParameters.timeout);\n\n  return task;\n}\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SVGGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(4);\n\nlet SVGGraphics = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: SVGGraphics\");\n  }\n\n};\nexports.SVGGraphics = SVGGraphics;\n{\n  const SVG_DEFAULTS = {\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    fillColor: \"#000000\"\n  };\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n  const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n  const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n  const convertImgDataToPng = function () {\n    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n    const CHUNK_WRAPPER_SIZE = 12;\n    const crcTable = new Int32Array(256);\n\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n\n      for (let h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n        } else {\n          c = c >> 1 & 0x7fffffff;\n        }\n      }\n\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      let crc = -1;\n\n      for (let i = start; i < end; i++) {\n        const a = (crc ^ data[i]) & 0xff;\n        const b = crcTable[a];\n        crc = crc >>> 8 ^ b;\n      }\n\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      let p = offset;\n      const len = body.length;\n      data[p] = len >> 24 & 0xff;\n      data[p + 1] = len >> 16 & 0xff;\n      data[p + 2] = len >> 8 & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n      data.set(body, p);\n      p += body.length;\n      const crc = crc32(data, offset + 4, p);\n      data[p] = crc >> 24 & 0xff;\n      data[p + 1] = crc >> 16 & 0xff;\n      data[p + 2] = crc >> 8 & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      let a = 1;\n      let b = 0;\n\n      for (let i = start; i < end; ++i) {\n        a = (a + (data[i] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      return b << 16 | a;\n    }\n\n    function deflateSync(literals) {\n      if (!_is_node.isNodeJS) {\n        return deflateSyncUncompressed(literals);\n      }\n\n      try {\n        let input;\n\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          input = Buffer.from(literals);\n        }\n\n        const output = require(\"zlib\").deflateSync(input, {\n          level: 9\n        });\n\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    function deflateSyncUncompressed(literals) {\n      let len = literals.length;\n      const maxBlockLength = 0xffff;\n      const deflateBlocks = Math.ceil(len / maxBlockLength);\n      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      let pi = 0;\n      idat[pi++] = 0x78;\n      idat[pi++] = 0x9c;\n      let pos = 0;\n\n      while (len > maxBlockLength) {\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = len >> 8 & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n      const adler = adler32(literals, 0, literals.length);\n      idat[pi++] = adler >> 24 & 0xff;\n      idat[pi++] = adler >> 16 & 0xff;\n      idat[pi++] = adler >> 8 & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      let bitDepth, colorType, lineSize;\n      const bytes = imgData.data;\n\n      switch (kind) {\n        case _util.ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = width + 7 >> 3;\n          break;\n\n        case _util.ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n\n        case _util.ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n\n        default:\n          throw new Error(\"invalid format\");\n      }\n\n      const literals = new Uint8Array((1 + lineSize) * height);\n      let offsetLiterals = 0,\n          offsetBytes = 0;\n\n      for (let y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0;\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n        offsetLiterals = 0;\n\n        for (let y = 0; y < height; y++) {\n          offsetLiterals++;\n\n          for (let i = 0; i < lineSize; i++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n      const idat = deflateSync(literals);\n      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      const data = new Uint8Array(pngLength);\n      let offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk(\"IHDR\", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk(\"IDATA\", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n      return (0, _util.createObjectURL)(data, \"image/png\", forceDataSchema);\n    }\n\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  }();\n\n  class SVGExtraState {\n    constructor() {\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = \"#000000\";\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = \"\";\n      this.lineCap = \"\";\n      this.miterLimit = 0;\n      this.dashArray = [];\n      this.dashPhase = 0;\n      this.dependencies = [];\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n      this.maskId = \"\";\n    }\n\n    clone() {\n      return Object.create(this);\n    }\n\n    setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n  }\n\n  function opListToTree(opList) {\n    let opTree = [];\n    const tmp = [];\n\n    for (const opListElement of opList) {\n      if (opListElement.fn === \"save\") {\n        opTree.push({\n          fnId: 92,\n          fn: \"group\",\n          items: []\n        });\n        tmp.push(opTree);\n        opTree = opTree[opTree.length - 1].items;\n        continue;\n      }\n\n      if (opListElement.fn === \"restore\") {\n        opTree = tmp.pop();\n      } else {\n        opTree.push(opListElement);\n      }\n    }\n\n    return opTree;\n  }\n\n  function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n\n    const s = value.toFixed(10);\n    let i = s.length - 1;\n\n    if (s[i] !== \"0\") {\n      return s;\n    }\n\n    do {\n      i--;\n    } while (s[i] === \"0\");\n\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\n  }\n\n  function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return \"\";\n        }\n\n        return `scale(${pf(m[0])} ${pf(m[3])})`;\n      }\n\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        const a = Math.acos(m[0]) * 180 / Math.PI;\n        return `rotate(${pf(a)})`;\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return `translate(${pf(m[4])} ${pf(m[5])})`;\n      }\n    }\n\n    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n  }\n\n  let clipCount = 0;\n  let maskCount = 0;\n  let shadingCount = 0;\n  exports.SVGGraphics = SVGGraphics = class {\n    constructor(commonObjs, objs, forceDataSchema = false) {\n      this.svgFactory = new _display_utils.DOMSVGFactory();\n      this.current = new SVGExtraState();\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n      this._operatorIdMapping = [];\n\n      for (const op in _util.OPS) {\n        this._operatorIdMapping[_util.OPS[op]] = op;\n      }\n    }\n\n    save() {\n      this.transformStack.push(this.transformMatrix);\n      const old = this.current;\n      this.extraStack.push(old);\n      this.current = old.clone();\n    }\n\n    restore() {\n      this.transformMatrix = this.transformStack.pop();\n      this.current = this.extraStack.pop();\n      this.pendingClip = null;\n      this.tgrp = null;\n    }\n\n    group(items) {\n      this.save();\n      this.executeOpTree(items);\n      this.restore();\n    }\n\n    loadDependencies(operatorList) {\n      const fnArray = operatorList.fnArray;\n      const argsArray = operatorList.argsArray;\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        if (fnArray[i] !== _util.OPS.dependency) {\n          continue;\n        }\n\n        for (const obj of argsArray[i]) {\n          const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n          const promise = new Promise(resolve => {\n            objsPool.get(obj, resolve);\n          });\n          this.current.dependencies.push(promise);\n        }\n      }\n\n      return Promise.all(this.current.dependencies);\n    }\n\n    transform(a, b, c, d, e, f) {\n      const transformMatrix = [a, b, c, d, e, f];\n      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n      this.tgrp = null;\n    }\n\n    getSVG(operatorList, viewport) {\n      this.viewport = viewport;\n\n      const svgElement = this._initialize(viewport);\n\n      return this.loadDependencies(operatorList).then(() => {\n        this.transformMatrix = _util.IDENTITY_MATRIX;\n        this.executeOpTree(this.convertOpList(operatorList));\n        return svgElement;\n      });\n    }\n\n    convertOpList(operatorList) {\n      const operatorIdMapping = this._operatorIdMapping;\n      const argsArray = operatorList.argsArray;\n      const fnArray = operatorList.fnArray;\n      const opList = [];\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        const fnId = fnArray[i];\n        opList.push({\n          fnId,\n          fn: operatorIdMapping[fnId],\n          args: argsArray[i]\n        });\n      }\n\n      return opListToTree(opList);\n    }\n\n    executeOpTree(opTree) {\n      for (const opTreeElement of opTree) {\n        const fn = opTreeElement.fn;\n        const fnId = opTreeElement.fnId;\n        const args = opTreeElement.args;\n\n        switch (fnId | 0) {\n          case _util.OPS.beginText:\n            this.beginText();\n            break;\n\n          case _util.OPS.dependency:\n            break;\n\n          case _util.OPS.setLeading:\n            this.setLeading(args);\n            break;\n\n          case _util.OPS.setLeadingMoveText:\n            this.setLeadingMoveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setFont:\n            this.setFont(args);\n            break;\n\n          case _util.OPS.showText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.showSpacedText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.endText:\n            this.endText();\n            break;\n\n          case _util.OPS.moveText:\n            this.moveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setCharSpacing:\n            this.setCharSpacing(args[0]);\n            break;\n\n          case _util.OPS.setWordSpacing:\n            this.setWordSpacing(args[0]);\n            break;\n\n          case _util.OPS.setHScale:\n            this.setHScale(args[0]);\n            break;\n\n          case _util.OPS.setTextMatrix:\n            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.setTextRise:\n            this.setTextRise(args[0]);\n            break;\n\n          case _util.OPS.setTextRenderingMode:\n            this.setTextRenderingMode(args[0]);\n            break;\n\n          case _util.OPS.setLineWidth:\n            this.setLineWidth(args[0]);\n            break;\n\n          case _util.OPS.setLineJoin:\n            this.setLineJoin(args[0]);\n            break;\n\n          case _util.OPS.setLineCap:\n            this.setLineCap(args[0]);\n            break;\n\n          case _util.OPS.setMiterLimit:\n            this.setMiterLimit(args[0]);\n            break;\n\n          case _util.OPS.setFillRGBColor:\n            this.setFillRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeRGBColor:\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeColorN:\n            this.setStrokeColorN(args);\n            break;\n\n          case _util.OPS.setFillColorN:\n            this.setFillColorN(args);\n            break;\n\n          case _util.OPS.shadingFill:\n            this.shadingFill(args[0]);\n            break;\n\n          case _util.OPS.setDash:\n            this.setDash(args[0], args[1]);\n            break;\n\n          case _util.OPS.setRenderingIntent:\n            this.setRenderingIntent(args[0]);\n            break;\n\n          case _util.OPS.setFlatness:\n            this.setFlatness(args[0]);\n            break;\n\n          case _util.OPS.setGState:\n            this.setGState(args[0]);\n            break;\n\n          case _util.OPS.fill:\n            this.fill();\n            break;\n\n          case _util.OPS.eoFill:\n            this.eoFill();\n            break;\n\n          case _util.OPS.stroke:\n            this.stroke();\n            break;\n\n          case _util.OPS.fillStroke:\n            this.fillStroke();\n            break;\n\n          case _util.OPS.eoFillStroke:\n            this.eoFillStroke();\n            break;\n\n          case _util.OPS.clip:\n            this.clip(\"nonzero\");\n            break;\n\n          case _util.OPS.eoClip:\n            this.clip(\"evenodd\");\n            break;\n\n          case _util.OPS.paintSolidColorImageMask:\n            this.paintSolidColorImageMask();\n            break;\n\n          case _util.OPS.paintImageXObject:\n            this.paintImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintInlineImageXObject:\n            this.paintInlineImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintImageMaskXObject:\n            this.paintImageMaskXObject(args[0]);\n            break;\n\n          case _util.OPS.paintFormXObjectBegin:\n            this.paintFormXObjectBegin(args[0], args[1]);\n            break;\n\n          case _util.OPS.paintFormXObjectEnd:\n            this.paintFormXObjectEnd();\n            break;\n\n          case _util.OPS.closePath:\n            this.closePath();\n            break;\n\n          case _util.OPS.closeStroke:\n            this.closeStroke();\n            break;\n\n          case _util.OPS.closeFillStroke:\n            this.closeFillStroke();\n            break;\n\n          case _util.OPS.closeEOFillStroke:\n            this.closeEOFillStroke();\n            break;\n\n          case _util.OPS.nextLine:\n            this.nextLine();\n            break;\n\n          case _util.OPS.transform:\n            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.constructPath:\n            this.constructPath(args[0], args[1]);\n            break;\n\n          case _util.OPS.endPath:\n            this.endPath();\n            break;\n\n          case 92:\n            this.group(opTreeElement.items);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented operator ${fn}`);\n            break;\n        }\n      }\n    }\n\n    setWordSpacing(wordSpacing) {\n      this.current.wordSpacing = wordSpacing;\n    }\n\n    setCharSpacing(charSpacing) {\n      this.current.charSpacing = charSpacing;\n    }\n\n    nextLine() {\n      this.moveText(0, this.current.leading);\n    }\n\n    setTextMatrix(a, b, c, d, e, f) {\n      const current = this.current;\n      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n      current.textMatrixScale = Math.hypot(a, b);\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtElement.appendChild(current.tspan);\n    }\n\n    beginText() {\n      const current = this.current;\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.textMatrix = _util.IDENTITY_MATRIX;\n      current.lineMatrix = _util.IDENTITY_MATRIX;\n      current.textMatrixScale = 1;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    moveText(x, y) {\n      const current = this.current;\n      current.x = current.lineX += x;\n      current.y = current.lineY += y;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    }\n\n    showText(glyphs) {\n      const current = this.current;\n      const font = current.font;\n      const fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return;\n      }\n\n      const fontSizeScale = current.fontSizeScale;\n      const charSpacing = current.charSpacing;\n      const wordSpacing = current.wordSpacing;\n      const fontDirection = current.fontDirection;\n      const textHScale = current.textHScale * fontDirection;\n      const vertical = font.vertical;\n      const spacingDir = vertical ? 1 : -1;\n      const defaultVMetrics = font.defaultVMetrics;\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\n      let x = 0;\n\n      for (const glyph of glyphs) {\n        if (glyph === null) {\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if ((0, _util.isNum)(glyph)) {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        const character = glyph.fontChar;\n        let scaledX, scaledY;\n        let width = glyph.width;\n\n        if (vertical) {\n          let vx;\n          const vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          const vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (glyph.isInFont || font.missingFile) {\n          current.xcoords.push(current.x + scaledX);\n\n          if (vertical) {\n            current.ycoords.push(-current.y + scaledY);\n          }\n\n          current.tspan.textContent += character;\n        } else {}\n\n        let charWidth;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n      }\n\n      current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n\n      if (vertical) {\n        current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n      } else {\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n        current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n      }\n\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n        current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n      }\n\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n          current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n        }\n\n        if (current.fillAlpha < 1) {\n          current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        }\n      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n        current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n      } else {\n        current.tspan.setAttributeNS(null, \"fill\", \"none\");\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        const lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n        this._setStrokeAttributes(current.tspan, lineWidthScale);\n      }\n\n      let textMatrix = current.textMatrix;\n\n      if (current.textRise !== 0) {\n        textMatrix = textMatrix.slice();\n        textMatrix[5] += current.textRise;\n      }\n\n      current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n      current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n      current.txtElement.appendChild(current.tspan);\n      current.txtgrp.appendChild(current.txtElement);\n\n      this._ensureTransformGroup().appendChild(current.txtElement);\n    }\n\n    setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    }\n\n    addFontStyle(fontObj) {\n      if (!fontObj.data) {\n        throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n      }\n\n      if (!this.cssStyle) {\n        this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n        this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n        this.defs.appendChild(this.cssStyle);\n      }\n\n      const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n      this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n    }\n\n    setFont(details) {\n      const current = this.current;\n      const fontObj = this.commonObjs.get(details[0]);\n      let size = details[1];\n      current.font = fontObj;\n\n      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n        this.addFontStyle(fontObj);\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\n      }\n\n      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n      let bold = \"normal\";\n\n      if (fontObj.black) {\n        bold = \"900\";\n      } else if (fontObj.bold) {\n        bold = \"bold\";\n      }\n\n      const italic = fontObj.italic ? \"italic\" : \"normal\";\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      current.fontSize = size;\n      current.fontFamily = fontObj.loadedName;\n      current.fontWeight = bold;\n      current.fontStyle = italic;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    endText() {\n      const current = this.current;\n\n      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n        current.element = current.txtElement;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    setLineWidth(width) {\n      if (width > 0) {\n        this.current.lineWidth = width;\n      }\n    }\n\n    setLineCap(style) {\n      this.current.lineCap = LINE_CAP_STYLES[style];\n    }\n\n    setLineJoin(style) {\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\n    }\n\n    setMiterLimit(limit) {\n      this.current.miterLimit = limit;\n    }\n\n    setStrokeAlpha(strokeAlpha) {\n      this.current.strokeAlpha = strokeAlpha;\n    }\n\n    setStrokeRGBColor(r, g, b) {\n      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n    }\n\n    setFillAlpha(fillAlpha) {\n      this.current.fillAlpha = fillAlpha;\n    }\n\n    setFillRGBColor(r, g, b) {\n      this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n      this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      this.current.xcoords = [];\n      this.current.ycoords = [];\n    }\n\n    setStrokeColorN(args) {\n      this.current.strokeColor = this._makeColorN_Pattern(args);\n    }\n\n    setFillColorN(args) {\n      this.current.fillColor = this._makeColorN_Pattern(args);\n    }\n\n    shadingFill(args) {\n      const width = this.viewport.width;\n      const height = this.viewport.height;\n\n      const inv = _util.Util.inverseTransform(this.transformMatrix);\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", x0);\n      rect.setAttributeNS(null, \"y\", y0);\n      rect.setAttributeNS(null, \"width\", x1 - x0);\n      rect.setAttributeNS(null, \"height\", y1 - y0);\n      rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n\n      if (this.current.fillAlpha < 1) {\n        rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n      }\n\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    _makeColorN_Pattern(args) {\n      if (args[0] === \"TilingPattern\") {\n        return this._makeTilingPattern(args);\n      }\n\n      return this._makeShadingPattern(args);\n    }\n\n    _makeTilingPattern(args) {\n      const color = args[1];\n      const operatorList = args[2];\n      const matrix = args[3] || _util.IDENTITY_MATRIX;\n      const [x0, y0, x1, y1] = args[4];\n      const xstep = args[5];\n      const ystep = args[6];\n      const paintType = args[7];\n      const tilingId = `shading${shadingCount++}`;\n\n      const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);\n\n      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n\n      const txstep = xstep * xscale;\n      const tystep = ystep * yscale;\n      const tiling = this.svgFactory.createElement(\"svg:pattern\");\n      tiling.setAttributeNS(null, \"id\", tilingId);\n      tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n      tiling.setAttributeNS(null, \"width\", txstep);\n      tiling.setAttributeNS(null, \"height\", tystep);\n      tiling.setAttributeNS(null, \"x\", `${tx0}`);\n      tiling.setAttributeNS(null, \"y\", `${ty0}`);\n      const svg = this.svg;\n      const transformMatrix = this.transformMatrix;\n      const fillColor = this.current.fillColor;\n      const strokeColor = this.current.strokeColor;\n      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n      this.svg = bbox;\n      this.transformMatrix = matrix;\n\n      if (paintType === 2) {\n        const cssColor = _util.Util.makeHexColor(...color);\n\n        this.current.fillColor = cssColor;\n        this.current.strokeColor = cssColor;\n      }\n\n      this.executeOpTree(this.convertOpList(operatorList));\n      this.svg = svg;\n      this.transformMatrix = transformMatrix;\n      this.current.fillColor = fillColor;\n      this.current.strokeColor = strokeColor;\n      tiling.appendChild(bbox.childNodes[0]);\n      this.defs.appendChild(tiling);\n      return `url(#${tilingId})`;\n    }\n\n    _makeShadingPattern(args) {\n      if (typeof args === \"string\") {\n        args = this.objs.get(args);\n      }\n\n      switch (args[0]) {\n        case \"RadialAxial\":\n          const shadingId = `shading${shadingCount++}`;\n          const colorStops = args[3];\n          let gradient;\n\n          switch (args[1]) {\n            case \"axial\":\n              const point0 = args[4];\n              const point1 = args[5];\n              gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"x1\", point0[0]);\n              gradient.setAttributeNS(null, \"y1\", point0[1]);\n              gradient.setAttributeNS(null, \"x2\", point1[0]);\n              gradient.setAttributeNS(null, \"y2\", point1[1]);\n              break;\n\n            case \"radial\":\n              const focalPoint = args[4];\n              const circlePoint = args[5];\n              const focalRadius = args[6];\n              const circleRadius = args[7];\n              gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n              gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n              gradient.setAttributeNS(null, \"r\", circleRadius);\n              gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n              gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n              gradient.setAttributeNS(null, \"fr\", focalRadius);\n              break;\n\n            default:\n              throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n          }\n\n          for (const colorStop of colorStops) {\n            const stop = this.svgFactory.createElement(\"svg:stop\");\n            stop.setAttributeNS(null, \"offset\", colorStop[0]);\n            stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n            gradient.appendChild(stop);\n          }\n\n          this.defs.appendChild(gradient);\n          return `url(#${shadingId})`;\n\n        case \"Mesh\":\n          (0, _util.warn)(\"Unimplemented pattern Mesh\");\n          return null;\n\n        case \"Dummy\":\n          return \"hotpink\";\n\n        default:\n          throw new Error(`Unknown IR type: ${args[0]}`);\n      }\n    }\n\n    setDash(dashArray, dashPhase) {\n      this.current.dashArray = dashArray;\n      this.current.dashPhase = dashPhase;\n    }\n\n    constructPath(ops, args) {\n      const current = this.current;\n      let x = current.x,\n          y = current.y;\n      let d = [];\n      let j = 0;\n\n      for (const op of ops) {\n        switch (op | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            const width = args[j++];\n            const height = args[j++];\n            const xw = x + width;\n            const yh = y + height;\n            d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"M\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"L\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            d.push(\"Z\");\n            break;\n        }\n      }\n\n      d = d.join(\" \");\n\n      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n        d = current.path.getAttributeNS(null, \"d\") + d;\n      } else {\n        current.path = this.svgFactory.createElement(\"svg:path\");\n\n        this._ensureTransformGroup().appendChild(current.path);\n      }\n\n      current.path.setAttributeNS(null, \"d\", d);\n      current.path.setAttributeNS(null, \"fill\", \"none\");\n      current.element = current.path;\n      current.setCurrentPoint(x, y);\n    }\n\n    endPath() {\n      const current = this.current;\n      current.path = null;\n\n      if (!this.pendingClip) {\n        return;\n      }\n\n      if (!current.element) {\n        this.pendingClip = null;\n        return;\n      }\n\n      const clipId = `clippath${clipCount++}`;\n      const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n      clipPath.setAttributeNS(null, \"id\", clipId);\n      clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n      const clipElement = current.element.cloneNode(true);\n\n      if (this.pendingClip === \"evenodd\") {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n      } else {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n      }\n\n      this.pendingClip = null;\n      clipPath.appendChild(clipElement);\n      this.defs.appendChild(clipPath);\n\n      if (current.activeClipUrl) {\n        current.clipGroup = null;\n\n        for (const prev of this.extraStack) {\n          prev.clipGroup = null;\n        }\n\n        clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n      }\n\n      current.activeClipUrl = `url(#${clipId})`;\n      this.tgrp = null;\n    }\n\n    clip(type) {\n      this.pendingClip = type;\n    }\n\n    closePath() {\n      const current = this.current;\n\n      if (current.path) {\n        const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n        current.path.setAttributeNS(null, \"d\", d);\n      }\n    }\n\n    setLeading(leading) {\n      this.current.leading = -leading;\n    }\n\n    setTextRise(textRise) {\n      this.current.textRise = textRise;\n    }\n\n    setTextRenderingMode(textRenderingMode) {\n      this.current.textRenderingMode = textRenderingMode;\n    }\n\n    setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    }\n\n    setRenderingIntent(intent) {}\n\n    setFlatness(flatness) {}\n\n    setGState(states) {\n      for (const [key, value] of states) {\n        switch (key) {\n          case \"LW\":\n            this.setLineWidth(value);\n            break;\n\n          case \"LC\":\n            this.setLineCap(value);\n            break;\n\n          case \"LJ\":\n            this.setLineJoin(value);\n            break;\n\n          case \"ML\":\n            this.setMiterLimit(value);\n            break;\n\n          case \"D\":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case \"RI\":\n            this.setRenderingIntent(value);\n            break;\n\n          case \"FL\":\n            this.setFlatness(value);\n            break;\n\n          case \"Font\":\n            this.setFont(value);\n            break;\n\n          case \"CA\":\n            this.setStrokeAlpha(value);\n            break;\n\n          case \"ca\":\n            this.setFillAlpha(value);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n            break;\n        }\n      }\n    }\n\n    fill() {\n      const current = this.current;\n\n      if (current.element) {\n        current.element.setAttributeNS(null, \"fill\", current.fillColor);\n        current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        this.endPath();\n      }\n    }\n\n    stroke() {\n      const current = this.current;\n\n      if (current.element) {\n        this._setStrokeAttributes(current.element);\n\n        current.element.setAttributeNS(null, \"fill\", \"none\");\n        this.endPath();\n      }\n    }\n\n    _setStrokeAttributes(element, lineWidthScale = 1) {\n      const current = this.current;\n      let dashArray = current.dashArray;\n\n      if (lineWidthScale !== 1 && dashArray.length > 0) {\n        dashArray = dashArray.map(function (value) {\n          return lineWidthScale * value;\n        });\n      }\n\n      element.setAttributeNS(null, \"stroke\", current.strokeColor);\n      element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n      element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n      element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n      element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n      element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n      element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n      element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n    }\n\n    eoFill() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fill();\n    }\n\n    fillStroke() {\n      this.stroke();\n      this.fill();\n    }\n\n    eoFillStroke() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fillStroke();\n    }\n\n    closeStroke() {\n      this.closePath();\n      this.stroke();\n    }\n\n    closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    }\n\n    closeEOFillStroke() {\n      this.closePath();\n      this.eoFillStroke();\n    }\n\n    paintSolidColorImageMask() {\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", \"1px\");\n      rect.setAttributeNS(null, \"height\", \"1px\");\n      rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    paintImageXObject(objId) {\n      const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    }\n\n    paintInlineImageXObject(imgData, mask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\n      cliprect.setAttributeNS(null, \"x\", \"0\");\n      cliprect.setAttributeNS(null, \"y\", \"0\");\n      cliprect.setAttributeNS(null, \"width\", pf(width));\n      cliprect.setAttributeNS(null, \"height\", pf(height));\n      this.current.element = cliprect;\n      this.clip(\"nonzero\");\n      const imgEl = this.svgFactory.createElement(\"svg:image\");\n      imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n      imgEl.setAttributeNS(null, \"x\", \"0\");\n      imgEl.setAttributeNS(null, \"y\", pf(-height));\n      imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n      imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n      imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n\n      if (mask) {\n        mask.appendChild(imgEl);\n      } else {\n        this._ensureTransformGroup().appendChild(imgEl);\n      }\n    }\n\n    paintImageMaskXObject(imgData) {\n      const current = this.current;\n      const width = imgData.width;\n      const height = imgData.height;\n      const fillColor = current.fillColor;\n      current.maskId = `mask${maskCount++}`;\n      const mask = this.svgFactory.createElement(\"svg:mask\");\n      mask.setAttributeNS(null, \"id\", current.maskId);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", pf(width));\n      rect.setAttributeNS(null, \"height\", pf(height));\n      rect.setAttributeNS(null, \"fill\", fillColor);\n      rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n      this.defs.appendChild(mask);\n\n      this._ensureTransformGroup().appendChild(rect);\n\n      this.paintInlineImageXObject(imgData, mask);\n    }\n\n    paintFormXObjectBegin(matrix, bbox) {\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n      }\n\n      if (bbox) {\n        const width = bbox[2] - bbox[0];\n        const height = bbox[3] - bbox[1];\n        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", bbox[0]);\n        cliprect.setAttributeNS(null, \"y\", bbox[1]);\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    paintFormXObjectEnd() {}\n\n    _initialize(viewport) {\n      const svg = this.svgFactory.create(viewport.width, viewport.height);\n      const definitions = this.svgFactory.createElement(\"svg:defs\");\n      svg.appendChild(definitions);\n      this.defs = definitions;\n      const rootGroup = this.svgFactory.createElement(\"svg:g\");\n      rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n      svg.appendChild(rootGroup);\n      this.svg = rootGroup;\n      return svg;\n    }\n\n    _ensureClipGroup() {\n      if (!this.current.clipGroup) {\n        const clipGroup = this.svgFactory.createElement(\"svg:g\");\n        clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n        this.svg.appendChild(clipGroup);\n        this.current.clipGroup = clipGroup;\n      }\n\n      return this.current.clipGroup;\n    }\n\n    _ensureTransformGroup() {\n      if (!this.tgrp) {\n        this.tgrp = this.svgFactory.createElement(\"svg:g\");\n        this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n        if (this.current.activeClipUrl) {\n          this._ensureClipGroup().appendChild(this.tgrp);\n        } else {\n          this.svg.appendChild(this.tgrp);\n        }\n      }\n\n      return this.tgrp;\n    }\n\n  };\n}\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNodeStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _network_utils = __w_pdfjs_require__(24);\n\n;\n\nconst fs = require(\"fs\");\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst url = require(\"url\");\n\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  const parsedUrl = url.parse(sourceUrl);\n\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n\n  return parsedUrl;\n}\n\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n    this._rangeRequestReaders.push(rangeReader);\n\n    return rangeReader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNodeStream = PDFNodeStream;\n\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._headersCapability = (0, _util.createPromiseCapability)();\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new _util.AbortException(\"streaming is disabled\"));\n    }\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers\n  };\n}\n\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._headersCapability.resolve();\n\n      this._setReadableStream(response);\n\n      const getResponseHeader = name => {\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n\n      this._headersCapability.reject(reason);\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    this._httpHeaders = {};\n\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      this._httpHeaders[property] = value;\n    }\n\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n\n      this._setReadableStream(response);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n        }\n\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._contentLength = stat.size;\n\n      this._setReadableStream(fs.createReadStream(path));\n\n      this._headersCapability.resolve();\n    });\n  }\n\n}\n\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    this._setReadableStream(fs.createReadStream(path, {\n      start,\n      end: end - 1\n    }));\n  }\n\n}\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _content_disposition = __w_pdfjs_require__(25);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nfunction validateRangeRequestCapabilities({\n  getResponseHeader,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  (0, _util.assert)(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\n\n  if (contentDisposition) {\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n\n    if ((0, _display_utils.isPdfFile)(filename)) {\n      return filename;\n    }\n  }\n\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n\n  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\nvar _util = __w_pdfjs_require__(2);\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  tmp = rfc2231getparam(contentDisposition);\n\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = (0, _util.stringToBytes)(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch (e) {\n        if (/^utf-?8$/i.test(encoding)) {\n          try {\n            value = decodeURIComponent(escape(value));\n            needsEncodingFixup = false;\n          } catch (err) {}\n        }\n      }\n    }\n\n    return value;\n  }\n\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n\n    return value;\n  }\n\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n\n        continue;\n      }\n\n      matches[n] = [quot, part];\n    }\n\n    const parts = [];\n\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n\n      if (quot) {\n        part = unescape(part);\n\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n\n      parts.push(part);\n    }\n\n    return parts.join(\"\");\n  }\n\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n      }\n\n      value = parts.join('\"');\n    }\n\n    return value;\n  }\n\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n\n    if (encodingend === -1) {\n      return extvalue;\n    }\n\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replace(/_/g, \" \");\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n\n      try {\n        text = atob(text);\n      } catch (e) {}\n\n      return textdecode(charset, text);\n    });\n  }\n\n  return \"\";\n}\n\n/***/ }),\n/* 26 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNetworkStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _network_utils = __w_pdfjs_require__(24);\n\n;\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n\n  if (typeof data !== \"string\") {\n    return data;\n  }\n\n  const array = (0, _util.stringToBytes)(data);\n  return array.buffer;\n}\n\nclass NetworkManager {\n  constructor(url, args = {}) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n    this.withCredentials = args.withCredentials || false;\n\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n      return new XMLHttpRequest();\n    };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n\n    return this.request(args);\n  }\n\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n\n  request(args) {\n    const xhr = this.getXhr();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      xhr.setRequestHeader(property, value);\n    }\n\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n\n    xhr.responseType = \"arraybuffer\";\n\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    pendingRequest.onProgress?.(evt);\n  }\n\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    const xhr = pendingRequest.xhr;\n\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n\n    delete this.pendingRequests[xhrId];\n\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const chunk = getArrayBuffer(xhr);\n\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n\n}\n\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNetworkStream = PDFNetworkStream;\n\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\n      getResponseHeader,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n\n    this._headersReceivedCapability.resolve();\n  }\n\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n\n    this._done = true;\n\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    this._headersReceivedCapability.reject(this._storedError);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._headersReceivedCapability.reject(reason);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n\n    this._fullRequestReader = null;\n  }\n\n}\n\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _close() {\n    this.onClosed?.(this);\n  }\n\n  _onDone(data) {\n    const chunk = data.chunk;\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._close();\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n\n    this._close();\n  }\n\n}\n\n/***/ }),\n/* 27 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFFetchStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _network_utils = __w_pdfjs_require__(24);\n\n;\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController?.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n\n    if (typeof value === \"undefined\") {\n      continue;\n    }\n\n    headers.append(property, value);\n  }\n\n  return headers;\n}\n\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFFetchStream = PDFFetchStream;\n\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._reader = response.body.getReader();\n\n      this._headersCapability.resolve();\n\n      const getResponseHeader = name => {\n        return response.headers.get(name);\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n\n}\n\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._isStreamingSupported = !source.disableStream;\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._readCapability.resolve();\n\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n\n}\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\nvar exports = __webpack_exports__;\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"AnnotationLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_layer.AnnotationLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationMode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationMode;\n  }\n}));\nObject.defineProperty(exports, \"CMapCompressionType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.CMapCompressionType;\n  }\n}));\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\n  enumerable: true,\n  get: function () {\n    return _worker_options.GlobalWorkerOptions;\n  }\n}));\nObject.defineProperty(exports, \"InvalidPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.InvalidPDFException;\n  }\n}));\nObject.defineProperty(exports, \"LinkTarget\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.LinkTarget;\n  }\n}));\nObject.defineProperty(exports, \"LoopbackPort\", ({\n  enumerable: true,\n  get: function () {\n    return _api.LoopbackPort;\n  }\n}));\nObject.defineProperty(exports, \"MissingPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.MissingPDFException;\n  }\n}));\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return _util.OPS;\n  }\n}));\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFDataRangeTransport;\n  }\n}));\nObject.defineProperty(exports, \"PDFDateString\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PDFDateString;\n  }\n}));\nObject.defineProperty(exports, \"PDFWorker\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFWorker;\n  }\n}));\nObject.defineProperty(exports, \"PasswordResponses\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PasswordResponses;\n  }\n}));\nObject.defineProperty(exports, \"PermissionFlag\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PermissionFlag;\n  }\n}));\nObject.defineProperty(exports, \"PixelsPerInch\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PixelsPerInch;\n  }\n}));\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.RenderingCancelledException;\n  }\n}));\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _svg.SVGGraphics;\n  }\n}));\nObject.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UNSUPPORTED_FEATURES;\n  }\n}));\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UnexpectedResponseException;\n  }\n}));\nObject.defineProperty(exports, \"Util\", ({\n  enumerable: true,\n  get: function () {\n    return _util.Util;\n  }\n}));\nObject.defineProperty(exports, \"VerbosityLevel\", ({\n  enumerable: true,\n  get: function () {\n    return _util.VerbosityLevel;\n  }\n}));\nObject.defineProperty(exports, \"XfaLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _xfa_layer.XfaLayer;\n  }\n}));\nObject.defineProperty(exports, \"addLinkAttributes\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.addLinkAttributes;\n  }\n}));\nObject.defineProperty(exports, \"build\", ({\n  enumerable: true,\n  get: function () {\n    return _api.build;\n  }\n}));\nObject.defineProperty(exports, \"createObjectURL\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createObjectURL;\n  }\n}));\nObject.defineProperty(exports, \"createPromiseCapability\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createPromiseCapability;\n  }\n}));\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createValidAbsoluteUrl;\n  }\n}));\nObject.defineProperty(exports, \"getDocument\", ({\n  enumerable: true,\n  get: function () {\n    return _api.getDocument;\n  }\n}));\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getPdfFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getPdfFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getXfaPageViewport\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getXfaPageViewport;\n  }\n}));\nObject.defineProperty(exports, \"isPdfFile\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isPdfFile;\n  }\n}));\nObject.defineProperty(exports, \"loadScript\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.loadScript;\n  }\n}));\nObject.defineProperty(exports, \"removeNullCharacters\", ({\n  enumerable: true,\n  get: function () {\n    return _util.removeNullCharacters;\n  }\n}));\nObject.defineProperty(exports, \"renderTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.renderTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"shadow\", ({\n  enumerable: true,\n  get: function () {\n    return _util.shadow;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function () {\n    return _api.version;\n  }\n}));\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _api = __w_pdfjs_require__(6);\n\nvar _annotation_layer = __w_pdfjs_require__(18);\n\nvar _worker_options = __w_pdfjs_require__(12);\n\nvar _is_node = __w_pdfjs_require__(4);\n\nvar _text_layer = __w_pdfjs_require__(21);\n\nvar _svg = __w_pdfjs_require__(22);\n\nvar _xfa_layer = __w_pdfjs_require__(20);\n\nconst pdfjsVersion = '2.12.313';\nconst pdfjsBuild = 'a2ae56f39';\n{\n  if (_is_node.isNodeJS) {\n    const {\n      PDFNodeStream\n    } = __w_pdfjs_require__(23);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    const {\n      PDFNetworkStream\n    } = __w_pdfjs_require__(26);\n\n    const {\n      PDFFetchStream\n    } = __w_pdfjs_require__(27);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      if ((0, _display_utils.isValidFetchUrl)(params.url)) {\n        return new PDFFetchStream(params);\n      }\n\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=pdf.js.map","\"use strict\";\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nexports.__esModule = true;\r\nexports.AnnotationFactory = exports.ParameterParser = void 0;\r\nvar parser_1 = require(\"./parser\");\r\nvar text_annotation_1 = require(\"./annotations/text_annotation\");\r\nvar text_markup_annotation_1 = require(\"./annotations/text_markup_annotation\");\r\nvar freetext_annotation_1 = require(\"./annotations/freetext_annotation\");\r\nvar circle_square_annotation_1 = require(\"./annotations/circle_square_annotation\");\r\nvar polygon_polyline_annotation_1 = require(\"./annotations/polygon_polyline_annotation\");\r\nvar ink_annotation_1 = require(\"./annotations/ink_annotation\");\r\nvar util_1 = require(\"./util\");\r\nvar writer_1 = require(\"./writer\");\r\nvar ParameterParser = /** @class */ (function () {\r\n    function ParameterParser() {\r\n    }\r\n    /**\r\n     * Parses and checks the parameter. This is for backward compatibility and to support arbitrary annotation parameters\r\n     * */\r\n    ParameterParser.parseParameters = function (values) {\r\n        if (values.length === 0) {\r\n            throw Error(\"No parameters provided\");\r\n        }\r\n        var i = 0;\r\n        if (typeof values[i] === 'number') {\r\n            var ret_val = {};\r\n            ret_val.page = values[i++];\r\n            ret_val.rect = values[i++];\r\n            ret_val.contents = values[i++];\r\n            if (typeof ret_val.contents !== 'string') {\r\n                throw Error(\"Invalid contents parameter\");\r\n            }\r\n            ret_val.author = values[i++];\r\n            if (typeof ret_val.author !== 'string') {\r\n                throw Error(\"Invalid author parameter\");\r\n            }\r\n            if (i >= values.length)\r\n                return ret_val;\r\n            if (\"r\" in values[i] && \"g\" in values[i] && \"b\" in values[i]) {\r\n                ret_val.color = values[i++];\r\n            }\r\n            else if (Array.isArray(values[i]) && values[i].length > 0 && typeof values[i][0] === 'number') {\r\n                ret_val.vertices = values[i++];\r\n            }\r\n            else if (Array.isArray(values[i]) && values[i].length > 0 && Array.isArray(values[i][0])) {\r\n                ret_val.inkList = values[i++];\r\n            }\r\n            else {\r\n                throw Error(\"Invalid parameter provided - is neither color, nor quadpoints array or an inklist\");\r\n            }\r\n            if (i >= values.length)\r\n                return ret_val;\r\n            if (\"r\" in values[i] && \"g\" in values[i] && \"b\" in values[i]) {\r\n                if (ret_val.color) {\r\n                    ret_val.fill = values[i++];\r\n                }\r\n                else {\r\n                    ret_val.color = values[i++];\r\n                }\r\n            }\r\n            else if (Array.isArray(values[i]) && values[i].length > 0 && typeof values[i][0] === 'number') {\r\n                ret_val.quadPoints = values[i++];\r\n            }\r\n            else if (typeof values[i] === 'object') {\r\n                ret_val.config = true;\r\n                ret_val = Object.assign(ret_val, values[i++]);\r\n            }\r\n            else {\r\n                throw Error(\"Invalid parameter provided\");\r\n            }\r\n            if (i >= values.length)\r\n                return ret_val;\r\n            if (!ret_val.config && typeof values[i] === 'object') {\r\n                ret_val = Object.assign(ret_val, values[i++]);\r\n            }\r\n            else {\r\n                throw Error(\"Invalid configuration provided\");\r\n            }\r\n            return ret_val;\r\n        }\r\n        else if (typeof values[i] === 'object') {\r\n            return values[0];\r\n        }\r\n        else {\r\n            throw Error(\"Invalid configuration object\");\r\n        }\r\n    };\r\n    return ParameterParser;\r\n}());\r\nexports.ParameterParser = ParameterParser;\r\n/**\r\n * The annotation factory provides methods to create annotations. Those are stored temporarily\r\n * and than encoded into PDF code when the PDF document is written.\r\n * */\r\nvar AnnotationFactory = /** @class */ (function () {\r\n    function AnnotationFactory(data, userPassword, ownerPassword) {\r\n        if (userPassword === void 0) { userPassword = \"\"; }\r\n        if (ownerPassword === void 0) { ownerPassword = \"\"; }\r\n        this.data = data;\r\n        this.userPassword = userPassword;\r\n        this.ownerPassword = ownerPassword;\r\n        this.annotations = [];\r\n        this.toDelete = [];\r\n        this.data = data;\r\n        this.parser = new parser_1.PDFDocumentParser(this.data, this.userPassword, this.ownerPassword);\r\n    }\r\n    /**\r\n     * Returns the number of annotations that will be added to the PDF document\r\n     * */\r\n    AnnotationFactory.prototype.getAnnotationCount = function () {\r\n        return this.annotations.length;\r\n    };\r\n    /**\r\n     * Load a PDF file referenced by the given 'path'\r\n     * */\r\n    AnnotationFactory.loadFile = function (path, userPassword, ownerPassword) {\r\n        if (userPassword === void 0) { userPassword = \"\"; }\r\n        if (ownerPassword === void 0) { ownerPassword = \"\"; }\r\n        return new Promise(function (resolve) {\r\n            if (typeof window !== 'undefined') { // browser environment\r\n                fetch(path).then(function (r) { return r.blob(); }).then(function (data) {\r\n                    var reader = new FileReader();\r\n                    reader.onload = function () {\r\n                        resolve(new AnnotationFactory(reader.result, userPassword, ownerPassword));\r\n                    };\r\n                    reader.readAsArrayBuffer(data);\r\n                });\r\n            }\r\n            else if (typeof process === 'object') { // node environment\r\n                var fs = require('fs');\r\n                var data = fs.readFileSync(path);\r\n                resolve(new AnnotationFactory(data, userPassword, ownerPassword));\r\n            }\r\n            else {\r\n                throw Error(\"Unsupported environment\");\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Generates a unique identifier necessary for creating the annotation\r\n     * */\r\n    AnnotationFactory.prototype.generateUniqueIdentifier = function () {\r\n        return \"pdfAnnotate-\" + util_1.Util.convertDateToPDFDate(new Date()).slice(3, 17) + \"-\" + this.annotations.length;\r\n    };\r\n    /**\r\n     * Generates a default border\r\n     * */\r\n    AnnotationFactory.prototype.createDefaultBorder = function () {\r\n        return {\r\n            vertical_corner_radius: 0,\r\n            horizontal_corner_radius: 0,\r\n            border_width: 1\r\n        };\r\n    };\r\n    /**\r\n     * Writes the created annotations into a bytestream\r\n     * */\r\n    AnnotationFactory.prototype.write = function () {\r\n        if (this.annotations.length === 0 && this.toDelete.length === 0)\r\n            return this.data;\r\n        var writer = new writer_1.Writer(this.data, this.annotations, this.toDelete, this.parser);\r\n        return writer.write();\r\n    };\r\n    /**\r\n     * Checks the 'rect' parameter, whether all the entries are of type number and if the the number of entries is correct\r\n     * */\r\n    AnnotationFactory.prototype.checkRect = function (nr, rect) {\r\n        if (!Array.isArray(rect)) {\r\n            throw Error(\"invalid rect parameter\");\r\n        }\r\n        if (rect.length !== nr)\r\n            throw Error(\"Rect has invalid number of entries: \" + rect + \" has \" + rect.length + \" entries, but should have \" + nr + \" entries\");\r\n        rect.forEach(function (a) {\r\n            if ('number' !== typeof a)\r\n                throw Error(\"Rect \" + rect + \" has invalid entry: \" + a);\r\n        });\r\n    };\r\n    /**\r\n     * Creates a base annotation that means the raw object of annotation or those parts that exist\r\n     * in equal form in all types of annotations\r\n     * */\r\n    AnnotationFactory.prototype.createBaseAnnotation = function (page) {\r\n        if (page < 0) {\r\n            throw Error(\"Invalid page number: \".concat(page));\r\n        }\r\n        var annot = {\r\n            object_id: this.parser.getFreeObjectId(),\r\n            id: this.generateUniqueIdentifier(),\r\n            pageReference: this.parser.getPage(page),\r\n            updateDate: util_1.Util.convertDateToPDFDate(new Date()),\r\n            border: this.createDefaultBorder(),\r\n            page: page, rect: [], factory: this\r\n        };\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a text annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * options : dictionary containing additional configuration values, see documentation\r\n     * */\r\n    AnnotationFactory.prototype.createTextAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new text_annotation_1.TextAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a highlight annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * quadPoints : regions to mark with the highlight\r\n     * */\r\n    AnnotationFactory.prototype.createHighlightAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new text_markup_annotation_1.HighlightAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates an underline annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * quadPoints : regions to mark with the highlight\r\n     * */\r\n    AnnotationFactory.prototype.createUnderlineAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new text_markup_annotation_1.UnderlineAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a squiggle annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * quadPoints : regions to mark with the highlight\r\n     * */\r\n    AnnotationFactory.prototype.createSquigglyAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new text_markup_annotation_1.SquigglyAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a strike out annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * quadPoints : regions to mark with the highlight\r\n     * */\r\n    AnnotationFactory.prototype.createStrikeOutAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new text_markup_annotation_1.StrikeOutAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a free text annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createFreeTextAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new freetext_annotation_1.FreeTextAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    AnnotationFactory.prototype.createLineAnnotation = function () {\r\n        throw Error(\"No yet implemented\");\r\n    };\r\n    /**\r\n     * Creates a square annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * fill : the filling color of  the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createSquareAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new circle_square_annotation_1.SquareAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a circle annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * fill : the filling color of  the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createCircleAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new circle_square_annotation_1.CircleAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a polygon annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * vertices : the vertices defining the arrangement of the object\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createPolygonAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new polygon_polyline_annotation_1.PolygonAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a polyline annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * vertices : the vertices defining the arrangement of the object\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createPolyLineAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new polygon_polyline_annotation_1.PolyLineAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates an ink annotation\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * rect : the position of the annotation on the page\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * inkList : a list of list containing the points for drawing the lines\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createInkAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = new ink_annotation_1.InkAnnotationObj();\r\n        annot = Object.assign(annot, this.createBaseAnnotation(params.page));\r\n        annot = Object.assign(annot, params);\r\n        annot.validate();\r\n        this.annotations.push(annot);\r\n        return annot;\r\n    };\r\n    /**\r\n     * Creates a stamp annotation. There exists a number of predifined stamps that can be attached to PDF documents.\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * stampType : the name of the used stamp type. Can be: [Approved, Experimental, NotApproved, AsIs, Expired, NotForPublicRelease, Confidential, Final, Sold, Departmental, ForComment, TopSecret, Draft, ForPublicRelease]\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createStampAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = Object.assign(this.createBaseAnnotation(params.page), {\r\n            opacity: 1,\r\n            initiallyOpen: false,\r\n            annotation_flag: 4,\r\n            color: params.color,\r\n            stampType: params.stampType\r\n        });\r\n        annot.type = \"/Stamp\";\r\n        this.annotations.push(annot);\r\n    };\r\n    /**\r\n     * Creates a visual symbol that indcates the existance of text edits.\r\n     * page : the number of the PDF document page, where the annotation must be attached\r\n     * contents : the content of the annotation\r\n     * author : the author of the annotation\r\n     * caretSymbol : None or P, with P for using the paragraph symbol as caret\r\n     * color : the color of the annotation in rgb. Can be of domain 0 - 255 or 0 - 1\r\n     * */\r\n    AnnotationFactory.prototype.createCaretAnnotation = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var params = ParameterParser.parseParameters(values);\r\n        var annot = Object.assign(this.createBaseAnnotation(params.page), {\r\n            opacity: 1,\r\n            initiallyOpen: false,\r\n            annotation_flag: 4,\r\n            color: params.color,\r\n            caretSymbol: params.caretSymbol\r\n        });\r\n        annot.type = \"/Caret\";\r\n        this.annotations.push(annot);\r\n    };\r\n    AnnotationFactory.prototype.createPopupAnnotation = function () {\r\n        throw Error(\"No yet implemented\");\r\n    };\r\n    /**\r\n     * Deletes the annotation with the given id or the given reference object\r\n     * */\r\n    AnnotationFactory.prototype.deleteAnnotation = function (id) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            // delete if it was just created but is not in the pdf document\r\n            for (var i = 0; i < _this.annotations.length; ++i) {\r\n                if ('string' === typeof id && _this.annotations[i].id === id) {\r\n                    _this.annotations = _this.annotations = __spreadArray(__spreadArray([], _this.annotations.slice(0, i), true), _this.annotations.slice(i + 1), true);\r\n                    resolve(_this.toDelete);\r\n                    return;\r\n                }\r\n                else if (id.obj && _this.annotations[i].object_id && id.obj === _this.annotations[i].object_id.obj && id.generation && id.generation === _this.annotations[i].object_id.generation) {\r\n                    _this.annotations = _this.annotations = __spreadArray(__spreadArray([], _this.annotations.slice(0, i), true), _this.annotations.slice(i + 1), true);\r\n                    resolve(_this.toDelete);\r\n                    return;\r\n                }\r\n            }\r\n            _this.getAnnotations().then(function (annots) {\r\n                for (var _i = 0, annots_1 = annots; _i < annots_1.length; _i++) {\r\n                    var _annots = annots_1[_i];\r\n                    for (var _a = 0, _annots_1 = _annots; _a < _annots_1.length; _a++) {\r\n                        var annot = _annots_1[_a];\r\n                        if ('string' === typeof id && annot.id === id) {\r\n                            _this.toDelete.push(annot);\r\n                            resolve(_this.toDelete);\r\n                            return;\r\n                        }\r\n                        else if (id.obj && annot.object_id && id.obj === annot.object_id.obj && id.generation && id.generation === annot.object_id.generation) {\r\n                            _this.toDelete.push(annot);\r\n                            resolve(_this.toDelete);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n    AnnotationFactory.prototype._getAnnotations = function () {\r\n        var existingAnnots = this.parser.extractAnnotations(this);\r\n        for (var _i = 0, _a = this.annotations; _i < _a.length; _i++) {\r\n            var newAnnot = _a[_i];\r\n            existingAnnots[newAnnot.page].push(newAnnot);\r\n        }\r\n        return existingAnnots;\r\n    };\r\n    /**\r\n     * Returns a promise with all the annotations that are part of the document. This\r\n     * comprises annotations, that are already part of the parsed document and those that were created using this library and\r\n     * not yet appended to the document.\r\n     * */\r\n    AnnotationFactory.prototype.getAnnotations = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            resolve(_this._getAnnotations());\r\n        });\r\n    };\r\n    /**\r\n     * Returns the fonts, that are available in the PDF document\r\n     * */\r\n    AnnotationFactory.prototype.getFonts = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            resolve(_this.parser.getFonts().fonts);\r\n        });\r\n    };\r\n    /**\r\n     * Downloads the adapted PDF document\r\n     * */\r\n    AnnotationFactory.prototype.download = function (fileName) {\r\n        if (fileName === void 0) { fileName = \"output.pdf\"; }\r\n        var a = document.createElement(\"a\");\r\n        document.body.appendChild(a);\r\n        a.style = \"display: none\";\r\n        var extended_pdf = this.write();\r\n        var blob = new Blob([extended_pdf], { type: \"application/pdf\" });\r\n        var url = window.URL.createObjectURL(blob);\r\n        a.href = url;\r\n        a.download = fileName;\r\n        a.click();\r\n        a.remove();\r\n        window.URL.revokeObjectURL(url);\r\n    };\r\n    /**\r\n     * Saves the adapted PDF document in a nodejs environment and downloads it in a browser environment.\r\n     * */\r\n    AnnotationFactory.prototype.save = function (fileName) {\r\n        if (fileName === void 0) { fileName = \"output.pdf\"; }\r\n        if (typeof window !== 'undefined') { // browser environment\r\n            this.download(fileName);\r\n        }\r\n        else if (typeof process === 'object') { // node environment\r\n            var fs = require('fs');\r\n            var data = this.write();\r\n            fs.writeFile(fileName, Buffer.from(new Uint8Array(data)), function (err) {\r\n                if (err) {\r\n                    throw Error(err);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            throw Error(\"Unsupported environment\");\r\n        }\r\n    };\r\n    return AnnotationFactory;\r\n}());\r\nexports.AnnotationFactory = AnnotationFactory;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.InvalidFontError = exports.InvalidFontSizeError = exports.InvalidAppearanceStreamError = exports.InvalidAnnotationReference = exports.InvalidVerticesError = exports.InvalidQuadPointError = exports.InvalidStateError = exports.InvalidIDError = exports.InvalidRectError = exports.InvalidDateError = exports.InvalidReferencePointerError = exports.ColorOutOfRangeError = exports.InvalidColorError = exports.InvalidOpacityError = exports.InvalidAnnotationTypeError = void 0;\r\nvar InvalidAnnotationTypeError = /** @class */ (function (_super) {\r\n    __extends(InvalidAnnotationTypeError, _super);\r\n    function InvalidAnnotationTypeError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidAnnotationTypeError\";\r\n        return _this;\r\n    }\r\n    return InvalidAnnotationTypeError;\r\n}(Error));\r\nexports.InvalidAnnotationTypeError = InvalidAnnotationTypeError;\r\nvar InvalidOpacityError = /** @class */ (function (_super) {\r\n    __extends(InvalidOpacityError, _super);\r\n    function InvalidOpacityError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidOpacityError\";\r\n        return _this;\r\n    }\r\n    return InvalidOpacityError;\r\n}(Error));\r\nexports.InvalidOpacityError = InvalidOpacityError;\r\nvar InvalidColorError = /** @class */ (function (_super) {\r\n    __extends(InvalidColorError, _super);\r\n    function InvalidColorError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidColorError\";\r\n        return _this;\r\n    }\r\n    return InvalidColorError;\r\n}(Error));\r\nexports.InvalidColorError = InvalidColorError;\r\nvar ColorOutOfRangeError = /** @class */ (function (_super) {\r\n    __extends(ColorOutOfRangeError, _super);\r\n    function ColorOutOfRangeError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"ColorOutOfRangeError\";\r\n        return _this;\r\n    }\r\n    return ColorOutOfRangeError;\r\n}(Error));\r\nexports.ColorOutOfRangeError = ColorOutOfRangeError;\r\nvar InvalidReferencePointerError = /** @class */ (function (_super) {\r\n    __extends(InvalidReferencePointerError, _super);\r\n    function InvalidReferencePointerError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidReferencePointerError\";\r\n        return _this;\r\n    }\r\n    return InvalidReferencePointerError;\r\n}(Error));\r\nexports.InvalidReferencePointerError = InvalidReferencePointerError;\r\nvar InvalidDateError = /** @class */ (function (_super) {\r\n    __extends(InvalidDateError, _super);\r\n    function InvalidDateError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidDateError\";\r\n        return _this;\r\n    }\r\n    return InvalidDateError;\r\n}(Error));\r\nexports.InvalidDateError = InvalidDateError;\r\nvar InvalidRectError = /** @class */ (function (_super) {\r\n    __extends(InvalidRectError, _super);\r\n    function InvalidRectError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidRectError\";\r\n        return _this;\r\n    }\r\n    return InvalidRectError;\r\n}(Error));\r\nexports.InvalidRectError = InvalidRectError;\r\nvar InvalidIDError = /** @class */ (function (_super) {\r\n    __extends(InvalidIDError, _super);\r\n    function InvalidIDError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidIDError\";\r\n        return _this;\r\n    }\r\n    return InvalidIDError;\r\n}(Error));\r\nexports.InvalidIDError = InvalidIDError;\r\nvar InvalidStateError = /** @class */ (function (_super) {\r\n    __extends(InvalidStateError, _super);\r\n    function InvalidStateError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidStateError\";\r\n        return _this;\r\n    }\r\n    return InvalidStateError;\r\n}(Error));\r\nexports.InvalidStateError = InvalidStateError;\r\nvar InvalidQuadPointError = /** @class */ (function (_super) {\r\n    __extends(InvalidQuadPointError, _super);\r\n    function InvalidQuadPointError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidQuadPointError\";\r\n        return _this;\r\n    }\r\n    return InvalidQuadPointError;\r\n}(Error));\r\nexports.InvalidQuadPointError = InvalidQuadPointError;\r\nvar InvalidVerticesError = /** @class */ (function (_super) {\r\n    __extends(InvalidVerticesError, _super);\r\n    function InvalidVerticesError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidVerticesError\";\r\n        return _this;\r\n    }\r\n    return InvalidVerticesError;\r\n}(Error));\r\nexports.InvalidVerticesError = InvalidVerticesError;\r\nvar InvalidAnnotationReference = /** @class */ (function (_super) {\r\n    __extends(InvalidAnnotationReference, _super);\r\n    function InvalidAnnotationReference(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidAnnotationError\";\r\n        return _this;\r\n    }\r\n    return InvalidAnnotationReference;\r\n}(Error));\r\nexports.InvalidAnnotationReference = InvalidAnnotationReference;\r\nvar InvalidAppearanceStreamError = /** @class */ (function (_super) {\r\n    __extends(InvalidAppearanceStreamError, _super);\r\n    function InvalidAppearanceStreamError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidAppearanceStreamError\";\r\n        return _this;\r\n    }\r\n    return InvalidAppearanceStreamError;\r\n}(Error));\r\nexports.InvalidAppearanceStreamError = InvalidAppearanceStreamError;\r\nvar InvalidFontSizeError = /** @class */ (function (_super) {\r\n    __extends(InvalidFontSizeError, _super);\r\n    function InvalidFontSizeError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidFontSizeError\";\r\n        return _this;\r\n    }\r\n    return InvalidFontSizeError;\r\n}(Error));\r\nexports.InvalidFontSizeError = InvalidFontSizeError;\r\nvar InvalidFontError = /** @class */ (function (_super) {\r\n    __extends(InvalidFontError, _super);\r\n    function InvalidFontError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.name = \"InvalidFontError\";\r\n        return _this;\r\n    }\r\n    return InvalidFontError;\r\n}(Error));\r\nexports.InvalidFontError = InvalidFontError;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nexports.__esModule = true;\r\nexports.MarkupAnnotationObj = exports.ReplyTypes = exports.RawAnnotationObj = exports.BaseAnnotationObj = exports.BorderStyles = exports.LineEndingStyle = void 0;\r\nvar parser_1 = require(\"../parser\");\r\nvar util_1 = require(\"../util\");\r\nvar annotation_errors_1 = require(\"./annotation_errors\");\r\nvar writer_util_1 = require(\"../writer-util\");\r\nvar LineEndingStyle;\r\n(function (LineEndingStyle) {\r\n    LineEndingStyle[LineEndingStyle[\"Square\"] = 0] = \"Square\";\r\n    LineEndingStyle[LineEndingStyle[\"Circle\"] = 1] = \"Circle\";\r\n    LineEndingStyle[LineEndingStyle[\"Diamond\"] = 2] = \"Diamond\";\r\n    LineEndingStyle[LineEndingStyle[\"OpenArrow\"] = 3] = \"OpenArrow\";\r\n    LineEndingStyle[LineEndingStyle[\"ClosedArrow\"] = 4] = \"ClosedArrow\";\r\n    LineEndingStyle[LineEndingStyle[\"Butt\"] = 5] = \"Butt\";\r\n    LineEndingStyle[LineEndingStyle[\"ROpenArrow\"] = 6] = \"ROpenArrow\";\r\n    LineEndingStyle[LineEndingStyle[\"RClosedArrow\"] = 7] = \"RClosedArrow\";\r\n    LineEndingStyle[LineEndingStyle[\"Slash\"] = 8] = \"Slash\";\r\n    LineEndingStyle[LineEndingStyle[\"None\"] = 9] = \"None\";\r\n})(LineEndingStyle = exports.LineEndingStyle || (exports.LineEndingStyle = {}));\r\nvar BorderStyles;\r\n(function (BorderStyles) {\r\n    BorderStyles[BorderStyles[\"Solid\"] = 0] = \"Solid\";\r\n    BorderStyles[BorderStyles[\"Dashed\"] = 1] = \"Dashed\";\r\n    BorderStyles[BorderStyles[\"Beveled\"] = 2] = \"Beveled\";\r\n    BorderStyles[BorderStyles[\"Inset\"] = 3] = \"Inset\";\r\n    BorderStyles[BorderStyles[\"Underline\"] = 4] = \"Underline\";\r\n})(BorderStyles = exports.BorderStyles || (exports.BorderStyles = {}));\r\nvar BaseAnnotationObj = /** @class */ (function () {\r\n    function BaseAnnotationObj() {\r\n        this.object_id = undefined; // an unused object id\r\n        this.is_deleted = false; // internal flag to determine whether the annotation was deleted\r\n        this.additional_objects_to_write = []; // holds objects, that must be written, since they are used by the annotation\r\n        this.page = -1;\r\n        this.pageReference = undefined; // The reference to the page object to which the annotation is added\r\n        this.type = \"\";\r\n        this.type_encoded = [];\r\n        this.rect = [];\r\n        this.contents = \"\";\r\n        this.id = \"\"; // /NM\r\n        this.updateDate = \"\"; // /M\r\n        this.takeAppearanceStreamFrom = undefined;\r\n        this.factory = undefined;\r\n    }\r\n    /**\r\n     * Creates a default appearance stream for the given annotation type and assigns it to the annotation\r\n     * */\r\n    BaseAnnotationObj.prototype.createDefaultAppearanceStream = function () { };\r\n    BaseAnnotationObj.prototype.writeAnnotationPreamble = function () {\r\n        var ret = writer_util_1.WriterUtil.writeReferencePointer(this.object_id);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.OBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);\r\n        ret = ret.concat(writer_util_1.WriterUtil.TYPE_ANNOT);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        return ret;\r\n    };\r\n    BaseAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = [];\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.PAGE_REFERENCE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(this.pageReference.object_id, true));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.SUBTYPE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(this.type_encoded);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.RECT);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.rect));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.CONTENTS);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.contents)), this.object_id))));\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.ID);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.id)), this.object_id))));\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.UPDATE_DATE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.updateDate)), this.object_id))));\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.appearanceStream) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.AP);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.appearanceStream.writeAppearanceStream());\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.annotationFlags) {\r\n            var flags_value = this.encodeAnnotationFlags();\r\n            ret = ret.concat(writer_util_1.WriterUtil.FLAG);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(flags_value));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.border) {\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.BORDER);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([this.border.horizontal_corner_radius || 0, this.border.vertical_corner_radius || 0, this.border.border_width || 1]));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.color) {\r\n            this.color = util_1.Util.colorToRange01(this.color);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.COLOR);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([this.color.r, this.color.g, this.color.b]));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.raw_parameters && this.raw_parameters.length > 0) {\r\n            for (var _i = 0, _a = this.raw_parameters; _i < _a.length; _i++) {\r\n                var i = _a[_i];\r\n                ret.push(writer_util_1.WriterUtil.SPACE);\r\n                ret = ret.concat(i);\r\n                ret.push(writer_util_1.WriterUtil.SPACE);\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    BaseAnnotationObj.prototype.convertLineEndingStyle = function (lne) {\r\n        switch (lne) {\r\n            case LineEndingStyle.Square:\r\n                return util_1.Util.convertStringToAscii(\"/Square\");\r\n            case LineEndingStyle.Circle:\r\n                return util_1.Util.convertStringToAscii(\"/Circle\");\r\n            case LineEndingStyle.Diamond:\r\n                return util_1.Util.convertStringToAscii(\"/Diamond\");\r\n            case LineEndingStyle.OpenArrow:\r\n                return util_1.Util.convertStringToAscii(\"/OpenArrow\");\r\n            case LineEndingStyle.ClosedArrow:\r\n                return util_1.Util.convertStringToAscii(\"/ClosedArrow\");\r\n            case LineEndingStyle.Butt:\r\n                return util_1.Util.convertStringToAscii(\"/Butt\");\r\n            case LineEndingStyle.ROpenArrow:\r\n                return util_1.Util.convertStringToAscii(\"/ROpenArrow\");\r\n            case LineEndingStyle.RClosedArrow:\r\n                return util_1.Util.convertStringToAscii(\"/RClosedArrow\");\r\n            case LineEndingStyle.Slash:\r\n                return util_1.Util.convertStringToAscii(\"/Slash\");\r\n            default:\r\n                return util_1.Util.convertStringToAscii(\"/None\");\r\n        }\r\n    };\r\n    BaseAnnotationObj.prototype.writeAnnotationPostamble = function () {\r\n        var ret = __spreadArray([], writer_util_1.WriterUtil.DICT_END, true);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        return ret;\r\n    };\r\n    BaseAnnotationObj.prototype.encodeAnnotationFlags = function () {\r\n        if (!this.annotationFlags) {\r\n            return 0;\r\n        }\r\n        var val = 0;\r\n        if (this.annotationFlags.invisible) {\r\n            val |= 1;\r\n        }\r\n        if (this.annotationFlags.hidden) {\r\n            val |= 2;\r\n        }\r\n        if (this.annotationFlags.print) {\r\n            val |= 4;\r\n        }\r\n        if (this.annotationFlags.noZoom) {\r\n            val |= 8;\r\n        }\r\n        if (this.annotationFlags.noRotate) {\r\n            val |= 16;\r\n        }\r\n        if (this.annotationFlags.noView) {\r\n            val |= 32;\r\n        }\r\n        if (this.annotationFlags.readOnly) {\r\n            val |= 64;\r\n        }\r\n        if (this.annotationFlags.locked) {\r\n            val |= 128;\r\n        }\r\n        if (this.annotationFlags.toggleNoView) {\r\n            val |= 256;\r\n        }\r\n        if (this.annotationFlags.lockedContents) {\r\n            val |= 512;\r\n        }\r\n        return val;\r\n    };\r\n    /**\r\n     * If enact is true, the error will be thrown directly, otherwise the errors are collected\r\n     * and returned as error list.\r\n     * */\r\n    BaseAnnotationObj.prototype.validate = function (enact) {\r\n        var _this = this;\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = this.checkRect(4, this.rect);\r\n        errorList = errorList.concat(this.checkReferencePointer(this.object_id));\r\n        if (!this.pageReference || typeof this.pageReference !== 'object') {\r\n            errorList.push(new annotation_errors_1.InvalidReferencePointerError(\"Inalid page reference\"));\r\n        }\r\n        var res = this.checkDate(this.updateDate);\r\n        if (res[1]) {\r\n            this.updateDate = res[1];\r\n        }\r\n        errorList = errorList.concat(res[0]);\r\n        errorList = errorList.concat(this.checkColor(this.color));\r\n        if (!this.id || this.id === \"\") {\r\n            errorList.push(new annotation_errors_1.InvalidIDError(\"Invalid ID provided\"));\r\n        }\r\n        // Check referenced appearance streams\r\n        if (this.takeAppearanceStreamFrom) {\r\n            if (typeof this.takeAppearanceStreamFrom === 'string') { // lookup appearance stream\r\n                var res_1 = [];\r\n                this.factory._getAnnotations().forEach(function (annots) {\r\n                    res_1 = annots.filter(function (value) { return value.id === _this.takeAppearanceStreamFrom; });\r\n                });\r\n                if (res_1.length === 0 || res_1.length > 1) {\r\n                    errorList.push(new annotation_errors_1.InvalidAnnotationReference(\"The provided string referencing the annotation to take the appearance stream from is not valid.\"));\r\n                }\r\n                if (!res_1[0].appearanceStream) {\r\n                    errorList.push(new annotation_errors_1.InvalidAppearanceStreamError(\"The referenced annotation has no specified appearance stream.\"));\r\n                }\r\n                this.appearanceStream = res_1[0].appearanceStream;\r\n            }\r\n            else if (this.takeAppearanceStreamFrom instanceof BaseAnnotationObj) {\r\n                this.appearanceStream = this.takeAppearanceStreamFrom.appearanceStream;\r\n            }\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {\r\n                var error = errorList_1[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    BaseAnnotationObj.prototype.checkColor = function (color) {\r\n        var errorList = [];\r\n        if (!color) {\r\n            return errorList;\r\n        }\r\n        if (!(color && \"r\" in color && \"g\" in color && \"b\" in color)) {\r\n            errorList.push(new annotation_errors_1.InvalidColorError(\"Not {r: <r>, g: <g>, b: <b>}\"));\r\n        }\r\n        if (color.r > 255 || color.r < 0) {\r\n            errorList.push(new annotation_errors_1.ColorOutOfRangeError(\"Red value out of range\"));\r\n        }\r\n        if (color.g > 255 || color.g < 0) {\r\n            errorList.push(new annotation_errors_1.ColorOutOfRangeError(\"Green value out of range\"));\r\n        }\r\n        if (color.b > 255 && color.b < 0) {\r\n            errorList.push(new annotation_errors_1.ColorOutOfRangeError(\"Blue value out of range\"));\r\n        }\r\n        return errorList;\r\n    };\r\n    BaseAnnotationObj.prototype.checkReferencePointer = function (ptr) {\r\n        var errorList = [];\r\n        if (!(ptr && \"obj\" in ptr && ptr.obj >= 0 && \"generation\" in ptr && ptr.generation >= 0)) {\r\n            errorList.push(new annotation_errors_1.InvalidReferencePointerError(\"Invalid reference pointer\"));\r\n        }\r\n        return errorList;\r\n    };\r\n    BaseAnnotationObj.prototype.checkDate = function (date) {\r\n        if (typeof date === 'string') {\r\n            return [[], date];\r\n        }\r\n        var errorList = [];\r\n        var ret_val = undefined;\r\n        try {\r\n            ret_val = util_1.Util.convertDateToPDFDate(date);\r\n        }\r\n        catch (e) {\r\n            errorList.push(new annotation_errors_1.InvalidDateError(\"Invalid update date provided\"));\r\n        }\r\n        return [errorList, ret_val];\r\n    };\r\n    BaseAnnotationObj.prototype.checkRect = function (nr, rect) {\r\n        var errorList = [];\r\n        if (!Array.isArray(rect)) {\r\n            errorList.push(new annotation_errors_1.InvalidRectError(\"invalid rect parameter\"));\r\n        }\r\n        if (rect.length !== nr) {\r\n            errorList.push(new annotation_errors_1.InvalidRectError(\"Rect has invalid number of entries: \" + rect + \" has \" + rect.length + \" entries, but should have \" + nr + \" entries\"));\r\n        }\r\n        rect.forEach(function (a) {\r\n            if ('number' !== typeof a) {\r\n                errorList.push(new annotation_errors_1.InvalidRectError(\"Rect \" + rect + \" has invalid entry: \" + a));\r\n            }\r\n        });\r\n        return errorList;\r\n    };\r\n    /**\r\n     * Extracts the information of the raw annotation obj that is provided by the PDF document parser\r\n     * */\r\n    BaseAnnotationObj.prototype.extract = function (annot_obj, page, cryptoInterface) {\r\n        this.pageReference = page;\r\n        this.type = annot_obj[\"/Subtype\"];\r\n        this.rect = annot_obj[\"/Rect\"];\r\n        if (annot_obj[\"/M\"])\r\n            this.updateDate = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj[\"/M\"], this.object_id));\r\n        if (annot_obj[\"/Border\"])\r\n            this.border = annot_obj[\"/Border\"];\r\n        if (annot_obj[\"/C\"])\r\n            this.color = annot_obj[\"/C\"];\r\n        if (annot_obj[\"/NM\"])\r\n            this.id = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj[\"/NM\"], this.object_id));\r\n        if (annot_obj[\"/Contents\"])\r\n            this.contents = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj[\"/Contents\"], this.object_id));\r\n        if (annot_obj[\"/AP\"])\r\n            this.appearanceStream = parser_1.AppearanceStreamParser.parse(this, annot_obj[\"/AP\"]);\r\n    };\r\n    return BaseAnnotationObj;\r\n}());\r\nexports.BaseAnnotationObj = BaseAnnotationObj;\r\n/**\r\n * A helper class that is only used if a parsed annotation type cannot be identified and translated into a supported annotation type\r\n * */\r\nvar RawAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(RawAnnotationObj, _super);\r\n    function RawAnnotationObj() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return RawAnnotationObj;\r\n}(BaseAnnotationObj));\r\nexports.RawAnnotationObj = RawAnnotationObj;\r\nvar ReplyTypes;\r\n(function (ReplyTypes) {\r\n    ReplyTypes[ReplyTypes[\"Reply\"] = 0] = \"Reply\";\r\n    ReplyTypes[ReplyTypes[\"Group\"] = 1] = \"Group\";\r\n})(ReplyTypes = exports.ReplyTypes || (exports.ReplyTypes = {}));\r\nvar MarkupAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(MarkupAnnotationObj, _super);\r\n    function MarkupAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.author = \"\";\r\n        _this.opacity = 1; // /CA\r\n        _this.subject = \"\";\r\n        return _this;\r\n    }\r\n    MarkupAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        ret = ret.concat(writer_util_1.WriterUtil.AUTHOR);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n        ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.author)), this.object_id))));\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.opacity) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.OPACITY);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.opacity));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.creationDate) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.CREATION_DATE);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n            ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.creationDate)), this.object_id))));\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.subject !== \"\") {\r\n            ret = ret.concat(writer_util_1.WriterUtil.SUBJ);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n            ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.subject)), this.object_id))));\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.richtextString) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.RC);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n            ret = ret.concat(Array.from(util_1.Util.escapeString(cryptoInterface.encrypt(new Uint8Array(util_1.Util.convertStringToAscii(this.richtextString)), this.object_id))));\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        return ret;\r\n    };\r\n    MarkupAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.opacity) {\r\n            try {\r\n                this.opacity = +this.opacity;\r\n            }\r\n            catch (e) {\r\n                errorList.push(new annotation_errors_1.InvalidOpacityError(\"Opacity no numerical value\"));\r\n            }\r\n            if (this.opacity < 0 || this.opacity > 255) {\r\n                errorList.push(new annotation_errors_1.InvalidOpacityError(\"Opacity out of range\"));\r\n            }\r\n        }\r\n        if (this.creationDate) {\r\n            var res = this.checkDate(this.creationDate);\r\n            this.creationDate = res[1];\r\n            errorList = errorList.concat(res[0]);\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {\r\n                var error = errorList_2[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    MarkupAnnotationObj.prototype.extract = function (annot_obj, page, cryptoInterface) {\r\n        _super.prototype.extract.call(this, annot_obj, page, cryptoInterface);\r\n        if (annot_obj[\"/T\"])\r\n            this.author = util_1.Util.convertUnicodeToString(cryptoInterface.decrypt(annot_obj[\"/T\"], this.object_id));\r\n    };\r\n    return MarkupAnnotationObj;\r\n}(BaseAnnotationObj));\r\nexports.MarkupAnnotationObj = MarkupAnnotationObj;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.SquareAnnotationObj = exports.CircleAnnotationObj = exports.CircleSquareAnnotationObj = void 0;\r\nvar annotation_types_1 = require(\"./annotation_types\");\r\nvar annotation_errors_1 = require(\"./annotation_errors\");\r\nvar writer_util_1 = require(\"../writer-util\");\r\nvar appearance_stream_1 = require(\"../appearance-stream\");\r\nvar resources_1 = require(\"../resources\");\r\nvar content_stream_1 = require(\"../content-stream\");\r\nvar CircleSquareAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(CircleSquareAnnotationObj, _super);\r\n    function CircleSquareAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.differenceRectangle = [];\r\n        return _this;\r\n    }\r\n    CircleSquareAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        if (this.fill) {\r\n            var fill = this.fill;\r\n            if (fill.r > 1)\r\n                fill.r /= 255;\r\n            if (fill.g > 1)\r\n                fill.g /= 255;\r\n            if (fill.b > 1)\r\n                fill.b /= 255;\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.FILL);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([fill.r, fill.g, fill.b]));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.differenceRectangle && this.differenceRectangle.length > 0) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.DIFFERENCE_RECTANGLE);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.differenceRectangle));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        return ret;\r\n    };\r\n    CircleSquareAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.fill) {\r\n            errorList = errorList.concat(this.checkColor(this.fill));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {\r\n                var error = errorList_1[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    return CircleSquareAnnotationObj;\r\n}(annotation_types_1.MarkupAnnotationObj));\r\nexports.CircleSquareAnnotationObj = CircleSquareAnnotationObj;\r\nvar CircleAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(CircleAnnotationObj, _super);\r\n    function CircleAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = \"/Circle\";\r\n        _this.type_encoded = [47, 67, 105, 114, 99, 108, 101]; // = '/Circle'\r\n        return _this;\r\n    }\r\n    CircleAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Circle\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {\r\n                var error = errorList_2[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    CircleAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = this.rect;\r\n        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillCircle(this.rect[0], this.rect[1], this.rect[2], this.rect[3]);\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return CircleAnnotationObj;\r\n}(CircleSquareAnnotationObj));\r\nexports.CircleAnnotationObj = CircleAnnotationObj;\r\nvar SquareAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(SquareAnnotationObj, _super);\r\n    function SquareAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = \"/Square\";\r\n        _this.type_encoded = [47, 83, 113, 117, 97, 114, 101]; // = '/Square'\r\n        return _this;\r\n    }\r\n    SquareAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Square\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_3 = errorList; _i < errorList_3.length; _i++) {\r\n                var error = errorList_3[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    SquareAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = this.rect;\r\n        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob, cryptoInterface) { return ob.writeGStateParameter(cryptoInterface); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillRect(this.rect[0], this.rect[1], this.rect[2], this.rect[3]);\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return SquareAnnotationObj;\r\n}(CircleSquareAnnotationObj));\r\nexports.SquareAnnotationObj = SquareAnnotationObj;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.FreeTextAnnotationObj = exports.FreeTextType = exports.TextJustification = void 0;\r\nvar annotation_types_1 = require(\"./annotation_types\");\r\nvar annotation_errors_1 = require(\"./annotation_errors\");\r\nvar writer_util_1 = require(\"../writer-util\");\r\nvar util_1 = require(\"../util\");\r\nvar appearance_stream_1 = require(\"../appearance-stream\");\r\nvar resources_1 = require(\"../resources\");\r\nvar content_stream_1 = require(\"../content-stream\");\r\nvar fonts_1 = require(\"../fonts\");\r\nvar TextJustification;\r\n(function (TextJustification) {\r\n    TextJustification[TextJustification[\"Left\"] = 0] = \"Left\";\r\n    TextJustification[TextJustification[\"Centered\"] = 1] = \"Centered\";\r\n    TextJustification[TextJustification[\"Right\"] = 2] = \"Right\";\r\n})(TextJustification = exports.TextJustification || (exports.TextJustification = {}));\r\nvar FreeTextType;\r\n(function (FreeTextType) {\r\n    FreeTextType[FreeTextType[\"FreeText\"] = 0] = \"FreeText\";\r\n    FreeTextType[FreeTextType[\"FreeTextCallout\"] = 1] = \"FreeTextCallout\";\r\n    FreeTextType[FreeTextType[\"FreeTextTypeWriter\"] = 2] = \"FreeTextTypeWriter\";\r\n})(FreeTextType = exports.FreeTextType || (exports.FreeTextType = {}));\r\nvar FreeTextAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(FreeTextAnnotationObj, _super);\r\n    function FreeTextAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.defaultAppearance = new content_stream_1.ContentStream(); // /DA\r\n        _this.differenceRectangle = [];\r\n        _this.textJustification = TextJustification.Left; // /Q\r\n        _this.calloutLine = [];\r\n        _this.freeTextType = FreeTextType.FreeText;\r\n        _this.lineEndingStyle = annotation_types_1.LineEndingStyle.None;\r\n        _this.font = \"/Helvetica\";\r\n        _this.fontSize = 18;\r\n        _this.resources = undefined;\r\n        _this.textColor = undefined;\r\n        _this.type = \"/FreeText\";\r\n        _this.type_encoded = [47, 70, 114, 101, 101, 84, 101, 120, 116]; // = '/FreeText'\r\n        return _this;\r\n    }\r\n    FreeTextAnnotationObj.prototype.convertJustification = function (just) {\r\n        switch (just) {\r\n            case TextJustification.Left:\r\n                return 0;\r\n            case TextJustification.Centered:\r\n                return 1;\r\n            case TextJustification.Right:\r\n                return 2;\r\n            default:\r\n                return 0;\r\n        }\r\n    };\r\n    FreeTextAnnotationObj.prototype.convertFreeTextType = function (ft) {\r\n        switch (ft) {\r\n            case FreeTextType.FreeText:\r\n                return util_1.Util.convertStringToAscii(\"/FreeText\");\r\n            case FreeTextType.FreeTextCallout:\r\n                return util_1.Util.convertStringToAscii(\"/FreeTextCallout\");\r\n            case FreeTextType.FreeTextTypeWriter:\r\n                return util_1.Util.convertStringToAscii(\"/FreeTextTypeWriter\");\r\n            default:\r\n                return util_1.Util.convertStringToAscii(\"/FreeText\");\r\n        }\r\n    };\r\n    FreeTextAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        var font = this.factory.parser.getFonts().getFont(this.font);\r\n        if (!font) {\r\n            font = this.factory.parser.getFonts().addFont(this.font);\r\n        }\r\n        if (!this.resources) {\r\n            this.resources = new resources_1.Resource();\r\n        }\r\n        if (!font.name) {\r\n            throw Error(\"Selected font has no name\");\r\n        }\r\n        this.resources.addFontDef({ name: font.name, refPtr: font.object_id });\r\n        if (this.defaultAppearance.isEmpty()) {\r\n            if (this.textColor) {\r\n                this.defaultAppearance.addOperator(\"rg\", [this.textColor.r, this.textColor.g, this.textColor.b]);\r\n            }\r\n            this.defaultAppearance.addOperator(\"Tf\", [font.name, this.fontSize]);\r\n        }\r\n        if (!this.defaultStyleString || \"\" === this.defaultStyleString) {\r\n            if (font.fontType === fonts_1.FontType.Type1) {\r\n                if (!font.baseFont) {\r\n                    throw Error(\"Type 1 font has no defined baseFont\");\r\n                }\r\n                var font_family = font.baseFont.substring(1);\r\n                this.defaultStyleString = \"font:\".concat(this.fontSize, \"pt \\\"\").concat(font_family, \"\\\";\");\r\n                if (this.color) {\r\n                    this.defaultStyleString += \"color:\".concat(util_1.Util.colorToHex(this.color), \";\");\r\n                }\r\n            }\r\n            else {\r\n                this.defaultStyleString = undefined;\r\n            }\r\n        }\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.DEFAULT_APPEARANCE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n        ret = ret.concat(this.defaultAppearance.writeContentStream(true));\r\n        ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.TEXT_JUSTIFICATION);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.convertJustification(this.textJustification)));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.IT);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(this.convertFreeTextType(this.freeTextType));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.calloutLine.length > 0) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.CALLOUT_LINE);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.calloutLine));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.lineEndingStyle !== annotation_types_1.LineEndingStyle.None) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.LINE_ENDING);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.convertLineEndingStyle(this.lineEndingStyle));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.defaultStyleString && this.defaultStyleString !== \"\") {\r\n            ret = ret.concat(writer_util_1.WriterUtil.DEFAULT_STYLE_STRING);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_START);\r\n            ret = ret.concat(util_1.Util.convertStringToAscii(this.defaultStyleString));\r\n            ret.push(writer_util_1.WriterUtil.BRACKET_END);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.differenceRectangle && this.differenceRectangle.length > 0) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.DIFFERENCE_RECTANGLE);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.differenceRectangle));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.resources) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.RESOURCES);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.resources.writeResource());\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        return ret;\r\n    };\r\n    FreeTextAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/FreeText\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        errorList = errorList.concat(this.checkColor(this.textColor));\r\n        if (this.calloutLine && this.calloutLine.length > 0 && this.freeTextType !== FreeTextType.FreeTextCallout) {\r\n            console.log(\"Warning: Callout line only relevant for free text type: 'Callout'\");\r\n        }\r\n        if (this.fontSize < 0) {\r\n            errorList.push(new annotation_errors_1.InvalidFontSizeError(\"A font size < 0 is not allowed\"));\r\n        }\r\n        if (typeof this.font === 'string' || this.font instanceof fonts_1.Font) {\r\n            if (typeof this.font === 'string') {\r\n                if (!this.font.startsWith(\"/\")) {\r\n                    this.font = \"/\".concat(this.font);\r\n                }\r\n            }\r\n            if (!this.factory.parser.getFonts().isRegisteredFont(this.font)) {\r\n                errorList.push(new annotation_errors_1.InvalidFontError(\"Only fonts registered in the PDF and standard fonts are allowed\"));\r\n            }\r\n        }\r\n        else {\r\n            errorList.push(new annotation_errors_1.InvalidFontError(\"Only fonts registered in the PDF and standard fonts are allowed\"));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {\r\n                var error = errorList_1[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    FreeTextAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        var font = this.factory.parser.getFonts().getFont(this.font);\r\n        if (!font) {\r\n            font = this.factory.parser.getFonts().addFont(this.font);\r\n        }\r\n        if (!font.name) {\r\n            font.name = this.factory.parser.getFonts().getUnusedFontName();\r\n        }\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = this.rect;\r\n        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];\r\n        if (!xobj.resources) {\r\n            xobj.resources = new resources_1.Resource();\r\n        }\r\n        xobj.resources.addFontDef({ name: font.name, refPtr: font.object_id });\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        go.setFillColor(this.color);\r\n        go.fillRect(this.rect[0], this.rect[1], this.rect[2], this.rect[3]);\r\n        var to = go.addTextObject();\r\n        to.setColor(this.textColor);\r\n        to.setFont(font.name, this.fontSize);\r\n        to.formatText(this.contents, font, this.fontSize, this.rect, this.textJustification);\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return FreeTextAnnotationObj;\r\n}(annotation_types_1.MarkupAnnotationObj));\r\nexports.FreeTextAnnotationObj = FreeTextAnnotationObj;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.InkAnnotationObj = void 0;\r\nvar annotation_types_1 = require(\"./annotation_types\");\r\nvar annotation_errors_1 = require(\"./annotation_errors\");\r\nvar writer_util_1 = require(\"../writer-util\");\r\nvar appearance_stream_1 = require(\"../appearance-stream\");\r\nvar resources_1 = require(\"../resources\");\r\nvar content_stream_1 = require(\"../content-stream\");\r\nvar InkAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(InkAnnotationObj, _super);\r\n    function InkAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.inkList = [];\r\n        _this.type = \"/Ink\";\r\n        _this.type_encoded = [47, 73, 110, 107]; // = '/Ink'\r\n        return _this;\r\n    }\r\n    InkAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        if (this.inkList && this.inkList.length > 0) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.INKLIST);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNestedNumberArray(this.inkList));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        return ret;\r\n    };\r\n    InkAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Ink\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if ('number' === typeof this.inkList[0]) {\r\n            this.inkList = [this.inkList];\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {\r\n                var error = errorList_1[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    InkAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = this.rect;\r\n        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color);\r\n        for (var _i = 0, _a = this.inkList; _i < _a.length; _i++) {\r\n            var inkl = _a[_i];\r\n            go.drawPolygon(inkl);\r\n        }\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return InkAnnotationObj;\r\n}(annotation_types_1.MarkupAnnotationObj));\r\nexports.InkAnnotationObj = InkAnnotationObj;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.PolygonAnnotationObj = exports.PolyLineAnnotationObj = exports.PolygonPolyLineAnnotationObj = exports.PolygonPolyLineIntent = void 0;\r\nvar annotation_types_1 = require(\"./annotation_types\");\r\nvar annotation_errors_1 = require(\"./annotation_errors\");\r\nvar writer_util_1 = require(\"../writer-util\");\r\nvar appearance_stream_1 = require(\"../appearance-stream\");\r\nvar resources_1 = require(\"../resources\");\r\nvar content_stream_1 = require(\"../content-stream\");\r\nvar PolygonPolyLineIntent;\r\n(function (PolygonPolyLineIntent) {\r\n    PolygonPolyLineIntent[PolygonPolyLineIntent[\"PolygonCloud\"] = 0] = \"PolygonCloud\";\r\n    PolygonPolyLineIntent[PolygonPolyLineIntent[\"PolyLineDimension\"] = 1] = \"PolyLineDimension\";\r\n    PolygonPolyLineIntent[PolygonPolyLineIntent[\"PolygonDimension\"] = 2] = \"PolygonDimension\";\r\n})(PolygonPolyLineIntent = exports.PolygonPolyLineIntent || (exports.PolygonPolyLineIntent = {}));\r\nvar PolygonPolyLineAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(PolygonPolyLineAnnotationObj, _super);\r\n    function PolygonPolyLineAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.vertices = [];\r\n        return _this;\r\n    }\r\n    PolygonPolyLineAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        if (this.fill) {\r\n            var fill = this.fill;\r\n            if (fill.r > 1)\r\n                fill.r /= 255;\r\n            if (fill.g > 1)\r\n                fill.g /= 255;\r\n            if (fill.b > 1)\r\n                fill.b /= 255;\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.FILL);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray([fill.r, fill.g, fill.b]));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.VERTICES);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.vertices));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        return ret;\r\n    };\r\n    PolygonPolyLineAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.fill) {\r\n            errorList = errorList.concat(this.checkColor(this.fill));\r\n        }\r\n        if (!this.vertices || this.vertices.length == 0) {\r\n            errorList.push(new annotation_errors_1.InvalidVerticesError(\"No vertices provided\"));\r\n        }\r\n        if (this.vertices.length % 2 !== 0) {\r\n            errorList.push(new annotation_errors_1.InvalidVerticesError(\"number of vertices must be an even number\"));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {\r\n                var error = errorList_1[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    return PolygonPolyLineAnnotationObj;\r\n}(annotation_types_1.MarkupAnnotationObj));\r\nexports.PolygonPolyLineAnnotationObj = PolygonPolyLineAnnotationObj;\r\nvar PolyLineAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(PolyLineAnnotationObj, _super);\r\n    function PolyLineAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.lineEndingStyles = [];\r\n        _this.type = \"/PolyLine\";\r\n        _this.type_encoded = [47, 80, 111, 108, 121, 76, 105, 110, 101]; // '/PolyLine\r\n        return _this;\r\n    }\r\n    PolyLineAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        if (this.lineEndingStyles && this.lineEndingStyles.length >= 2) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.LINE_ENDING);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret.push(writer_util_1.WriterUtil.ARRAY_START);\r\n            ret = ret.concat(this.convertLineEndingStyle(this.lineEndingStyles[0]));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.convertLineEndingStyle(this.lineEndingStyles[1]));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret.push(writer_util_1.WriterUtil.ARRAY_END);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        return ret;\r\n    };\r\n    PolyLineAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/PolyLine\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {\r\n                var error = errorList_2[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    PolyLineAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = this.rect;\r\n        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawPolygon(this.vertices);\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return PolyLineAnnotationObj;\r\n}(PolygonPolyLineAnnotationObj));\r\nexports.PolyLineAnnotationObj = PolyLineAnnotationObj;\r\nvar PolygonAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(PolygonAnnotationObj, _super);\r\n    function PolygonAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = \"/Polygon\";\r\n        _this.type_encoded = [47, 80, 111, 108, 121, 103, 111, 110]; // = '/Polygon\r\n        return _this;\r\n    }\r\n    PolygonAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Polygon\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_3 = errorList; _i < errorList_3.length; _i++) {\r\n                var error = errorList_3[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    PolygonAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = this.rect;\r\n        xobj.matrix = [1, 0, 0, 1, -this.rect[0], -this.rect[1]];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillPolygon(this.vertices);\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return PolygonAnnotationObj;\r\n}(PolygonPolyLineAnnotationObj));\r\nexports.PolygonAnnotationObj = PolygonAnnotationObj;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.TextAnnotationObj = exports.AnnotationState = exports.AnnotationStateModel = exports.AnnotationIcon = void 0;\r\nvar annotation_types_1 = require(\"./annotation_types\");\r\nvar annotation_errors_1 = require(\"./annotation_errors\");\r\nvar writer_util_1 = require(\"../writer-util\");\r\nvar util_1 = require(\"../util\");\r\nvar appearance_stream_1 = require(\"../appearance-stream\");\r\nvar resources_1 = require(\"../resources\");\r\nvar content_stream_1 = require(\"../content-stream\");\r\nvar AnnotationIcon;\r\n(function (AnnotationIcon) {\r\n    AnnotationIcon[AnnotationIcon[\"Comment\"] = 0] = \"Comment\";\r\n    AnnotationIcon[AnnotationIcon[\"Key\"] = 1] = \"Key\";\r\n    AnnotationIcon[AnnotationIcon[\"Note\"] = 2] = \"Note\";\r\n    AnnotationIcon[AnnotationIcon[\"Help\"] = 3] = \"Help\";\r\n    AnnotationIcon[AnnotationIcon[\"NewParagraph\"] = 4] = \"NewParagraph\";\r\n    AnnotationIcon[AnnotationIcon[\"Paragraph\"] = 5] = \"Paragraph\";\r\n    AnnotationIcon[AnnotationIcon[\"Insert\"] = 6] = \"Insert\";\r\n})(AnnotationIcon = exports.AnnotationIcon || (exports.AnnotationIcon = {}));\r\nvar AnnotationStateModel;\r\n(function (AnnotationStateModel) {\r\n    AnnotationStateModel[AnnotationStateModel[\"Marked\"] = 0] = \"Marked\";\r\n    AnnotationStateModel[AnnotationStateModel[\"Review\"] = 1] = \"Review\";\r\n})(AnnotationStateModel = exports.AnnotationStateModel || (exports.AnnotationStateModel = {}));\r\nvar AnnotationState;\r\n(function (AnnotationState) {\r\n    AnnotationState[AnnotationState[\"Marked\"] = 0] = \"Marked\";\r\n    AnnotationState[AnnotationState[\"Unmarked\"] = 1] = \"Unmarked\";\r\n    AnnotationState[AnnotationState[\"Accepted\"] = 2] = \"Accepted\";\r\n    AnnotationState[AnnotationState[\"Rejected\"] = 3] = \"Rejected\";\r\n    AnnotationState[AnnotationState[\"Cancelled\"] = 4] = \"Cancelled\";\r\n    AnnotationState[AnnotationState[\"Completed\"] = 5] = \"Completed\";\r\n    AnnotationState[AnnotationState[\"None\"] = 6] = \"None\";\r\n})(AnnotationState = exports.AnnotationState || (exports.AnnotationState = {}));\r\nvar TextAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(TextAnnotationObj, _super);\r\n    function TextAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.open = false;\r\n        _this.icon = AnnotationIcon.Note;\r\n        _this.state = undefined;\r\n        _this.type = \"/Text\";\r\n        _this.type_encoded = [47, 84, 101, 120, 116]; // = '/Text'\r\n        // demanded by PDF specification (p. 394 - 12.5.6.4 Text Annotations)\r\n        _this.annotationFlags = { noZoom: true, noRotate: true };\r\n        return _this;\r\n    }\r\n    TextAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = [0, 0, 100, 100];\r\n        xobj.matrix = [1, 0, 0, 1, 0, 0];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).drawFillRect(0, 0, 100, 100, 25);\r\n        switch (this.icon) {\r\n            case AnnotationIcon.Help:\r\n                go.addTextObject().setColor().setFont(\"/F1\", 120).setText(\"?\", [20, 10]);\r\n                break;\r\n            case AnnotationIcon.Insert:\r\n                throw Error(\"Not yet implemented. Pls. create ticket on Github with feature request.\");\r\n                break;\r\n            case AnnotationIcon.Key:\r\n                throw Error(\"Not yet implemented. Pls. create ticket on Github with feature request.\");\r\n                break;\r\n            case AnnotationIcon.NewParagraph:\r\n                throw Error(\"Not yet implemented. Pls. create ticket on Github with feature request.\");\r\n                break;\r\n            case AnnotationIcon.Paragraph:\r\n                throw Error(\"Not yet implemented. Pls. create ticket on Github with feature request.\");\r\n                break;\r\n            default:\r\n                go.drawPolygon([10, 10, 10, 90, 80, 90, 80, 80, 90, 80, 90, 10, 10, 10]).drawLine(80, 90, 90, 80);\r\n        }\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    TextAnnotationObj.prototype.convertAnnotationIcon = function (icon) {\r\n        switch (icon) {\r\n            case AnnotationIcon.Comment:\r\n                return [47, 67, 111, 109, 109, 101, 110, 116]; // = '/Comment'\r\n            case AnnotationIcon.Key:\r\n                return [47, 75, 101, 121]; // = '/Key'\r\n            case AnnotationIcon.Note:\r\n                return [47, 78, 111, 116, 101]; // = '/Note'\r\n            case AnnotationIcon.Help:\r\n                return [47, 72, 101, 108, 112]; // = '/Help'\r\n            case AnnotationIcon.NewParagraph:\r\n                return [47, 78, 101, 119, 80, 97, 114, 97, 103, 114, 97, 112, 104]; // = '/NewParagraph'\r\n            case AnnotationIcon.Paragraph:\r\n                return [47, 80, 97, 114, 97, 103, 114, 97, 112, 104]; // = '/Paragraph'\r\n            case AnnotationIcon.Insert:\r\n                return [47, 73, 110, 115, 101, 114, 116]; // = '/Insert'\r\n        }\r\n        return [];\r\n    };\r\n    TextAnnotationObj.prototype.convertState = function (state) {\r\n        switch (state) {\r\n            case AnnotationState.Marked:\r\n                return util_1.Util.convertStringToAscii(\"/Marked\");\r\n            case AnnotationState.Unmarked:\r\n                return util_1.Util.convertStringToAscii(\"/Unmarked\");\r\n            case AnnotationState.Accepted:\r\n                return util_1.Util.convertStringToAscii(\"/Accepted\");\r\n            case AnnotationState.Rejected:\r\n                return util_1.Util.convertStringToAscii(\"/Rejected\");\r\n            case AnnotationState.Cancelled:\r\n                return util_1.Util.convertStringToAscii(\"/Cancelled\");\r\n            case AnnotationState.Completed:\r\n                return util_1.Util.convertStringToAscii(\"/Completed\");\r\n            case AnnotationState.None:\r\n                return util_1.Util.convertStringToAscii(\"/None\");\r\n        }\r\n        return [];\r\n    };\r\n    TextAnnotationObj.prototype.convertStateModel = function (stateModel) {\r\n        switch (stateModel) {\r\n            case AnnotationStateModel.Marked:\r\n                return util_1.Util.convertStringToAscii(\"/Marked\");\r\n            case AnnotationStateModel.Review:\r\n                return util_1.Util.convertStringToAscii(\"/Review\");\r\n        }\r\n        return [];\r\n    };\r\n    TextAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        if (this.open) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.OPEN);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.TRUE);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.icon) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.NAME);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.convertAnnotationIcon(this.icon));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.state) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.STATE);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.convertState(this.state));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.stateModel) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.STATEMODEL);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.convertStateModel(this.stateModel));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        return ret;\r\n    };\r\n    TextAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Text\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (this.state && !this.stateModel) {\r\n            errorList.push(new annotation_errors_1.InvalidStateError(\"You need to specify a state model, when specifying a state\"));\r\n        }\r\n        if (this.stateModel && !this.state) {\r\n            if (this.stateModel.valueOf() === AnnotationStateModel.Marked) {\r\n                this.state = AnnotationState.Unmarked;\r\n            }\r\n            else if (this.stateModel.valueOf() === AnnotationStateModel.Review) {\r\n                this.state = AnnotationState.None;\r\n            }\r\n            else {\r\n                errorList.push(new annotation_errors_1.InvalidStateError(\"Invalid state model selected\"));\r\n            }\r\n        }\r\n        if (this.state && this.stateModel) {\r\n            if (this.stateModel.valueOf() === AnnotationStateModel.Marked) {\r\n                if (this.state.valueOf() !== AnnotationState.Marked && this.state.valueOf() !== AnnotationState.Unmarked) {\r\n                    errorList.push(new annotation_errors_1.InvalidStateError(\"Invalid annotation state for state model 'Marked' only 'Marked' and 'Unmarked' are legal values\"));\r\n                }\r\n            }\r\n            else if (this.stateModel.valueOf() === AnnotationStateModel.Review) {\r\n                if (this.state.valueOf() !== AnnotationState.Accepted && this.state.valueOf() !== AnnotationState.Rejected &&\r\n                    this.state.valueOf() !== AnnotationState.Cancelled && this.state.valueOf() !== AnnotationState.Completed &&\r\n                    this.state.valueOf() !== AnnotationState.None) {\r\n                    errorList.push(new annotation_errors_1.InvalidStateError(\"Invalid annotation state for state model 'Review' only 'Accepted', 'Rejected', 'Cancelled', 'Completed' and 'None' are legal values\"));\r\n                }\r\n            }\r\n            else {\r\n                errorList.push(new annotation_errors_1.InvalidStateError(\"Invalid state model selected\"));\r\n            }\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {\r\n                var error = errorList_1[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    return TextAnnotationObj;\r\n}(annotation_types_1.MarkupAnnotationObj));\r\nexports.TextAnnotationObj = TextAnnotationObj;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.StrikeOutAnnotationObj = exports.SquigglyAnnotationObj = exports.UnderlineAnnotationObj = exports.HighlightAnnotationObj = exports.TextMarkupAnnotationObj = void 0;\r\nvar annotation_types_1 = require(\"./annotation_types\");\r\nvar annotation_errors_1 = require(\"./annotation_errors\");\r\nvar writer_util_1 = require(\"../writer-util\");\r\nvar appearance_stream_1 = require(\"../appearance-stream\");\r\nvar resources_1 = require(\"../resources\");\r\nvar content_stream_1 = require(\"../content-stream\");\r\nvar TextMarkupAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(TextMarkupAnnotationObj, _super);\r\n    function TextMarkupAnnotationObj() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.quadPoints = [];\r\n        return _this;\r\n    }\r\n    TextMarkupAnnotationObj.prototype.writeAnnotationObject = function (cryptoInterface) {\r\n        var ret = _super.prototype.writeAnnotationObject.call(this, cryptoInterface);\r\n        ret = ret.concat(writer_util_1.WriterUtil.QUADPOINTS);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.quadPoints));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        return ret;\r\n    };\r\n    TextMarkupAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (errorList.length === 1 && errorList[0] instanceof annotation_errors_1.InvalidRectError) {\r\n            if (this.quadPoints && this.quadPoints.length > 0) {\r\n                this.rect = this.extractRectFromQuadPoints(this.quadPoints);\r\n                errorList = this.checkRect(4, this.rect);\r\n            }\r\n        }\r\n        if (!this.quadPoints || this.quadPoints.length === 0) {\r\n            var rect = this.rect;\r\n            this.quadPoints = [rect[0], rect[3], rect[2], rect[3], rect[0], rect[1], rect[2], rect[1]];\r\n        }\r\n        errorList = errorList.concat(this.checkQuadPoints(this.quadPoints));\r\n        if (enact) {\r\n            for (var _i = 0, errorList_1 = errorList; _i < errorList_1.length; _i++) {\r\n                var error = errorList_1[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    /**\r\n     * Extracts the rectangular hull from a quadPoint definition\r\n     * */\r\n    TextMarkupAnnotationObj.prototype.extractRectFromQuadPoints = function (quadPoints) {\r\n        var x_values = quadPoints.filter(function (element, index) { return index % 2 === 0; });\r\n        var y_values = quadPoints.filter(function (element, index) { return index % 2 !== 0; });\r\n        return [Math.min.apply(Math, x_values), Math.min.apply(Math, y_values), Math.max.apply(Math, x_values), Math.max.apply(Math, y_values)];\r\n    };\r\n    /**\r\n     * Checks the 'quadPoints' parameter\r\n     * */\r\n    TextMarkupAnnotationObj.prototype.checkQuadPoints = function (quadPoints) {\r\n        var errorList = [];\r\n        if (quadPoints.length % 8 !== 0)\r\n            errorList.push(new annotation_errors_1.InvalidQuadPointError(\"Quadpoints array has length \".concat(quadPoints.length, \" but must be a multiple of 8\")));\r\n        quadPoints.forEach(function (a) {\r\n            if ('number' !== typeof a)\r\n                errorList.push(new annotation_errors_1.InvalidQuadPointError(\"Quadpoint \" + quadPoints + \" has invalid entry: \" + a));\r\n        });\r\n        return errorList;\r\n    };\r\n    return TextMarkupAnnotationObj;\r\n}(annotation_types_1.MarkupAnnotationObj));\r\nexports.TextMarkupAnnotationObj = TextMarkupAnnotationObj;\r\nvar HighlightAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(HighlightAnnotationObj, _super);\r\n    function HighlightAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = \"/Highlight\";\r\n        _this.type_encoded = [47, 72, 105, 103, 104, 108, 105, 103, 104, 116]; // = '/Highlight'\r\n        return _this;\r\n    }\r\n    HighlightAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        var _this = this;\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = [0, 0, 100, 100];\r\n        xobj.matrix = [1, 0, 0, 1, 0, 0];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        if (this.quadPoints && this.quadPoints.length > 8) {\r\n            go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color);\r\n            var _loop_1 = function (i) {\r\n                var points = [];\r\n                this_1.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });\r\n                go.fillPolygon([points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]]);\r\n            };\r\n            var this_1 = this;\r\n            for (var i = 0; i < this.quadPoints.length; i += 8) {\r\n                _loop_1(i);\r\n            }\r\n        }\r\n        else {\r\n            go.setLineColor({ r: 0, g: 0, b: 0 }).setFillColor(this.color).fillRect(0, 0, 100, 100, 25);\r\n        }\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    HighlightAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Highlight\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_2 = errorList; _i < errorList_2.length; _i++) {\r\n                var error = errorList_2[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    return HighlightAnnotationObj;\r\n}(TextMarkupAnnotationObj));\r\nexports.HighlightAnnotationObj = HighlightAnnotationObj;\r\nvar UnderlineAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(UnderlineAnnotationObj, _super);\r\n    function UnderlineAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = \"/Underline\";\r\n        _this.type_encoded = [47, 85, 110, 100, 101, 114, 108, 105, 110, 101]; // = '/Underline'\r\n        return _this;\r\n    }\r\n    UnderlineAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Underline\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_3 = errorList; _i < errorList_3.length; _i++) {\r\n                var error = errorList_3[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    UnderlineAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        var _this = this;\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = [0, 0, 100, 100];\r\n        xobj.matrix = [1, 0, 0, 1, 0, 0];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        if (this.quadPoints && this.quadPoints.length > 8) {\r\n            go.setLineColor(this.color);\r\n            var _loop_2 = function (i) {\r\n                var points = [];\r\n                this_2.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });\r\n                go.drawLine(points[0], points[1], points[2], points[1]);\r\n            };\r\n            var this_2 = this;\r\n            for (var i = 0; i < this.quadPoints.length; i += 8) {\r\n                _loop_2(i);\r\n            }\r\n        }\r\n        else {\r\n            go.setLineColor(this.color).drawLine(0, 0, 100, 0);\r\n        }\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return UnderlineAnnotationObj;\r\n}(TextMarkupAnnotationObj));\r\nexports.UnderlineAnnotationObj = UnderlineAnnotationObj;\r\nvar SquigglyAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(SquigglyAnnotationObj, _super);\r\n    function SquigglyAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = \"/Squiggly\";\r\n        _this.type_encoded = [47, 83, 113, 117, 105, 103, 103, 108, 121]; // = '/Squiggly'\r\n        return _this;\r\n    }\r\n    SquigglyAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/Squiggly\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_4 = errorList; _i < errorList_4.length; _i++) {\r\n                var error = errorList_4[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    /**\r\n     * Draws a horizontal squiggly line\r\n     * */\r\n    SquigglyAnnotationObj.prototype.drawSquigglyLine = function (go, x1, x2, y) {\r\n        for (var i = x1; i < x2; i += 5) {\r\n            if (i % 2 === 0) {\r\n                go.drawLine(i, y, i + 5, y + 5);\r\n            }\r\n            else {\r\n                go.drawLine(i, y + 5, i + 5, y);\r\n            }\r\n        }\r\n    };\r\n    SquigglyAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        var _this = this;\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = [0, 0, 100, 100];\r\n        xobj.matrix = [1, 0, 0, 1, 0, 0];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        if (this.quadPoints && this.quadPoints.length > 8) {\r\n            go.setLineColor(this.color);\r\n            var _loop_3 = function (i) {\r\n                var points = [];\r\n                this_3.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });\r\n                this_3.drawSquigglyLine(go, points[0], points[2], points[1]);\r\n            };\r\n            var this_3 = this;\r\n            for (var i = 0; i < this.quadPoints.length; i += 8) {\r\n                _loop_3(i);\r\n            }\r\n        }\r\n        else {\r\n            go.setLineColor(this.color);\r\n            this.drawSquigglyLine(go, 0, 100, 0);\r\n        }\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return SquigglyAnnotationObj;\r\n}(TextMarkupAnnotationObj));\r\nexports.SquigglyAnnotationObj = SquigglyAnnotationObj;\r\nvar StrikeOutAnnotationObj = /** @class */ (function (_super) {\r\n    __extends(StrikeOutAnnotationObj, _super);\r\n    function StrikeOutAnnotationObj() {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = \"/StrikeOut\";\r\n        _this.type_encoded = [47, 83, 116, 114, 105, 107, 101, 79, 117, 116]; // = '/StrikeOut'\r\n        return _this;\r\n    }\r\n    StrikeOutAnnotationObj.prototype.validate = function (enact) {\r\n        if (enact === void 0) { enact = true; }\r\n        var errorList = _super.prototype.validate.call(this, false);\r\n        if (this.type !== \"/StrikeOut\") {\r\n            errorList.push(new annotation_errors_1.InvalidAnnotationTypeError(\"Invalid annotation type \".concat(this.type)));\r\n        }\r\n        if (enact) {\r\n            for (var _i = 0, errorList_5 = errorList; _i < errorList_5.length; _i++) {\r\n                var error = errorList_5[_i];\r\n                throw error;\r\n            }\r\n        }\r\n        return errorList;\r\n    };\r\n    StrikeOutAnnotationObj.prototype.createDefaultAppearanceStream = function () {\r\n        var _this = this;\r\n        this.appearanceStream = new appearance_stream_1.AppStream(this);\r\n        this.appearanceStream.new_object = true;\r\n        var xobj = new appearance_stream_1.XObjectObj();\r\n        xobj.object_id = this.factory.parser.getFreeObjectId();\r\n        xobj.new_object = true;\r\n        xobj.bBox = [0, 0, 100, 100];\r\n        xobj.matrix = [1, 0, 0, 1, 0, 0];\r\n        var cs = new content_stream_1.ContentStream();\r\n        xobj.contentStream = cs;\r\n        var cmo = cs.addMarkedContentObject([\"/Tx\"]);\r\n        var go = cmo.addGraphicObject();\r\n        if (this.opacity !== 1) {\r\n            go.addOperator(\"gs\", [\"/GParameters\"]);\r\n            var gsp = new appearance_stream_1.GraphicsStateParameter(this.factory.parser.getFreeObjectId());\r\n            gsp.CA = gsp.ca = this.opacity;\r\n            this.additional_objects_to_write.push({ obj: gsp, func: (function (ob) { return ob.writeGStateParameter(); }) });\r\n            var res = new resources_1.Resource();\r\n            res.addGStateDef({ name: \"/GParameters\", refPtr: gsp.object_id });\r\n            xobj.resources = res;\r\n        }\r\n        if (this.quadPoints && this.quadPoints.length > 8) {\r\n            go.setLineColor(this.color);\r\n            var _loop_4 = function (i) {\r\n                var points = [];\r\n                this_4.quadPoints.slice(i, i + 8).forEach(function (value, index) { return index % 2 === 0 ? points.push(value - _this.rect[0]) : points.push(value - _this.rect[1]); });\r\n                var y_value = (points[5] - points[1]) / 2 + points[1];\r\n                go.drawLine(points[0], y_value, points[2], y_value);\r\n            };\r\n            var this_4 = this;\r\n            for (var i = 0; i < this.quadPoints.length; i += 8) {\r\n                _loop_4(i);\r\n            }\r\n        }\r\n        else {\r\n            go.setLineColor(this.color).drawLine(0, 50, 100, 50);\r\n        }\r\n        this.appearanceStream.N = xobj;\r\n        this.additional_objects_to_write.push({ obj: xobj, func: (function (ob, cryptoInterface) { return ob.writeXObject(cryptoInterface); }) });\r\n    };\r\n    return StrikeOutAnnotationObj;\r\n}(TextMarkupAnnotationObj));\r\nexports.StrikeOutAnnotationObj = StrikeOutAnnotationObj;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.GraphicsStateParameter = exports.XObjectObj = exports.AppStream = void 0;\r\nvar writer_util_1 = require(\"./writer-util\");\r\nvar util_1 = require(\"./util\");\r\nvar content_stream_1 = require(\"./content-stream\");\r\nvar stream_1 = require(\"./stream\");\r\nvar AppStream = /** @class */ (function () {\r\n    function AppStream(annot) {\r\n        this.object_id = undefined;\r\n        this.new_object = false; // indicates to the factory that this object must be created when writing the document\r\n        this.N = undefined;\r\n        this.R = undefined;\r\n        this.D = undefined;\r\n        this.annot = annot;\r\n    }\r\n    /**\r\n     * Lookups the N content stream. If it is only provided by a reference pointer it will parse\r\n     * the corresponding Xobject\r\n     * */\r\n    AppStream.prototype.lookupNContentStream = function () {\r\n        if (!this.N) {\r\n            console.warn(\"call lookupNContentStream without set content stream value\");\r\n            return;\r\n        }\r\n        else if (util_1.Util.isReferencePointer(this.N)) {\r\n            this.N = this.annot.factory.parser.extractXObject(this.N);\r\n        }\r\n        else if (this.N instanceof XObjectObj) {\r\n            return; // already looked up\r\n        }\r\n        else {\r\n            throw Error(\"Could not lookup N content stream\");\r\n        }\r\n    };\r\n    /**\r\n     * Helper writer function of the references. Resolves different types\r\n     * */\r\n    AppStream.prototype.writeAppearanceStreamObj = function (ap) {\r\n        var ret = [];\r\n        if (util_1.Util.isReferencePointer(ap)) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(ap, true));\r\n        }\r\n        else if (ap instanceof XObjectObj) {\r\n            if (!ap.object_id) {\r\n                throw Error(\"No object id specified in XObject\");\r\n            }\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(ap.object_id, true));\r\n        }\r\n        else {\r\n            throw Error(\"Invalid appearance stream object\");\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Writes the appearance stream object\r\n     * */\r\n    AppStream.prototype.writeAppearanceStream = function () {\r\n        var ret = [];\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);\r\n        if (this.N) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.AP_N);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.writeAppearanceStreamObj(this.N));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.R) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.AP_R);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.writeAppearanceStreamObj(this.R));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.D) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.AP_D);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.writeAppearanceStreamObj(this.D));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);\r\n        return ret;\r\n    };\r\n    return AppStream;\r\n}());\r\nexports.AppStream = AppStream;\r\nvar XObjectObj = /** @class */ (function () {\r\n    // note that Type is /XObject instead of /Annot in annotation objects\r\n    function XObjectObj() {\r\n        this.object_id = undefined;\r\n        this.new_object = false; // indicates to the factory that this object must be created when writing the document\r\n        this.type = \"/Form\";\r\n        this.type_encoded = writer_util_1.WriterUtil.SUBTYPE; // = '/Form'\r\n        this.bBox = [];\r\n        this.name = \"/ARM\";\r\n        this.matrix = [1, 0, 0, 1, 0, 0];\r\n        this.formType = 1;\r\n        this.contentStream = undefined;\r\n        this.resources = undefined;\r\n    }\r\n    /**\r\n     * Adds a content stream operator\r\n     * */\r\n    XObjectObj.prototype.addOperator = function (operator, parameters) {\r\n        if (parameters === void 0) { parameters = []; }\r\n        if (!this.contentStream)\r\n            this.contentStream = new content_stream_1.ContentStream();\r\n        this.contentStream.addOperator(operator, parameters);\r\n    };\r\n    XObjectObj.prototype.writeXObject = function (cryptoInterface) {\r\n        if (!this.object_id)\r\n            throw Error(\"object_id of XObject not set\");\r\n        var ret = [];\r\n        ret = ret.concat(writer_util_1.WriterUtil.TYPE_XOBJECT);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.SUBTYPE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.FORM);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.FORMTYPE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.formType));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.BBOX);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.bBox));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.NAME);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(util_1.Util.convertStringToAscii(this.name));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.resources) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.RESOURCES);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.resources.writeResource());\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.MATRIX);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.matrix));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        var stream_data = (this.contentStream) ? this.contentStream.writeContentStream() : [];\r\n        return writer_util_1.WriterUtil.writeStreamObject(this.object_id, ret, new stream_1.FlateStream(new Uint8Array(stream_data), undefined, true, cryptoInterface, this.object_id));\r\n    };\r\n    return XObjectObj;\r\n}());\r\nexports.XObjectObj = XObjectObj;\r\nvar GraphicsStateParameter = /** @class */ (function () {\r\n    function GraphicsStateParameter(object_id) {\r\n        if (object_id === void 0) { object_id = undefined; }\r\n        this.object_id = undefined;\r\n        this.new_object = false; // indicates to the factory that this object must be created when writing the document\r\n        this.type = \"/ExtGState\";\r\n        this.type_encoded = writer_util_1.WriterUtil.EXTGSTATE; // = '/ExtGState'\r\n        this.CA = undefined;\r\n        this.ca = undefined;\r\n        this.object_id = object_id;\r\n    }\r\n    GraphicsStateParameter.prototype.writeGStateParameter = function () {\r\n        if (!this.object_id)\r\n            throw Error(\"GStateParameter dictionary has no object id\");\r\n        var ret = writer_util_1.WriterUtil.writeReferencePointer(this.object_id);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.OBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.TYPE_EXTGSTATE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        // opacity stroking operations\r\n        if (this.CA) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.OPACITY);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.CA));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        // opacity non stroking operations\r\n        if (this.ca) {\r\n            ret = ret.concat(writer_util_1.WriterUtil._OPACITY);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.ca));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        return ret;\r\n    };\r\n    return GraphicsStateParameter;\r\n}());\r\nexports.GraphicsStateParameter = GraphicsStateParameter;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.ArrayUtil = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar object_util_1 = require(\"./object-util\");\r\n/**\r\n * Holds the logic for extracting arrays\r\n * */\r\nvar ArrayUtil = /** @class */ (function () {\r\n    function ArrayUtil() {\r\n    }\r\n    /**\r\n     * Extracts array of numbers and arrays of references\r\n     *\r\n     * The function supports arbitrarily nesting of arrays and multiple types.\r\n     * */\r\n    ArrayUtil.extractArray = function (data, ptr) {\r\n        ptr = util_1.Util.skipSpaces(data, ptr);\r\n        var start_index = ptr;\r\n        if (data[ptr] !== util_1.Util.ARRAY_START[0])\r\n            throw Error(\"Invalid array sequence -- does not start with '['\");\r\n        ptr += 1;\r\n        var next = util_1.Util.readNextWord(data, ptr);\r\n        var next_string = next.result;\r\n        ptr = next.start_index;\r\n        var ret_list = [];\r\n        while (next_string) {\r\n            if (next_string[0] === util_1.Util.ARRAY_START[0]) {\r\n                var sub_array = ArrayUtil.extractArray(data, ptr);\r\n                ptr = sub_array.end_index;\r\n                ret_list.push(sub_array.result);\r\n            }\r\n            else if (util_1.Util.areArraysEqual(next_string, util_1.Util.NULL)) {\r\n                ret_list.push(\"null\");\r\n                ptr += next_string.length - 1;\r\n            }\r\n            else if (next_string[0] === util_1.Util.LITERAL_STRING_END[0]) {\r\n                return { result: ret_list, start_index: start_index, end_index: next.end_index };\r\n            }\r\n            else if (next_string[0] === util_1.Util.LITERAL_STRING_START[0]) {\r\n                var extracted_string = util_1.Util.extractString(data, ptr);\r\n                ret_list.push(extracted_string.result);\r\n                ptr = extracted_string.end_index;\r\n            }\r\n            else if (next_string[0] === util_1.Util.DICT_START[0]) { // <\r\n                var lookup_word = util_1.Util.readNextWord(data, next.end_index + 1);\r\n                if (lookup_word.result && lookup_word.result[0] === util_1.Util.DICT_START[0]) {\r\n                    var dict = {};\r\n                    ptr = object_util_1.ObjectUtil.extractDictValueRec(data, ptr, dict);\r\n                    ret_list.push(dict);\r\n                }\r\n                else {\r\n                    var hex_string = util_1.Util.extractHexString(data, ptr);\r\n                    ret_list.push(hex_string.result);\r\n                    ptr = hex_string.end_index;\r\n                }\r\n            }\r\n            else if (next_string[0] === 47) { // /\r\n                var opt_value = util_1.Util.extractOptionValue(data, ptr);\r\n                ret_list.push(\"/\" + opt_value.result);\r\n                ptr = opt_value.end_index;\r\n            }\r\n            else if (next_string[0] === util_1.Util.R[0]) { // Reference pointer\r\n                var obj = ret_list[ret_list.length - 2];\r\n                var generation = ret_list[ret_list.length - 1];\r\n                ret_list = ret_list.slice(0, ret_list.length - 2);\r\n                ret_list.push({ obj: obj, generation: generation });\r\n                ptr = next.end_index;\r\n            }\r\n            else if (next_string[0] === util_1.Util.ARRAY_END[0]) {\r\n                break;\r\n            }\r\n            else {\r\n                var nbr = util_1.Util.extractNumber(data, ptr);\r\n                ret_list.push(nbr.result);\r\n                ptr = nbr.end_index;\r\n            }\r\n            ++ptr;\r\n            ptr = util_1.Util.skipSpaces(data, ptr);\r\n            next = util_1.Util.readNextWord(data, ptr);\r\n            next_string = next.result;\r\n            ptr = next.start_index;\r\n        }\r\n        return { result: ret_list, start_index: start_index, end_index: next.end_index };\r\n    };\r\n    return ArrayUtil;\r\n}());\r\nexports.ArrayUtil = ArrayUtil;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.ContentStream = exports.TextObject = exports.GraphicsObject = exports.MarkedContent = exports.Operator = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar writer_util_1 = require(\"./writer-util\");\r\nvar freetext_annotation_1 = require(\"./annotations/freetext_annotation\");\r\nvar Operator = /** @class */ (function () {\r\n    function Operator(name, parameters) {\r\n        if (name === void 0) { name = \"\"; }\r\n        if (parameters === void 0) { parameters = []; }\r\n        this.name = name;\r\n        this.parameters = parameters;\r\n        this.operators = [];\r\n    }\r\n    /**\r\n     * Transforms operator to byte array\r\n     * */\r\n    Operator.prototype.toByteArray = function (noLineFeed) {\r\n        if (noLineFeed === void 0) { noLineFeed = false; }\r\n        var ret = [];\r\n        for (var _i = 0, _a = this.operators; _i < _a.length; _i++) {\r\n            var op = _a[_i];\r\n            for (var _b = 0, _c = op.parameters; _b < _c.length; _b++) {\r\n                var param = _c[_b];\r\n                ret = ret.concat(util_1.Util.convertStringToAscii(\"\".concat(param)));\r\n                ret.push(util_1.Util.SPACE);\r\n            }\r\n            if (op instanceof MarkedContent) {\r\n                ret = ret.concat(writer_util_1.WriterUtil.BMC);\r\n                if (!noLineFeed) {\r\n                    ret.push(util_1.Util.LF);\r\n                }\r\n                else {\r\n                    ret.push(util_1.Util.SPACE);\r\n                }\r\n                ret = ret.concat(op.toByteArray());\r\n                ret = ret.concat(writer_util_1.WriterUtil.EMC);\r\n            }\r\n            else if (op instanceof GraphicsObject) {\r\n                ret.push(writer_util_1.WriterUtil.q);\r\n                if (!noLineFeed) {\r\n                    ret.push(util_1.Util.LF);\r\n                }\r\n                else {\r\n                    ret.push(util_1.Util.SPACE);\r\n                }\r\n                ret = ret.concat(op.toByteArray());\r\n                ret.push(writer_util_1.WriterUtil.Q);\r\n            }\r\n            else if (op instanceof TextObject) {\r\n                ret = ret.concat(writer_util_1.WriterUtil.BT);\r\n                if (!noLineFeed) {\r\n                    ret.push(util_1.Util.LF);\r\n                }\r\n                else {\r\n                    ret.push(util_1.Util.SPACE);\r\n                }\r\n                ret = ret.concat(op.toByteArray());\r\n                ret = ret.concat(writer_util_1.WriterUtil.ET);\r\n            }\r\n            else {\r\n                ret = ret.concat(util_1.Util.convertStringToAscii(op.name));\r\n                if (!noLineFeed) {\r\n                    ret.push(util_1.Util.LF);\r\n                }\r\n                else {\r\n                    ret.push(util_1.Util.SPACE);\r\n                }\r\n            }\r\n        }\r\n        if (ret[ret.length - 1] !== util_1.Util.LF) {\r\n            if (!noLineFeed) {\r\n                ret.push(util_1.Util.LF);\r\n            }\r\n            else {\r\n                ret.push(util_1.Util.SPACE);\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Adds the provided operator\r\n     * */\r\n    Operator.prototype.addOperator = function (arg, params) {\r\n        if (params === void 0) { params = []; }\r\n        if (arg instanceof Operator) {\r\n            this.operators.push(arg);\r\n        }\r\n        else {\r\n            this.operators.push(new Operator(arg, params));\r\n        }\r\n    };\r\n    /**\r\n     * Add marked content object to stream\r\n     * */\r\n    Operator.prototype.addMarkedContentObject = function (params) {\r\n        if (params === void 0) { params = []; }\r\n        var mco = new MarkedContent(params);\r\n        this.operators.push(mco);\r\n        return mco;\r\n    };\r\n    /**\r\n     * Add a graphic state to the content stream\r\n     * */\r\n    Operator.prototype.addGraphicObject = function () {\r\n        var go = new GraphicsObject();\r\n        this.operators.push(go);\r\n        return go;\r\n    };\r\n    /**\r\n     * Add a text objct to the content stream\r\n     * */\r\n    Operator.prototype.addTextObject = function () {\r\n        var to = new TextObject();\r\n        this.operators.push(to);\r\n        return to;\r\n    };\r\n    return Operator;\r\n}());\r\nexports.Operator = Operator;\r\nvar MarkedContent = /** @class */ (function (_super) {\r\n    __extends(MarkedContent, _super);\r\n    function MarkedContent(params) {\r\n        if (params === void 0) { params = []; }\r\n        return _super.call(this, \"BMC\", params) || this;\r\n    }\r\n    return MarkedContent;\r\n}(Operator));\r\nexports.MarkedContent = MarkedContent;\r\nvar GraphicsObject = /** @class */ (function (_super) {\r\n    __extends(GraphicsObject, _super);\r\n    function GraphicsObject() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    GraphicsObject.prototype.drawFillRect = function (x_1, y_1, x_2, y_2, cornerRadius, linewidth) {\r\n        if (cornerRadius === void 0) { cornerRadius = undefined; }\r\n        if (linewidth === void 0) { linewidth = 2; }\r\n        this.addOperator(\"w\", [linewidth]);\r\n        if (cornerRadius && (2 * cornerRadius > Math.abs(x_1 - x_2) || 2 * cornerRadius > Math.abs(y_1 - y_2))) {\r\n            throw Error(\"Invalid corner radius. Must be small than two times the linewidth\");\r\n        }\r\n        if (cornerRadius) {\r\n            this.addOperator(\"m\", [x_1, y_1 + cornerRadius]);\r\n            this.addOperator(\"l\", [x_1, y_2 - cornerRadius]);\r\n            this.addOperator(\"c\", [x_1, y_2, x_1, y_2, x_1 + cornerRadius, y_2]);\r\n            this.addOperator(\"l\", [x_2 - cornerRadius, y_2]);\r\n            this.addOperator(\"c\", [x_2, y_2, x_2, y_2, x_2, y_2 - cornerRadius]);\r\n            this.addOperator(\"l\", [x_2, y_1 + cornerRadius]);\r\n            this.addOperator(\"c\", [x_2, y_1, x_2, y_1, x_2 - cornerRadius, y_1]);\r\n            this.addOperator(\"l\", [x_1 + cornerRadius, y_1]);\r\n            this.addOperator(\"c\", [x_1, y_1, x_1, y_1, x_1, y_1 + cornerRadius]);\r\n        }\r\n        else {\r\n            this.addOperator(\"m\", [x_1, y_1]);\r\n            this.addOperator(\"l\", [x_2, y_1]);\r\n            this.addOperator(\"l\", [x_2, y_2]);\r\n            this.addOperator(\"l\", [x_1, y_2]);\r\n            this.addOperator(\"l\", [x_1, y_1]);\r\n        }\r\n        this.addOperator(\"B\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.fillRect = function (x_1, y_1, x_2, y_2, cornerRadius) {\r\n        if (cornerRadius === void 0) { cornerRadius = undefined; }\r\n        if (cornerRadius && (2 * cornerRadius > Math.abs(x_1 - x_2) || 2 * cornerRadius > Math.abs(y_1 - y_2))) {\r\n            throw Error(\"Invalid corner radius. Must be small than two times the linewidth\");\r\n        }\r\n        if (cornerRadius) {\r\n            this.addOperator(\"m\", [x_1, y_1 + cornerRadius]);\r\n            this.addOperator(\"l\", [x_1, y_2 - cornerRadius]);\r\n            this.addOperator(\"c\", [x_1, y_2, x_1, y_2, x_1 + cornerRadius, y_2]);\r\n            this.addOperator(\"l\", [x_2 - cornerRadius, y_2]);\r\n            this.addOperator(\"c\", [x_2, y_2, x_2, y_2, x_2, y_2 - cornerRadius]);\r\n            this.addOperator(\"l\", [x_2, y_1 + cornerRadius]);\r\n            this.addOperator(\"c\", [x_2, y_1, x_2, y_1, x_2 - cornerRadius, y_1]);\r\n            this.addOperator(\"l\", [x_1 + cornerRadius, y_1]);\r\n            this.addOperator(\"c\", [x_1, y_1, x_1, y_1, x_1, y_1 + cornerRadius]);\r\n        }\r\n        else {\r\n            this.addOperator(\"m\", [x_1, y_1]);\r\n            this.addOperator(\"l\", [x_2, y_1]);\r\n            this.addOperator(\"l\", [x_2, y_2]);\r\n            this.addOperator(\"l\", [x_1, y_2]);\r\n            this.addOperator(\"l\", [x_1, y_1]);\r\n        }\r\n        this.addOperator(\"f\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.drawFillCircle = function (x_1, y_1, x_2, y_2, linewidth) {\r\n        if (linewidth === void 0) { linewidth = 2; }\r\n        x_1 += linewidth;\r\n        y_1 += linewidth;\r\n        x_2 -= linewidth;\r\n        y_2 -= linewidth;\r\n        var rect_width = Math.abs(x_2 - x_1);\r\n        var rect_height = Math.abs(y_2 - y_1);\r\n        this.addOperator(\"w\", [linewidth]);\r\n        this.addOperator(\"m\", [x_1 + rect_width / 2, y_1]);\r\n        this.addOperator(\"c\", [x_1 + rect_width / 2, y_1, x_2, y_1, x_2, y_1 + rect_height / 2]);\r\n        this.addOperator(\"c\", [x_2, y_1 + rect_height / 2, x_2, y_2, x_1 + rect_width / 2, y_2]);\r\n        this.addOperator(\"c\", [x_1 + rect_width / 2, y_2, x_1, y_2, x_1, y_1 + rect_height / 2]);\r\n        this.addOperator(\"c\", [x_1, y_1 + rect_height / 2, x_1, y_1, x_1 + rect_width / 2, y_1]);\r\n        this.addOperator(\"B\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.fillCircle = function (x_1, y_1, x_2, y_2) {\r\n        var rect_width = Math.abs(x_2 - x_1);\r\n        var rect_height = Math.abs(y_2 - y_1);\r\n        this.addOperator(\"m\", [x_1 + rect_width / 2, y_1]);\r\n        this.addOperator(\"v\", [x_2, y_1, x_2, y_1 + rect_height / 2]);\r\n        this.addOperator(\"v\", [x_2, y_2, x_1 + rect_width / 2, y_2]);\r\n        this.addOperator(\"v\", [x_1, y_2, x_1, y_1 + rect_height / 2]);\r\n        this.addOperator(\"v\", [x_1, y_1, x_1 + rect_width / 2, y_1]);\r\n        this.addOperator(\"f\");\r\n        return this;\r\n    };\r\n    /**\r\n     * Draws a circle (or an oval) where the rectangle defined by the coordinates represents the bounding box\r\n     * */\r\n    GraphicsObject.prototype.drawCircle = function (x_1, y_1, x_2, y_2, linewidth) {\r\n        if (linewidth === void 0) { linewidth = 2; }\r\n        x_1 += linewidth;\r\n        y_1 += linewidth;\r\n        x_2 -= linewidth;\r\n        y_2 -= linewidth;\r\n        var rect_width = Math.abs(x_2 - x_1);\r\n        var rect_height = Math.abs(y_2 - y_1);\r\n        this.addOperator(\"w\", [linewidth]);\r\n        this.addOperator(\"m\", [x_1 + rect_width / 2, y_1]);\r\n        this.addOperator(\"v\", [x_2, y_1, x_2, y_1 + rect_height / 2]);\r\n        this.addOperator(\"v\", [x_2, y_2, x_1 + rect_width / 2, y_2]);\r\n        this.addOperator(\"v\", [x_1, y_2, x_1, y_1 + rect_height / 2]);\r\n        this.addOperator(\"v\", [x_1, y_1, x_1 + rect_width / 2, y_1]);\r\n        this.addOperator(\"s\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.drawRect = function (x_1, y_1, x_2, y_2, cornerRadius, linewidth) {\r\n        if (cornerRadius === void 0) { cornerRadius = undefined; }\r\n        if (linewidth === void 0) { linewidth = 2; }\r\n        this.addOperator(\"w\", [linewidth]);\r\n        if (cornerRadius && (2 * cornerRadius > Math.abs(x_1 - x_2) || 2 * cornerRadius > Math.abs(y_1 - y_2))) {\r\n            throw Error(\"Invalid corner radius. Must be small than two times the linewidth\");\r\n        }\r\n        if (cornerRadius) {\r\n            this.addOperator(\"m\", [x_1, y_1 + cornerRadius]);\r\n            this.addOperator(\"l\", [x_1, y_2 - cornerRadius]);\r\n            this.addOperator(\"c\", [x_1, y_2, x_1, y_2, x_1 + cornerRadius, y_2]);\r\n            this.addOperator(\"l\", [x_2 - cornerRadius, y_2]);\r\n            this.addOperator(\"c\", [x_2, y_2, x_2, y_2, x_2, y_2 - cornerRadius]);\r\n            this.addOperator(\"l\", [x_2, y_1 + cornerRadius]);\r\n            this.addOperator(\"c\", [x_2, y_1, x_2, y_1, x_2 - cornerRadius, y_1]);\r\n            this.addOperator(\"l\", [x_1 + cornerRadius, y_1]);\r\n            this.addOperator(\"c\", [x_1, y_1, x_1, y_1, x_1, y_1 + cornerRadius]);\r\n        }\r\n        else {\r\n            this.addOperator(\"m\", [x_1, y_1]);\r\n            this.addOperator(\"l\", [x_2, y_1]);\r\n            this.addOperator(\"l\", [x_2, y_2]);\r\n            this.addOperator(\"l\", [x_1, y_2]);\r\n            this.addOperator(\"l\", [x_1, y_1]);\r\n        }\r\n        this.addOperator(\"s\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.drawFillPolygon = function (points, linewidth) {\r\n        if (linewidth === void 0) { linewidth = 2; }\r\n        if (points.length <= 2)\r\n            return this;\r\n        if (points.length % 2 !== 0)\r\n            throw Error(\"Number of points must be even\");\r\n        this.addOperator(\"w\", [linewidth]);\r\n        this.addOperator(\"m\", [points[0], points[1]]);\r\n        for (var i = 2; i < points.length; i += 2) {\r\n            this.addOperator(\"l\", [points[i], points[i + 1]]);\r\n        }\r\n        this.addOperator(\"B\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.drawPolygon = function (points, linewidth) {\r\n        if (linewidth === void 0) { linewidth = 2; }\r\n        if (points.length <= 2)\r\n            return this;\r\n        if (points.length % 2 !== 0)\r\n            throw Error(\"Number of points must be even\");\r\n        this.addOperator(\"w\", [linewidth]);\r\n        this.addOperator(\"m\", [points[0], points[1]]);\r\n        for (var i = 2; i < points.length; i += 2) {\r\n            this.addOperator(\"l\", [points[i], points[i + 1]]);\r\n        }\r\n        this.addOperator(\"S\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.fillPolygon = function (points) {\r\n        if (points.length <= 2)\r\n            return this;\r\n        if (points.length % 2 !== 0)\r\n            throw Error(\"Number of points must be even\");\r\n        this.addOperator(\"m\", [points[0], points[1]]);\r\n        for (var i = 2; i < points.length; i += 2) {\r\n            this.addOperator(\"l\", [points[i], points[i + 1]]);\r\n        }\r\n        this.addOperator(\"f\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.drawLine = function (x_1, y_1, x_2, y_2, linewidth) {\r\n        if (linewidth === void 0) { linewidth = 2; }\r\n        this.addOperator(\"w\", [linewidth]);\r\n        this.addOperator(\"m\", [x_1, y_1]);\r\n        this.addOperator(\"l\", [x_2, y_2]);\r\n        this.addOperator(\"S\");\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.setLineColor = function (color) {\r\n        if (color === void 0) { color = undefined; }\r\n        if (!color)\r\n            color = { r: 0, g: 0, b: 0 };\r\n        color = util_1.Util.colorToRange01(color);\r\n        this.addOperator(\"RG\", [color.r, color.g, color.b]);\r\n        return this;\r\n    };\r\n    GraphicsObject.prototype.setFillColor = function (color) {\r\n        if (color === void 0) { color = undefined; }\r\n        if (!color)\r\n            color = { r: 0, g: 0, b: 0 };\r\n        color = util_1.Util.colorToRange01(color);\r\n        this.addOperator(\"rg\", [color.r, color.g, color.b]);\r\n        return this;\r\n    };\r\n    return GraphicsObject;\r\n}(Operator));\r\nexports.GraphicsObject = GraphicsObject;\r\nvar TextObject = /** @class */ (function (_super) {\r\n    __extends(TextObject, _super);\r\n    function TextObject() {\r\n        return _super.call(this, \"BT\") || this;\r\n    }\r\n    /**\r\n     * Places text relative from the last given position or Tm object (origin) with + x_rel, + y_rel location\r\n     * */\r\n    TextObject.prototype.setTextRelative = function (text, x_rel, y_rel) {\r\n        if (x_rel === void 0) { x_rel = undefined; }\r\n        if (y_rel === void 0) { y_rel = undefined; }\r\n        if (text === \"\")\r\n            return this;\r\n        if (x_rel && Array.isArray(x_rel)) {\r\n            y_rel = x_rel[1];\r\n            x_rel = x_rel[0];\r\n        }\r\n        else if (x_rel && typeof x_rel === 'number' && (!y_rel || typeof y_rel === 'number')) {\r\n            throw Error(\"Invalid number of positioning elements. Must be x and y coordinate\");\r\n        }\r\n        text = text.trim();\r\n        if (text.charAt(0) !== \"(\" || text.charAt(text.length - 1) !== \")\") {\r\n            text = \"(\".concat(text, \")\");\r\n        }\r\n        if (typeof x_rel !== 'undefined' && typeof y_rel !== 'undefined') {\r\n            this.addOperator(\"Td\", [x_rel, y_rel]);\r\n        }\r\n        this.addOperator(\"Tj\", [text]);\r\n    };\r\n    /**\r\n     * Places text absolut at the current position or if provided at the x, y coordinates\r\n     *\r\n     * Uses a '1 0 0 1 x y Tm' for placing. So this method cannot be used for scaling.\r\n     * */\r\n    TextObject.prototype.setText = function (text, x, y) {\r\n        if (x === void 0) { x = undefined; }\r\n        if (y === void 0) { y = undefined; }\r\n        if (text === \"\")\r\n            return this;\r\n        if (x && Array.isArray(x) && x.length >= 2) {\r\n            y = x[1];\r\n            x = x[0];\r\n        }\r\n        else if (x && typeof x === 'number' && (!y || typeof y === 'number')) {\r\n            throw Error(\"Invalid number of positioning elements. Must be x and y coordinate\");\r\n        }\r\n        text = text.trim();\r\n        if (text.charAt(0) !== \"(\" || text.charAt(text.length - 1) !== \")\") {\r\n            text = \"(\".concat(text, \")\");\r\n        }\r\n        if (typeof x !== 'undefined' && typeof y !== 'undefined') {\r\n            this.addOperator(\"Tm\", [1, 0, 0, 1, x, y]);\r\n        }\r\n        this.addOperator(\"Tj\", [text]);\r\n        return this;\r\n    };\r\n    /**\r\n     * Places a text in the rectangle defined by 'rect'. It applies text justification.\r\n     *\r\n     * It applies line breaks. It first tries linebreaking at spaces between words and if that is not possible it will break between letters\r\n     * */\r\n    TextObject.prototype.formatText = function (text, font, textSize, rect, justification) {\r\n        if (justification === void 0) { justification = undefined; }\r\n        var rect_width = Math.abs(rect[2] - rect[0]);\r\n        var rect_height = Math.abs(rect[3] - rect[1]);\r\n        var calc_just = function (textwidth) {\r\n            if (justification === freetext_annotation_1.TextJustification.Centered) {\r\n                return rect_width / 2 - textwidth / 2 + rect[0];\r\n            }\r\n            else if (justification === freetext_annotation_1.TextJustification.Right) {\r\n                return rect_width + rect[0] - textwidth;\r\n            }\r\n            else {\r\n                return rect[0];\r\n            }\r\n        };\r\n        // If text fits into the rectangle\r\n        // just place the text\r\n        if (rect_width < TextObject.SINGLE_CHAR_WIDTH) { // if provided rectangle is too small to present a single letter just write it but warn\r\n            console.warn(\"Overfull hbox \".concat(rect_width, \" is below minimal threshold of \").concat(TextObject.SINGLE_CHAR_WIDTH));\r\n            this.setText(text, [calc_just(font.calculateTextDimensions(text, textSize)[0]), rect_height - textSize * 1.2 + rect[1]]);\r\n            return this;\r\n        }\r\n        else {\r\n            var positions = font.proposeLinebreaks(text, textSize, rect_width);\r\n            var last_pos = calc_just(positions[0].width);\r\n            this.setText(text.substring(positions[0].start, positions[0].end + 1), [last_pos, rect_height - textSize * 1.2 + rect[1]]);\r\n            for (var i = 1; i < positions.length; ++i) {\r\n                var x_pos = calc_just(positions[i].width);\r\n                this.setTextRelative(text.substring(positions[i].start, positions[i].end + 1), [x_pos - last_pos, -textSize]);\r\n                last_pos = x_pos;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    TextObject.prototype.setFont = function (font, fontSize) {\r\n        if (font === void 0) { font = \"/F1\"; }\r\n        if (fontSize === void 0) { fontSize = 14; }\r\n        this.addOperator(\"Tf\", [font, fontSize]);\r\n        return this;\r\n    };\r\n    TextObject.prototype.setColor = function (color) {\r\n        if (color === void 0) { color = undefined; }\r\n        if (!color)\r\n            color = { r: 0, g: 0, b: 0 };\r\n        color = util_1.Util.colorToRange01(color);\r\n        this.addOperator(\"rg\", [color.r, color.g, color.b]);\r\n        return this;\r\n    };\r\n    TextObject.SINGLE_CHAR_WIDTH = 10;\r\n    return TextObject;\r\n}(Operator));\r\nexports.TextObject = TextObject;\r\nvar ContentStream = /** @class */ (function (_super) {\r\n    __extends(ContentStream, _super);\r\n    function ContentStream() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * True, if the content stream is empty\r\n     * */\r\n    ContentStream.prototype.isEmpty = function () {\r\n        return this.operators.length === 0;\r\n    };\r\n    /**\r\n     * Outputs the content stream as byte sequence\r\n     * */\r\n    ContentStream.prototype.writeContentStream = function (noLineFeed) {\r\n        if (noLineFeed === void 0) { noLineFeed = false; }\r\n        return this.toByteArray(noLineFeed);\r\n    };\r\n    return ContentStream;\r\n}(Operator));\r\nexports.ContentStream = ContentStream;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.CryptoUtil = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar crypto = require(\"crypto-js\");\r\nvar CryptoUtil = /** @class */ (function () {\r\n    function CryptoUtil() {\r\n    }\r\n    /**\r\n     * Transforms a uint8array into a crypto-js word array\r\n     * */\r\n    CryptoUtil.convertToWordArray = function (arr) {\r\n        var new_val_int32 = util_1.Util.convertUint8ArrayToInt32Array(arr);\r\n        return crypto.lib.WordArray.create(Array.from(new_val_int32), arr.length);\r\n    };\r\n    /**\r\n     * Converts a given word array into a uint8 array\r\n     * */\r\n    CryptoUtil.convertWordArrayToByteArray = function (arr) {\r\n        return util_1.Util.convertInt32ArrayToUint8Array(arr.words);\r\n    };\r\n    /**\r\n     * Converts a number into a little endian byte array\r\n     * */\r\n    CryptoUtil.convertNumberToLittleEndianByteArray = function (nbr) {\r\n        return util_1.Util.convertInt32ArrayToUint8Array(new Int32Array([nbr])).reverse();\r\n    };\r\n    /**\r\n     * Returns the MD5 hash\r\n     * */\r\n    CryptoUtil.MD5 = function (data) {\r\n        if (data instanceof Uint8Array) {\r\n            data = CryptoUtil.convertToWordArray(data);\r\n        }\r\n        return crypto.MD5(data);\r\n    };\r\n    /**\r\n     * Returns the MD5 hash as byte array\r\n     * */\r\n    CryptoUtil.MD5AsByteArray = function (data) {\r\n        if (data instanceof Uint8Array) {\r\n            data = CryptoUtil.convertToWordArray(data);\r\n        }\r\n        return CryptoUtil.convertWordArrayToByteArray(crypto.MD5(data));\r\n    };\r\n    /**\r\n     * Returns the MD5 hash as hex string\r\n     * */\r\n    CryptoUtil.MD5Hex = function (data) {\r\n        return CryptoUtil.MD5(data).toString(crypto.enc.Hex);\r\n    };\r\n    /**\r\n     * Returns the RC4 encrypted data\r\n     * */\r\n    CryptoUtil.RC4 = function (data, key) {\r\n        if (data instanceof Uint8Array) {\r\n            data = CryptoUtil.convertToWordArray(data);\r\n        }\r\n        if (key instanceof Uint8Array) {\r\n            key = CryptoUtil.convertToWordArray(key);\r\n        }\r\n        return crypto.RC4.encrypt(data, key).ciphertext;\r\n    };\r\n    /**\r\n     * Returns the RC4 encrypted data as hex string\r\n     * */\r\n    CryptoUtil.RC4Hex = function (data, key) {\r\n        return CryptoUtil.RC4(data, key).toString(crypto.enc.Hex);\r\n    };\r\n    /**\r\n     * Pads the provided password string\r\n     * */\r\n    CryptoUtil.padPasswortString = function (password) {\r\n        if (typeof password === 'string') {\r\n            password = new Uint8Array(util_1.Util.convertStringToAscii(password));\r\n        }\r\n        var ret_val = new Uint8Array(32);\r\n        ret_val.set(password.slice(0, 32));\r\n        if (password.length < 32) {\r\n            ret_val.set(CryptoUtil.PADDING_STRING.slice(0, 32 - password.length), password.length);\r\n        }\r\n        return ret_val;\r\n    };\r\n    /**\r\n     * Xors every byte of the provided _byte_array with the value _k\r\n     * */\r\n    CryptoUtil.xorBytes = function (_byte_array, _k) {\r\n        var _ret_val = [];\r\n        for (var i = 0; i < _byte_array.length; ++i) {\r\n            _ret_val.push(_byte_array[i] ^ _k);\r\n        }\r\n        return CryptoUtil.convertToWordArray(new Uint8Array(_ret_val));\r\n    };\r\n    CryptoUtil.PADDING_STRING = [\r\n        0x28,\r\n        0xBF,\r\n        0x4E,\r\n        0x5E,\r\n        0x4E,\r\n        0x75,\r\n        0x8A,\r\n        0x41,\r\n        0x64,\r\n        0x00,\r\n        0x4E,\r\n        0x56,\r\n        0xFF,\r\n        0xFA,\r\n        0x01,\r\n        0x08,\r\n        0x2E,\r\n        0x2E,\r\n        0x00,\r\n        0xB6,\r\n        0xD0,\r\n        0x68,\r\n        0x3E,\r\n        0x80,\r\n        0x2F,\r\n        0x0C,\r\n        0xA9,\r\n        0xFE,\r\n        0x64,\r\n        0x53,\r\n        0x69,\r\n        0x7A\r\n    ];\r\n    return CryptoUtil;\r\n}());\r\nexports.CryptoUtil = CryptoUtil;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.RC4CryptoEngine = exports.IdentityEngine = exports.RC4_40_BIT = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar crypto_util_1 = require(\"./crypto-util\");\r\nexports.RC4_40_BIT = true;\r\nvar IdentityEngine = /** @class */ (function () {\r\n    function IdentityEngine() {\r\n    }\r\n    IdentityEngine.prototype.encrypt = function (data, reference) {\r\n        return data;\r\n    };\r\n    IdentityEngine.prototype.decrypt = function (data, reference) {\r\n        return data;\r\n    };\r\n    IdentityEngine.prototype.isUserPasswordCorrect = function () {\r\n        return true;\r\n    };\r\n    IdentityEngine.prototype.isOwnerPasswordCorrect = function () {\r\n        return true;\r\n    };\r\n    return IdentityEngine;\r\n}());\r\nexports.IdentityEngine = IdentityEngine;\r\nvar RC4CryptoEngine = /** @class */ (function () {\r\n    function RC4CryptoEngine(cryptoConfiguration, file_id, rc4_40_bit) {\r\n        if (rc4_40_bit === void 0) { rc4_40_bit = false; }\r\n        this.cryptoConfiguration = cryptoConfiguration;\r\n        this.file_id = file_id;\r\n        this.rc4_40_bit = rc4_40_bit;\r\n        this.encryptionKey = undefined;\r\n        this.computed_user_password = undefined;\r\n        this.computed_owner_password = undefined;\r\n    }\r\n    RC4CryptoEngine.prototype.encrypt = function (data, reference) {\r\n        if (!reference)\r\n            throw Error(\"Undefined reference pointer of encrypted object\");\r\n        var encryptionKey = this.computeEncryptionKey();\r\n        var adapted_key = new Uint8Array(encryptionKey.length + 5);\r\n        adapted_key.set(encryptionKey, 0);\r\n        var obj = crypto_util_1.CryptoUtil.convertNumberToLittleEndianByteArray(reference.obj);\r\n        adapted_key.set(obj.slice(0, 3), encryptionKey.length);\r\n        var gen = crypto_util_1.CryptoUtil.convertNumberToLittleEndianByteArray(reference.generation);\r\n        adapted_key.set(gen.slice(0, 2), encryptionKey.length + 3);\r\n        var key_hash = crypto_util_1.CryptoUtil.MD5AsByteArray(adapted_key);\r\n        var encrypted = crypto_util_1.CryptoUtil.RC4(data, key_hash.slice(0, Math.min(encryptionKey.length + 5, 16)));\r\n        return crypto_util_1.CryptoUtil.convertWordArrayToByteArray(encrypted);\r\n    };\r\n    RC4CryptoEngine.prototype.decrypt = function (data, reference) {\r\n        return this.encrypt(data, reference);\r\n    };\r\n    /**\r\n     * Computes the RC4 encryption key\r\n     * */\r\n    RC4CryptoEngine.prototype.computeEncryptionKey = function () {\r\n        if (this.encryptionKey)\r\n            return this.encryptionKey;\r\n        var userpwd = crypto_util_1.CryptoUtil.padPasswortString(this.cryptoConfiguration.user_pwd);\r\n        if (!this.cryptoConfiguration.owner_pwd_c)\r\n            throw Error(\"Invalid /O value (owner password)\");\r\n        var oValue = this.cryptoConfiguration.owner_pwd_c;\r\n        if (oValue.length !== 32)\r\n            throw Error(\"Invalid length of owner value. Is \".concat(oValue.length, \" but must be 32.\"));\r\n        if (!this.cryptoConfiguration.permissions)\r\n            throw Error(\"Permissions not set\");\r\n        var permissions = crypto_util_1.CryptoUtil.convertNumberToLittleEndianByteArray(this.cryptoConfiguration.permissions);\r\n        if (!this.file_id || this.file_id.length === 0)\r\n            throw Error(\"File ID not set\");\r\n        var keylength = 40;\r\n        if (this.cryptoConfiguration.length)\r\n            keylength = this.cryptoConfiguration.length;\r\n        var file_id = this.file_id[0];\r\n        var stuff = new Uint8Array(userpwd.length + oValue.length + permissions.length + file_id.length);\r\n        stuff.set(userpwd, 0);\r\n        stuff.set(oValue, userpwd.length);\r\n        stuff.set(permissions, userpwd.length + oValue.length);\r\n        stuff.set(file_id, userpwd.length + oValue.length + permissions.length);\r\n        var h = crypto_util_1.CryptoUtil.MD5AsByteArray(stuff);\r\n        keylength = keylength >> 3;\r\n        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {\r\n            for (var i = 0; i < 50; ++i) {\r\n                h = crypto_util_1.CryptoUtil.MD5AsByteArray(h.slice(0, keylength));\r\n            }\r\n        }\r\n        if (this.rc4_40_bit) {\r\n            this.encryptionKey = h.slice(0, 5);\r\n        }\r\n        else {\r\n            this.encryptionKey = h;\r\n        }\r\n        return this.encryptionKey;\r\n    };\r\n    /**\r\n     * Derives the user password (/U) value\r\n     * */\r\n    RC4CryptoEngine.prototype.computeUserPassword = function () {\r\n        if (this.computed_user_password)\r\n            return this.computed_user_password;\r\n        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {\r\n            return this.computeUserPasswordRevision3OrGreater();\r\n        }\r\n        else if (this.cryptoConfiguration.revision === 2) {\r\n            return this.computeUserPasswordRevision2();\r\n        }\r\n        return new Uint8Array([]);\r\n    };\r\n    /**\r\n     * Computes the user password for security handlers of revision 2\r\n     * */\r\n    RC4CryptoEngine.prototype.computeUserPasswordRevision2 = function () {\r\n        var padding_str = new Uint8Array(crypto_util_1.CryptoUtil.PADDING_STRING);\r\n        var enc_key = this.computeEncryptionKey();\r\n        var x = crypto_util_1.CryptoUtil.RC4(padding_str, enc_key);\r\n        this.computed_user_password = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(x);\r\n        return this.computed_user_password;\r\n    };\r\n    /**\r\n     * Computes the user password for security handlers of revision 3 or higher\r\n     * */\r\n    RC4CryptoEngine.prototype.computeUserPasswordRevision3OrGreater = function () {\r\n        if (!this.file_id)\r\n            throw Error(\"No file id\");\r\n        var id_str_array = this.file_id[0];\r\n        var new_val = new Uint8Array(crypto_util_1.CryptoUtil.PADDING_STRING.length + id_str_array.length);\r\n        new_val.set(crypto_util_1.CryptoUtil.PADDING_STRING, 0);\r\n        new_val.set(id_str_array, crypto_util_1.CryptoUtil.PADDING_STRING.length);\r\n        var x = crypto_util_1.CryptoUtil.MD5(new_val);\r\n        var enc_key = this.computeEncryptionKey();\r\n        for (var i = 0; i < 20; ++i) {\r\n            x = crypto_util_1.CryptoUtil.RC4(x, crypto_util_1.CryptoUtil.xorBytes(enc_key, i));\r\n        }\r\n        this.computed_user_password = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(x);\r\n        return this.computed_user_password;\r\n    };\r\n    /**\r\n     * Derives the owner password (/O) value\r\n     **/\r\n    RC4CryptoEngine.prototype.computeOwnerPassword = function () {\r\n        if (this.computed_owner_password)\r\n            return this.computed_owner_password;\r\n        var pwd_string = this.cryptoConfiguration.owner_pwd;\r\n        // if no owner password is set, but a user password use this\r\n        if (!this.cryptoConfiguration.owner_pwd || this.cryptoConfiguration.owner_pwd === \"\")\r\n            pwd_string = this.cryptoConfiguration.user_pwd;\r\n        var ownerpwd = crypto_util_1.CryptoUtil.padPasswortString(pwd_string);\r\n        var h = crypto_util_1.CryptoUtil.MD5(ownerpwd);\r\n        var count = 1;\r\n        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {\r\n            count = 20;\r\n            for (var i = 0; i < 50; ++i) {\r\n                h = crypto_util_1.CryptoUtil.MD5(h);\r\n            }\r\n        }\r\n        var length = 128;\r\n        if (this.cryptoConfiguration.length)\r\n            length = this.cryptoConfiguration.length;\r\n        var enc_key = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(h).slice(0, length / 8);\r\n        var userpwd = crypto_util_1.CryptoUtil.padPasswortString(this.cryptoConfiguration.user_pwd);\r\n        var x = crypto_util_1.CryptoUtil.convertToWordArray(userpwd);\r\n        for (var i = 0; i < count; ++i) {\r\n            x = crypto_util_1.CryptoUtil.RC4(x, crypto_util_1.CryptoUtil.xorBytes(enc_key, i));\r\n        }\r\n        this.computed_owner_password = crypto_util_1.CryptoUtil.convertWordArrayToByteArray(x);\r\n        return this.computed_owner_password;\r\n    };\r\n    /**\r\n     * Returns true if the provided password corresponds to the defined /U value\r\n     * */\r\n    RC4CryptoEngine.prototype.isUserPasswordCorrect = function () {\r\n        var user_pwd = this.computeUserPassword();\r\n        if (!this.cryptoConfiguration.user_pwd_c)\r\n            throw Error(\"Invalid /U value (user password)\");\r\n        if (this.cryptoConfiguration.revision && this.cryptoConfiguration.revision >= 3) {\r\n            return util_1.Util.areArraysEqual(user_pwd, this.cryptoConfiguration.user_pwd_c.slice(0, 16));\r\n        }\r\n        else {\r\n            return util_1.Util.areArraysEqual(user_pwd, this.cryptoConfiguration.user_pwd_c);\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if the provided password corresponds to the defined /O value\r\n     * */\r\n    RC4CryptoEngine.prototype.isOwnerPasswordCorrect = function () {\r\n        var owner_pwd = this.computeOwnerPassword();\r\n        if (!this.cryptoConfiguration.owner_pwd_c)\r\n            throw Error(\"Invalid /O value (owner password)\");\r\n        return util_1.Util.areArraysEqual(owner_pwd, this.cryptoConfiguration.owner_pwd_c);\r\n    };\r\n    return RC4CryptoEngine;\r\n}());\r\nexports.RC4CryptoEngine = RC4CryptoEngine;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.DocumentHistory = exports.CrossReferenceTable = exports.CrossReferenceStreamObject = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar object_util_1 = require(\"./object-util\");\r\nvar generateDefaultTrailer = function () {\r\n    return { size: -1, root: { obj: -1, generation: -1 }, is_encrypted: false };\r\n};\r\n/**\r\n * Holds the complete information of one update section in the Cross-Reference-Stream Object format.\r\n *\r\n * */\r\nvar CrossReferenceStreamObject = /** @class */ (function () {\r\n    function CrossReferenceStreamObject(data) {\r\n        this.data = data;\r\n        this.refs = [];\r\n        this.trailer = generateDefaultTrailer();\r\n        this.streamLength = -1;\r\n        this.w = [];\r\n        this.index = [];\r\n        this.start_pointer = 0;\r\n    }\r\n    /**\r\n     * Extracts a cross reference section that is a continuous definition of cross reference entries\r\n     * */\r\n    CrossReferenceStreamObject.prototype.extractCrossReferenceSection = function (first_object_id, object_count, stream) {\r\n        var current_object_id = first_object_id;\r\n        for (var i = 0; i < object_count; ++i) {\r\n            var _type = stream.getNBytesAsNumber(this.w[0]);\r\n            var xref = undefined;\r\n            switch (_type) {\r\n                case 0:\r\n                    xref = { id: current_object_id++, pointer: stream.getNBytesAsNumber(this.w[1]), generation: this.w[2] === 0 ? 0 : stream.getNBytesAsNumber(this.w[2]), free: true, update: false };\r\n                    break;\r\n                case 1:\r\n                    xref = { id: current_object_id++, pointer: stream.getNBytesAsNumber(this.w[1]), generation: this.w[2] === 0 ? 0 : stream.getNBytesAsNumber(this.w[2]), free: false, update: true };\r\n                    break;\r\n                case 2:\r\n                    // in this case the pointer becomes the stream object id that contains the compressed object and the generation represents the index of the object in the stream\r\n                    xref = { id: current_object_id++, pointer: stream.getNBytesAsNumber(this.w[1]), generation: this.w[2] === 0 ? 0 : stream.getNBytesAsNumber(this.w[2]), free: true, update: false, compressed: true };\r\n                    break;\r\n            }\r\n            if (xref)\r\n                this.refs.push(xref);\r\n            else\r\n                throw Error(\"Invalid cross-reference-stream type \".concat(_type));\r\n        }\r\n    };\r\n    /**\r\n     * Extracts the cross-reference-table from the stream\r\n     * */\r\n    CrossReferenceStreamObject.prototype.extractStream = function (stream) {\r\n        var cross_reference_length = this.w.reduce(function (a, b) { return a + b; }, 0);\r\n        // check if the data stream has a valid size\r\n        if (stream.getLength() !== cross_reference_length * this.index.filter(function (v, i) { return i % 2 === 1; }).reduce(function (a, b) { return a + b; }, 0))\r\n            throw Error(\"Invalid stream length - is \".concat(stream.getLength(), \" but should be \").concat(cross_reference_length * this.index.filter(function (v, i) { return i % 2 === 1; }).reduce(function (a, b) { return a + b; }, 0)));\r\n        if (this.index.length % 2 === 1)\r\n            throw Error(\"Invalid index flag \".concat(this.index));\r\n        for (var i = 0; i < this.index.length; i += 2) {\r\n            this.extractCrossReferenceSection(this.index[i], this.index[i + 1], stream);\r\n        }\r\n    };\r\n    /**\r\n     * Parses the Cross-Reference-Stream-Object at the given index\r\n     * */\r\n    CrossReferenceStreamObject.prototype.extract = function (xref) {\r\n        var index = xref.pointer;\r\n        this.start_pointer = index;\r\n        var crs_object = object_util_1.ObjectUtil.extractObject(this.data, xref);\r\n        var ptr_object_end = util_1.Util.locateSequence(util_1.Util.ENDOBJ, this.data, index);\r\n        this.data = this.data.slice(index, ptr_object_end);\r\n        // check type\r\n        if (crs_object.value[\"/Type\"] !== \"/XRef\")\r\n            throw Error(\"Invalid Cross-Reference-Stream-object type: \".concat(crs_object.value[\"/Type\"]));\r\n        // extract size\r\n        if (!crs_object.value[\"/Size\"])\r\n            throw Error(\"Invalid size value \".concat(crs_object.value[\"/Size\"]));\r\n        this.trailer.size = crs_object.value[\"/Size\"];\r\n        // extract ROOT if it exists\r\n        if (crs_object.value[\"/Root\"])\r\n            this.trailer.root = crs_object.value[\"/Root\"];\r\n        // extract PREV if it exists\r\n        if (crs_object.value[\"/Prev\"])\r\n            this.trailer.prev = crs_object.value[\"/Prev\"];\r\n        // extract W parameter\r\n        this.w = crs_object.value[\"/W\"];\r\n        if (!this.w || 0 === this.w.length)\r\n            throw Error(\"Invalid /W parameter in Cross-Reference-Stream-Object\");\r\n        // extract Index parameter\r\n        this.index = crs_object.value[\"/Index\"];\r\n        if (!this.index || 0 === this.index.length)\r\n            this.index = [0, crs_object.value[\"/Size\"]];\r\n        if (!crs_object.stream)\r\n            throw Error(\"Missing stream at cross reference stream object\");\r\n        var stream = crs_object.stream;\r\n        if (!stream)\r\n            throw Error(\"Invalid stream object\");\r\n        this.streamLength = crs_object.value[\"/Length\"];\r\n        this.extractStream(stream);\r\n        // the cross-reference-stream object is also a known reference\r\n        this.refs.push({ id: crs_object.id.obj, pointer: this.start_pointer, generation: crs_object.id.generation, free: false, update: true });\r\n    };\r\n    /**\r\n     * Returs the update section representing this CrossReferenceStreamObject\r\n     * */\r\n    CrossReferenceStreamObject.prototype.getUpdateSection = function () {\r\n        return {\r\n            start_pointer: this.start_pointer,\r\n            size: this.trailer.size,\r\n            prev: this.trailer.prev,\r\n            root: this.trailer.root,\r\n            refs: this.refs,\r\n            is_encrypted: this.trailer.is_encrypted,\r\n            encrypt: this.trailer.encrypt,\r\n            id: this.trailer.id\r\n        };\r\n    };\r\n    return CrossReferenceStreamObject;\r\n}());\r\nexports.CrossReferenceStreamObject = CrossReferenceStreamObject;\r\n/**\r\n * Holds the complete information of one update section in the Cross-Reference-Table format. That comprises:\r\n * - the body update\r\n * - the crossiste reference table\r\n * - the trailer\r\n * */\r\nvar CrossReferenceTable = /** @class */ (function () {\r\n    function CrossReferenceTable(data) {\r\n        this.data = data;\r\n        this.refs = [];\r\n        this.start_pointer = -1;\r\n        this.trailer = generateDefaultTrailer();\r\n    }\r\n    /**\r\n     * Returns the reference with the given id\r\n     * */\r\n    CrossReferenceTable.prototype.getReference = function (id) {\r\n        for (var _i = 0, _a = this.refs; _i < _a.length; _i++) {\r\n            var ref = _a[_i];\r\n            if (ref.id === id)\r\n                return ref;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returs the update section representing this CrossReferenceTable\r\n     * */\r\n    CrossReferenceTable.prototype.getUpdateSection = function () {\r\n        return {\r\n            start_pointer: this.start_pointer,\r\n            size: this.trailer.size,\r\n            refs: this.refs,\r\n            prev: this.trailer.prev,\r\n            root: this.trailer.root,\r\n            is_encrypted: this.trailer.is_encrypted,\r\n            encrypt: this.trailer.encrypt,\r\n            id: this.trailer.id\r\n        };\r\n    };\r\n    /**\r\n     * Extracts the header of a sub section. For instance\r\n     *\r\n     * 0 1 // <--\r\n     * ...\r\n     *\r\n     * So the obejct id 0 and the number of sub section entries 1\r\n     * */\r\n    CrossReferenceTable.prototype.extractSubSectionHeader = function (index) {\r\n        var ptr = util_1.Util.locateDelimiter(this.data, index);\r\n        var obj_id = util_1.Util.extractNumber(this.data, index, ptr).result;\r\n        ptr = util_1.Util.skipDelimiter(this.data, ptr + 1);\r\n        var ptr_ref_count = ptr;\r\n        ptr = util_1.Util.locateDelimiter(this.data, ptr);\r\n        var reference_count = util_1.Util.extractNumber(this.data, ptr_ref_count, ptr).result;\r\n        return { id: obj_id, count: reference_count, end_ptr: ptr };\r\n    };\r\n    /**\r\n     * Extracts the references of a sub section. The index points to the start of\r\n     * the first reference and count represents the number of references that are\r\n     * contained in the subsection.\r\n     *\r\n     * The first_object_id is the id provided in the sub section header\r\n     *\r\n     * By definition of the PDF standard one entry is 20 bytes long, but since the standard is rarely respected we better make it failsafe\r\n     * */\r\n    CrossReferenceTable.prototype.extractReferences = function (index, count, first_object_id) {\r\n        var _refs = [];\r\n        var res = { result: null, start_index: -1, end_index: index };\r\n        for (var i = 0; count === -1 || i < count; ++i) {\r\n            res = util_1.Util.readNextWord(this.data, res.end_index + 1);\r\n            var pointer = util_1.Util.extractNumber(res.result, 0).result;\r\n            res = util_1.Util.readNextWord(this.data, res.end_index + 1);\r\n            var generation = util_1.Util.extractNumber(res.result, 0).result;\r\n            res = util_1.Util.readNextWord(this.data, res.end_index + 1);\r\n            var ptr_flag = res.result;\r\n            var isFree = ptr_flag[0] === 102; // 102 = f\r\n            _refs.push({\r\n                id: first_object_id + i,\r\n                pointer: pointer,\r\n                generation: generation,\r\n                free: isFree,\r\n                update: !isFree\r\n            });\r\n            // if the word trailer occurs stop since we reached the end\r\n            if (this.data[util_1.Util.skipSpaces(this.data, res.end_index + 1)] === 116) {\r\n                break;\r\n            }\r\n        }\r\n        return { refs: _refs, end_index: res.end_index };\r\n    };\r\n    /**\r\n     * Extracts the trailer of the subsection that means the part stating with the 'trailer' keyword and\r\n     * in particular the trailer dictionary\r\n     * */\r\n    CrossReferenceTable.prototype.extractTrailer = function (index) {\r\n        // run forward to the dictionary start\r\n        index = util_1.Util.locateSequence(util_1.Util.DICT_START, this.data, index) + 2;\r\n        var obj = {};\r\n        object_util_1.ObjectUtil.extractDictKeyRec(this.data, index, obj);\r\n        return {\r\n            size: obj[\"/Size\"],\r\n            root: obj[\"/Root\"],\r\n            prev: obj[\"/Prev\"] ? obj[\"/Prev\"] : undefined,\r\n            is_encrypted: obj[\"/Encrypt\"] ? true : false,\r\n            encrypt: obj[\"/Encrypt\"] ? obj[\"/Encrypt\"] : undefined,\r\n            id: obj[\"/ID\"] ? obj[\"/ID\"] : undefined\r\n        };\r\n    };\r\n    /**\r\n     * Parses the Cross Reference Table at the given index\r\n     * */\r\n    CrossReferenceTable.prototype.extract = function (index, skipXREFString) {\r\n        if (skipXREFString === void 0) { skipXREFString = false; }\r\n        this.start_pointer = index;\r\n        var start_ptr = index;\r\n        if (!skipXREFString)\r\n            start_ptr += 5; // + length(xref) + blank\r\n        start_ptr = util_1.Util.skipDelimiter(this.data, start_ptr);\r\n        // check if there actually is a subsection header\r\n        // if the line finishes with an 'f' we know that it starts with the first cross reference entry\r\n        var tmp_ptr = start_ptr;\r\n        while (tmp_ptr < this.data.length && this.data[tmp_ptr] !== 102 && this.data[tmp_ptr] !== 13 && this.data[tmp_ptr] !== 10)\r\n            tmp_ptr++;\r\n        var first_header = { id: 0, count: -1, end_ptr: start_ptr - 1 };\r\n        if (this.data[tmp_ptr] === 10 || this.data[tmp_ptr] === 13)\r\n            first_header = this.extractSubSectionHeader(start_ptr);\r\n        var ref_start = util_1.Util.skipDelimiter(this.data, first_header.end_ptr + 1);\r\n        // extract first reference\r\n        var reference_result = this.extractReferences(ref_start, first_header.count, first_header.id);\r\n        this.refs = this.refs.concat(reference_result.refs);\r\n        // extract remaining references\r\n        start_ptr = util_1.Util.skipSpaces(this.data, reference_result.end_index + 1);\r\n        while (first_header.count > 0 && this.data[start_ptr] !== 116) { // 116 = 't' start of the word trailer that concludes the crosssite reference section\r\n            var header = this.extractSubSectionHeader(start_ptr);\r\n            ref_start = util_1.Util.skipDelimiter(this.data, header.end_ptr + 1);\r\n            var references = this.extractReferences(ref_start, header.count, header.id);\r\n            this.refs = this.refs.concat(references.refs);\r\n            start_ptr = util_1.Util.skipSpaces(this.data, references.end_index + 1);\r\n        }\r\n        this.trailer = this.extractTrailer(start_ptr);\r\n    };\r\n    return CrossReferenceTable;\r\n}());\r\nexports.CrossReferenceTable = CrossReferenceTable;\r\n/**\r\n * Represents the complete PDF document history and therefore holds the\r\n * updated body parts, the crosssite references and the document trailers\r\n * */\r\nvar DocumentHistory = /** @class */ (function () {\r\n    function DocumentHistory(data) {\r\n        this.data = data;\r\n        this.updates = [];\r\n        this.trailerSize = -1;\r\n        /**\r\n         * Holds object ids that were formerly freed and are now 'already' reused.\r\n         * This is used to prevent a freed object a second time */\r\n        this.already_reused_ids = [];\r\n        this.data = new Uint8Array(data);\r\n    }\r\n    /**\r\n     * Extracts the cross reference table starting at the given index\r\n     * */\r\n    DocumentHistory.prototype.extractCrossReferenceTable = function (index, skipXREFString) {\r\n        if (skipXREFString === void 0) { skipXREFString = false; }\r\n        var crt = new CrossReferenceTable(this.data);\r\n        crt.extract(index, skipXREFString);\r\n        return crt;\r\n    };\r\n    /**\r\n     * Extracts the cross reference stream object starting at the given index\r\n     * */\r\n    DocumentHistory.prototype.extractCrossReferenceStreamObject = function (xref) {\r\n        var crs = new CrossReferenceStreamObject(this.data);\r\n        crs.extract(xref);\r\n        return crs;\r\n    };\r\n    /**\r\n     * Extracts the last update section of a document (that means\r\n     * the most recent update locating at the end of the file)\r\n     *\r\n     * Handles missing or wrong pointers\r\n     * and also decides, whether the cross reference table is provided as stream object or regular\r\n     * */\r\n    DocumentHistory.prototype.extractDocumentEntry = function () {\r\n        var _this = this;\r\n        var ptr = this.data.length - 1;\r\n        var ptr_startxref = util_1.Util.locateSequenceReversed(util_1.Util.STARTXREF, this.data, ptr, true) + 9;\r\n        // identify cross reference section type\r\n        var section_type = \"UNKNOWN\";\r\n        var preceding_word_index = util_1.Util.skipSpacesReverse(this.data, ptr_startxref - 10);\r\n        if (util_1.Util.areArraysEqual(this.data.slice(preceding_word_index - 5, preceding_word_index + 1), util_1.Util.ENDOBJ)) {\r\n            section_type = \"stream\";\r\n        }\r\n        else {\r\n            section_type = \"trailer\";\r\n        }\r\n        // try to locate cross reference table manually\r\n        var locateXREFStartManually = function () {\r\n            var new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.XREF, _this.data, _this.data.length);\r\n            section_type = \"trailer\";\r\n            while (new_ptr > 0 && _this.data[new_ptr - 1] === 116) { // 116 = 't' -> we are looking for 'xref' not 'startxref'\r\n                new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.XREF, _this.data, new_ptr - 1);\r\n            }\r\n            if (new_ptr === -1) { // than we try to identify the word 'trailer' and run backwards as long as we find a symbol that is not a number or 'f' or 'n' - what could possibly go wrong\r\n                section_type = \"trailer_without_xref_start\";\r\n                new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.TRAILER, _this.data, _this.data.length);\r\n                if (new_ptr > 0) {\r\n                    new_ptr--;\r\n                    while (new_ptr > 0 && (util_1.Util.isSpace(_this.data[new_ptr]) || util_1.Util.isNumber(_this.data[new_ptr]) || _this.data[new_ptr] === 110 || //110 = 'n' 102 = 'f'\r\n                        _this.data[new_ptr] === 102))\r\n                        --new_ptr;\r\n                    new_ptr = util_1.Util.skipSpaces(_this.data, new_ptr + 1);\r\n                }\r\n            }\r\n            return { pointer: new_ptr, sectionType: section_type };\r\n        };\r\n        try {\r\n            ptr = util_1.Util.extractNumber(this.data, ptr_startxref).result;\r\n        }\r\n        catch (err) {\r\n            return locateXREFStartManually();\r\n        }\r\n        if (ptr > this.data.length) {\r\n            return locateXREFStartManually();\r\n        }\r\n        // start section with XREF?\r\n        if (section_type !== \"stream\" && !(this.data[ptr] === util_1.Util.XREF[0] && this.data[ptr + 1] === util_1.Util.XREF[1] && this.data[ptr + 2] === util_1.Util.XREF[2] && this.data[ptr + 3] === util_1.Util.XREF[3])) {\r\n            return locateXREFStartManually();\r\n        }\r\n        return { pointer: ptr, sectionType: section_type };\r\n    };\r\n    /**\r\n     * Extracts the entire update sections\r\n     *\r\n     * Needs to adapt depending whether the document uses a cross-reference table or a cross-reference stream object\r\n     * */\r\n    DocumentHistory.prototype.extractDocumentHistory = function () {\r\n        var document_entry = this.extractDocumentEntry();\r\n        var ptr = document_entry.pointer;\r\n        if (ptr === -1) {\r\n            throw Error(\"Could not locate document entry\");\r\n        }\r\n        var xref = {\r\n            id: -1,\r\n            pointer: ptr,\r\n            generation: 0,\r\n            free: false,\r\n            update: true\r\n        };\r\n        this.extractCrossReferenceTables(document_entry, xref);\r\n        // adapt pointer in case there is junk before the header\r\n        var pdf_header_start = util_1.Util.locateSequence(util_1.Util.VERSION, this.data, 0);\r\n        if (pdf_header_start !== 0 && pdf_header_start !== -1) {\r\n            for (var _i = 0, _a = this.updates; _i < _a.length; _i++) {\r\n                var updateSection = _a[_i];\r\n                for (var _b = 0, _c = updateSection.refs; _b < _c.length; _b++) {\r\n                    var ref = _c[_b];\r\n                    ref.pointer += pdf_header_start;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Extracts the cross reference tables of the entire document\r\n     * */\r\n    DocumentHistory.prototype.extractCrossReferenceTables = function (document_entry, xref) {\r\n        var ptr = document_entry.pointer;\r\n        // Handle cross reference table\r\n        if (document_entry.sectionType === \"trailer\") {\r\n            var crt = this.extractCrossReferenceTable(ptr);\r\n            this.updates.push(crt.getUpdateSection());\r\n            var us = this.updates[0];\r\n            while (us.prev) {\r\n                crt = this.extractCrossReferenceTable(us.prev);\r\n                this.updates.push(crt.getUpdateSection());\r\n                us = this.updates[this.updates.length - 1];\r\n            }\r\n        }\r\n        else if (document_entry.sectionType === \"stream\") { // handle cross reference stream object\r\n            var crs = this.extractCrossReferenceStreamObject(xref);\r\n            this.updates.push(crs.getUpdateSection());\r\n            var us = this.updates[0];\r\n            while (us.prev) {\r\n                var _xref = {\r\n                    id: -1,\r\n                    pointer: us.prev,\r\n                    generation: 0,\r\n                    free: false,\r\n                    update: true\r\n                };\r\n                crs = this.extractCrossReferenceStreamObject(_xref);\r\n                this.updates.push(crs.getUpdateSection());\r\n                us = this.updates[this.updates.length - 1];\r\n            }\r\n        }\r\n        else if (document_entry.sectionType === \"trailer_without_xref_start\") {\r\n            var crt = this.extractCrossReferenceTable(ptr, true);\r\n            this.updates.push(crt.getUpdateSection());\r\n            var us = this.updates[0];\r\n            while (us.prev) {\r\n                crt = this.extractCrossReferenceTable(us.prev);\r\n                this.updates.push(crt.getUpdateSection());\r\n                us = this.updates[this.updates.length - 1];\r\n            }\r\n        }\r\n        else {\r\n            throw Error(\"Could not part cross reference table\");\r\n        }\r\n        this.trailerSize = this.extractReferenceNumberCount();\r\n    };\r\n    /**\r\n     * Counts the number of specified objects\r\n     * */\r\n    DocumentHistory.prototype.extractReferenceNumberCount = function () {\r\n        var visited = [];\r\n        var count = 0;\r\n        for (var _i = 0, _a = this.updates; _i < _a.length; _i++) {\r\n            var update = _a[_i];\r\n            for (var _b = 0, _c = update.refs; _b < _c.length; _b++) {\r\n                var ref = _c[_b];\r\n                if (!visited.includes(ref.id)) {\r\n                    count++;\r\n                    visited.push(ref.id);\r\n                }\r\n            }\r\n        }\r\n        return count;\r\n    };\r\n    /**\r\n     * Primarily for clarification. The first element is the most recent. We parsed backwards.\r\n     * */\r\n    DocumentHistory.prototype.getRecentUpdate = function () {\r\n        return this.updates[0];\r\n    };\r\n    /**\r\n     * Indicates whether the PDF document is encrypted\r\n     * */\r\n    DocumentHistory.prototype.isEncrypted = function () {\r\n        return this.getRecentUpdate().is_encrypted;\r\n    };\r\n    /**\r\n     * By running through the PDf history we can for every object id determine the pointer address to the most recent version, and\r\n     * whether the object id is still in used.\r\n     *\r\n     * So the object lookup table has an entry for every existing object id, a pointer to the the most recent object definition, as long\r\n     * as the object exists, or an according indication otherwise.\r\n     * */\r\n    DocumentHistory.prototype.createObjectLookupTable = function () {\r\n        var objTable = {};\r\n        var update = this.getRecentUpdate();\r\n        var i = 1;\r\n        while (Object.keys(objTable).length < this.extractReferenceNumberCount()) {\r\n            var refs = update.refs;\r\n            for (var _i = 0, refs_1 = refs; _i < refs_1.length; _i++) {\r\n                var ref = refs_1[_i];\r\n                if (!objTable.hasOwnProperty(ref.id)) {\r\n                    objTable[ref.id] = ref;\r\n                }\r\n            }\r\n            update = this.updates[i];\r\n            ++i;\r\n        }\r\n        return objTable;\r\n    };\r\n    /**\r\n     * Returns the new object id. It primarily tries to reuse an existing id, but if no such exists it will return a\r\n     * new one\r\n     * */\r\n    DocumentHistory.prototype.getFreeObjectId = function () {\r\n        var _this = this;\r\n        var objectLookupTable = this.createObjectLookupTable();\r\n        var free_header = objectLookupTable[0];\r\n        if (!free_header)\r\n            throw Error(\"Crosssite reference has no header for the linked list of free objects\");\r\n        // if the pointer of object 0 points to 0 there is no freed object that can be reused\r\n        if (0 === free_header.pointer) {\r\n            if (-1 === this.trailerSize)\r\n                throw Error(\"Trailer size not set\");\r\n            return { obj: this.trailerSize++, generation: 0, reused: false };\r\n        }\r\n        // get list head\r\n        var ptr = free_header.pointer;\r\n        var freedHeaderList = [];\r\n        while (ptr !== 0) {\r\n            freedHeaderList.push(free_header);\r\n            free_header = objectLookupTable[ptr];\r\n            if (!free_header.free) {\r\n                // handle the case of an incosistent xref\r\n                return { obj: this.trailerSize++, generation: 0, reused: false };\r\n            }\r\n            ptr = free_header.pointer;\r\n        }\r\n        var getFreeHeader = function (freeHeaderList) {\r\n            for (var _i = 0, _a = freeHeaderList.reverse(); _i < _a.length; _i++) {\r\n                var p = _a[_i];\r\n                if (p.generation < 65535 && // max generation number\r\n                    -1 === _this.already_reused_ids.indexOf(p)) { // not already reused\r\n                    return p;\r\n                }\r\n            }\r\n            return undefined;\r\n        };\r\n        var reused_free_header = getFreeHeader(freedHeaderList);\r\n        if (reused_free_header) {\r\n            free_header = reused_free_header;\r\n            // store used id to make sure it will not be selected again\r\n            this.already_reused_ids.push(free_header);\r\n        }\r\n        else {\r\n            // handle the case that all freed object ids are already reused\r\n            return { obj: this.trailerSize++, generation: 0, reused: false };\r\n        }\r\n        return { obj: free_header.pointer, generation: objectLookupTable[free_header.id].generation, reused: true };\r\n    };\r\n    return DocumentHistory;\r\n}());\r\nexports.DocumentHistory = DocumentHistory;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.STANDARD_FONT_DATA = void 0;\r\nexports.STANDARD_FONT_DATA = {\r\n    \"Times-Roman\": { widths: [250, 333, 408, 500, 500, 833, 778, 333, 333, 333, 500, 564, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 564, 564, 564, 444, 921, 722, 667, 667, 722, 611, 556, 722, 722, 333, 389, 722, 611, 889, 722, 722, 556, 722, 667, 556, 611, 722, 722, 944, 722, 722, 611, 333, 278, 333, 469, 500, 333, 444, 500, 444, 500, 444, 333, 500, 500, 278, 278, 500, 278, 778, 500, 500, 500, 500, 333, 389, 278, 500, 500, 722, 500, 500, 444, 480, 200, 480, 541, 333, 500, 500, 167, 500, 500, 500, 500, 180, 444, 500, 333, 333, 556, 556, 500, 500, 500, 250, 453, 350, 333, 444, 444, 500, 1000, 1000, 444, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 889, 276, 611, 722, 889, 310, 667, 278, 278, 500, 722, 500, 333, 444, 444, 500, 444, 722, 564, 722, 722, 444, 722, 500, 389, 444, 722, 722, 444, 722, 500, 611, 722, 250, 760, 611, 444, 444, 722, 278, 444, 611, 667, 444, 611, 389, 389, 278, 471, 667, 722, 500, 444, 722, 333, 444, 611, 556, 722, 667, 556, 588, 722, 500, 300, 722, 722, 722, 564, 500, 611, 476, 500, 722, 278, 611, 444, 444, 444, 500, 500, 722, 333, 564, 200, 760, 722, 333, 600, 611, 333, 500, 611, 611, 549, 722, 667, 278, 326, 444, 722, 722, 722, 444, 444, 278, 722, 500, 444, 389, 278, 722, 722, 612, 500, 300, 722, 500, 278, 500, 611, 500, 750, 556, 344, 722, 611, 980, 444, 333, 333, 611, 750, 549, 500, 500, 722, 611, 444, 500, 750, 556, 556, 722, 400, 500, 667, 500, 453, 722, 333, 722, 500, 667, 611, 722, 722, 722, 722, 444, 611, 333, 500, 564, 333, 500, 278, 564, 500, 500, 549, 500, 500, 444, 500, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: \"Times\", fontWeight: \"Roman\", italicAngle: 0, fontBBox: [-168, -218, 1000, 898], capHeight: 662, xHeight: 450, ascent: 683, descent: -217, stemH: 28, stemV: 84, flag: 34, kernings: [[65, 67, -40], [65, 71, -40], [65, 79, -55], [65, 233, -55], [65, 81, -55], [65, 84, -111], [65, 85, -55], [65, 86, -135], [65, 87, -90], [65, 89, -105], [65, 39, -111], [65, 118, -74], [65, 119, -92], [65, 121, -92], [66, 65, -35], [66, 85, -10], [68, 65, -40], [68, 86, -40], [68, 87, -30], [68, 89, -55], [70, 65, -74], [70, 97, -15], [70, 44, -80], [70, 111, -15], [70, 249, -15], [70, 46, -80], [74, 65, -60], [75, 79, -30], [75, 233, -30], [75, 101, -25], [75, 111, -35], [75, 249, -35], [75, 117, -15], [75, 121, -25], [76, 84, -92], [76, 86, -100], [76, 87, -74], [76, 89, -100], [76, 39, -92], [76, 121, -55], [232, 84, -92], [232, 86, -100], [232, 87, -74], [232, 89, -100], [232, 39, -92], [232, 121, -55], [78, 65, -35], [79, 65, -35], [79, 84, -40], [79, 86, -50], [79, 87, -35], [79, 88, -40], [79, 89, -50], [233, 65, -35], [233, 84, -40], [233, 86, -50], [233, 87, -35], [233, 88, -40], [233, 89, -50], [80, 65, -92], [80, 97, -15], [80, 44, -111], [80, 46, -111], [81, 85, -10], [82, 79, -40], [82, 233, -40], [82, 84, -60], [82, 85, -40], [82, 86, -80], [82, 87, -55], [82, 89, -65], [84, 65, -93], [84, 79, -18], [84, 233, -18], [84, 97, -80], [84, 58, -50], [84, 44, -74], [84, 101, -70], [84, 45, -92], [84, 105, -35], [84, 111, -80], [84, 249, -80], [84, 46, -74], [84, 114, -35], [84, 59, -55], [84, 117, -45], [84, 119, -80], [84, 121, -80], [85, 65, -40], [86, 65, -135], [86, 71, -15], [86, 79, -40], [86, 233, -40], [86, 97, -111], [86, 58, -74], [86, 44, -129], [86, 101, -111], [86, 45, -100], [86, 105, -60], [86, 111, -129], [86, 249, -129], [86, 46, -129], [86, 59, -74], [86, 117, -75], [87, 65, -120], [87, 79, -10], [87, 233, -10], [87, 97, -80], [87, 58, -37], [87, 44, -92], [87, 101, -80], [87, 45, -65], [87, 105, -40], [87, 111, -80], [87, 249, -80], [87, 46, -92], [87, 59, -37], [87, 117, -50], [87, 121, -73], [89, 65, -120], [89, 79, -30], [89, 233, -30], [89, 97, -100], [89, 58, -92], [89, 44, -129], [89, 101, -100], [89, 45, -111], [89, 105, -55], [89, 111, -110], [89, 249, -110], [89, 46, -129], [89, 59, -92], [89, 117, -111], [97, 118, -20], [97, 119, -15], [98, 46, -40], [98, 117, -20], [98, 118, -15], [99, 121, -15], [44, 186, -70], [44, 39, -70], [101, 103, -15], [101, 118, -25], [101, 119, -25], [101, 120, -15], [101, 121, -15], [102, 97, -10], [102, 245, -50], [102, 102, -25], [102, 105, -20], [102, 39, 55], [103, 97, -5], [104, 121, -5], [105, 118, -25], [107, 101, -10], [107, 111, -10], [107, 249, -10], [107, 121, -15], [108, 119, -10], [248, 119, -10], [110, 118, -40], [110, 121, -15], [111, 118, -15], [111, 119, -25], [111, 121, -10], [249, 118, -15], [249, 119, -25], [249, 121, -10], [112, 121, -10], [46, 186, -70], [46, 39, -70], [170, 65, -80], [96, 65, -80], [96, 96, -74], [39, 100, -50], [39, 108, -10], [39, 248, -10], [39, 39, -74], [39, 114, -50], [39, 115, -55], [39, 32, -74], [39, 116, -18], [39, 118, -50], [114, 44, -40], [114, 103, -18], [114, 45, -20], [114, 46, -55], [32, 65, -55], [32, 84, -18], [32, 86, -50], [32, 87, -30], [32, 89, -90], [118, 97, -25], [118, 44, -65], [118, 101, -15], [118, 111, -20], [118, 249, -20], [118, 46, -65], [119, 97, -10], [119, 44, -65], [119, 111, -10], [119, 249, -10], [119, 46, -65], [120, 101, -15], [121, 44, -65], [121, 46, -65]] },\r\n    \"ZapfDingbats\": { widths: [278, 974, 961, 974, 980, 719, 789, 790, 791, 690, 960, 939, 549, 855, 911, 933, 911, 945, 974, 755, 846, 762, 761, 571, 677, 763, 760, 759, 754, 494, 552, 537, 577, 692, 786, 788, 788, 790, 793, 794, 816, 823, 789, 841, 823, 833, 816, 831, 923, 744, 723, 749, 790, 792, 695, 776, 768, 792, 759, 707, 708, 682, 701, 826, 815, 789, 789, 707, 687, 696, 689, 786, 787, 713, 791, 785, 791, 873, 761, 762, 762, 759, 759, 892, 892, 788, 784, 438, 138, 277, 415, 392, 392, 668, 668, 390, 390, 317, 317, 276, 276, 509, 509, 410, 410, 234, 234, 334, 334, 732, 544, 544, 910, 667, 760, 760, 776, 595, 694, 626, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 894, 838, 1016, 458, 748, 924, 748, 918, 927, 928, 928, 834, 873, 828, 924, 924, 917, 930, 931, 463, 883, 836, 836, 867, 867, 696, 696, 874, 874, 760, 946, 771, 865, 771, 888, 967, 888, 831, 873, 927, 970, 918], firstChar: 32, lastChar: 254, familyName: \"ZapfDingbats\", fontWeight: \"Medium\", italicAngle: 0, fontBBox: [-1, -143, 981, 820], stemH: 28, stemV: 90, flag: 4, kernings: [] },\r\n    \"Helvetica\": { widths: [278, 278, 355, 556, 556, 889, 667, 222, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 222, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 167, 556, 556, 556, 556, 191, 333, 556, 333, 333, 500, 500, 556, 556, 556, 278, 537, 350, 222, 333, 333, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 556, 778, 1000, 365, 889, 278, 222, 611, 944, 611, 278, 556, 556, 556, 556, 667, 584, 667, 667, 556, 722, 500, 500, 556, 722, 722, 556, 722, 556, 667, 722, 250, 737, 667, 500, 556, 722, 222, 556, 611, 722, 556, 667, 500, 500, 278, 471, 722, 778, 556, 556, 667, 333, 500, 611, 667, 778, 722, 667, 643, 722, 556, 333, 778, 667, 667, 584, 556, 611, 476, 500, 722, 278, 667, 556, 556, 500, 556, 556, 722, 278, 584, 260, 737, 778, 278, 600, 667, 333, 556, 611, 611, 549, 722, 722, 222, 317, 556, 722, 667, 667, 556, 500, 222, 778, 556, 556, 500, 278, 778, 722, 612, 556, 333, 778, 556, 278, 556, 667, 556, 834, 667, 299, 667, 556, 1000, 556, 278, 278, 556, 834, 549, 556, 556, 722, 667, 556, 556, 834, 667, 667, 778, 400, 556, 722, 556, 453, 722, 333, 722, 556, 722, 556, 667, 667, 667, 778, 500, 667, 278, 500, 584, 278, 556, 278, 584, 556, 556, 549, 556, 556, 500, 556, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: \"Helvetica\", fontWeight: \"Medium\", italicAngle: 0, fontBBox: [-166, -225, 1000, 931], capHeight: 718, xHeight: 523, ascent: 718, descent: -207, stemH: 76, stemV: 88, flag: 32, kernings: [[65, 67, -30], [65, 71, -30], [65, 79, -30], [65, 233, -30], [65, 81, -30], [65, 84, -120], [65, 85, -50], [65, 86, -70], [65, 87, -50], [65, 89, -100], [65, 117, -30], [65, 118, -40], [65, 119, -40], [65, 121, -40], [66, 85, -10], [66, 44, -20], [66, 46, -20], [67, 44, -30], [67, 46, -30], [68, 65, -40], [68, 86, -70], [68, 87, -40], [68, 89, -90], [68, 44, -70], [68, 46, -70], [70, 65, -80], [70, 97, -50], [70, 44, -150], [70, 101, -30], [70, 111, -30], [70, 249, -30], [70, 46, -150], [70, 114, -45], [74, 65, -20], [74, 97, -20], [74, 44, -30], [74, 46, -30], [74, 117, -20], [75, 79, -50], [75, 233, -50], [75, 101, -40], [75, 111, -40], [75, 249, -40], [75, 117, -30], [75, 121, -50], [76, 84, -110], [76, 86, -110], [76, 87, -70], [76, 89, -140], [76, 186, -140], [76, 39, -160], [76, 121, -30], [232, 84, -110], [232, 86, -110], [232, 87, -70], [232, 89, -140], [232, 186, -140], [232, 39, -160], [232, 121, -30], [79, 65, -20], [79, 84, -40], [79, 86, -50], [79, 87, -30], [79, 88, -60], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -20], [233, 84, -40], [233, 86, -50], [233, 87, -30], [233, 88, -60], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -120], [80, 97, -40], [80, 44, -180], [80, 101, -50], [80, 111, -50], [80, 249, -50], [80, 46, -180], [81, 85, -10], [82, 79, -20], [82, 233, -20], [82, 84, -30], [82, 85, -40], [82, 86, -50], [82, 87, -30], [82, 89, -50], [83, 44, -20], [83, 46, -20], [84, 65, -120], [84, 79, -40], [84, 233, -40], [84, 97, -120], [84, 58, -20], [84, 44, -120], [84, 101, -120], [84, 45, -140], [84, 111, -120], [84, 249, -120], [84, 46, -120], [84, 114, -120], [84, 59, -20], [84, 117, -120], [84, 119, -120], [84, 121, -120], [85, 65, -40], [85, 44, -40], [85, 46, -40], [86, 65, -80], [86, 71, -40], [86, 79, -40], [86, 233, -40], [86, 97, -70], [86, 58, -40], [86, 44, -125], [86, 101, -80], [86, 45, -80], [86, 111, -80], [86, 249, -80], [86, 46, -125], [86, 59, -40], [86, 117, -70], [87, 65, -50], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 44, -80], [87, 101, -30], [87, 45, -40], [87, 111, -30], [87, 249, -30], [87, 46, -80], [87, 117, -30], [87, 121, -20], [89, 65, -110], [89, 79, -85], [89, 233, -85], [89, 97, -140], [89, 58, -60], [89, 44, -140], [89, 101, -140], [89, 45, -140], [89, 105, -20], [89, 111, -140], [89, 249, -140], [89, 46, -140], [89, 59, -60], [89, 117, -110], [97, 118, -20], [97, 119, -20], [97, 121, -30], [98, 98, -10], [98, 44, -40], [98, 108, -20], [98, 248, -20], [98, 46, -40], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 44, -15], [99, 107, -20], [58, 32, -50], [44, 186, -100], [44, 39, -100], [101, 44, -15], [101, 46, -15], [101, 118, -30], [101, 119, -20], [101, 120, -30], [101, 121, -20], [102, 97, -30], [102, 44, -30], [102, 245, -28], [102, 101, -30], [102, 111, -30], [102, 249, -30], [102, 46, -30], [102, 186, 60], [102, 39, 50], [103, 114, -10], [104, 121, -30], [107, 101, -20], [107, 111, -20], [107, 249, -20], [109, 117, -10], [109, 121, -15], [110, 117, -10], [110, 118, -20], [110, 121, -15], [111, 44, -40], [111, 46, -40], [111, 118, -15], [111, 119, -15], [111, 120, -30], [111, 121, -30], [249, 97, -55], [249, 98, -55], [249, 99, -55], [249, 44, -95], [249, 100, -55], [249, 101, -55], [249, 102, -55], [249, 103, -55], [249, 104, -55], [249, 105, -55], [249, 106, -55], [249, 107, -55], [249, 108, -55], [249, 248, -55], [249, 109, -55], [249, 110, -55], [249, 111, -55], [249, 249, -55], [249, 112, -55], [249, 46, -95], [249, 113, -55], [249, 114, -55], [249, 115, -55], [249, 116, -55], [249, 117, -55], [249, 118, -70], [249, 119, -70], [249, 120, -85], [249, 121, -70], [249, 122, -55], [112, 44, -35], [112, 46, -35], [112, 121, -30], [46, 186, -100], [46, 39, -100], [46, 32, -60], [186, 32, -40], [96, 96, -57], [39, 100, -50], [39, 39, -57], [39, 114, -50], [39, 115, -50], [39, 32, -70], [114, 97, -10], [114, 58, 30], [114, 44, -50], [114, 105, 15], [114, 107, 15], [114, 108, 15], [114, 248, 15], [114, 109, 25], [114, 110, 25], [114, 112, 30], [114, 46, -50], [114, 59, 30], [114, 116, 40], [114, 117, 15], [114, 118, 30], [114, 121, 30], [115, 44, -15], [115, 46, -15], [115, 119, -30], [59, 32, -50], [32, 84, -50], [32, 86, -50], [32, 87, -40], [32, 89, -90], [32, 170, -30], [32, 96, -60], [118, 97, -25], [118, 44, -80], [118, 101, -25], [118, 111, -25], [118, 249, -25], [118, 46, -80], [119, 97, -15], [119, 44, -60], [119, 101, -10], [119, 111, -10], [119, 249, -10], [119, 46, -60], [120, 101, -30], [121, 97, -20], [121, 44, -100], [121, 101, -20], [121, 111, -20], [121, 249, -20], [121, 46, -100], [122, 101, -15], [122, 111, -15], [122, 249, -15]] },\r\n    \"Courier-Oblique\": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: \"Courier\", fontWeight: \"Medium\", italicAngle: -12, fontBBox: [-27, -250, 849, 805], capHeight: 562, xHeight: 426, ascent: 629, descent: -157, stemH: 51, stemV: 51, flag: 35, kernings: [] },\r\n    \"Times-BoldItalic\": { widths: [250, 389, 555, 500, 500, 833, 778, 333, 333, 333, 500, 570, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570, 570, 500, 832, 667, 667, 667, 722, 667, 667, 722, 778, 389, 500, 667, 611, 889, 722, 722, 611, 722, 667, 556, 611, 722, 667, 889, 667, 611, 611, 333, 278, 333, 570, 500, 333, 500, 500, 444, 500, 444, 333, 500, 556, 278, 278, 500, 278, 778, 556, 500, 500, 500, 389, 389, 278, 556, 444, 667, 500, 444, 389, 348, 220, 348, 570, 389, 500, 500, 167, 500, 500, 500, 500, 278, 500, 500, 333, 333, 556, 556, 500, 500, 500, 250, 500, 350, 333, 500, 500, 500, 1000, 1000, 500, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 944, 266, 611, 722, 944, 300, 722, 278, 278, 500, 722, 500, 389, 444, 500, 556, 444, 611, 570, 611, 667, 500, 722, 444, 389, 444, 722, 722, 500, 722, 556, 667, 722, 250, 747, 667, 444, 500, 722, 278, 500, 611, 667, 500, 667, 389, 389, 278, 494, 667, 722, 556, 500, 667, 389, 444, 611, 611, 722, 667, 556, 608, 722, 556, 300, 722, 667, 667, 570, 556, 611, 494, 444, 722, 278, 667, 500, 444, 444, 556, 556, 722, 389, 570, 220, 747, 722, 389, 600, 667, 389, 500, 611, 611, 549, 722, 667, 278, 366, 444, 722, 667, 667, 444, 389, 278, 722, 500, 500, 389, 278, 722, 722, 612, 500, 300, 722, 576, 278, 500, 667, 500, 750, 556, 382, 667, 611, 1000, 444, 389, 389, 611, 750, 549, 500, 556, 722, 667, 444, 500, 750, 556, 556, 722, 400, 500, 667, 556, 549, 722, 389, 722, 500, 667, 611, 667, 667, 667, 722, 389, 667, 389, 500, 606, 389, 556, 278, 606, 500, 556, 549, 500, 500, 389, 556, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: \"Times\", fontWeight: \"Bold\", italicAngle: -15, fontBBox: [-200, -218, 996, 921], capHeight: 669, xHeight: 462, ascent: 683, descent: -217, stemH: 42, stemV: 121, flag: 34, kernings: [[65, 67, -65], [65, 71, -60], [65, 79, -50], [65, 233, -50], [65, 81, -55], [65, 84, -55], [65, 85, -50], [65, 86, -95], [65, 87, -100], [65, 89, -70], [65, 39, -74], [65, 117, -30], [65, 118, -74], [65, 119, -74], [65, 121, -74], [66, 65, -25], [66, 85, -10], [68, 65, -25], [68, 86, -50], [68, 87, -40], [68, 89, -50], [70, 65, -100], [70, 97, -95], [70, 44, -129], [70, 101, -100], [70, 105, -40], [70, 111, -70], [70, 249, -70], [70, 46, -129], [70, 114, -50], [74, 65, -25], [74, 97, -40], [74, 44, -10], [74, 101, -40], [74, 111, -40], [74, 249, -40], [74, 46, -10], [74, 117, -40], [75, 79, -30], [75, 233, -30], [75, 101, -25], [75, 111, -25], [75, 249, -25], [75, 117, -20], [75, 121, -20], [76, 84, -18], [76, 86, -37], [76, 87, -37], [76, 89, -37], [76, 39, -55], [76, 121, -37], [232, 84, -18], [232, 86, -37], [232, 87, -37], [232, 89, -37], [232, 39, -55], [232, 121, -37], [78, 65, -30], [79, 65, -40], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -40], [79, 89, -50], [233, 65, -40], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -40], [233, 89, -50], [80, 65, -85], [80, 97, -40], [80, 44, -129], [80, 101, -50], [80, 111, -55], [80, 249, -55], [80, 46, -129], [81, 85, -10], [82, 79, -40], [82, 233, -40], [82, 84, -30], [82, 85, -40], [82, 86, -18], [82, 87, -18], [82, 89, -18], [84, 65, -55], [84, 79, -18], [84, 233, -18], [84, 97, -92], [84, 58, -74], [84, 44, -92], [84, 101, -92], [84, 45, -92], [84, 105, -37], [84, 111, -95], [84, 249, -95], [84, 46, -92], [84, 114, -37], [84, 59, -74], [84, 117, -37], [84, 119, -37], [84, 121, -37], [85, 65, -45], [86, 65, -85], [86, 71, -10], [86, 79, -30], [86, 233, -30], [86, 97, -111], [86, 58, -74], [86, 44, -129], [86, 101, -111], [86, 45, -70], [86, 105, -55], [86, 111, -111], [86, 249, -111], [86, 46, -129], [86, 59, -74], [86, 117, -55], [87, 65, -74], [87, 79, -15], [87, 233, -15], [87, 97, -85], [87, 58, -55], [87, 44, -74], [87, 101, -90], [87, 45, -50], [87, 105, -37], [87, 111, -80], [87, 249, -80], [87, 46, -74], [87, 59, -55], [87, 117, -55], [87, 121, -55], [89, 65, -74], [89, 79, -25], [89, 233, -25], [89, 97, -92], [89, 58, -92], [89, 44, -92], [89, 101, -111], [89, 45, -92], [89, 105, -55], [89, 111, -111], [89, 249, -111], [89, 46, -74], [89, 59, -92], [89, 117, -92], [98, 98, -10], [98, 46, -40], [98, 117, -20], [99, 104, -10], [99, 107, -10], [44, 186, -95], [44, 39, -95], [101, 98, -10], [102, 44, -10], [102, 245, -30], [102, 101, -10], [102, 102, -18], [102, 111, -10], [102, 249, -10], [102, 46, -10], [102, 39, 55], [107, 101, -30], [107, 111, -10], [107, 249, -10], [110, 118, -40], [111, 118, -15], [111, 119, -25], [111, 120, -10], [111, 121, -10], [249, 118, -15], [249, 119, -25], [249, 120, -10], [249, 121, -10], [46, 186, -95], [46, 39, -95], [96, 96, -74], [39, 100, -15], [39, 39, -74], [39, 114, -15], [39, 115, -74], [39, 32, -74], [39, 116, -37], [39, 118, -15], [114, 44, -65], [114, 46, -65], [32, 65, -37], [32, 86, -70], [32, 87, -70], [32, 89, -70], [118, 44, -37], [118, 101, -15], [118, 111, -15], [118, 249, -15], [118, 46, -37], [119, 97, -10], [119, 44, -37], [119, 101, -10], [119, 111, -15], [119, 249, -15], [119, 46, -37], [120, 101, -10], [121, 44, -37], [121, 46, -37]] },\r\n    \"Courier-BoldOblique\": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: \"Courier\", fontWeight: \"Bold\", italicAngle: -12, fontBBox: [-57, -250, 869, 801], capHeight: 562, xHeight: 439, ascent: 629, descent: -157, stemH: 84, stemV: 106, flag: 35, kernings: [] },\r\n    \"Times-Bold\": { widths: [250, 333, 555, 500, 500, 1000, 833, 333, 333, 333, 500, 570, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570, 570, 500, 930, 722, 667, 722, 722, 667, 611, 778, 778, 389, 500, 778, 667, 944, 722, 778, 611, 778, 722, 556, 667, 722, 722, 1000, 722, 722, 667, 333, 278, 333, 581, 500, 333, 500, 556, 444, 556, 444, 333, 500, 556, 278, 333, 556, 278, 833, 556, 500, 556, 556, 444, 389, 333, 556, 500, 722, 500, 500, 444, 394, 220, 394, 520, 333, 500, 500, 167, 500, 500, 500, 500, 278, 500, 500, 333, 333, 556, 556, 500, 500, 500, 250, 540, 350, 333, 500, 500, 500, 1000, 1000, 500, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 300, 667, 778, 1000, 330, 722, 278, 278, 500, 722, 556, 389, 444, 500, 556, 444, 722, 570, 722, 722, 500, 722, 500, 389, 444, 722, 722, 500, 722, 556, 667, 722, 250, 747, 667, 444, 500, 722, 278, 500, 667, 722, 500, 667, 389, 389, 278, 494, 722, 778, 556, 500, 722, 444, 444, 667, 611, 778, 722, 556, 672, 722, 556, 300, 778, 722, 722, 570, 556, 667, 494, 500, 722, 278, 667, 500, 444, 444, 556, 556, 722, 389, 570, 220, 747, 778, 389, 600, 667, 444, 500, 667, 667, 549, 722, 722, 278, 416, 444, 722, 722, 722, 444, 444, 278, 778, 500, 500, 389, 278, 778, 722, 612, 556, 300, 778, 556, 278, 500, 667, 556, 750, 556, 394, 778, 667, 1000, 444, 389, 389, 667, 750, 549, 500, 556, 722, 667, 444, 500, 750, 556, 556, 778, 400, 500, 722, 556, 549, 722, 444, 722, 500, 722, 667, 722, 722, 722, 778, 444, 667, 389, 556, 570, 389, 556, 333, 570, 500, 556, 549, 500, 500, 444, 556, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: \"Times\", fontWeight: \"Bold\", italicAngle: 0, fontBBox: [-168, -218, 1000, 935], capHeight: 676, xHeight: 461, ascent: 683, descent: -217, stemH: 44, stemV: 139, flag: 34, kernings: [[65, 67, -55], [65, 71, -55], [65, 79, -45], [65, 233, -45], [65, 81, -45], [65, 84, -95], [65, 85, -50], [65, 86, -145], [65, 87, -130], [65, 89, -100], [65, 112, -25], [65, 39, -74], [65, 117, -50], [65, 118, -100], [65, 119, -90], [65, 121, -74], [66, 65, -30], [66, 85, -10], [68, 65, -35], [68, 86, -40], [68, 87, -40], [68, 89, -40], [68, 46, -20], [70, 65, -90], [70, 97, -25], [70, 44, -92], [70, 101, -25], [70, 111, -25], [70, 249, -25], [70, 46, -110], [74, 65, -30], [74, 97, -15], [74, 101, -15], [74, 111, -15], [74, 249, -15], [74, 46, -20], [74, 117, -15], [75, 79, -30], [75, 233, -30], [75, 101, -25], [75, 111, -25], [75, 249, -25], [75, 117, -15], [75, 121, -45], [76, 84, -92], [76, 86, -92], [76, 87, -92], [76, 89, -92], [76, 186, -20], [76, 39, -110], [76, 121, -55], [232, 84, -92], [232, 86, -92], [232, 87, -92], [232, 89, -92], [232, 186, -20], [232, 39, -110], [232, 121, -55], [78, 65, -20], [79, 65, -40], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -40], [79, 89, -50], [233, 65, -40], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -40], [233, 89, -50], [80, 65, -74], [80, 97, -10], [80, 44, -92], [80, 101, -20], [80, 111, -20], [80, 249, -20], [80, 46, -110], [81, 85, -10], [81, 46, -20], [82, 79, -30], [82, 233, -30], [82, 84, -40], [82, 85, -30], [82, 86, -55], [82, 87, -35], [82, 89, -35], [84, 65, -90], [84, 79, -18], [84, 233, -18], [84, 97, -92], [84, 58, -74], [84, 44, -74], [84, 101, -92], [84, 45, -92], [84, 105, -18], [84, 111, -92], [84, 249, -92], [84, 46, -90], [84, 114, -74], [84, 59, -74], [84, 117, -92], [84, 119, -74], [84, 121, -34], [85, 65, -60], [85, 44, -50], [85, 46, -50], [86, 65, -135], [86, 71, -30], [86, 79, -45], [86, 233, -45], [86, 97, -92], [86, 58, -92], [86, 44, -129], [86, 101, -100], [86, 45, -74], [86, 105, -37], [86, 111, -100], [86, 249, -100], [86, 46, -145], [86, 59, -92], [86, 117, -92], [87, 65, -120], [87, 79, -10], [87, 233, -10], [87, 97, -65], [87, 58, -55], [87, 44, -92], [87, 101, -65], [87, 45, -37], [87, 105, -18], [87, 111, -75], [87, 249, -75], [87, 46, -92], [87, 59, -55], [87, 117, -50], [87, 121, -60], [89, 65, -110], [89, 79, -35], [89, 233, -35], [89, 97, -85], [89, 58, -92], [89, 44, -92], [89, 101, -111], [89, 45, -92], [89, 105, -37], [89, 111, -111], [89, 249, -111], [89, 46, -92], [89, 59, -92], [89, 117, -92], [97, 118, -25], [98, 98, -10], [98, 46, -40], [98, 117, -20], [98, 118, -15], [44, 186, -45], [44, 39, -55], [100, 119, -15], [101, 118, -15], [102, 44, -15], [102, 245, -35], [102, 105, -25], [102, 111, -25], [102, 249, -25], [102, 46, -15], [102, 186, 50], [102, 39, 55], [103, 46, -15], [104, 121, -15], [105, 118, -10], [107, 101, -10], [107, 111, -15], [107, 249, -15], [107, 121, -15], [110, 118, -40], [111, 118, -10], [111, 119, -10], [249, 118, -10], [249, 119, -10], [46, 186, -55], [46, 39, -55], [170, 65, -10], [96, 65, -10], [96, 96, -63], [39, 100, -20], [39, 39, -63], [39, 114, -20], [39, 115, -37], [39, 32, -74], [39, 118, -20], [114, 99, -18], [114, 44, -92], [114, 101, -18], [114, 103, -10], [114, 45, -37], [114, 110, -15], [114, 111, -18], [114, 249, -18], [114, 112, -10], [114, 46, -100], [114, 113, -18], [114, 118, -10], [32, 65, -55], [32, 84, -30], [32, 86, -45], [32, 87, -30], [32, 89, -55], [118, 97, -10], [118, 44, -55], [118, 101, -10], [118, 111, -10], [118, 249, -10], [118, 46, -70], [119, 44, -55], [119, 111, -10], [119, 249, -10], [119, 46, -70], [121, 44, -55], [121, 101, -10], [121, 111, -25], [121, 249, -25], [121, 46, -70]] },\r\n    \"Courier\": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: \"Courier\", fontWeight: \"Medium\", italicAngle: 0, fontBBox: [-23, -250, 715, 805], capHeight: 562, xHeight: 426, ascent: 629, descent: -157, stemH: 51, stemV: 51, flag: 35, kernings: [] },\r\n    \"Helvetica-BoldOblique\": { widths: [278, 333, 474, 556, 556, 889, 722, 278, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 278, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 167, 556, 556, 556, 556, 238, 500, 556, 333, 333, 611, 611, 556, 556, 556, 278, 556, 350, 278, 500, 500, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 611, 778, 1000, 365, 889, 278, 278, 611, 944, 611, 278, 556, 556, 611, 556, 667, 584, 667, 722, 556, 722, 556, 556, 556, 722, 722, 556, 722, 611, 667, 722, 250, 737, 667, 556, 556, 722, 278, 556, 611, 722, 556, 667, 556, 556, 278, 494, 722, 778, 611, 556, 722, 389, 556, 611, 667, 778, 722, 667, 743, 722, 611, 333, 778, 722, 722, 584, 611, 611, 494, 556, 722, 278, 667, 556, 556, 556, 611, 611, 722, 278, 584, 280, 737, 778, 278, 600, 667, 389, 611, 611, 611, 549, 722, 722, 278, 389, 556, 722, 722, 722, 556, 500, 278, 778, 611, 556, 556, 278, 778, 722, 612, 611, 333, 778, 611, 278, 611, 667, 611, 834, 667, 400, 722, 611, 1000, 556, 278, 278, 611, 834, 549, 611, 611, 722, 667, 556, 611, 834, 667, 667, 778, 400, 611, 722, 611, 549, 722, 389, 722, 611, 722, 611, 722, 722, 722, 778, 500, 667, 278, 556, 584, 278, 611, 333, 584, 611, 611, 549, 611, 611, 500, 611, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: \"Helvetica\", fontWeight: \"Bold\", italicAngle: -12, fontBBox: [-174, -228, 1114, 962], capHeight: 718, xHeight: 532, ascent: 718, descent: -207, stemH: 118, stemV: 140, flag: 32, kernings: [[65, 67, -40], [65, 71, -50], [65, 79, -40], [65, 233, -40], [65, 81, -40], [65, 84, -90], [65, 85, -50], [65, 86, -80], [65, 87, -60], [65, 89, -110], [65, 117, -30], [65, 118, -40], [65, 119, -30], [65, 121, -30], [66, 65, -30], [66, 85, -10], [68, 65, -40], [68, 86, -40], [68, 87, -40], [68, 89, -70], [68, 44, -30], [68, 46, -30], [70, 65, -80], [70, 97, -20], [70, 44, -100], [70, 46, -100], [74, 65, -20], [74, 44, -20], [74, 46, -20], [74, 117, -20], [75, 79, -30], [75, 233, -30], [75, 101, -15], [75, 111, -35], [75, 249, -35], [75, 117, -30], [75, 121, -40], [76, 84, -90], [76, 86, -110], [76, 87, -80], [76, 89, -120], [76, 186, -140], [76, 39, -140], [76, 121, -30], [232, 84, -90], [232, 86, -110], [232, 87, -80], [232, 89, -120], [232, 186, -140], [232, 39, -140], [232, 121, -30], [79, 65, -50], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -50], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -50], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -50], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -100], [80, 97, -30], [80, 44, -120], [80, 101, -30], [80, 111, -40], [80, 249, -40], [80, 46, -120], [81, 85, -10], [81, 44, 20], [81, 46, 20], [82, 79, -20], [82, 233, -20], [82, 84, -20], [82, 85, -20], [82, 86, -50], [82, 87, -40], [82, 89, -50], [84, 65, -90], [84, 79, -40], [84, 233, -40], [84, 97, -80], [84, 58, -40], [84, 44, -80], [84, 101, -60], [84, 45, -120], [84, 111, -80], [84, 249, -80], [84, 46, -80], [84, 114, -80], [84, 59, -40], [84, 117, -90], [84, 119, -60], [84, 121, -60], [85, 65, -50], [85, 44, -30], [85, 46, -30], [86, 65, -80], [86, 71, -50], [86, 79, -50], [86, 233, -50], [86, 97, -60], [86, 58, -40], [86, 44, -120], [86, 101, -50], [86, 45, -80], [86, 111, -90], [86, 249, -90], [86, 46, -120], [86, 59, -40], [86, 117, -60], [87, 65, -60], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 58, -10], [87, 44, -80], [87, 101, -35], [87, 45, -40], [87, 111, -60], [87, 249, -60], [87, 46, -80], [87, 59, -10], [87, 117, -45], [87, 121, -20], [89, 65, -110], [89, 79, -70], [89, 233, -70], [89, 97, -90], [89, 58, -50], [89, 44, -100], [89, 101, -80], [89, 111, -100], [89, 249, -100], [89, 46, -100], [89, 59, -50], [89, 117, -100], [97, 103, -10], [97, 118, -15], [97, 119, -15], [97, 121, -20], [98, 108, -10], [98, 248, -10], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 104, -10], [99, 107, -20], [99, 108, -20], [99, 248, -20], [99, 121, -10], [58, 32, -40], [44, 186, -120], [44, 39, -120], [44, 32, -40], [100, 100, -10], [100, 118, -15], [100, 119, -15], [100, 121, -15], [101, 44, 10], [101, 46, 20], [101, 118, -15], [101, 119, -15], [101, 120, -15], [101, 121, -15], [102, 44, -10], [102, 101, -10], [102, 111, -20], [102, 249, -20], [102, 46, -10], [102, 186, 30], [102, 39, 30], [103, 101, 10], [103, 103, -10], [104, 121, -20], [107, 111, -15], [107, 249, -15], [108, 119, -15], [108, 121, -15], [248, 119, -15], [248, 121, -15], [109, 117, -20], [109, 121, -30], [110, 117, -10], [110, 118, -40], [110, 121, -20], [111, 118, -20], [111, 119, -15], [111, 120, -30], [111, 121, -20], [249, 118, -20], [249, 119, -15], [249, 120, -30], [249, 121, -20], [112, 121, -15], [46, 186, -120], [46, 39, -120], [46, 32, -40], [186, 32, -80], [96, 96, -46], [39, 100, -80], [39, 108, -20], [39, 248, -20], [39, 39, -46], [39, 114, -40], [39, 115, -60], [39, 32, -80], [39, 118, -20], [114, 99, -20], [114, 44, -60], [114, 100, -20], [114, 103, -15], [114, 45, -20], [114, 111, -20], [114, 249, -20], [114, 46, -60], [114, 113, -20], [114, 115, -15], [114, 116, 20], [114, 118, 10], [114, 121, 10], [115, 119, -15], [59, 32, -40], [32, 84, -100], [32, 86, -80], [32, 87, -80], [32, 89, -120], [32, 170, -80], [32, 96, -60], [118, 97, -20], [118, 44, -80], [118, 111, -30], [118, 249, -30], [118, 46, -80], [119, 44, -40], [119, 111, -20], [119, 249, -20], [119, 46, -40], [120, 101, -10], [121, 97, -30], [121, 44, -80], [121, 101, -10], [121, 111, -25], [121, 249, -25], [121, 46, -80], [122, 101, 10]] },\r\n    \"Helvetica-Bold\": { widths: [278, 333, 474, 556, 556, 889, 722, 278, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 278, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 167, 556, 556, 556, 556, 238, 500, 556, 333, 333, 611, 611, 556, 556, 556, 278, 556, 350, 278, 500, 500, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 611, 778, 1000, 365, 889, 278, 278, 611, 944, 611, 278, 556, 556, 611, 556, 667, 584, 667, 722, 556, 722, 556, 556, 556, 722, 722, 556, 722, 611, 667, 722, 250, 737, 667, 556, 556, 722, 278, 556, 611, 722, 556, 667, 556, 556, 278, 494, 722, 778, 611, 556, 722, 389, 556, 611, 667, 778, 722, 667, 743, 722, 611, 333, 778, 722, 722, 584, 611, 611, 494, 556, 722, 278, 667, 556, 556, 556, 611, 611, 722, 278, 584, 280, 737, 778, 278, 600, 667, 389, 611, 611, 611, 549, 722, 722, 278, 389, 556, 722, 722, 722, 556, 500, 278, 778, 611, 556, 556, 278, 778, 722, 612, 611, 333, 778, 611, 278, 611, 667, 611, 834, 667, 400, 722, 611, 1000, 556, 278, 278, 611, 834, 549, 611, 611, 722, 667, 556, 611, 834, 667, 667, 778, 400, 611, 722, 611, 549, 722, 389, 722, 611, 722, 611, 722, 722, 722, 778, 500, 667, 278, 556, 584, 278, 611, 333, 584, 611, 611, 549, 611, 611, 500, 611, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: \"Helvetica\", fontWeight: \"Bold\", italicAngle: 0, fontBBox: [-170, -228, 1003, 962], capHeight: 718, xHeight: 532, ascent: 718, descent: -207, stemH: 118, stemV: 140, flag: 32, kernings: [[65, 67, -40], [65, 71, -50], [65, 79, -40], [65, 233, -40], [65, 81, -40], [65, 84, -90], [65, 85, -50], [65, 86, -80], [65, 87, -60], [65, 89, -110], [65, 117, -30], [65, 118, -40], [65, 119, -30], [65, 121, -30], [66, 65, -30], [66, 85, -10], [68, 65, -40], [68, 86, -40], [68, 87, -40], [68, 89, -70], [68, 44, -30], [68, 46, -30], [70, 65, -80], [70, 97, -20], [70, 44, -100], [70, 46, -100], [74, 65, -20], [74, 44, -20], [74, 46, -20], [74, 117, -20], [75, 79, -30], [75, 233, -30], [75, 101, -15], [75, 111, -35], [75, 249, -35], [75, 117, -30], [75, 121, -40], [76, 84, -90], [76, 86, -110], [76, 87, -80], [76, 89, -120], [76, 186, -140], [76, 39, -140], [76, 121, -30], [232, 84, -90], [232, 86, -110], [232, 87, -80], [232, 89, -120], [232, 186, -140], [232, 39, -140], [232, 121, -30], [79, 65, -50], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -50], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -50], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -50], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -100], [80, 97, -30], [80, 44, -120], [80, 101, -30], [80, 111, -40], [80, 249, -40], [80, 46, -120], [81, 85, -10], [81, 44, 20], [81, 46, 20], [82, 79, -20], [82, 233, -20], [82, 84, -20], [82, 85, -20], [82, 86, -50], [82, 87, -40], [82, 89, -50], [84, 65, -90], [84, 79, -40], [84, 233, -40], [84, 97, -80], [84, 58, -40], [84, 44, -80], [84, 101, -60], [84, 45, -120], [84, 111, -80], [84, 249, -80], [84, 46, -80], [84, 114, -80], [84, 59, -40], [84, 117, -90], [84, 119, -60], [84, 121, -60], [85, 65, -50], [85, 44, -30], [85, 46, -30], [86, 65, -80], [86, 71, -50], [86, 79, -50], [86, 233, -50], [86, 97, -60], [86, 58, -40], [86, 44, -120], [86, 101, -50], [86, 45, -80], [86, 111, -90], [86, 249, -90], [86, 46, -120], [86, 59, -40], [86, 117, -60], [87, 65, -60], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 58, -10], [87, 44, -80], [87, 101, -35], [87, 45, -40], [87, 111, -60], [87, 249, -60], [87, 46, -80], [87, 59, -10], [87, 117, -45], [87, 121, -20], [89, 65, -110], [89, 79, -70], [89, 233, -70], [89, 97, -90], [89, 58, -50], [89, 44, -100], [89, 101, -80], [89, 111, -100], [89, 249, -100], [89, 46, -100], [89, 59, -50], [89, 117, -100], [97, 103, -10], [97, 118, -15], [97, 119, -15], [97, 121, -20], [98, 108, -10], [98, 248, -10], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 104, -10], [99, 107, -20], [99, 108, -20], [99, 248, -20], [99, 121, -10], [58, 32, -40], [44, 186, -120], [44, 39, -120], [44, 32, -40], [100, 100, -10], [100, 118, -15], [100, 119, -15], [100, 121, -15], [101, 44, 10], [101, 46, 20], [101, 118, -15], [101, 119, -15], [101, 120, -15], [101, 121, -15], [102, 44, -10], [102, 101, -10], [102, 111, -20], [102, 249, -20], [102, 46, -10], [102, 186, 30], [102, 39, 30], [103, 101, 10], [103, 103, -10], [104, 121, -20], [107, 111, -15], [107, 249, -15], [108, 119, -15], [108, 121, -15], [248, 119, -15], [248, 121, -15], [109, 117, -20], [109, 121, -30], [110, 117, -10], [110, 118, -40], [110, 121, -20], [111, 118, -20], [111, 119, -15], [111, 120, -30], [111, 121, -20], [249, 118, -20], [249, 119, -15], [249, 120, -30], [249, 121, -20], [112, 121, -15], [46, 186, -120], [46, 39, -120], [46, 32, -40], [186, 32, -80], [96, 96, -46], [39, 100, -80], [39, 108, -20], [39, 248, -20], [39, 39, -46], [39, 114, -40], [39, 115, -60], [39, 32, -80], [39, 118, -20], [114, 99, -20], [114, 44, -60], [114, 100, -20], [114, 103, -15], [114, 45, -20], [114, 111, -20], [114, 249, -20], [114, 46, -60], [114, 113, -20], [114, 115, -15], [114, 116, 20], [114, 118, 10], [114, 121, 10], [115, 119, -15], [59, 32, -40], [32, 84, -100], [32, 86, -80], [32, 87, -80], [32, 89, -120], [32, 170, -80], [32, 96, -60], [118, 97, -20], [118, 44, -80], [118, 111, -30], [118, 249, -30], [118, 46, -80], [119, 44, -40], [119, 111, -20], [119, 249, -20], [119, 46, -40], [120, 101, -10], [121, 97, -30], [121, 44, -80], [121, 101, -10], [121, 111, -25], [121, 249, -25], [121, 46, -80], [122, 101, 10]] },\r\n    \"Times-Italic\": { widths: [250, 333, 420, 500, 500, 833, 778, 333, 333, 333, 500, 675, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 675, 675, 675, 500, 920, 611, 611, 667, 722, 611, 611, 722, 722, 333, 444, 667, 556, 833, 667, 722, 611, 722, 611, 500, 556, 722, 611, 833, 611, 556, 556, 389, 278, 389, 422, 500, 333, 500, 500, 444, 500, 444, 278, 500, 500, 278, 278, 444, 278, 722, 500, 500, 500, 500, 389, 389, 278, 500, 444, 667, 444, 444, 389, 400, 275, 400, 541, 389, 500, 500, 167, 500, 500, 500, 500, 214, 556, 500, 333, 333, 500, 500, 500, 500, 500, 250, 523, 350, 333, 556, 556, 500, 889, 1000, 500, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 889, 889, 276, 556, 722, 944, 310, 667, 278, 278, 500, 667, 500, 333, 444, 500, 500, 444, 556, 675, 556, 611, 500, 722, 444, 389, 444, 722, 722, 500, 722, 500, 611, 722, 250, 760, 611, 444, 500, 667, 278, 500, 556, 667, 500, 611, 389, 389, 278, 471, 611, 722, 500, 500, 611, 389, 444, 556, 611, 722, 611, 500, 544, 722, 500, 300, 722, 611, 611, 675, 500, 556, 476, 444, 667, 278, 611, 500, 444, 444, 500, 500, 667, 333, 675, 275, 760, 722, 333, 600, 611, 389, 500, 556, 556, 549, 722, 667, 278, 300, 444, 722, 611, 611, 444, 389, 278, 722, 500, 500, 389, 278, 722, 722, 612, 500, 300, 722, 500, 278, 500, 611, 500, 750, 500, 300, 667, 556, 980, 444, 333, 333, 611, 750, 549, 500, 500, 722, 611, 444, 500, 750, 500, 500, 722, 400, 500, 667, 500, 453, 722, 389, 667, 500, 611, 556, 611, 611, 611, 722, 389, 611, 333, 444, 675, 333, 500, 278, 675, 500, 500, 549, 500, 500, 389, 500, 300, 278, 500], firstChar: 32, lastChar: 251, familyName: \"Times\", fontWeight: \"Medium\", italicAngle: -15.5, fontBBox: [-169, -217, 1010, 883], capHeight: 653, xHeight: 441, ascent: 683, descent: -217, stemH: 32, stemV: 76, flag: 34, kernings: [[65, 67, -30], [65, 71, -35], [65, 79, -40], [65, 233, -40], [65, 81, -40], [65, 84, -37], [65, 85, -50], [65, 86, -105], [65, 87, -95], [65, 89, -55], [65, 39, -37], [65, 117, -20], [65, 118, -55], [65, 119, -55], [65, 121, -55], [66, 65, -25], [66, 85, -10], [68, 65, -35], [68, 86, -40], [68, 87, -40], [68, 89, -40], [70, 65, -115], [70, 97, -75], [70, 44, -135], [70, 101, -75], [70, 105, -45], [70, 111, -105], [70, 249, -105], [70, 46, -135], [70, 114, -55], [74, 65, -40], [74, 97, -35], [74, 44, -25], [74, 101, -25], [74, 111, -25], [74, 249, -25], [74, 46, -25], [74, 117, -35], [75, 79, -50], [75, 233, -50], [75, 101, -35], [75, 111, -40], [75, 249, -40], [75, 117, -40], [75, 121, -40], [76, 84, -20], [76, 86, -55], [76, 87, -55], [76, 89, -20], [76, 39, -37], [76, 121, -30], [232, 84, -20], [232, 86, -55], [232, 87, -55], [232, 89, -20], [232, 39, -37], [232, 121, -30], [78, 65, -27], [79, 65, -55], [79, 84, -40], [79, 86, -50], [79, 87, -50], [79, 88, -40], [79, 89, -50], [233, 65, -55], [233, 84, -40], [233, 86, -50], [233, 87, -50], [233, 88, -40], [233, 89, -50], [80, 65, -90], [80, 97, -80], [80, 44, -135], [80, 101, -80], [80, 111, -80], [80, 249, -80], [80, 46, -135], [81, 85, -10], [82, 79, -40], [82, 233, -40], [82, 85, -40], [82, 86, -18], [82, 87, -18], [82, 89, -18], [84, 65, -50], [84, 79, -18], [84, 233, -18], [84, 97, -92], [84, 58, -55], [84, 44, -74], [84, 101, -92], [84, 45, -74], [84, 105, -55], [84, 111, -92], [84, 249, -92], [84, 46, -74], [84, 114, -55], [84, 59, -65], [84, 117, -55], [84, 119, -74], [84, 121, -74], [85, 65, -40], [85, 44, -25], [85, 46, -25], [86, 65, -60], [86, 79, -30], [86, 233, -30], [86, 97, -111], [86, 58, -65], [86, 44, -129], [86, 101, -111], [86, 45, -55], [86, 105, -74], [86, 111, -111], [86, 249, -111], [86, 46, -129], [86, 59, -74], [86, 117, -74], [87, 65, -60], [87, 79, -25], [87, 233, -25], [87, 97, -92], [87, 58, -65], [87, 44, -92], [87, 101, -92], [87, 45, -37], [87, 105, -55], [87, 111, -92], [87, 249, -92], [87, 46, -92], [87, 59, -65], [87, 117, -55], [87, 121, -70], [89, 65, -50], [89, 79, -15], [89, 233, -15], [89, 97, -92], [89, 58, -65], [89, 44, -92], [89, 101, -92], [89, 45, -74], [89, 105, -74], [89, 111, -92], [89, 249, -92], [89, 46, -92], [89, 59, -65], [89, 117, -92], [97, 103, -10], [98, 46, -40], [98, 117, -20], [99, 104, -15], [99, 107, -20], [44, 186, -140], [44, 39, -140], [101, 44, -10], [101, 103, -40], [101, 46, -15], [101, 118, -15], [101, 119, -15], [101, 120, -20], [101, 121, -30], [102, 44, -10], [102, 245, -60], [102, 102, -18], [102, 105, -20], [102, 46, -15], [102, 39, 92], [103, 44, -10], [103, 101, -10], [103, 103, -10], [103, 46, -15], [107, 101, -10], [107, 111, -10], [107, 249, -10], [107, 121, -10], [110, 118, -40], [111, 103, -10], [111, 118, -10], [249, 103, -10], [249, 118, -10], [46, 186, -140], [46, 39, -140], [96, 96, -111], [39, 100, -25], [39, 39, -111], [39, 114, -25], [39, 115, -40], [39, 32, -111], [39, 116, -30], [39, 118, -10], [114, 97, -15], [114, 99, -37], [114, 44, -111], [114, 100, -37], [114, 101, -37], [114, 103, -37], [114, 45, -20], [114, 111, -45], [114, 249, -45], [114, 46, -111], [114, 113, -37], [114, 115, -10], [32, 65, -18], [32, 84, -18], [32, 86, -35], [32, 87, -40], [32, 89, -75], [118, 44, -74], [118, 46, -74], [119, 44, -74], [119, 46, -74], [121, 44, -55], [121, 46, -55]] },\r\n    \"Symbol\": { widths: [250, 333, 713, 500, 549, 833, 778, 439, 333, 333, 500, 549, 250, 549, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 549, 549, 549, 444, 549, 722, 667, 722, 612, 611, 763, 603, 722, 333, 631, 722, 686, 889, 722, 722, 768, 741, 556, 592, 611, 690, 439, 768, 645, 795, 611, 333, 863, 333, 658, 500, 500, 631, 549, 549, 494, 439, 521, 411, 603, 329, 603, 549, 549, 576, 521, 549, 549, 521, 549, 603, 439, 576, 713, 686, 493, 686, 494, 480, 200, 480, 549, 750, 620, 247, 549, 167, 713, 500, 753, 753, 753, 753, 1042, 987, 603, 987, 603, 400, 549, 411, 549, 549, 713, 494, 460, 549, 549, 549, 549, 1000, 603, 1000, 658, 823, 686, 795, 987, 768, 768, 823, 768, 768, 713, 713, 713, 713, 713, 713, 713, 768, 713, 790, 790, 890, 823, 549, 250, 713, 603, 603, 1042, 987, 603, 987, 603, 494, 329, 790, 790, 786, 713, 384, 384, 384, 384, 384, 384, 494, 494, 494, 494, 329, 274, 686, 686, 686, 384, 384, 384, 384, 384, 384, 494, 494, 494, 790], firstChar: 32, lastChar: 254, familyName: \"Symbol\", fontWeight: \"Medium\", italicAngle: 0, fontBBox: [-180, -293, 1090, 1010], stemH: 92, stemV: 85, flag: 4, kernings: [] },\r\n    \"Courier-Bold\": { widths: [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], firstChar: 32, lastChar: 251, familyName: \"Courier\", fontWeight: \"Bold\", italicAngle: 0, fontBBox: [-113, -250, 749, 801], capHeight: 562, xHeight: 439, ascent: 629, descent: -157, stemH: 84, stemV: 106, flag: 35, kernings: [] },\r\n    \"Helvetica-Oblique\": { widths: [278, 278, 355, 556, 556, 889, 667, 222, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 222, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 167, 556, 556, 556, 556, 191, 333, 556, 333, 333, 500, 500, 556, 556, 556, 278, 537, 350, 222, 333, 333, 556, 1000, 1000, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 1000, 1000, 370, 556, 778, 1000, 365, 889, 278, 222, 611, 944, 611, 278, 556, 556, 556, 556, 667, 584, 667, 667, 556, 722, 500, 500, 556, 722, 722, 556, 722, 556, 667, 722, 250, 737, 667, 500, 556, 722, 222, 556, 611, 722, 556, 667, 500, 500, 278, 471, 722, 778, 556, 556, 667, 333, 500, 611, 667, 778, 722, 667, 643, 722, 556, 333, 778, 667, 667, 584, 556, 611, 476, 500, 722, 278, 667, 556, 556, 500, 556, 556, 722, 278, 584, 260, 737, 778, 278, 600, 667, 333, 556, 611, 611, 549, 722, 722, 222, 317, 556, 722, 667, 667, 556, 500, 222, 778, 556, 556, 500, 278, 778, 722, 612, 556, 333, 778, 556, 278, 556, 667, 556, 834, 667, 299, 667, 556, 1000, 556, 278, 278, 556, 834, 549, 556, 556, 722, 667, 556, 556, 834, 667, 667, 778, 400, 556, 722, 556, 453, 722, 333, 722, 556, 722, 556, 667, 667, 667, 778, 500, 667, 278, 500, 584, 278, 556, 278, 584, 556, 556, 549, 556, 556, 500, 556, 333, 278, 556], firstChar: 32, lastChar: 251, familyName: \"Helvetica\", fontWeight: \"Medium\", italicAngle: -12, fontBBox: [-170, -225, 1116, 931], capHeight: 718, xHeight: 523, ascent: 718, descent: -207, stemH: 76, stemV: 88, flag: 32, kernings: [[65, 67, -30], [65, 71, -30], [65, 79, -30], [65, 233, -30], [65, 81, -30], [65, 84, -120], [65, 85, -50], [65, 86, -70], [65, 87, -50], [65, 89, -100], [65, 117, -30], [65, 118, -40], [65, 119, -40], [65, 121, -40], [66, 85, -10], [66, 44, -20], [66, 46, -20], [67, 44, -30], [67, 46, -30], [68, 65, -40], [68, 86, -70], [68, 87, -40], [68, 89, -90], [68, 44, -70], [68, 46, -70], [70, 65, -80], [70, 97, -50], [70, 44, -150], [70, 101, -30], [70, 111, -30], [70, 249, -30], [70, 46, -150], [70, 114, -45], [74, 65, -20], [74, 97, -20], [74, 44, -30], [74, 46, -30], [74, 117, -20], [75, 79, -50], [75, 233, -50], [75, 101, -40], [75, 111, -40], [75, 249, -40], [75, 117, -30], [75, 121, -50], [76, 84, -110], [76, 86, -110], [76, 87, -70], [76, 89, -140], [76, 186, -140], [76, 39, -160], [76, 121, -30], [232, 84, -110], [232, 86, -110], [232, 87, -70], [232, 89, -140], [232, 186, -140], [232, 39, -160], [232, 121, -30], [79, 65, -20], [79, 84, -40], [79, 86, -50], [79, 87, -30], [79, 88, -60], [79, 89, -70], [79, 44, -40], [79, 46, -40], [233, 65, -20], [233, 84, -40], [233, 86, -50], [233, 87, -30], [233, 88, -60], [233, 89, -70], [233, 44, -40], [233, 46, -40], [80, 65, -120], [80, 97, -40], [80, 44, -180], [80, 101, -50], [80, 111, -50], [80, 249, -50], [80, 46, -180], [81, 85, -10], [82, 79, -20], [82, 233, -20], [82, 84, -30], [82, 85, -40], [82, 86, -50], [82, 87, -30], [82, 89, -50], [83, 44, -20], [83, 46, -20], [84, 65, -120], [84, 79, -40], [84, 233, -40], [84, 97, -120], [84, 58, -20], [84, 44, -120], [84, 101, -120], [84, 45, -140], [84, 111, -120], [84, 249, -120], [84, 46, -120], [84, 114, -120], [84, 59, -20], [84, 117, -120], [84, 119, -120], [84, 121, -120], [85, 65, -40], [85, 44, -40], [85, 46, -40], [86, 65, -80], [86, 71, -40], [86, 79, -40], [86, 233, -40], [86, 97, -70], [86, 58, -40], [86, 44, -125], [86, 101, -80], [86, 45, -80], [86, 111, -80], [86, 249, -80], [86, 46, -125], [86, 59, -40], [86, 117, -70], [87, 65, -50], [87, 79, -20], [87, 233, -20], [87, 97, -40], [87, 44, -80], [87, 101, -30], [87, 45, -40], [87, 111, -30], [87, 249, -30], [87, 46, -80], [87, 117, -30], [87, 121, -20], [89, 65, -110], [89, 79, -85], [89, 233, -85], [89, 97, -140], [89, 58, -60], [89, 44, -140], [89, 101, -140], [89, 45, -140], [89, 105, -20], [89, 111, -140], [89, 249, -140], [89, 46, -140], [89, 59, -60], [89, 117, -110], [97, 118, -20], [97, 119, -20], [97, 121, -30], [98, 98, -10], [98, 44, -40], [98, 108, -20], [98, 248, -20], [98, 46, -40], [98, 117, -20], [98, 118, -20], [98, 121, -20], [99, 44, -15], [99, 107, -20], [58, 32, -50], [44, 186, -100], [44, 39, -100], [101, 44, -15], [101, 46, -15], [101, 118, -30], [101, 119, -20], [101, 120, -30], [101, 121, -20], [102, 97, -30], [102, 44, -30], [102, 245, -28], [102, 101, -30], [102, 111, -30], [102, 249, -30], [102, 46, -30], [102, 186, 60], [102, 39, 50], [103, 114, -10], [104, 121, -30], [107, 101, -20], [107, 111, -20], [107, 249, -20], [109, 117, -10], [109, 121, -15], [110, 117, -10], [110, 118, -20], [110, 121, -15], [111, 44, -40], [111, 46, -40], [111, 118, -15], [111, 119, -15], [111, 120, -30], [111, 121, -30], [249, 97, -55], [249, 98, -55], [249, 99, -55], [249, 44, -95], [249, 100, -55], [249, 101, -55], [249, 102, -55], [249, 103, -55], [249, 104, -55], [249, 105, -55], [249, 106, -55], [249, 107, -55], [249, 108, -55], [249, 248, -55], [249, 109, -55], [249, 110, -55], [249, 111, -55], [249, 249, -55], [249, 112, -55], [249, 46, -95], [249, 113, -55], [249, 114, -55], [249, 115, -55], [249, 116, -55], [249, 117, -55], [249, 118, -70], [249, 119, -70], [249, 120, -85], [249, 121, -70], [249, 122, -55], [112, 44, -35], [112, 46, -35], [112, 121, -30], [46, 186, -100], [46, 39, -100], [46, 32, -60], [186, 32, -40], [96, 96, -57], [39, 100, -50], [39, 39, -57], [39, 114, -50], [39, 115, -50], [39, 32, -70], [114, 97, -10], [114, 58, 30], [114, 44, -50], [114, 105, 15], [114, 107, 15], [114, 108, 15], [114, 248, 15], [114, 109, 25], [114, 110, 25], [114, 112, 30], [114, 46, -50], [114, 59, 30], [114, 116, 40], [114, 117, 15], [114, 118, 30], [114, 121, 30], [115, 44, -15], [115, 46, -15], [115, 119, -30], [59, 32, -50], [32, 84, -50], [32, 86, -50], [32, 87, -40], [32, 89, -90], [32, 170, -30], [32, 96, -60], [118, 97, -25], [118, 44, -80], [118, 101, -25], [118, 111, -25], [118, 249, -25], [118, 46, -80], [119, 97, -15], [119, 44, -60], [119, 101, -10], [119, 111, -10], [119, 249, -10], [119, 46, -60], [120, 101, -30], [121, 97, -20], [121, 44, -100], [121, 101, -20], [121, 111, -20], [121, 249, -20], [121, 46, -100], [122, 101, -15], [122, 111, -15], [122, 249, -15]] }\r\n};\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.FontManager = exports.Font = exports.FontType = void 0;\r\nvar font_data_1 = require(\"./font-data\");\r\nvar writer_util_1 = require(\"./writer-util\");\r\nvar util_1 = require(\"./util\");\r\nvar FontType;\r\n(function (FontType) {\r\n    FontType[FontType[\"Type0\"] = 0] = \"Type0\";\r\n    FontType[FontType[\"Type1\"] = 1] = \"Type1\";\r\n    FontType[FontType[\"Type3\"] = 2] = \"Type3\";\r\n    FontType[FontType[\"MMType1\"] = 3] = \"MMType1\";\r\n    FontType[FontType[\"TrueType\"] = 4] = \"TrueType\";\r\n    FontType[FontType[\"CIDFontType0\"] = 5] = \"CIDFontType0\";\r\n    FontType[FontType[\"CIDFontType2\"] = 6] = \"CIDFontType2\";\r\n})(FontType = exports.FontType || (exports.FontType = {}));\r\nvar Font = /** @class */ (function () {\r\n    function Font(fontType, name, baseFont) {\r\n        if (fontType === void 0) { fontType = undefined; }\r\n        if (name === void 0) { name = undefined; }\r\n        if (baseFont === void 0) { baseFont = undefined; }\r\n        this.object_id = undefined;\r\n        /**\r\n         * Determines if the font must be written to the PDF document, since it is not yet defined\r\n         * */\r\n        this.is_new = false;\r\n        this.fontType = undefined;\r\n        this.name = undefined;\r\n        this.baseFont = undefined;\r\n        this.firstChar = undefined;\r\n        this.lastChar = undefined;\r\n        this.widths = undefined;\r\n        this.fontDescriptor = undefined;\r\n        this.encoding = undefined;\r\n        this.kernings = undefined;\r\n        this.fontType = fontType;\r\n        this.name = name;\r\n        this.baseFont = baseFont;\r\n        if (this.name && !this.name.startsWith(\"/\")) {\r\n            this.name = \"/\".concat(this.name);\r\n        }\r\n        if (this.baseFont && !this.baseFont.startsWith(\"/\")) {\r\n            this.baseFont = \"/\".concat(this.baseFont);\r\n        }\r\n        if (this.baseFont && Font.isStandardFont(this.baseFont)) {\r\n            this.populateStandardFontData(this.baseFont);\r\n            if (!this.widths) {\r\n                throw Error(\"No widths found for standard font \\\"\".concat(this.baseFont, \"\\\"\"));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calculates the dimensions of the text using this font\r\n     *\r\n     * It also proposes linebreak positions for the provided width\r\n     * */\r\n    Font.prototype.proposeLinebreaks = function (text, fontSize, width) {\r\n        if (!this.widths) {\r\n            return [];\r\n        }\r\n        if (!this.firstChar) {\r\n            this.firstChar = 0;\r\n        }\r\n        var ascii = this.getTextWidthArray(text, fontSize);\r\n        var positions = [];\r\n        var line_width = 0, last_space = -1, last_pos = 0;\r\n        for (var l = 0; l < ascii.length; ++l) {\r\n            if (text.charAt(l) === \" \") {\r\n                last_space = l;\r\n            }\r\n            if (line_width + ascii[l] > width) {\r\n                // backtrack to last space in the same line and move remainder in the next line\r\n                if (last_space !== -1) {\r\n                    positions.push({ start: last_pos, end: last_space - 1, width: ascii.slice(last_pos, last_space).reduce(function (x, y) { return x + y; }, 0) });\r\n                    l = last_space + 1;\r\n                    last_pos = l;\r\n                    last_space = -1;\r\n                }\r\n                else { // if no such last space is in the line return line_width - last letter width\r\n                    positions.push({ start: last_pos, end: l - 1, width: ascii.slice(last_pos, l).reduce(function (x, y) { return x + y; }, 0) });\r\n                    last_pos = l;\r\n                }\r\n                line_width = 0;\r\n            }\r\n            line_width += ascii[l];\r\n        }\r\n        if (last_pos !== ascii.length) {\r\n            positions.push({ start: last_pos, end: ascii.length - 1, width: ascii.slice(last_pos, ascii.length).reduce(function (x, y) { return x + y; }, 0) });\r\n        }\r\n        return positions;\r\n    };\r\n    /**\r\n     * Calculates the dimensions of the text using this font\r\n     *\r\n     * Returns [width, height]\r\n     * */\r\n    Font.prototype.calculateTextDimensions = function (text, fontSize) {\r\n        var widths = this.getTextWidthArray(text, fontSize);\r\n        // calculate the sum of the widths array\r\n        return [widths.reduce(function (pv, cv) { return pv + cv; }, 0), fontSize];\r\n    };\r\n    /**\r\n     * Calculates the dimensions of the text using this font in mm\r\n     *\r\n     * Returns [width, height]\r\n     * */\r\n    Font.prototype.calculateTextDimensionsInMM = function (text, fontSize) {\r\n        var values = this.calculateTextDimensions(text, fontSize);\r\n        return [values[0] * 25.4 / 72, values[1]];\r\n    };\r\n    /**\r\n     * Helper method to lookup the kerning value\r\n     * */\r\n    Font.prototype.getKerningValue = function (previousChar, currentChar) {\r\n        if (!this.kernings)\r\n            return 0;\r\n        var list = this.kernings.get(previousChar);\r\n        if (!list)\r\n            return 0;\r\n        list = list.filter(function (x) { return x[0] === currentChar; });\r\n        if (list.length === 1) {\r\n            return list[0][1];\r\n        }\r\n        return 0;\r\n    };\r\n    /**\r\n     * Returns the array of letter widths that are contained in the string\r\n     * */\r\n    Font.prototype.getTextWidthArray = function (text, fontSize) {\r\n        if (!this.widths) {\r\n            return [];\r\n        }\r\n        if (!this.firstChar) {\r\n            this.firstChar = 0;\r\n        }\r\n        var ascii = util_1.Util.convertStringToAscii(text);\r\n        var ret_val = [];\r\n        var previous_char = -1;\r\n        for (var _i = 0, ascii_1 = ascii; _i < ascii_1.length; _i++) {\r\n            var letter = ascii_1[_i];\r\n            var kerning_value = 0;\r\n            if (previous_char != -1 && this.kernings) {\r\n                kerning_value = this.getKerningValue(previous_char, letter);\r\n            }\r\n            ret_val.push((this.widths[letter - this.firstChar] + kerning_value) / 1000 * fontSize);\r\n            previous_char = letter;\r\n        }\r\n        return ret_val;\r\n    };\r\n    /**\r\n     * Returns the widths array of a standard font\r\n     * */\r\n    Font.prototype.populateStandardFontData = function (font_name) {\r\n        if (font_name.startsWith(\"/\")) {\r\n            font_name = font_name.substring(1);\r\n        }\r\n        var key = Object.keys(font_data_1.STANDARD_FONT_DATA).filter(function (name) { return font_name.localeCompare(name) === 0; });\r\n        if (!key || key.length === 0 || key.length > 1) {\r\n            throw Error(\"No font widths for standard font \".concat(font_name));\r\n        }\r\n        var font_data = font_data_1.STANDARD_FONT_DATA[key[0]];\r\n        if (!font_data) {\r\n            throw Error(\"No font data for standard font \".concat(font_name));\r\n        }\r\n        this.widths = font_data.widths;\r\n        this.firstChar = font_data.firstChar;\r\n        this.lastChar = font_data.lastChar;\r\n        this.fontDescriptor = {\r\n            fontName: this.baseFont,\r\n            fontFamily: font_data.familyName,\r\n            fontWeight: font_data.fontWeight,\r\n            italicAngle: font_data.italicAngle,\r\n            fontBBox: font_data.fontBBox,\r\n            capHeight: font_data.capHeight,\r\n            xHeight: font_data.xHeight,\r\n            ascent: font_data.ascent,\r\n            descent: font_data.descent,\r\n            stemH: font_data.stemH,\r\n            stemV: font_data.stemV,\r\n            flags: font_data.flag\r\n        };\r\n        // setup hash map that contains the kerning data\r\n        if (font_data.kernings) {\r\n            this.kernings = new Map();\r\n            for (var _i = 0, _a = font_data.kernings; _i < _a.length; _i++) {\r\n                var value = _a[_i];\r\n                var _list = [];\r\n                if (this.kernings.has(value[0])) {\r\n                    _list = this.kernings.get(value[0]);\r\n                }\r\n                _list.push(value.slice(1));\r\n                this.kernings.set(value[0], _list);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns a standard font\r\n     * fontName the name reference the font name\r\n     * baseFont the standard font\r\n     * */\r\n    Font.createStandardFont = function (object_id, fontName, baseFont) {\r\n        var font = new Font(FontType.Type1, fontName, baseFont);\r\n        font.object_id = object_id;\r\n        return font;\r\n    };\r\n    /**\r\n     * True, if the name is a standard font name\r\n     * */\r\n    Font.isStandardFont = function (name) {\r\n        if (name.startsWith(\"/\")) {\r\n            name = name.substring(1);\r\n        }\r\n        switch (name) {\r\n            case \"Times-Roman\":\r\n                return true;\r\n            case \"Times-Bold\":\r\n                return true;\r\n            case \"Times-Italic\":\r\n                return true;\r\n            case \"Times-BoldItalic\":\r\n                return true;\r\n            case \"Helvetica\":\r\n                return true;\r\n            case \"Helvetica-Bold\":\r\n                return true;\r\n            case \"Helvetica-Oblique\":\r\n                return true;\r\n            case \"Helvetica-BoldOblique\":\r\n                return true;\r\n            case \"Courier\":\r\n                return true;\r\n            case \"Courier-Oblique\":\r\n                return true;\r\n            case \"Courier-BoldOblique\":\r\n                return true;\r\n            case \"Courier-Bold\":\r\n                return true;\r\n            case \"Symbol\":\r\n                return true;\r\n            case \"ZapfDingbats\":\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    Font.prototype.typeToNumberArray = function (fontType) {\r\n        switch (fontType) {\r\n            case FontType.Type0:\r\n                return writer_util_1.WriterUtil.TYPE0;\r\n                break;\r\n            case FontType.Type1:\r\n                return writer_util_1.WriterUtil.TYPE1;\r\n                break;\r\n            case FontType.Type3:\r\n                return writer_util_1.WriterUtil.TYPE3;\r\n                break;\r\n            case FontType.MMType1:\r\n                return writer_util_1.WriterUtil.MMTYPE1;\r\n                break;\r\n            case FontType.TrueType:\r\n                return writer_util_1.WriterUtil.TRUETYPE;\r\n                break;\r\n            case FontType.CIDFontType0:\r\n                return writer_util_1.WriterUtil.CIDFONTTYPE0;\r\n                break;\r\n            case FontType.CIDFontType2:\r\n                return writer_util_1.WriterUtil.CIDFONTTYPE2;\r\n                break;\r\n        }\r\n        return [];\r\n    };\r\n    Font.prototype.writeFontDescriptor = function () {\r\n        if (!this.fontDescriptor)\r\n            return [];\r\n        var ret = [];\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.TYPE_FONTDESCRIPTOR);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.baseFont) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.FONTNAME);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertStringToAscii(this.baseFont));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.fontFamily) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.FONTFAMILY);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertStringToByteString(this.fontDescriptor.fontFamily));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.fontStretch) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.FONTSTRETCH);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertStringToAscii(this.fontDescriptor.fontStretch));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.flags) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.FLAGS);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.flags));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.fontBBox) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.FONTBBOX);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.fontDescriptor.fontBBox));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.italicAngle) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.ITALICANGLE);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.italicAngle));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.ascent) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.ASCENT);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.ascent));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.descent) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.DESCENT);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.descent));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.leading) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.LEADING);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.leading));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.capHeight) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.CAPHEIGHT);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.capHeight));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.xHeight) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.XHEIGHT);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.xHeight));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.stemV) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.STEMV);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.stemV));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.stemH) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.STEMH);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.stemH));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.avgWidth) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.AVGWIDTH);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.avgWidth));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.maxWidth) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.MAXWIDTH);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.maxWidth));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor.missingWidth) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.MISSINGWIDTH);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.fontDescriptor.missingWidth));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        return ret;\r\n    };\r\n    Font.prototype.writeFont = function () {\r\n        if (!this.object_id)\r\n            throw Error(\"object_id of font not set\");\r\n        var ret = writer_util_1.WriterUtil.writeReferencePointer(this.object_id);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.OBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.TYPE_FONT);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (!this.fontType) {\r\n            throw Error(\"Font Type not set\");\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.SUBTYPE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(this.typeToNumberArray(this.fontType));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.baseFont) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.BASEFONT);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertStringToAscii(this.baseFont));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.firstChar) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.FIRSTCHAR);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.firstChar));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.lastChar) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.LASTCHAR);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(this.lastChar));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.widths) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.WIDTHS);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeNumberArray(this.widths));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.fontDescriptor) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.FONTDESCRIPTOR);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(this.writeFontDescriptor());\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.encoding) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.ENCODING);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertStringToAscii(this.encoding));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        return ret;\r\n    };\r\n    return Font;\r\n}());\r\nexports.Font = Font;\r\nvar FontManager = /** @class */ (function () {\r\n    function FontManager(parser) {\r\n        this.parser = parser;\r\n        /**\r\n         * The fonts in the document\r\n         * */\r\n        this.fonts = [];\r\n    }\r\n    /**\r\n     * Returns the font with the corresponding reference pointer or name or basefont\r\n     *\r\n     * If there is no such font it returns undefined\r\n     * */\r\n    FontManager.prototype.getFont = function (font) {\r\n        for (var _i = 0, _a = this.fonts; _i < _a.length; _i++) {\r\n            var f = _a[_i];\r\n            if (typeof font === 'string') {\r\n                if (f.name === font || f.baseFont === font)\r\n                    return f;\r\n            }\r\n            else if (font instanceof Font) {\r\n                if (font.object_id && f.object_id) {\r\n                    if (f.object_id.obj === font.object_id.obj && f.object_id.generation === font.object_id.generation)\r\n                        return f;\r\n                }\r\n                else if (font.name && f.name) {\r\n                    if (f.name === font.name)\r\n                        return f;\r\n                }\r\n                else if (font.baseFont && f.baseFont) {\r\n                    if (f.baseFont === font.baseFont)\r\n                        return f;\r\n                }\r\n            }\r\n            else {\r\n                if (f.object_id.obj === font.obj && f.object_id.generation === font.generation)\r\n                    return f;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Adds a font, if it does not already exists.\r\n     * */\r\n    FontManager.prototype.addFont = function (font) {\r\n        if (this.hasFont(font)) {\r\n            return undefined;\r\n        }\r\n        if (typeof font === \"string\") {\r\n            if (Font.isStandardFont(font)) {\r\n                font = Font.createStandardFont(this.parser.getFreeObjectId(), this.getUnusedFontName(), font);\r\n                font.is_new = true;\r\n            }\r\n        }\r\n        if (!(font instanceof Font)) {\r\n            throw Error('Could not add font');\r\n        }\r\n        this.fonts.push(font);\r\n        return font;\r\n    };\r\n    /**\r\n     * Returns a font name that is not used yet\r\n     * */\r\n    FontManager.prototype.getUnusedFontName = function () {\r\n        var font_name = \"/F\".concat(this.fonts.length);\r\n        var i = 1;\r\n        while (this.hasFont(font_name)) {\r\n            font_name = \"/F\".concat(this.fonts.length + i++);\r\n        }\r\n        return font_name;\r\n    };\r\n    /**\r\n     * Retutrns true, if the font is already part of the font manager\r\n     *\r\n     * Font can be a Font object, a reference pointer of a font object a font name or a base font\r\n     * */\r\n    FontManager.prototype.hasFont = function (font_ptr) {\r\n        if (font_ptr instanceof Font && font_ptr.object_id) {\r\n            font_ptr = font_ptr.object_id;\r\n        }\r\n        else if (typeof font_ptr === \"string\") {\r\n            return this.fonts.filter(function (f) { return f.name === font_ptr ||\r\n                f.baseFont === font_ptr; }).length > 0;\r\n        }\r\n        return this.fonts.filter(function (f) { return f.object_id && f.object_id.obj === font_ptr.obj &&\r\n            f.object_id.generation === font_ptr.generation; }).length > 0;\r\n    };\r\n    /**\r\n     * Returns true, if the font with the given name is registered, or if it is the name of a standard font.\r\n     * */\r\n    FontManager.prototype.isRegisteredFont = function (font) {\r\n        if (typeof font === 'string') {\r\n            if (Font.isStandardFont(font))\r\n                return true;\r\n            for (var _i = 0, _a = this.fonts; _i < _a.length; _i++) {\r\n                var _font = _a[_i];\r\n                if (_font.name === font) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (font instanceof Font) {\r\n            for (var _b = 0, _c = this.fonts; _b < _c.length; _b++) {\r\n                var _font = _c[_b];\r\n                if (_font.name === font.name) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Returns the new fonts that must be appended to the document\r\n     * */\r\n    FontManager.prototype.getFontsToWrite = function () {\r\n        return this.fonts.filter(function (x) { return x.is_new; });\r\n    };\r\n    return FontManager;\r\n}());\r\nexports.FontManager = FontManager;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nexports.__esModule = true;\r\nexports.AnnotationFactory = exports.Util = exports.FreeTextType = exports.TextJustification = exports.AnnotationStateModel = exports.AnnotationState = exports.AnnotationIcon = exports.LineEndingStyle = exports.PDFDocumentParser = void 0;\r\nvar parser_1 = require(\"./parser\");\r\n__createBinding(exports, parser_1, \"PDFDocumentParser\");\r\nvar annotation_types_1 = require(\"./annotations/annotation_types\");\r\n__createBinding(exports, annotation_types_1, \"LineEndingStyle\");\r\nvar text_annotation_1 = require(\"./annotations/text_annotation\");\r\n__createBinding(exports, text_annotation_1, \"AnnotationIcon\");\r\n__createBinding(exports, text_annotation_1, \"AnnotationState\");\r\n__createBinding(exports, text_annotation_1, \"AnnotationStateModel\");\r\nvar freetext_annotation_1 = require(\"./annotations/freetext_annotation\");\r\n__createBinding(exports, freetext_annotation_1, \"TextJustification\");\r\n__createBinding(exports, freetext_annotation_1, \"FreeTextType\");\r\nvar util_1 = require(\"./util\");\r\n__createBinding(exports, util_1, \"Util\");\r\nvar annotation_1 = require(\"./annotation\");\r\n__createBinding(exports, annotation_1, \"AnnotationFactory\");\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.ObjectUtil = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar array_util_1 = require(\"./array-util\");\r\nvar stream_1 = require(\"./stream\");\r\n/**\r\n * While the general Util class holds low level methods to navigate through the pdf data, the ObjectUtil\r\n * is purposefully build to extract complete objects. It returns those as json dictionaries.\r\n * */\r\nvar ObjectUtil = /** @class */ (function () {\r\n    function ObjectUtil() {\r\n    }\r\n    ObjectUtil.extractDictKeyRec = function (data, ptr, dict) {\r\n        var next = util_1.Util.readNextWord(data, ptr);\r\n        var next_string = next.result;\r\n        if (!next_string)\r\n            return ptr;\r\n        var _ptr = util_1.Util.skipDelimiter(next_string, 0);\r\n        if (next_string[0] && util_1.Util.DICT_END[0] === next_string[0]) {\r\n            var wordLookup = util_1.Util.readNextWord(data, next.end_index + 1);\r\n            if (wordLookup.result && util_1.Util.DICT_END[0] === wordLookup.result[0]) {\r\n                return wordLookup.end_index;\r\n            }\r\n        }\r\n        return ObjectUtil.extractDictValueRec(data, next.end_index + 1, dict, util_1.Util.convertAsciiToString(next_string));\r\n    };\r\n    ObjectUtil.extractDictValueRec = function (data, ptr, dict, current_key) {\r\n        if (current_key === void 0) { current_key = undefined; }\r\n        var next = util_1.Util.readNextWord(data, ptr);\r\n        var next_string = next.result || new Uint8Array([]);\r\n        ptr = next.end_index - next_string.length + 1;\r\n        if (next_string[0] === util_1.Util.ARRAY_START[0]) {\r\n            if (!current_key)\r\n                throw Error(\"Invalid anonymous array definition\");\r\n            // handle array\r\n            var extracted_array = array_util_1.ArrayUtil.extractArray(data, ptr);\r\n            dict[current_key] = extracted_array.result;\r\n            return ObjectUtil.extractDictKeyRec(data, extracted_array.end_index + 1, dict);\r\n        }\r\n        else if (next_string[0] === util_1.Util.DICT_START[0] && data[next.end_index + 1] === util_1.Util.DICT_START[0]) {\r\n            if (current_key) {\r\n                var sup_dict = {};\r\n                var end_sub_dict = ObjectUtil.extractDictKeyRec(data, next.end_index + 2, sup_dict);\r\n                dict[current_key] = sup_dict;\r\n                return ObjectUtil.extractDictKeyRec(data, end_sub_dict + 1, dict);\r\n            }\r\n            else {\r\n                return ObjectUtil.extractDictKeyRec(data, next.end_index + 2, dict);\r\n            }\r\n        }\r\n        else if (next_string[0] === util_1.Util.HEX_STRING_START[0]) {\r\n            if (!current_key)\r\n                throw Error(\"Invalid anonymous string definition\");\r\n            var extracted_string = util_1.Util.extractHexString(data, ptr);\r\n            dict[current_key] = extracted_string.result;\r\n            return ObjectUtil.extractDictKeyRec(data, extracted_string.end_index + 1, dict);\r\n        }\r\n        else if (next_string[0] === util_1.Util.LITERAL_STRING_START[0]) {\r\n            if (!current_key)\r\n                throw Error(\"Invalid anonymous string definition\");\r\n            var extracted_string = util_1.Util.extractString(data, ptr);\r\n            dict[current_key] = extracted_string.result;\r\n            return ObjectUtil.extractDictKeyRec(data, extracted_string.end_index + 1, dict);\r\n        }\r\n        else if (next_string[0] === 47) { // /\r\n            if (!current_key)\r\n                throw Error(\"Invalid anonymous property definition\");\r\n            var opt_value = util_1.Util.extractOptionValue(data, ptr);\r\n            dict[current_key] = \"/\" + opt_value.result;\r\n            return ObjectUtil.extractDictKeyRec(data, opt_value.end_index + 1, dict);\r\n        }\r\n        else { // It is a number, but this number might be part of a Reference\r\n            var lookupNext = util_1.Util.readNextWord(data, next.end_index + 1);\r\n            var lookupNextWord = lookupNext.result || new Uint8Array([]);\r\n            if (!current_key)\r\n                throw Error(\"Invalid anonymous reference/number definition\");\r\n            var value_end_ptr = next.end_index + 1;\r\n            if (lookupNextWord[0] === 47 || lookupNextWord[0] === util_1.Util.DICT_END[0]) { // is a number\r\n                dict[current_key] = util_1.Util.extractNumber(data, ptr).result;\r\n            }\r\n            else { // is a rereference\r\n                var extracted_reference = util_1.Util.extractReferenceTyped(data, ptr);\r\n                dict[current_key] = extracted_reference.result;\r\n                value_end_ptr = extracted_reference.end_index + 1;\r\n            }\r\n            // handle Reference\r\n            return ObjectUtil.extractDictKeyRec(data, value_end_ptr, dict);\r\n        }\r\n    };\r\n    /**\r\n     * Locates the object start in case the ptr does not point correctly\r\n     * */\r\n    ObjectUtil.locateObjectStart = function (data, ptr) {\r\n        var obj_ptr = util_1.Util.locateSequence(util_1.Util.OBJ, data, ptr);\r\n        var endobj_ptr = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, ptr);\r\n        var consumeGenerationAndNumberRevere = function (ptr) {\r\n            // <id> <generation> obj ... endobj\r\n            //                   ^\r\n            // being somewhere here\r\n            var new_ptr = util_1.Util.skipSpacesReverse(data, ptr - 1);\r\n            // <id> <generation> obj ... endobj\r\n            //                 ^\r\n            // being somewhere here\r\n            while (new_ptr > 0 && !util_1.Util.isDelimiter(data[new_ptr]))\r\n                --new_ptr;\r\n            // <id> <generation> obj ... endobj\r\n            //      ^\r\n            // being somewhere here\r\n            new_ptr = util_1.Util.skipSpacesReverse(data, new_ptr - 1);\r\n            // <id> <generation> obj ... endobj\r\n            // ^\r\n            // being somewhere here\r\n            while (new_ptr > 0 && !util_1.Util.isDelimiter(data[new_ptr]))\r\n                --new_ptr;\r\n            return new_ptr;\r\n        };\r\n        if (obj_ptr !== -1 && obj_ptr < endobj_ptr) {\r\n            return consumeGenerationAndNumberRevere(obj_ptr);\r\n        }\r\n        else if (obj_ptr > endobj_ptr || (obj_ptr === -1 && endobj_ptr > -1)) {\r\n            // <id> <generation> obj ... endobj\r\n            //                        ^\r\n            // being somewhere here\r\n            var new_ptr = util_1.Util.locateSequenceReversed(util_1.Util.OBJ, data, ptr);\r\n            return consumeGenerationAndNumberRevere(new_ptr);\r\n        }\r\n        else {\r\n            throw Error(\"Could not correct object start\");\r\n        }\r\n    };\r\n    /**\r\n     * Parses a PDF object and returns a dictionary containing its fields\r\n     * */\r\n    ObjectUtil.extractObject = function (data, xref, objectLookupTable) {\r\n        if (objectLookupTable === void 0) { objectLookupTable = undefined; }\r\n        if (typeof xref !== 'number' && xref.compressed) {\r\n            if (!objectLookupTable)\r\n                throw Error(\"Provide ObjectLookupTable to extract stream object\");\r\n            return ObjectUtil.extractStreamObject(data, xref.id, xref.generation, objectLookupTable[xref.pointer]);\r\n        }\r\n        var ret_obj = {};\r\n        var ptr = typeof xref === 'number' ? xref : xref.pointer;\r\n        var object_id = util_1.Util.extractObjectId(data, ptr);\r\n        if (isNaN(object_id.obj) || isNaN(object_id.generation)) {\r\n            return ObjectUtil.extractObject(data, ObjectUtil.locateObjectStart(data, ptr), objectLookupTable);\r\n        }\r\n        ret_obj.id = object_id;\r\n        ptr = util_1.Util.locateSequence(util_1.Util.OBJ, data, ptr);\r\n        if (ptr === -1)\r\n            throw { message: \"Object missing 'obj' sequence\", name: \"MissingObjSequenceError\" };\r\n        ptr += util_1.Util.OBJ.length;\r\n        var ptr_obj_end = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, ptr);\r\n        data = data.slice(ptr, ptr_obj_end);\r\n        // determine the type of the object:\r\n        var next = util_1.Util.readNextWord(data, 0);\r\n        if (next.result && next.result[0] === util_1.Util.DICT_START[0]) { // object contains a dict\r\n            var result_dict = {};\r\n            ObjectUtil.extractDictValueRec(data, 0, result_dict);\r\n            ret_obj.value = result_dict;\r\n        }\r\n        else if (next.result && next.result[0] === util_1.Util.ARRAY_START[0]) { // object contains an array\r\n            var lst = array_util_1.ArrayUtil.extractArray(data, 0);\r\n            ret_obj.value = lst.result;\r\n        }\r\n        else {\r\n            throw Error(\"Invalid object type - starting with: \".concat(next.result));\r\n        }\r\n        // check if the object has a stream part\r\n        ptr = util_1.Util.locateSequence(util_1.Util.STREAM, data, 0);\r\n        if (-1 !== ptr) {\r\n            // extract stream part\r\n            var ptr_stream_data_start = ptr + util_1.Util.STREAM.length;\r\n            ptr_stream_data_start = util_1.Util.skipDelimiter(data, ptr_stream_data_start);\r\n            var ptr_stream_data_end = ptr_stream_data_start + ret_obj.value[\"/Length\"];\r\n            ret_obj.stream = ObjectUtil.extractStreamData(data.slice(ptr_stream_data_start, ptr_stream_data_end), ret_obj.value[\"/Filter\"], ObjectUtil.translateDecodeParams(ret_obj));\r\n        }\r\n        return ret_obj;\r\n    };\r\n    ObjectUtil.extractStreamObject = function (data, object_id_to_extract, offset, streamObj_xref) {\r\n        var ptr = streamObj_xref.pointer;\r\n        var ret_obj = {};\r\n        // extract object id\r\n        var object_id = util_1.Util.extractObjectId(data, ptr);\r\n        ret_obj.id = object_id;\r\n        ptr = util_1.Util.locateSequence(util_1.Util.OBJ, data, ptr) + util_1.Util.OBJ.length;\r\n        var ptr_obj_end = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, ptr);\r\n        data = data.slice(ptr, ptr_obj_end);\r\n        // extract dict part\r\n        var next = util_1.Util.readNextWord(data, 0);\r\n        if (!next.result || next.result[0] !== util_1.Util.DICT_START[0]) {\r\n            throw Error(\"Invalid stream object -- no dict\");\r\n        }\r\n        var result_dict = {};\r\n        ObjectUtil.extractDictValueRec(data, 0, result_dict);\r\n        ret_obj.value = result_dict;\r\n        if (result_dict[\"/Filter\"] && Array.isArray(result_dict[\"/Filter\"]) && result_dict[\"/Filter\"].length > 0)\r\n            result_dict[\"/Filter\"] = result_dict[\"/Filter\"][0];\r\n        // check if filter is supported\r\n        if (!result_dict[\"/Filter\"] || result_dict[\"/Filter\"] !== \"/FlateDecode\")\r\n            throw Error(\"Unsupported stream filter: \".concat(result_dict[\"/Filter\"], \" - Only supported filter is FlateDecode\"));\r\n        if (!result_dict[\"/Type\"] || result_dict[\"/Type\"] !== \"/ObjStm\")\r\n            throw Error(\"Invalid stream object type: \".concat(result_dict[\"/Type\"]));\r\n        // extract the stream length\r\n        var streamLength = result_dict[\"/Length\"];\r\n        // extract stream part\r\n        var ptr_stream_data_start = util_1.Util.locateSequence(util_1.Util.STREAM, data) + util_1.Util.STREAM.length;\r\n        ptr_stream_data_start = util_1.Util.skipDelimiter(data, ptr_stream_data_start);\r\n        var ptr_stream_data_end = ptr_stream_data_start + streamLength;\r\n        var stream = ObjectUtil.extractStreamData(data.slice(ptr_stream_data_start, ptr_stream_data_end), result_dict[\"/Filter\"], ObjectUtil.translateDecodeParams(result_dict));\r\n        if (!result_dict[\"/N\"])\r\n            throw Error(\"Invalid stream object -- no number of objects specified\");\r\n        if (!result_dict[\"/First\"])\r\n            throw Error(\"Invalid stream object -- no offset to the first objct specified\");\r\n        var streamReferences = ObjectUtil.extractStreamObjectTable(stream, result_dict[\"/N\"], result_dict[\"/First\"]);\r\n        if (!streamReferences[object_id_to_extract])\r\n            throw Error(\"Object \".concat(object_id_to_extract, \" not in stream object\"));\r\n        var result_obj = { id: { obj: object_id_to_extract, generation: 0 } };\r\n        var stream_data = stream.getData();\r\n        next = util_1.Util.readNextWord(stream_data, streamReferences[object_id_to_extract]);\r\n        if (next.result && next.result[0] === util_1.Util.DICT_START[0]) { // object contains a dict\r\n            var value = {};\r\n            result_obj.pointer_stream_end = ObjectUtil.extractDictValueRec(stream_data, streamReferences[object_id_to_extract], value);\r\n            result_obj.value = value;\r\n            result_obj.stream = stream;\r\n            result_obj.pointer_stream_start = streamReferences[object_id_to_extract];\r\n        }\r\n        else if (next.result && next.result[0] === util_1.Util.ARRAY_START[0]) { // object contains an array\r\n            var lst = array_util_1.ArrayUtil.extractArray(stream_data, streamReferences[object_id_to_extract]);\r\n            result_obj.value = lst.result;\r\n            result_obj.stream = stream;\r\n            result_obj.pointer_stream_start = streamReferences[object_id_to_extract];\r\n        }\r\n        else {\r\n            throw Error(\"Invalid stream object type - starting with: \".concat(next.result));\r\n        }\r\n        return result_obj;\r\n    };\r\n    ObjectUtil.translateDecodeParams = function (dict) {\r\n        if (!dict.value)\r\n            return undefined;\r\n        if (!dict.value[\"/DecodeParms\"])\r\n            return undefined;\r\n        if (!dict.value[\"/DecodeParms\"][\"/Columns\"])\r\n            return undefined;\r\n        if (!dict.value[\"/DecodeParms\"][\"/Predictor\"])\r\n            return undefined;\r\n        return { columns: dict.value[\"/DecodeParms\"][\"/Columns\"], predictor: dict.value[\"/DecodeParms\"][\"/Predictor\"] };\r\n    };\r\n    ObjectUtil.extractStreamObjectTable = function (stream, number_of_obj, offset_first_obj) {\r\n        var references = {};\r\n        for (var i = 0; i < number_of_obj; ++i) {\r\n            var obj_id = stream.getNumber();\r\n            var pointer = stream.getNumber() + offset_first_obj;\r\n            references[obj_id] = pointer;\r\n        }\r\n        return references;\r\n    };\r\n    ObjectUtil.extractStreamData = function (streamData, compression, decodeParameters) {\r\n        if (decodeParameters === void 0) { decodeParameters = undefined; }\r\n        var stream = undefined;\r\n        if (compression === '/FlateDecode') {\r\n            stream = new stream_1.FlateStream(streamData, decodeParameters);\r\n        }\r\n        else {\r\n            throw Error(\"Unsupported stream filter: \".concat(compression, \" - Only supported filter is FlateDecode (right now)\"));\r\n        }\r\n        if (!stream)\r\n            throw Error(\"Could not derive stream\");\r\n        return stream;\r\n    };\r\n    ObjectUtil.i = 0;\r\n    return ObjectUtil;\r\n}());\r\nexports.ObjectUtil = ObjectUtil;\r\n","\"use strict\";\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nexports.__esModule = true;\r\nexports.PDFDocumentParser = exports.CryptoInterface = exports.Page = exports.Pages = exports.PageTree = exports.CatalogObject = exports.AnnotationParser = exports.FontParser = exports.AppearanceStreamParser = exports.XObjectParser = exports.ContentStreamParser = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar object_util_1 = require(\"./object-util\");\r\nvar document_history_1 = require(\"./document-history\");\r\nvar crypto_1 = require(\"./crypto\");\r\nvar annotation_types_1 = require(\"./annotations/annotation_types\");\r\nvar text_annotation_1 = require(\"./annotations/text_annotation\");\r\nvar text_markup_annotation_1 = require(\"./annotations/text_markup_annotation\");\r\nvar freetext_annotation_1 = require(\"./annotations/freetext_annotation\");\r\nvar circle_square_annotation_1 = require(\"./annotations/circle_square_annotation\");\r\nvar polygon_polyline_annotation_1 = require(\"./annotations/polygon_polyline_annotation\");\r\nvar ink_annotation_1 = require(\"./annotations/ink_annotation\");\r\nvar content_stream_1 = require(\"./content-stream\");\r\nvar appearance_stream_1 = require(\"./appearance-stream\");\r\nvar fonts_1 = require(\"./fonts\");\r\nvar resources_1 = require(\"./resources\");\r\n/**\r\n * Parses the content stream of an XObject.\r\n * */\r\nvar ContentStreamParser = /** @class */ (function () {\r\n    function ContentStreamParser() {\r\n    }\r\n    ContentStreamParser.extract = function (data) {\r\n        var ret_val = new content_stream_1.ContentStream();\r\n        var grouping_object = [ret_val];\r\n        var index = 0;\r\n        var parameters = [];\r\n        while (index < data.length) {\r\n            var word = util_1.Util.readNextWord(data, index);\r\n            var skipped_index = util_1.Util.skipSymbol(data, util_1.Util.SPACE, word.end_index + 1); // make it robust against traling spaces\r\n            if ((data[skipped_index] === util_1.Util.LF || data[skipped_index] === util_1.Util.COMMENT_START[0]) && word.result !== \"\") {\r\n                var op_name = util_1.Util.convertUnicodeToString(word.result);\r\n                if (op_name === ContentStreamParser.TEXT_OBJECT_START) {\r\n                    grouping_object.push([parameters]);\r\n                }\r\n                else if (op_name === ContentStreamParser.TEXT_OBJECT_END) {\r\n                    var new_ops = grouping_object.pop();\r\n                    var to = new content_stream_1.TextObject();\r\n                    to.parameters = __spreadArray([], new_ops[0], true);\r\n                    to.operators = new_ops.slice(1);\r\n                    if (Array.isArray(grouping_object[grouping_object.length - 1])) {\r\n                        grouping_object[grouping_object.length - 1].push(to);\r\n                    }\r\n                    else {\r\n                        grouping_object[grouping_object.length - 1].addOperator(to);\r\n                    }\r\n                }\r\n                else if (op_name === ContentStreamParser.MARKED_CONTENT_START) {\r\n                    grouping_object.push([parameters]);\r\n                }\r\n                else if (op_name === ContentStreamParser.MARKED_CONTENT_END) {\r\n                    var new_ops = grouping_object.pop();\r\n                    var to = new content_stream_1.MarkedContent();\r\n                    to.parameters = __spreadArray([], new_ops[0], true);\r\n                    to.operators = new_ops.slice(1);\r\n                    if (Array.isArray(grouping_object[grouping_object.length - 1])) {\r\n                        grouping_object[grouping_object.length - 1].push(to);\r\n                    }\r\n                    else {\r\n                        grouping_object[grouping_object.length - 1].addOperator(to);\r\n                    }\r\n                }\r\n                else {\r\n                    if (grouping_object[grouping_object.length - 1] instanceof content_stream_1.ContentStream) {\r\n                        grouping_object[grouping_object.length - 1].addOperator(new content_stream_1.Operator(op_name, __spreadArray([], parameters, true)));\r\n                    }\r\n                    else {\r\n                        grouping_object[grouping_object.length - 1].push(new content_stream_1.Operator(op_name, __spreadArray([], parameters, true)));\r\n                    }\r\n                }\r\n                parameters = [];\r\n                index = word.end_index + 1;\r\n            }\r\n            else {\r\n                if (!word.result) {\r\n                    index = word.end_index + 1;\r\n                }\r\n                else if (word.result[0] === util_1.Util.LITERAL_STRING_START[0]) {\r\n                    var res = util_1.Util.extractString(data, word.start_index);\r\n                    parameters.push(util_1.Util.convertUnicodeToString(res.result));\r\n                    index = res.end_index + 1;\r\n                }\r\n                else if (word.result[0] === util_1.Util.HEX_STRING_START[0]) {\r\n                    var res = util_1.Util.extractHexString(data, word.start_index);\r\n                    parameters.push(res.result);\r\n                    index = res.end_index + 1;\r\n                }\r\n                else if (word.result[0] === 47) {\r\n                    var res = util_1.Util.extractOptionValue(data, word.start_index);\r\n                    parameters.push(\"/\" + res.result);\r\n                    index = res.end_index + 1;\r\n                }\r\n                else if (word.result[0] === util_1.Util.R[0]) {\r\n                    var ref_ptr = { obj: parameters[parameters.length - 2], generation: parameters[parameters.length - 1] };\r\n                    parameters = parameters.slice(0, parameters.length - 2);\r\n                    parameters.push(ref_ptr);\r\n                    index = word.end_index + 1;\r\n                }\r\n                else { // number\r\n                    var res = util_1.Util.extractNumber(data, word.start_index);\r\n                    parameters.push(res.result);\r\n                    index = res.end_index + 1;\r\n                }\r\n            }\r\n        }\r\n        return ret_val;\r\n    };\r\n    ContentStreamParser.TEXT_OBJECT_START = \"BT\";\r\n    ContentStreamParser.TEXT_OBJECT_END = \"ET\";\r\n    ContentStreamParser.MARKED_CONTENT_START = \"BMC\";\r\n    ContentStreamParser.MARKED_CONTENT_END = \"EMC\";\r\n    return ContentStreamParser;\r\n}());\r\nexports.ContentStreamParser = ContentStreamParser;\r\nvar XObjectParser = /** @class */ (function () {\r\n    function XObjectParser() {\r\n    }\r\n    XObjectParser.extract = function (data, xref, objectLookupTable, cryptoInterface) {\r\n        var res = object_util_1.ObjectUtil.extractObject(data, xref, objectLookupTable);\r\n        if (res.value[\"/Type\"] !== \"/XObject\" || res.value[\"/Subtype\"] !== \"/Form\") {\r\n            throw Error(\"Xref {xref} is no valid XObject\");\r\n        }\r\n        var ret_obj = new appearance_stream_1.XObjectObj();\r\n        if (res.value[\"/Name\"])\r\n            ret_obj.name = res.value[\"/Name\"];\r\n        if (res.value[\"/Matrix\"])\r\n            ret_obj.matrix = res.value[\"/Matrix\"];\r\n        if (res.value[\"/FormType\"])\r\n            ret_obj.formType = res.value[\"/FormType\"];\r\n        if (res.value[\"/BBox\"])\r\n            ret_obj.bBox = res.value[\"/BBox\"];\r\n        if (res.value[\"/Resources\"])\r\n            ret_obj.resources = res.value[\"/Resources\"];\r\n        // parse content stream\r\n        if (res.stream && res.stream.data && res.stream.data.length > 0) {\r\n            ret_obj.contentStream = ContentStreamParser.extract(res.stream.data);\r\n        }\r\n        return ret_obj;\r\n    };\r\n    return XObjectParser;\r\n}());\r\nexports.XObjectParser = XObjectParser;\r\n/**\r\n * Parses the appearance stream object. But if it is a reference it will not resolve the object and just provide\r\n * the reference.\r\n * */\r\nvar AppearanceStreamParser = /** @class */ (function () {\r\n    function AppearanceStreamParser() {\r\n    }\r\n    AppearanceStreamParser.parseXObject = function (to_parse) {\r\n        return new appearance_stream_1.XObjectObj();\r\n    };\r\n    AppearanceStreamParser.parseAppearanceStream = function (key, to_parse) {\r\n        if (util_1.Util.isReferencePointer(to_parse[key])) {\r\n            return to_parse[key];\r\n        }\r\n        else if (to_parse[key][\"/Off\"] && to_parse[key][\"/ON\"]) {\r\n            if (util_1.Util.isReferencePointer(to_parse[key][\"/Off\"])) {\r\n                return to_parse[key][\"/Off\"];\r\n            }\r\n            else {\r\n                return AppearanceStreamParser.parseXObject(to_parse[key][\"/Off\"]);\r\n            }\r\n            if (util_1.Util.isReferencePointer(to_parse[key][\"/On\"])) {\r\n                return to_parse[key][\"/On\"];\r\n            }\r\n            else {\r\n                return AppearanceStreamParser.parseXObject(to_parse[key][\"/On\"]);\r\n            }\r\n        }\r\n        else {\r\n            return AppearanceStreamParser.parseXObject(to_parse[key]);\r\n        }\r\n    };\r\n    AppearanceStreamParser.parse = function (annot, to_parse) {\r\n        if (!to_parse[\"/N\"]) {\r\n            throw Error(\"/N flag is required in appearance stream\");\r\n        }\r\n        var appStream = new appearance_stream_1.AppStream(annot);\r\n        appStream.N = AppearanceStreamParser.parseAppearanceStream(\"/N\", to_parse);\r\n        if (to_parse[\"/R\"]) {\r\n            appStream.R = AppearanceStreamParser.parseAppearanceStream(\"/R\", to_parse);\r\n        }\r\n        if (to_parse[\"/D\"]) {\r\n            appStream.D = AppearanceStreamParser.parseAppearanceStream(\"/D\", to_parse);\r\n        }\r\n        return appStream;\r\n    };\r\n    return AppearanceStreamParser;\r\n}());\r\nexports.AppearanceStreamParser = AppearanceStreamParser;\r\n/**\r\n * Parses a font object\r\n * */\r\nvar FontParser = /** @class */ (function () {\r\n    function FontParser() {\r\n    }\r\n    /**\r\n     * Extract the font dictionary\r\n     * */\r\n    FontParser.extract = function (data, xref, objectLookupTable, name) {\r\n        var res = object_util_1.ObjectUtil.extractObject(data, xref, objectLookupTable);\r\n        var ftype = fonts_1.FontType.Type1;\r\n        switch (res.value[\"/Subtype\"]) {\r\n            case \"/Type0\":\r\n                ftype = fonts_1.FontType.Type0;\r\n                break;\r\n            case \"/Type1\":\r\n                ftype = fonts_1.FontType.Type1;\r\n                break;\r\n            case \"/Type3\":\r\n                ftype = fonts_1.FontType.Type3;\r\n                break;\r\n            case \"/MMType1\":\r\n                ftype = fonts_1.FontType.MMType1;\r\n                break;\r\n            case \"/TrueType\":\r\n                ftype = fonts_1.FontType.TrueType;\r\n                break;\r\n            case \"/CIDFontType0\":\r\n                ftype = fonts_1.FontType.CIDFontType0;\r\n                break;\r\n            case \"/CIDFontType2\":\r\n                ftype = fonts_1.FontType.CIDFontType2;\r\n                break;\r\n            default:\r\n                ftype = undefined;\r\n        }\r\n        var font = new fonts_1.Font(ftype, name, res.value[\"/BaseFont\"]);\r\n        return font;\r\n    };\r\n    return FontParser;\r\n}());\r\nexports.FontParser = FontParser;\r\n/**\r\n * Parses an annotation from the document and translates this into the pdfAnnotate datastructure\r\n * */\r\nvar AnnotationParser = /** @class */ (function () {\r\n    function AnnotationParser() {\r\n    }\r\n    /**\r\n     * Extract the annotation object it also assigns the raw data, i.e., potentially unknown/ additional attributes\r\n     * */\r\n    AnnotationParser.extract = function (factory, data, xref, page, objectLookupTable, cryptoInterface) {\r\n        var annot_obj = object_util_1.ObjectUtil.extractObject(data, xref, objectLookupTable);\r\n        annot_obj = annot_obj.value;\r\n        var ret_obj;\r\n        switch (annot_obj[\"/Subtype\"]) {\r\n            case \"/Circle\":\r\n                ret_obj = new circle_square_annotation_1.CircleAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/Square\":\r\n                ret_obj = new circle_square_annotation_1.SquareAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/FreeText\":\r\n                ret_obj = new freetext_annotation_1.FreeTextAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/Ink\":\r\n                ret_obj = new ink_annotation_1.InkAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/PolyLine\":\r\n                ret_obj = new polygon_polyline_annotation_1.PolyLineAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/Polygon\":\r\n                ret_obj = new polygon_polyline_annotation_1.PolygonAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/Text\":\r\n                ret_obj = new text_annotation_1.TextAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/Highlight\":\r\n                ret_obj = new text_markup_annotation_1.HighlightAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/Underline\":\r\n                ret_obj = new text_markup_annotation_1.UnderlineAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/Squiggly\":\r\n                ret_obj = new text_markup_annotation_1.SquigglyAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            case \"/StrikeOut\":\r\n                ret_obj = new text_markup_annotation_1.StrikeOutAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n                break;\r\n            default:\r\n                ret_obj = new annotation_types_1.RawAnnotationObj();\r\n                ret_obj.object_id = { obj: xref.id, generation: xref.generation };\r\n                ret_obj.extract(annot_obj, page, cryptoInterface);\r\n        }\r\n        ret_obj.factory = factory;\r\n        return ret_obj;\r\n    };\r\n    return AnnotationParser;\r\n}());\r\nexports.AnnotationParser = AnnotationParser;\r\n/**\r\n * Represents the Catalog object of the PDF document\r\n * */\r\nvar CatalogObject = /** @class */ (function () {\r\n    /**\r\n     * Extracts the data representing the object.\r\n     * */\r\n    function CatalogObject(data, xref, objectLookupTable) {\r\n        this.data = data;\r\n        this.xref = xref;\r\n        this.objectLookupTable = objectLookupTable;\r\n        this.pagesObjectId = { obj: -1, generation: -1 };\r\n        this.data = data;\r\n        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable).value;\r\n        if (page_obj[\"/Type\"] !== \"/Catalog\")\r\n            throw Error(\"Invalid catalog object at position \".concat(xref.pointer));\r\n        this.pagesObjectId = page_obj[\"/Pages\"];\r\n    }\r\n    CatalogObject.prototype.getPagesObjectId = function () {\r\n        return this.pagesObjectId;\r\n    };\r\n    return CatalogObject;\r\n}());\r\nexports.CatalogObject = CatalogObject;\r\n/**\r\n * Represents the PageTree object of the PDF document\r\n * This is the object with /Type /Pages\r\n * */\r\nvar PageTree = /** @class */ (function () {\r\n    function PageTree(data, objectLookupTable) {\r\n        this.data = data;\r\n        this.objectLookupTable = objectLookupTable;\r\n        this.pageCount = -1;\r\n        /**\r\n         * References to page objects\r\n         * */\r\n        this.pageReferences = [];\r\n        /**\r\n         * References to pages objects\r\n         * */\r\n        this.visitedPages = [];\r\n        this.data = data;\r\n    }\r\n    /**\r\n     * Extracts the kids references recursively.\r\n     * For every kid it checks if the referenced object type is:\r\n     * - a /Pages object then it recursively lookups its children\r\n     * - a /Page object then it adds the references\r\n     * */\r\n    PageTree.prototype.extractPageReferences = function (references) {\r\n        var _loop_1 = function (reference) {\r\n            if (this_1.visitedPages.some(function (el) { return el.obj === reference.obj &&\r\n                el.generation === reference.generation; })) {\r\n                return \"continue\";\r\n            }\r\n            var xref = this_1.objectLookupTable[reference.obj];\r\n            var kid_page_obj = object_util_1.ObjectUtil.extractObject(this_1.data, xref, this_1.objectLookupTable).value;\r\n            if (kid_page_obj[\"/Type\"] === \"/Page\") {\r\n                this_1.pageReferences.push(reference);\r\n            }\r\n            else if (kid_page_obj[\"/Type\"] === \"/Pages\") {\r\n                this_1.visitedPages.push(reference);\r\n                this_1.extractPageReferences(kid_page_obj[\"/Kids\"]);\r\n            }\r\n            else {\r\n                throw Error(\"Invalid object type \".concat(kid_page_obj[\"/Type\"]));\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {\r\n            var reference = references_1[_i];\r\n            _loop_1(reference);\r\n        }\r\n    };\r\n    /**\r\n     * Extract the object data at the given pointer\r\n     * */\r\n    PageTree.prototype.extract = function (xref, objectLookupTable) {\r\n        var page_tree_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable).value;\r\n        if (!page_tree_obj[\"/Kids\"])\r\n            throw Error(\"Could not find index of /Kids in /Pages object\");\r\n        var refs = page_tree_obj[\"/Kids\"];\r\n        this.pageReferences = [];\r\n        this.extractPageReferences(refs);\r\n        this.pageCount = this.pageReferences.length;\r\n    };\r\n    /**\r\n     * Returns the number of pages the page tree comprises\r\n     * */\r\n    PageTree.prototype.getPageCount = function () {\r\n        return this.pageCount;\r\n    };\r\n    /**\r\n     * Returns the reference to the page objects\r\n     * */\r\n    PageTree.prototype.getPageReferences = function () {\r\n        return this.pageReferences;\r\n    };\r\n    /**\r\n     * Returns the references to the pages objects\r\n     * */\r\n    PageTree.prototype.getPagesReferences = function () {\r\n        return this.visitedPages;\r\n    };\r\n    return PageTree;\r\n}());\r\nexports.PageTree = PageTree;\r\n/**\r\n * Represent a pages object in the PDF document\r\n * */\r\nvar Pages = /** @class */ (function () {\r\n    function Pages(data, documentHistory) {\r\n        this.data = data;\r\n        this.documentHistory = documentHistory;\r\n        /**\r\n         * Holds the resource dictionary that might be associated with the object\r\n         * */\r\n        this.resources = undefined;\r\n        this.data = data;\r\n    }\r\n    /**\r\n     * Extracts the page object starting at position ptr\r\n     * */\r\n    Pages.prototype.extract = function (xref, objectLookupTable) {\r\n        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable);\r\n        this.object_id = page_obj.id;\r\n        var resources = page_obj.value[\"/Resources\"];\r\n        if (resources) {\r\n            this.resources = new resources_1.Resource();\r\n            this.resources.associatedWith = this.object_id;\r\n            this.resources.extract(resources);\r\n        }\r\n    };\r\n    return Pages;\r\n}());\r\nexports.Pages = Pages;\r\n/**\r\n * Represents a page object in the PDF document\r\n * */\r\nvar Page = /** @class */ (function () {\r\n    function Page(data, documentHistory) {\r\n        this.data = data;\r\n        this.documentHistory = documentHistory;\r\n        /**\r\n         * Holds the resource dictionary that might be associated with the object\r\n         * */\r\n        this.resources = undefined;\r\n        this.annots = [];\r\n        this.hasAnnotsField = false;\r\n        this.data = data;\r\n    }\r\n    /**\r\n     * Extracts the references in the linked annotations array\r\n     * */\r\n    Page.prototype.extractAnnotationArray = function () {\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        if (!this.annotsPointer)\r\n            throw Error(\"Annotations pointer not set\");\r\n        var ref_annot_table = obj_table[this.annotsPointer.obj];\r\n        var annotations_obj = object_util_1.ObjectUtil.extractObject(this.data, ref_annot_table, obj_table);\r\n        this.annots = annotations_obj.value;\r\n    };\r\n    /**\r\n     * Extracts the page object starting at position ptr\r\n     * */\r\n    Page.prototype.extract = function (xref, objectLookupTable) {\r\n        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, xref, objectLookupTable);\r\n        this.object_id = page_obj.id;\r\n        var annots = page_obj.value[\"/Annots\"];\r\n        if (annots) {\r\n            this.hasAnnotsField = true;\r\n            if (Array.isArray(annots)) {\r\n                this.annots = annots.filter(function (x) { return x !== 'null'; });\r\n            }\r\n            else {\r\n                this.annotsPointer = annots;\r\n                this.extractAnnotationArray();\r\n            }\r\n        }\r\n        var resources = page_obj.value[\"/Resources\"];\r\n        if (resources) {\r\n            this.resources = new resources_1.Resource();\r\n            this.resources.associatedWith = this.object_id;\r\n            this.resources.extract(resources);\r\n        }\r\n    };\r\n    return Page;\r\n}());\r\nexports.Page = Page;\r\n/**\r\n * Provides a configured interface to handle the encryption and decryption of PDFs\r\n * */\r\nvar CryptoInterface = /** @class */ (function () {\r\n    function CryptoInterface(data, documentHistory, ref_ptr, user_pwd, owner_pwd) {\r\n        this.data = data;\r\n        this.documentHistory = documentHistory;\r\n        this.ref_ptr = ref_ptr;\r\n        this.cryptoConfiguration = { version: undefined, revision: undefined, filter: undefined, user_pwd: \"\", owner_pwd: \"\", length: undefined, permissions: undefined, owner_pwd_c: undefined, user_pwd_c: undefined };\r\n        this.cryptoEngine = new crypto_1.IdentityEngine();\r\n        this.data = data;\r\n        this.documentHistory = documentHistory;\r\n        this.cryptoConfiguration.user_pwd = user_pwd ? user_pwd : \"\";\r\n        this.cryptoConfiguration.owner_pwd = owner_pwd ? owner_pwd : \"\";\r\n        if (this.ref_ptr && this.documentHistory) {\r\n            this.extractEncryptionDictionary(this.ref_ptr);\r\n            // setup crypto-engine\r\n            if (this.cryptoConfiguration.version === 1) {\r\n                this.cryptoEngine = new crypto_1.RC4CryptoEngine(this.cryptoConfiguration, this.documentHistory.getRecentUpdate().id, crypto_1.RC4_40_BIT);\r\n            }\r\n            else if (this.cryptoConfiguration.version === 2) {\r\n                this.cryptoEngine = new crypto_1.RC4CryptoEngine(this.cryptoConfiguration, this.documentHistory.getRecentUpdate().id);\r\n            }\r\n            else if (this.cryptoConfiguration.version === 4) {\r\n                console.log(\"Some fancy AES encryption\");\r\n            }\r\n            else {\r\n                throw Error(\"Unsupported Encryption \".concat(this.cryptoConfiguration.version));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the reference pointer\r\n     * */\r\n    CryptoInterface.prototype.getEncryptionDictReference = function () {\r\n        if (!this.ref_ptr)\r\n            return undefined;\r\n        return { obj: this.ref_ptr.id, generation: this.ref_ptr.generation };\r\n    };\r\n    CryptoInterface.prototype.encrypt = function (data, reference) {\r\n        return this.cryptoEngine.encrypt(data, reference);\r\n    };\r\n    CryptoInterface.prototype.decrypt = function (data, reference) {\r\n        return this.cryptoEngine.decrypt(data, reference);\r\n    };\r\n    CryptoInterface.prototype.isUserPasswordCorrect = function () {\r\n        if (!this.cryptoEngine) {\r\n            throw Error(\"Crypto engine not configured\");\r\n        }\r\n        return this.cryptoEngine.isUserPasswordCorrect();\r\n    };\r\n    CryptoInterface.prototype.isOwnerPasswordCorrect = function () {\r\n        if (!this.cryptoEngine) {\r\n            throw Error(\"Crypto engine not configured\");\r\n        }\r\n        return this.cryptoEngine.isOwnerPasswordCorrect();\r\n    };\r\n    /**\r\n     * Extracts the enrcyption dictionary\r\n     * */\r\n    CryptoInterface.prototype.extractEncryptionDictionary = function (ptr) {\r\n        if (!this.documentHistory) {\r\n            throw Error(\"Documenthistory not configured\");\r\n        }\r\n        if (!this.data) {\r\n            throw Error(\"Data not configured\");\r\n        }\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        var page_obj = object_util_1.ObjectUtil.extractObject(this.data, ptr, obj_table);\r\n        this.cryptoConfiguration.version = page_obj.value[\"/V\"];\r\n        this.cryptoConfiguration.revision = page_obj.value[\"/R\"];\r\n        this.cryptoConfiguration.filter = page_obj.value[\"/Filter\"];\r\n        this.cryptoConfiguration.user_pwd_c = page_obj.value[\"/U\"];\r\n        this.cryptoConfiguration.owner_pwd_c = page_obj.value[\"/O\"];\r\n        this.cryptoConfiguration.length = page_obj.value[\"/Length\"];\r\n        this.cryptoConfiguration.permissions = page_obj.value[\"/P\"];\r\n    };\r\n    return CryptoInterface;\r\n}());\r\nexports.CryptoInterface = CryptoInterface;\r\nvar ObjectCache = /** @class */ (function () {\r\n    function ObjectCache() {\r\n        this.cache = {};\r\n    }\r\n    ObjectCache.prototype.set = function (key, value) {\r\n        this.cache[\"\".concat(key.obj, \"_\").concat(key.generation)] = value;\r\n    };\r\n    ObjectCache.prototype.get = function (key, otherwise) {\r\n        if (otherwise === void 0) { otherwise = undefined; }\r\n        return this.cache[\"\".concat(key.obj, \"_\").concat(key.generation)] || otherwise;\r\n    };\r\n    ObjectCache.prototype.has = function (key) {\r\n        return typeof this.cache[\"\".concat(key.obj, \"_\").concat(key.generation)] !== 'undefined';\r\n    };\r\n    return ObjectCache;\r\n}());\r\n/**\r\n * Parses the relevant parts of the PDF document and provides functionality to extract the necessary information for\r\n * adding annotations\r\n * */\r\nvar PDFDocumentParser = /** @class */ (function () {\r\n    /**\r\n     * Parses a PDF document and allows access to the cross reference table and individual PDF objects.\r\n     *\r\n     * Note that this class heavily relies on caching to prevent expensive lookup operations.\r\n     * */\r\n    function PDFDocumentParser(data, userpwd, ownerpwd) {\r\n        if (userpwd === void 0) { userpwd = \"\"; }\r\n        if (ownerpwd === void 0) { ownerpwd = \"\"; }\r\n        this.data = data;\r\n        this.version = undefined;\r\n        this.documentHistory = new document_history_1.DocumentHistory(new Uint8Array([]));\r\n        this.catalogObject = undefined;\r\n        this.pageTree = undefined;\r\n        this.objectCache = new ObjectCache();\r\n        this.cryptoInterface = new CryptoInterface();\r\n        this.fontManager = undefined;\r\n        this.data = new Uint8Array(data);\r\n        this.documentHistory = new document_history_1.DocumentHistory(this.data);\r\n        this.documentHistory.extractDocumentHistory();\r\n        if (this.documentHistory.isEncrypted()) {\r\n            // extract encryption dictionary\r\n            var obj_table = this.documentHistory.createObjectLookupTable();\r\n            var enc_obj = this.documentHistory.getRecentUpdate().encrypt;\r\n            if (!enc_obj)\r\n                throw Error(\"Invalid encryption indication\");\r\n            var enc_obj_ptr = obj_table[enc_obj.obj];\r\n            this.cryptoInterface = new CryptoInterface(this.data, this.documentHistory, enc_obj_ptr, userpwd, ownerpwd);\r\n            // verify keys\r\n            if (!this.cryptoInterface.isUserPasswordCorrect()) {\r\n                if (!this.cryptoInterface.isOwnerPasswordCorrect()) {\r\n                    throw Error(\"No valid user credentials\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the crypto interface\r\n     * */\r\n    PDFDocumentParser.prototype.getCryptoInterface = function () {\r\n        return this.cryptoInterface;\r\n    };\r\n    /**\r\n     * Returns the major and minor version of the pdf document\r\n     * */\r\n    PDFDocumentParser.prototype.getPDFVersion = function () {\r\n        if (this.version)\r\n            return this.version;\r\n        this.version = util_1.Util.extractVersion(this.data, 0);\r\n        return this.version;\r\n    };\r\n    /**\r\n     * Returns a free object id. It first checks wether there can be an freed object id reused. If that is not the case\r\n     * it creates a new one\r\n     * */\r\n    PDFDocumentParser.prototype.getFreeObjectId = function () {\r\n        return this.documentHistory.getFreeObjectId();\r\n    };\r\n    /**\r\n     * Returns the catalog object of the PDF file\r\n     * */\r\n    PDFDocumentParser.prototype.getCatalog = function () {\r\n        var recent_update = this.documentHistory.getRecentUpdate();\r\n        if (recent_update.root) {\r\n            var root_obj = recent_update.root;\r\n            var obj_table = this.documentHistory.createObjectLookupTable();\r\n            return new CatalogObject(this.data, obj_table[root_obj.obj], obj_table);\r\n        }\r\n        else { // If we do not know the catalogue object we need to look it up\r\n            // In cross reference stream objects no /ROOT field is required, however often it is provided anyway\r\n            // otherwise run this routine, but buffer the catalog object\r\n            if (this.catalogObject)\r\n                return this.catalogObject;\r\n            throw Error(\"Does not work for compressed data\");\r\n        }\r\n    };\r\n    /**\r\n     * Returns the latest version of the page tree object of the document\r\n     * */\r\n    PDFDocumentParser.prototype.getPageTree = function () {\r\n        if (this.pageTree)\r\n            return this.pageTree;\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        var catalog_object = this.getCatalog();\r\n        var pages_id = catalog_object.getPagesObjectId();\r\n        var pages_ref = obj_table[pages_id.obj];\r\n        var pageTree = new PageTree(this.data, obj_table);\r\n        pageTree.extract(pages_ref, obj_table);\r\n        this.pageTree = pageTree;\r\n        return pageTree;\r\n    };\r\n    /**\r\n     * Returns the latest version of the page with the given pageNumber\r\n     * */\r\n    PDFDocumentParser.prototype.getPage = function (pageNumber) {\r\n        var pageId = undefined;\r\n        if (typeof pageNumber === 'number') {\r\n            var pageTree = this.getPageTree();\r\n            pageId = pageTree.getPageReferences()[pageNumber];\r\n        }\r\n        else if (util_1.Util.isReferencePointer(pageNumber)) {\r\n            pageId = pageNumber;\r\n        }\r\n        if (!pageId)\r\n            throw Error(\"Could not determine reference pointer from page number\");\r\n        if (this.objectCache.has(pageId)) {\r\n            var cached = this.objectCache.get(pageId);\r\n            if (!(cached instanceof Page))\r\n                throw Error(\"Invalid cached Page object\");\r\n            return cached;\r\n        }\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        var obj_ptr = obj_table[pageId.obj];\r\n        var page = new Page(this.data, this.documentHistory);\r\n        page.extract(obj_ptr, obj_table);\r\n        this.objectCache.set(pageId, page);\r\n        return page;\r\n    };\r\n    /**\r\n     * Returns the pages object with the given reference pointer\r\n     * */\r\n    PDFDocumentParser.prototype.getPages = function (refPtr) {\r\n        if (this.objectCache.has(refPtr)) {\r\n            var cached = this.objectCache.get(refPtr);\r\n            if (!(cached instanceof Pages))\r\n                throw Error(\"Invalid cached Pages object\");\r\n            return cached;\r\n        }\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        var obj_ptr = obj_table[refPtr.obj];\r\n        var page = new Pages(this.data, this.documentHistory);\r\n        page.extract(obj_ptr, obj_table);\r\n        this.objectCache.set(refPtr, page);\r\n        return page;\r\n    };\r\n    /**\r\n     * Returns the annotations that exist in the document\r\n     * */\r\n    PDFDocumentParser.prototype.extractAnnotations = function (factory) {\r\n        var annots = [];\r\n        var pt = this.getPageTree();\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        var pageCount = pt.getPageCount();\r\n        for (var i = 0; i < pageCount; ++i) {\r\n            var page = this.getPage(i);\r\n            var annotationReferences = page.annots;\r\n            var pageAnnots = [];\r\n            for (var _i = 0, annotationReferences_1 = annotationReferences; _i < annotationReferences_1.length; _i++) {\r\n                var refPtr = annotationReferences_1[_i];\r\n                var a = AnnotationParser.extract(factory, this.data, obj_table[refPtr.obj], page, obj_table, this.cryptoInterface);\r\n                a.page = i;\r\n                pageAnnots.push(a);\r\n            }\r\n            annots.push(pageAnnots);\r\n        }\r\n        return annots;\r\n    };\r\n    /**\r\n     * Extracts the fonts, hat are available in the document and setups the font manager\r\n     * */\r\n    PDFDocumentParser.prototype.extractFonts = function () {\r\n        var pageTree = this.getPageTree();\r\n        var pageReferences = pageTree.getPageReferences();\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        if (!this.fontManager) {\r\n            throw Error(\"FontManager not set\");\r\n        }\r\n        for (var _i = 0, pageReferences_1 = pageReferences; _i < pageReferences_1.length; _i++) {\r\n            var reference = pageReferences_1[_i];\r\n            var page = this.getPage(reference);\r\n            if (page.resources) {\r\n                for (var _a = 0, _b = page.resources.font; _a < _b.length; _a++) {\r\n                    var resDef = _b[_a];\r\n                    if (!resDef.refPtr) {\r\n                        throw Error(\"Reference pointer not set in resource definition\");\r\n                    }\r\n                    if (!this.fontManager.hasFont(resDef.refPtr)) {\r\n                        var font = FontParser.extract(this.data, obj_table[resDef.refPtr.obj], obj_table, resDef.name);\r\n                        font.object_id = resDef.refPtr;\r\n                        this.fontManager.addFont(font);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var pagesReferences = pageTree.getPagesReferences();\r\n        for (var _c = 0, pagesReferences_1 = pagesReferences; _c < pagesReferences_1.length; _c++) {\r\n            var reference = pagesReferences_1[_c];\r\n            var pages = this.getPages(reference);\r\n            if (pages.resources) {\r\n                for (var _d = 0, _e = pages.resources.font; _d < _e.length; _d++) {\r\n                    var resDef = _e[_d];\r\n                    if (!resDef.refPtr) {\r\n                        throw Error(\"Reference pointer not set in resource definition\");\r\n                    }\r\n                    if (!this.fontManager.hasFont(resDef.refPtr)) {\r\n                        var font = FontParser.extract(this.data, obj_table[resDef.refPtr.obj], obj_table, resDef.name);\r\n                        font.object_id = resDef.refPtr;\r\n                        this.fontManager.addFont(font);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns the font manager, that manages the available fonts in the document\r\n     * */\r\n    PDFDocumentParser.prototype.getFonts = function () {\r\n        if (this.fontManager)\r\n            return this.fontManager;\r\n        this.fontManager = new fonts_1.FontManager(this);\r\n        this.extractFonts();\r\n        return this.fontManager;\r\n    };\r\n    /**\r\n     * Extracts the XObject with the provided reference pointer\r\n     * */\r\n    PDFDocumentParser.prototype.extractXObject = function (p) {\r\n        var obj_table = this.documentHistory.createObjectLookupTable();\r\n        return XObjectParser.extract(this.data, obj_table[p.obj], obj_table, this.cryptoInterface);\r\n    };\r\n    return PDFDocumentParser;\r\n}());\r\nexports.PDFDocumentParser = PDFDocumentParser;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nexports.Resource = void 0;\r\nvar writer_util_1 = require(\"./writer-util\");\r\nvar util_1 = require(\"./util\");\r\nvar Resource = /** @class */ (function () {\r\n    function Resource() {\r\n        this.object_id = undefined;\r\n        this.new_object = false; // indicates to the factory that this object must be created when writing the document\r\n        /**\r\n         * Hoelds the reference pointer of the object to which the resource dictionary is related\r\n         * */\r\n        this.associatedWith = undefined;\r\n        this.extGState = [];\r\n        this.colorSpace = [];\r\n        this.pattern = [];\r\n        this.shading = [];\r\n        this.xObject = [];\r\n        this.font = [];\r\n        this.procSet = [];\r\n        this.properties = [];\r\n    }\r\n    Resource.prototype.containsResourceDef = function (def, list) {\r\n        return list.filter(function (d) { return d.name === def.name && def.refPtr && d.refPtr && def.refPtr.obj === d.refPtr.obj && def.refPtr.generation === d.refPtr.generation; }).length > 0;\r\n    };\r\n    Resource.prototype.addGStateDef = function (def) {\r\n        if (!this.containsResourceDef(def, this.extGState)) {\r\n            this.extGState.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.addColorSpaceDef = function (def) {\r\n        if (!this.containsResourceDef(def, this.colorSpace)) {\r\n            this.colorSpace.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.addPatternDef = function (def) {\r\n        if (!this.containsResourceDef(def, this.pattern)) {\r\n            this.pattern.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.addShadingDef = function (def) {\r\n        if (!this.containsResourceDef(def, this.shading)) {\r\n            this.shading.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.addXObjectDef = function (def) {\r\n        if (!this.containsResourceDef(def, this.xObject)) {\r\n            this.xObject.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.addFontDef = function (def) {\r\n        if (!this.containsResourceDef(def, this.font)) {\r\n            this.font.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.addProcSetDef = function (def) {\r\n        if (!this.containsResourceDef(def, this.procSet)) {\r\n            this.procSet.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.addProperty = function (def) {\r\n        if (!this.containsResourceDef(def, this.properties)) {\r\n            this.properties.push(def);\r\n        }\r\n    };\r\n    Resource.prototype.writeDictAttribute = function (defs) {\r\n        var ret_val = [];\r\n        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_START);\r\n        ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {\r\n            var def = defs_1[_i];\r\n            def.name = def.name.trim();\r\n            if (def.name.charAt(0) !== \"/\")\r\n                def.name = \"/\".concat(def.name);\r\n            ret_val = ret_val.concat(util_1.Util.convertStringToAscii(def.name));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            if (!def.refPtr)\r\n                throw Error(\"Missing reference pointer in resource definition\");\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.writeReferencePointer(def.refPtr, true));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_END);\r\n        return ret_val;\r\n    };\r\n    Resource.prototype.writeArrayAttribute = function (defs) {\r\n        var ret_val = [];\r\n        ret_val = ret_val.concat(writer_util_1.WriterUtil.ARRAY_START);\r\n        for (var _i = 0, defs_2 = defs; _i < defs_2.length; _i++) {\r\n            var def = defs_2[_i];\r\n            def.name = def.name.trim();\r\n            if (def.name.charAt(0) !== \"/\")\r\n                def.name = \"/\".concat(def.name);\r\n            ret_val = ret_val.concat(util_1.Util.convertStringToAscii(def.name));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret_val = ret_val.concat(writer_util_1.WriterUtil.ARRAY_END);\r\n        return ret_val;\r\n    };\r\n    Resource.prototype.writeResource = function () {\r\n        var ret_val = [];\r\n        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_START);\r\n        ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.extGState.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.EXTGSTATE);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeDictAttribute(this.extGState));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.colorSpace.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.COLORSPACE);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeDictAttribute(this.colorSpace));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.pattern.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.PATTERN);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeDictAttribute(this.pattern));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.shading.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.SHADING);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeDictAttribute(this.shading));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.xObject.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.XOBJECT);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeDictAttribute(this.xObject));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.font.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.FONT);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeDictAttribute(this.font));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.procSet.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.PROCSET);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeArrayAttribute(this.procSet));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        if (this.properties.length > 0) {\r\n            ret_val = ret_val.concat(writer_util_1.WriterUtil.PROPERTIES);\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n            ret_val = ret_val.concat(this.writeDictAttribute(this.properties));\r\n            ret_val.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret_val = ret_val.concat(writer_util_1.WriterUtil.DICT_END);\r\n        return ret_val;\r\n    };\r\n    /**\r\n     * Extract the resource mappings from a dictionary\r\n     * */\r\n    Resource.prototype.extract = function (value) {\r\n        if (value[\"/ExtGState\"]) {\r\n            for (var _i = 0, _a = Object.keys(value[\"/ExtGState\"]); _i < _a.length; _i++) {\r\n                var key = _a[_i];\r\n                this.addGStateDef({ name: key, refPtr: value[\"/ExtGState\"][key] });\r\n            }\r\n        }\r\n        if (value[\"/ColorSpace\"]) {\r\n            for (var _b = 0, _c = Object.keys(value[\"/ColorSpace\"]); _b < _c.length; _b++) {\r\n                var key = _c[_b];\r\n                this.addColorSpaceDef({ name: key, refPtr: value[\"/ColorSpace\"][key] });\r\n            }\r\n        }\r\n        if (value[\"/Pattern\"]) {\r\n            for (var _d = 0, _e = Object.keys(value[\"/Pattern\"]); _d < _e.length; _d++) {\r\n                var key = _e[_d];\r\n                this.addPatternDef({ name: key, refPtr: value[\"/Pattern\"][key] });\r\n            }\r\n        }\r\n        if (value[\"/Shading\"]) {\r\n            for (var _f = 0, _g = Object.keys(value[\"/Shading\"]); _f < _g.length; _f++) {\r\n                var key = _g[_f];\r\n                this.addShadingDef({ name: key, refPtr: value[\"/Shading\"][key] });\r\n            }\r\n        }\r\n        if (value[\"/XObject\"]) {\r\n            for (var _h = 0, _j = Object.keys(value[\"/XObject\"]); _h < _j.length; _h++) {\r\n                var key = _j[_h];\r\n                this.addXObjectDef({ name: key, refPtr: value[\"/XObject\"][key] });\r\n            }\r\n        }\r\n        if (value[\"/Font\"]) {\r\n            for (var _k = 0, _l = Object.keys(value[\"/Font\"]); _k < _l.length; _k++) {\r\n                var key = _l[_k];\r\n                this.addFontDef({ name: key, refPtr: value[\"/Font\"][key] });\r\n            }\r\n        }\r\n        if (value[\"/ProcSet\"]) {\r\n            for (var _m = 0, _o = Object.keys(value[\"/ProcSet\"]); _m < _o.length; _m++) {\r\n                var key = _o[_m];\r\n                this.addProcSetDef({ name: key, refPtr: value[\"/ProcSet\"][key] });\r\n            }\r\n        }\r\n        if (value[\"/Properties\"]) {\r\n            for (var _p = 0, _q = Object.keys(value[\"/Properties\"]); _p < _q.length; _p++) {\r\n                var key = _q[_p];\r\n                this.addProperty({ name: key, refPtr: value[\"/Properties\"][key] });\r\n            }\r\n        }\r\n    };\r\n    return Resource;\r\n}());\r\nexports.Resource = Resource;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.FlateStream = exports.Stream = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar Pako = require(\"pako\");\r\nvar Stream = /** @class */ (function () {\r\n    function Stream(data) {\r\n        this.data = data;\r\n        this._ptr = 0;\r\n    }\r\n    Stream.prototype.getData = function () {\r\n        return this.data;\r\n    };\r\n    /**\r\n     * Returns the data encoded\r\n     * */\r\n    Stream.prototype.encode = function () {\r\n        throw Error(\"abstract method\");\r\n    };\r\n    Stream.prototype.getLength = function () {\r\n        return this.data.length;\r\n    };\r\n    Stream.prototype.peekNBytes = function (n, ptr) {\r\n        if (n === void 0) { n = 1; }\r\n        if (ptr === void 0) { ptr = 0; }\r\n        return this.data.slice(ptr, ptr + n);\r\n    };\r\n    Stream.prototype.peekNBytesAsNumber = function (n, ptr) {\r\n        if (n === void 0) { n = 1; }\r\n        if (ptr === void 0) { ptr = 0; }\r\n        var res = 0;\r\n        for (var i = 0; i < n; ++i) {\r\n            res += (this.data[i + ptr] << 8 * (n - i - 1));\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * reads the next 'n' bytes of position 'ptr' and returns its content as a number\r\n     * */\r\n    Stream.prototype.getNBytesAsNumber = function (n) {\r\n        if (n === void 0) { n = 1; }\r\n        var res = this.peekNBytesAsNumber(n, this._ptr);\r\n        this._ptr += n;\r\n        return res;\r\n    };\r\n    /**\r\n     * Reads the next byte from the stream\r\n     * */\r\n    Stream.prototype.getByte = function () {\r\n        return this.data[this._ptr++];\r\n    };\r\n    /**\r\n     * Skips spaces and than adds as many bytes to the number until another space is reached\r\n     * */\r\n    Stream.prototype.getNumber = function () {\r\n        var nbr = util_1.Util.extractNumber(this.data, this._ptr);\r\n        this._ptr = nbr.end_index + 1;\r\n        return nbr.result;\r\n    };\r\n    return Stream;\r\n}());\r\nexports.Stream = Stream;\r\nvar FlateStream = /** @class */ (function (_super) {\r\n    __extends(FlateStream, _super);\r\n    /**\r\n     * rawData : if true, the provided data is not compressed yet.\r\n     * */\r\n    function FlateStream(data, decodeParameters, rawData, cryptoInterface, object_id) {\r\n        if (decodeParameters === void 0) { decodeParameters = undefined; }\r\n        if (rawData === void 0) { rawData = false; }\r\n        if (cryptoInterface === void 0) { cryptoInterface = undefined; }\r\n        if (object_id === void 0) { object_id = undefined; }\r\n        var _this = _super.call(this, data) || this;\r\n        _this.data = data;\r\n        _this.decodeParameters = decodeParameters;\r\n        _this.rawData = rawData;\r\n        _this.cryptoInterface = cryptoInterface;\r\n        _this.object_id = object_id;\r\n        if (_this.data.length > 0 && !rawData) {\r\n            _this.data = Pako.inflate(data);\r\n        }\r\n        if (decodeParameters && !rawData) {\r\n            _this.data = _this.applyDecoding(_this.data, decodeParameters);\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns the data encoded\r\n     * */\r\n    FlateStream.prototype.encode = function () {\r\n        if (!this.data || this.data.length === 0)\r\n            return new Uint8Array();\r\n        var int_data = this.data;\r\n        if (this.decodeParameters && this.rawData) {\r\n            int_data = this.applyEncoding(int_data, this.decodeParameters);\r\n        }\r\n        var compressed_data = Pako.deflate(int_data);\r\n        if (this.cryptoInterface && this.object_id) {\r\n            return this.cryptoInterface.encrypt(compressed_data, this.object_id);\r\n        }\r\n        return compressed_data;\r\n    };\r\n    FlateStream.prototype.applyEncoding = function (data, decodeParameters) {\r\n        if (decodeParameters.predictor >= 10) {\r\n            return this.encodePNGFilter(data, decodeParameters);\r\n        }\r\n        else if (decodeParameters.predictor === 2) {\r\n            throw Error(\"Unsupported filter -- file feature request\");\r\n        }\r\n        return data;\r\n    };\r\n    FlateStream.prototype.applyDecoding = function (data, decodeParameters) {\r\n        if (decodeParameters.predictor >= 10) {\r\n            return this.decodePNGFilter(data, decodeParameters);\r\n        }\r\n        else if (decodeParameters.predictor === 2) {\r\n            throw Error(\"Unsupported filter -- file feature request\");\r\n        }\r\n        return data;\r\n    };\r\n    /**\r\n     * Applies PNG filter for encoding the data stream\r\n     * */\r\n    FlateStream.prototype.encodePNGFilter = function (data, decodeParameters) {\r\n        if (data.length % (decodeParameters.columns) !== 0)\r\n            throw Error(\"Invalid decode parameters\");\r\n        if ((typeof decodeParameters.encoding == 'undefined') || decodeParameters.encoding < 0 || decodeParameters.encoding > 4)\r\n            throw Error(\"Invalid PNG filter encoding\");\r\n        var total_columns = decodeParameters.columns;\r\n        var encoded_data = [];\r\n        var encoding = 0;\r\n        var offset = 0;\r\n        var index_upper_value = 0;\r\n        var upper_value = 0;\r\n        var left_value = 0;\r\n        var left_upper_value = 0;\r\n        for (var i = 0; i < data.length; ++i) {\r\n            if (i % total_columns === 0) {\r\n                encoded_data.push(decodeParameters.encoding);\r\n            }\r\n            switch (decodeParameters.encoding) {\r\n                case 0:\r\n                    encoded_data.push(data[i]);\r\n                    break;\r\n                case 1:\r\n                    offset = Math.floor(i / total_columns) * total_columns;\r\n                    encoded_data.push(((i % total_columns) === 0) ? data[(i % total_columns) + offset] : (data[(i % total_columns) + offset] - data[(i % total_columns) + offset - 1]) % 256);\r\n                    break;\r\n                case 2:\r\n                    index_upper_value = i - total_columns;\r\n                    upper_value = (index_upper_value < 0) ? 0 : data[index_upper_value];\r\n                    encoded_data.push((data[i] - upper_value) % 256);\r\n                    break;\r\n                case 3:\r\n                    index_upper_value = i - total_columns;\r\n                    upper_value = (index_upper_value < 0) ? 0 : data[index_upper_value];\r\n                    left_value = ((i % total_columns) - 1 < 0) ? 0 : data[i - 1];\r\n                    encoded_data.push((data[i] - Math.floor((upper_value + left_value) / 2)) % 256);\r\n                    break;\r\n                case 4: // Paeth -- uses three neighbouring bytes (left, upper and upper left) to compute a linear function\r\n                    index_upper_value = i - total_columns;\r\n                    upper_value = (index_upper_value < 0) ? 0 : data[index_upper_value];\r\n                    left_value = ((i % total_columns) - 1 < 0) ? 0 : data[i - 1];\r\n                    left_upper_value = (index_upper_value - 1 < 0) ? 0 : data[index_upper_value - 1];\r\n                    encoded_data.push((data[i] - this.paethPredictor(left_value, upper_value, left_upper_value)) % 256);\r\n                    break;\r\n                default:\r\n                    throw Error(\"Invalid PNG filter encoding\");\r\n            }\r\n        }\r\n        return new Uint8Array(encoded_data);\r\n    };\r\n    /**\r\n     * Applies PNG Filter for decoding the data stream\r\n     * */\r\n    FlateStream.prototype.decodePNGFilter = function (data, decodeParameters) {\r\n        if (data.length % (decodeParameters.columns + 1) !== 0)\r\n            throw Error(\"Invalid decode parameters\");\r\n        var total_columns = decodeParameters.columns + 1;\r\n        var unfiltered_data = [];\r\n        var encoding = 0;\r\n        for (var i = 0; i < data.length; ++i) {\r\n            var left_value = 0;\r\n            var upper_value = 0;\r\n            var index_upper_value = 0;\r\n            var left_upper_value = 0;\r\n            if (i % total_columns === 0) {\r\n                encoding = data[i];\r\n            }\r\n            else {\r\n                switch (encoding) {\r\n                    case 0: // no encoding\r\n                        unfiltered_data.push(data[i]);\r\n                        break;\r\n                    case 1: // Sub filter -- the difference of the current pixel and the pixel before\r\n                        // add the left already decoded pixel and 0 at the start of a row\r\n                        left_value = ((i % total_columns) - 2 < 0) ? 0 : unfiltered_data[((i - 2) % decodeParameters.columns) + Math.floor(i / total_columns) * (decodeParameters.columns - 1)];\r\n                        unfiltered_data.push((data[i] + left_value) % 256);\r\n                        break;\r\n                    case 2: // Up filter -- the difference of the current prixel and the pixel above\r\n                        index_upper_value = i - (total_columns + Math.floor(i / total_columns));\r\n                        upper_value = (index_upper_value < 0) ? 0 : unfiltered_data[index_upper_value];\r\n                        unfiltered_data.push((data[i] + upper_value) % 256);\r\n                        break;\r\n                    case 3: // Average filter -- considers the average of the upper and the left pixel\r\n                        index_upper_value = i - (total_columns + Math.floor(i / total_columns));\r\n                        upper_value = (index_upper_value < 0) ? 0 : unfiltered_data[index_upper_value];\r\n                        left_value = ((i % total_columns) - 2 < 0) ? 0 : unfiltered_data[((i - 2) % decodeParameters.columns) + Math.floor(i / total_columns) * (decodeParameters.columns - 1)];\r\n                        unfiltered_data.push((data[i] + Math.floor((upper_value + left_value) / 2)) % 256);\r\n                        break;\r\n                    case 4: // Paeth -- uses three neighbouring bytes (left, upper and upper left) to compute a linear function\r\n                        index_upper_value = i - (total_columns + Math.floor(i / total_columns));\r\n                        upper_value = (index_upper_value < 0) ? 0 : unfiltered_data[index_upper_value];\r\n                        left_value = ((i % total_columns) - 2 < 0) ? 0 : unfiltered_data[((i - 2) % decodeParameters.columns) + Math.floor(i / total_columns) * (decodeParameters.columns - 1)];\r\n                        left_upper_value = (index_upper_value - 1 < 0) ? 0 : unfiltered_data[index_upper_value - 1];\r\n                        unfiltered_data.push((data[i] + this.paethPredictor(left_value, upper_value, left_upper_value)) % 256);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return new Uint8Array(unfiltered_data);\r\n    };\r\n    /**\r\n     * Computes the path predictor of the given bytes\r\n     * */\r\n    FlateStream.prototype.paethPredictor = function (left_byte, upper_byte, upper_left_byte) {\r\n        var p = left_byte + upper_byte - upper_left_byte;\r\n        var pa = Math.abs(p - left_byte);\r\n        var pb = Math.abs(p - upper_byte);\r\n        var pc = Math.abs(p - upper_left_byte);\r\n        if (pa <= pb && pa <= pc) {\r\n            return left_byte;\r\n        }\r\n        else if (pb <= pc) {\r\n            return upper_byte;\r\n        }\r\n        else {\r\n            return upper_left_byte;\r\n        }\r\n    };\r\n    return FlateStream;\r\n}(Stream));\r\nexports.FlateStream = FlateStream;\r\n","\"use strict\";\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nexports.__esModule = true;\r\nexports.Util = void 0;\r\n/**\r\n * This class provides methods to navigate through the byte array representing the PDF document\r\n * */\r\nvar Util = /** @class */ (function () {\r\n    function Util() {\r\n    }\r\n    /**\r\n     * Extracts the version information of a PDF file\r\n     * */\r\n    Util.extractVersion = function (data, index) {\r\n        if (index === void 0) { index = 0; }\r\n        var ptr_version_start = Util.locateSequence(Util.VERSION, data, index) + Util.VERSION.length;\r\n        var ptr_delimiter = Util.locateSequence([Util.DOT], data, ptr_version_start);\r\n        var major_version = Util.extractNumber(data, ptr_version_start, ptr_delimiter).result;\r\n        var ptr_end = Util.locateDelimiter(data, ptr_delimiter);\r\n        var minor_version = Util.extractNumber(data, ptr_delimiter + 1, ptr_end).result;\r\n        return { major: major_version, minor: minor_version };\r\n    };\r\n    /**\r\n     * Consumes comments that is\r\n     *  '%.................. EOL'\r\n     *\r\n     *  Also handles mulitple line comments\r\n     * */\r\n    Util.consumeComment = function (data, index) {\r\n        while (data[index] !== 13 && data[index] != 10 && index < data.length)\r\n            ++index;\r\n        index = Util.skipSpaces(data, index);\r\n        if (data[index] == 37) //%\r\n            return Util.consumeComment(data, index);\r\n        return index;\r\n    };\r\n    /**\r\n     * Returns the next word. These are bytes that are not separated by a delimiter and a ptr to the position where the word ends\r\n     * It ignores/skips comments.\r\n     * */\r\n    Util.readNextWord = function (data, index) {\r\n        if (index === void 0) { index = 0; }\r\n        if (index >= data.length) {\r\n            return { result: undefined, start_index: index, end_index: data.length - 1 };\r\n        }\r\n        index = Util.skipSpaces(data, index);\r\n        if (data[index] === 37) { //%\r\n            index = Util.consumeComment(data, index);\r\n        }\r\n        var start_index = index;\r\n        index++;\r\n        while (!Util.isDelimiter(data[index]) && index < data.length)\r\n            ++index;\r\n        if (index <= data.length)\r\n            return { result: data.slice(start_index, index), start_index: start_index, end_index: index - 1 };\r\n        return { result: undefined, start_index: start_index, end_index: index - 1 };\r\n    };\r\n    /**\r\n     * Assumes that at position index is a delimiter and than runs as long forward until it finds\r\n     * another delimiter or reaches the end of the document\r\n     * */\r\n    Util.skipDelimiter = function (data, index) {\r\n        if (index === void 0) { index = 0; }\r\n        while (index < data.length && this.isDelimiter(data[index]))\r\n            ++index;\r\n        return index;\r\n    };\r\n    /**\r\n     * Skips only spaces\r\n     * */\r\n    Util.skipSpaces = function (data, index) {\r\n        if (index === void 0) { index = 0; }\r\n        while (index < data.length && (data[index] === 10 || data[index] === 9 || data[index] === 13 || data[index] === 32))\r\n            ++index;\r\n        return index;\r\n    };\r\n    /**\r\n     * Skips the symbol specified by _symbol\r\n     * */\r\n    Util.skipSymbol = function (data, _symbol, index) {\r\n        if (index === void 0) { index = 0; }\r\n        while (index < data.length && (data[index] === _symbol))\r\n            ++index;\r\n        return index;\r\n    };\r\n    /**\r\n     * Skips only spaces\r\n     * */\r\n    Util.skipSpacesReverse = function (data, index) {\r\n        if (index === void 0) { index = 0; }\r\n        while (index > 0 && (data[index] === 10 || data[index] === 9 || data[index] === 13 || data[index] === 32))\r\n            --index;\r\n        return index;\r\n    };\r\n    /**\r\n     * Assumes that at position index is a delimiter and than runs as long backwards until it finds\r\n     * another delimiter or reaches the end of the document\r\n     * */\r\n    Util.skipDelimiterReverse = function (data, index) {\r\n        if (index === void 0) { index = 0; }\r\n        while (index > 0 && this.isDelimiter(data[index]))\r\n            --index;\r\n        return index;\r\n    };\r\n    /**\r\n     * Transforms a string into an array of the corresponding ascii values\r\n     * */\r\n    Util.convertStringToAscii = function (toConvert) {\r\n        var asciis = [];\r\n        for (var i = 0; i < toConvert.length; ++i) {\r\n            asciis.push(+toConvert.charCodeAt(i));\r\n        }\r\n        return asciis;\r\n    };\r\n    Util.isSpace = function (value) {\r\n        return value === Util.LF ||\r\n            value === Util.CR ||\r\n            value === Util.SPACE;\r\n    };\r\n    Util.isDelimiter = function (value) {\r\n        return Util.isSpace(value) ||\r\n            value === 47 || // /\r\n            value === 37 || // %\r\n            value === 60 || // <\r\n            value === 62 || // >\r\n            value === 91 || // [\r\n            value === 93 || // ]\r\n            value === 40 || // (\r\n            value === 41; // )\r\n    };\r\n    Util.isNumber = function (value) {\r\n        return value >= 48 && value <= 57; // 0 <= value <=  9\r\n    };\r\n    /**\r\n     * Search the sequence in data starting at the offset\r\n     *\r\n     * Set the 'closed' flag to check if the suceeding char after the sequence is a line feed (10), a carriage return (13), the end\r\n     * of the whole sequence or a space (32)\r\n     * */\r\n    Util.locateSequence = function (sequence, data, offset, closed) {\r\n        if (offset === void 0) { offset = 0; }\r\n        if (closed === void 0) { closed = false; }\r\n        var i = offset;\r\n        for (var j = 0; i < data.length; ++i) {\r\n            if (data[i] == sequence[j]) {\r\n                if (j == sequence.length - 1) {\r\n                    if (!closed || data.length == i + 1 || this.isDelimiter(data[i + 1])) {\r\n                        return i - (sequence.length - 1);\r\n                    }\r\n                    else {\r\n                        j = -1;\r\n                    }\r\n                }\r\n                ++j;\r\n            }\r\n            else {\r\n                j = 0;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n    /**\r\n     * Search the sequence in data starting at the offset in reverse direction\r\n     *\r\n     * Set the 'closed' flag to check if the preceding char before the sequence is a line feed (10), a carriage return (13), the start\r\n     * of the whole data sequence or a space (32)\r\n     * */\r\n    Util.locateSequenceReversed = function (sequence, data, offset, closed) {\r\n        if (offset === void 0) { offset = data.length - 1; }\r\n        if (closed === void 0) { closed = false; }\r\n        var i = offset;\r\n        for (var j = sequence.length - 1; i >= 0; --i) {\r\n            if (data[i] == sequence[j]) {\r\n                if (j == 0) {\r\n                    if (!closed || i - 1 < 0 || this.isDelimiter(data[i - 1])) {\r\n                        return i;\r\n                    }\r\n                    else {\r\n                        j = sequence.length;\r\n                    }\r\n                }\r\n                --j;\r\n            }\r\n            else {\r\n                j = sequence.length - 1;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n    /**\r\n     * Locates the index before the next delimiter. Delimiters can be a line feed (10), a carriage return (13), the end of the whole sequence\r\n     * or a space (32)\r\n     * */\r\n    Util.locateDelimiter = function (data, offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        while (offset < data.length && !this.isDelimiter(data[offset]))\r\n            ++offset;\r\n        return offset - 1;\r\n    };\r\n    /**\r\n     * Locates the index after the last delimiter. Delimiters can be a line feed (10), a carriage return (13), the end of the whole sequence\r\n     * or a space (32)\r\n     * */\r\n    Util.locateDelimiterReversed = function (data, offset) {\r\n        if (offset === void 0) { offset = data.length - 1; }\r\n        while (offset > 0 && !this.isDelimiter(data[offset]))\r\n            --offset;\r\n        if (offset <= 0)\r\n            return offset;\r\n        return offset - 1;\r\n    };\r\n    /**\r\n     * Extract an object identifier\r\n     * <ID> <GEN> obj\r\n     * */\r\n    Util.extractObjectId = function (data, index) {\r\n        index = Util.skipDelimiter(data, index);\r\n        var end_obj_ptr = Util.locateDelimiter(data, index + 1);\r\n        var obj = Util.extractNumber(data, index, end_obj_ptr).result;\r\n        var start_gen_ptr = Util.skipDelimiter(data, end_obj_ptr + 1);\r\n        var end_gen_ptr = Util.locateDelimiter(data, start_gen_ptr + 1);\r\n        var gen = Util.extractNumber(data, start_gen_ptr, end_gen_ptr).result;\r\n        return { obj: obj, generation: gen };\r\n    };\r\n    /**\r\n     * Extract the reference starting at position 'index'\r\n     * */\r\n    Util.extractReference = function (data, index) {\r\n        index = Util.skipDelimiter(data, index);\r\n        var r_index = this.locateSequence(this.convertStringToAscii(\" R\"), data, index, true);\r\n        return data.slice(index, r_index);\r\n    };\r\n    /**\r\n     * Returns a reference as typed object\r\n     * */\r\n    Util.extractReferenceTyped = function (data, index) {\r\n        var ref_data = this.extractReference(data, index);\r\n        var del_index = this.locateDelimiter(ref_data, 0);\r\n        var id = this.extractNumber(ref_data, 0, del_index).result;\r\n        var gen = this.extractNumber(ref_data, del_index + 2).result;\r\n        return { result: { obj: id, generation: gen }, start_index: index, end_index: index + ref_data.length + 1 }; // + _R\r\n    };\r\n    /**\r\n     * Extracts a string in Hex notation <...>\r\n     * */\r\n    Util.extractHexString = function (data, index) {\r\n        var string_start = Util.locateSequence(Util.HEX_STRING_START, data, index);\r\n        var string_end = Util.locateSequence(Util.HEX_STRING_END, data, index);\r\n        data = data.slice(string_start + 1, string_end);\r\n        return { result: new Uint8Array(Util.convertHexStringToByteArray(data)), start_index: string_start, end_index: string_end };\r\n    };\r\n    /**\r\n     * Extratcs a string (...)\r\n     * */\r\n    Util.extractString = function (data, index) {\r\n        var string_start = Util.locateSequence(Util.LITERAL_STRING_START, data, index);\r\n        var string_end = Util.locateSequence(Util.LITERAL_STRING_END, data, index);\r\n        while (data[string_end - 1] === 92) { // \"\\\" escape\r\n            string_end = Util.locateSequence(Util.LITERAL_STRING_END, data, string_end + 1);\r\n        }\r\n        data = data.slice(string_start + 1, string_end);\r\n        return { result: Util.unescapeString(data), start_index: string_start, end_index: string_end };\r\n    };\r\n    /**\r\n     * Returns the value of an option\r\n     * /<option>\r\n     *\r\n     * so for instance for /Highlight it would return 'Highlight'\r\n     *\r\n     * The index must point to the \"/\"\r\n     * */\r\n    Util.extractOptionValue = function (data, index) {\r\n        if (index === void 0) { index = 0; }\r\n        if (data[index] !== 47)\r\n            throw Error(\"misplaced option value pointer\");\r\n        var end = Util.locateDelimiter(data, index + 1);\r\n        return { result: Util.convertAsciiToString(Array.from(data.slice(index + 1, end + 1))), start_index: index, end_index: end };\r\n    };\r\n    /**\r\n     * Parses the ascii encoded number of the PDF file\r\n     * */\r\n    Util.extractNumber = function (data, start, end) {\r\n        if (end === void 0) { end = -1; }\r\n        start = Util.skipDelimiter(data, start);\r\n        if (-1 == end) {\r\n            end = Util.locateDelimiter(data, start);\r\n        }\r\n        if (end < start) {\r\n            throw Error(\"Could not identify number bounds: [\".concat(start, \",\").concat(end, \"]\"));\r\n        }\r\n        var str_id = \"\";\r\n        for (var i = start; i <= end; ++i) {\r\n            str_id += String.fromCharCode(data[i]);\r\n        }\r\n        if (\"\" === str_id) {\r\n            throw Error(\"Could not parse number at position \".concat(start));\r\n        }\r\n        return { result: +str_id, start_index: start, end_index: end };\r\n    };\r\n    /**\r\n     * Converts the given date into PDF formatting\r\n     * */\r\n    Util.convertDateToPDFDate = function (date) {\r\n        var date_str = \"D:\";\r\n        date_str += date.getFullYear();\r\n        var month = String(date.getMonth() + 1);\r\n        date_str += (month.length == 1 ? \"0\" : \"\") + month;\r\n        var day = String(date.getDate());\r\n        date_str += (day.length == 1 ? \"0\" : \"\") + day;\r\n        var hours = String(date.getHours());\r\n        date_str += (hours.length == 1 ? \"0\" : \"\") + hours;\r\n        var minutes = String(date.getMinutes());\r\n        date_str += (minutes.length == 1 ? \"0\" : \"\") + minutes;\r\n        var seconds = String(date.getSeconds());\r\n        date_str += (seconds.length == 1 ? \"0\" : \"\") + seconds;\r\n        return date_str;\r\n    };\r\n    /**\r\n     * Converts a unicode sequence into a string\r\n     * */\r\n    Util.convertUnicodeToString = function (val) {\r\n        if (val instanceof Uint8Array)\r\n            val = new Uint8Array(val);\r\n        if (val[0] === 254 && val[1] === 255) {\r\n            val = val.slice(2, val.length);\r\n            var uintToString = function (uintArray) {\r\n                var ret = \"\";\r\n                for (var i = 0; i < uintArray.length - 1; i += 2) {\r\n                    ret += String.fromCharCode((uintArray[i] << 8) | uintArray[i + 1] & 0xFF);\r\n                }\r\n                return ret;\r\n            };\r\n            var ret_1 = uintToString(val);\r\n            return ret_1;\r\n        }\r\n        // handle utf-8 compression\r\n        var Utf8ArrayToStr = function (array) {\r\n            var ret = \"\";\r\n            var i = 0;\r\n            while (i < array.length) {\r\n                var char1 = array[i++];\r\n                var char2 = void 0;\r\n                switch (char1 >> 4) {\r\n                    case 0:\r\n                    case 1:\r\n                    case 2:\r\n                    case 3:\r\n                    case 4:\r\n                    case 5:\r\n                    case 6:\r\n                    case 7:\r\n                        // one byte\r\n                        ret += String.fromCharCode(char1);\r\n                        break;\r\n                    case 12:\r\n                    case 13:\r\n                        // two byte sequence\r\n                        char2 = array[i++];\r\n                        ret += String.fromCharCode(((char1 & 0x1F) << 6) | (char2 & 0x3F));\r\n                        break;\r\n                    case 14:\r\n                        // three byte sequence\r\n                        char2 = array[i++];\r\n                        var char3 = array[i++];\r\n                        ret += String.fromCharCode(((char1 & 0x0F) << 12) |\r\n                            ((char2 & 0x3F) << 6) |\r\n                            ((char3 & 0x3F) << 0));\r\n                        break;\r\n                }\r\n            }\r\n            return ret;\r\n        };\r\n        var ret = Utf8ArrayToStr(Array.from(val));\r\n        return ret;\r\n    };\r\n    Util.convertAsciiToString = function (val) {\r\n        var ret = \"\";\r\n        for (var i = 0; i < val.length; ++i) {\r\n            ret += String.fromCharCode(val[i]);\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * takes a number and returns an array of its char representations\r\n     * */\r\n    Util.convertNumberToCharArray = function (nbr) {\r\n        return Util.convertStringToAscii(String(nbr));\r\n    };\r\n    /**\r\n     * Converts a hex string into a byte array\r\n     * That means two consecutive hex values are merged into one byte that is appended to the array\r\n     * */\r\n    Util.convertHexStringToByteArray = function (hex_string) {\r\n        var ret_val = [];\r\n        if (typeof hex_string !== \"string\") {\r\n            hex_string = Util.convertAsciiToString(hex_string);\r\n        }\r\n        for (var i = 0; i < hex_string.length - 1; i += 2) {\r\n            ret_val.push((parseInt(hex_string.charAt(i), 16) << 4) + parseInt(hex_string.charAt(i + 1), 16));\r\n        }\r\n        if (hex_string.length % 2 !== 0) {\r\n            ret_val.push(parseInt(hex_string.charAt(hex_string.length - 1), 16));\r\n        }\r\n        return ret_val;\r\n    };\r\n    /**\r\n     * Converts an array of byte values into a hex string\r\n     * */\r\n    Util.convertByteArrayToHexString = function (values) {\r\n        var ret_val = \"\";\r\n        var HEX_VALUES = \"0123456789ABCDEF\";\r\n        for (var i_1 = 0; i_1 < values.length; ++i_1) {\r\n            ret_val += HEX_VALUES.charAt(values[i_1] >> 4);\r\n            ret_val += HEX_VALUES.charAt(values[i_1] & 15);\r\n        }\r\n        // remove leading zeros\r\n        var i = 0;\r\n        while ('0' === ret_val.charAt(i) && i < ret_val.length)\r\n            ++i;\r\n        return ret_val.slice(i, ret_val.length);\r\n    };\r\n    /**\r\n     * takes two arrays and checks their equality\r\n     * */\r\n    Util.areArraysEqual = function (array_one, array_two) {\r\n        if (array_one.length !== array_two.length)\r\n            return false;\r\n        for (var i = 0; i < array_one.length; ++i) {\r\n            if (array_one[i] !== array_two[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Prints the array with leading indexes 10 bytes in a row\r\n     * Delimiter are substituted by '.'\r\n     * */\r\n    Util.debug_printIndexed = function (array) {\r\n        var outp = \"\";\r\n        for (var i = 0; i < array.length; ++i) {\r\n            if (i % 10 === 0) {\r\n                outp += \"\\n\" + i + \":\";\r\n            }\r\n            if (Util.isSpace(array[i]))\r\n                outp += \" .\";\r\n            else\r\n                outp += \" \" + String.fromCharCode(array[i]);\r\n        }\r\n        console.log(outp);\r\n    };\r\n    /**\r\n     * Converts a list of 8 bit integers into a list of 32 bit integers\r\n     * */\r\n    Util.convertUint8ArrayToInt32Array = function (a) {\r\n        var ret_val = new Int32Array(Math.ceil(a.length / 4));\r\n        var i = 0;\r\n        var index = 0;\r\n        while (i < a.length) {\r\n            if (a[i] > 255 || a[i + 1] > 255 || a[i + 2] >> 255 || a[i + 3] > 255)\r\n                throw Error(\"Invalid byte size\");\r\n            ret_val[index++] = (a[i++] << 24) + (a[i++] << 16) + (a[i++] << 8) + (a[i++] << 0);\r\n        }\r\n        return ret_val;\r\n    };\r\n    /**\r\n     * Converts a list of 32 bit integers into a list of 8 bit UNSIGNED integers\r\n     * */\r\n    Util.convertInt32ArrayToUint8Array = function (a) {\r\n        var ret_val = new Uint8Array(a.length * 4);\r\n        for (var i = 0; i < a.length; ++i) {\r\n            for (var j = 0; j < 4; ++j) {\r\n                ret_val[i * 4 + j] = (a[i] >> 8 * (4 - j - 1)) & 0xFF;\r\n            }\r\n        }\r\n        return ret_val;\r\n    };\r\n    /**\r\n     * Adds escape symbols to specific elements of the provided string\r\n     *\r\n     * Symbols that needs to be escaped are: \\ ) (\r\n     * */\r\n    Util.escapeString = function (array) {\r\n        var ret_val = [];\r\n        for (var i = 0; i < array.length; ++i) {\r\n            switch (array[i]) {\r\n                case Util.LITERAL_STRING_START[0]:\r\n                case Util.LITERAL_STRING_END[0]:\r\n                case 92: // 92 = '\\'\r\n                    ret_val.push(92);\r\n                    ret_val.push(array[i]);\r\n                    break;\r\n                case 9: // 9 = TAB\r\n                    ret_val.push(92);\r\n                    ret_val.push(116); // \\t\r\n                    break;\r\n                case 10: // 10 = LINE FEED\r\n                    ret_val.push(92);\r\n                    ret_val.push(110); // \\n\r\n                    break;\r\n                case 13: // 13 = CARRIAGE RETURN\r\n                    ret_val.push(92);\r\n                    ret_val.push(114); // \\r\r\n                    break;\r\n                case 8: // 8 = BACKSPACE\r\n                    ret_val.push(92);\r\n                    ret_val.push(98); // \\b\r\n                    break;\r\n                case 12: // 255 = FORM FEED\r\n                    ret_val.push(92);\r\n                    ret_val.push(102); // \\f\r\n                    break;\r\n                default:\r\n                    ret_val.push(array[i]);\r\n            }\r\n        }\r\n        return new Uint8Array(ret_val);\r\n    };\r\n    /**\r\n     * Removes escape symbols from the given string\r\n     *\r\n     * Symbols that needs to be escaped are: \\ ) (\r\n     * */\r\n    Util.unescapeString = function (array) {\r\n        var ret_val = [];\r\n        var in_escape = false;\r\n        for (var i = 0; i < array.length; ++i) {\r\n            if (in_escape) {\r\n                in_escape = false;\r\n                switch (array[i]) {\r\n                    case 92: // \\\r\n                        ret_val.push(92);\r\n                        break;\r\n                    case Util.LITERAL_STRING_START[0]:\r\n                        ret_val.push(Util.LITERAL_STRING_START[0]);\r\n                        break;\r\n                    case Util.LITERAL_STRING_END[0]:\r\n                        ret_val.push(Util.LITERAL_STRING_END[0]);\r\n                        break;\r\n                    case 116: // \\t\r\n                        ret_val.push(9);\r\n                        break;\r\n                    case 110: // \\n\r\n                        ret_val.push(10);\r\n                        break;\r\n                    case 114: // \\r\r\n                        ret_val.push(13);\r\n                        break;\r\n                    case 98: // \\b\r\n                        ret_val.push(8);\r\n                        break;\r\n                    case 102: // \\f\r\n                        ret_val.push(12);\r\n                        break;\r\n                    default:\r\n                        ret_val.push(array[i]);\r\n                }\r\n            }\r\n            else {\r\n                if (array[i] === 92) {\r\n                    in_escape = true;\r\n                }\r\n                else {\r\n                    ret_val.push(array[i]);\r\n                }\r\n            }\r\n        }\r\n        return new Uint8Array(ret_val);\r\n    };\r\n    /**\r\n     * Returns true, if the object corresponds to the interface of a reference pointer.\r\n     * */\r\n    Util.isReferencePointer = function (obj) {\r\n        return (\"obj\" in obj && \"generation\" in obj && Object.keys(obj).length == 2);\r\n    };\r\n    /**\r\n     * If color is provided in range [0,1) it will map these values in the color range [0, 255]\r\n     * */\r\n    Util.colorToRange255 = function (color) {\r\n        if (color.r <= 1) {\r\n            color.r = Math.round(color.r * 255);\r\n        }\r\n        if (color.g <= 1) {\r\n            color.g = Math.round(color.g * 255);\r\n        }\r\n        if (color.b <= 1) {\r\n            color.b = Math.round(color.b * 255);\r\n        }\r\n        return color;\r\n    };\r\n    /**\r\n     * If color is provided in range [0,255] it will map these values in the color range [0, 1]\r\n     * */\r\n    Util.colorToRange01 = function (color) {\r\n        if (color.r > 1) {\r\n            color.r = +(color.r / 255).toFixed(3);\r\n        }\r\n        if (color.g > 1) {\r\n            color.g = +(color.g / 255).toFixed(3);\r\n        }\r\n        if (color.b > 1) {\r\n            color.b = +(color.b / 255).toFixed(3);\r\n        }\r\n        return color;\r\n    };\r\n    /**\r\n     * Returns the HTML color hex code of the provided color\r\n     * */\r\n    Util.colorToHex = function (color) {\r\n        if (color.r <= 1 || color.g <= 1 || color.b <= 1) {\r\n            color = Util.colorToRange255(color);\r\n        }\r\n        var r = color.r.toString(16);\r\n        r = r.length === 1 ? \"0\" + r : r;\r\n        var g = color.g.toString(16);\r\n        g = g.length === 1 ? \"0\" + g : g;\r\n        var b = color.b.toString(16);\r\n        b = b.length === 1 ? \"0\" + b : b;\r\n        return \"#\".concat(r.toUpperCase()).concat(g.toUpperCase()).concat(b.toUpperCase());\r\n    };\r\n    /**\r\n     * Converts a string into a byte string / hex string <12AFA3>\r\n     * */\r\n    Util.convertStringToByteString = function (value) {\r\n        var ret_value = __spreadArray([], Util.HEX_STRING_START, true);\r\n        var hex_val = Util.convertByteArrayToHexString(Util.convertStringToAscii(value));\r\n        ret_value = ret_value.concat(Util.convertStringToAscii(hex_val));\r\n        ret_value = ret_value.concat(Util.HEX_STRING_END);\r\n        return ret_value;\r\n    };\r\n    /**\r\n     * Converts a string into a byte string / hex string <12AFA3>\r\n     * */\r\n    Util.convertStringToHexString = function (value) {\r\n        return Util.convertStringToByteString(value);\r\n    };\r\n    Util.VERSION = [37, 80, 68, 70, 45]; // %PDF-\r\n    Util.COMMENT_START = [37]; // '%'\r\n    Util.NULL = [110, 117, 108, 108]; // null\r\n    Util.DOT = 46;\r\n    Util.CR = 13;\r\n    Util.LF = 10;\r\n    Util.TYPE = \"/Type \";\r\n    Util.SPACE = 32;\r\n    Util.OBJ = [111, 98, 106]; // 'obj'\r\n    Util.ENDOBJ = [101, 110, 100, 111, 98, 106]; // 'endobj'\r\n    Util.ARRAY_START = [91]; // '['\r\n    Util.ARRAY_END = [93]; // ']'\r\n    Util.LITERAL_STRING_START = [40]; // '('\r\n    Util.HEX_STRING_START = [60]; // '<'\r\n    Util.LITERAL_STRING_END = [41]; // ')'\r\n    Util.HEX_STRING_END = [62]; // '>'\r\n    Util.R = [82]; // 'R'\r\n    Util.ANNOTS = [47, 65, 110, 110, 111, 116, 115]; // '/Annot'\r\n    Util.DICT_START = [60, 60]; // '<<'\r\n    Util.DICT_END = [62, 62]; // '>>'\r\n    Util.PAGE = [47, 80, 97, 103, 101];\r\n    Util.SIZE = [47, 83, 105, 122, 101]; // /Size\r\n    Util.ROOT = [47, 82, 111, 111, 116]; // /Root\r\n    Util.PREV = [47, 80, 114, 101, 118]; // /Prev\r\n    Util.STARTXREF = [115, 116, 97, 114, 116, 120, 114, 101, 102]; // = 'startxref'\r\n    Util.XREF = [120, 114, 101, 102]; // = 'xref'\r\n    Util.STREAM = [115, 116, 114, 101, 97, 109]; // = 'stream'\r\n    Util.TRAILER = [116, 114, 97, 105, 108, 101, 114]; // = 'trailer'\r\n    return Util;\r\n}());\r\nexports.Util = Util;\r\n","\"use strict\";\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nexports.__esModule = true;\r\nexports.WriterUtil = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar stream_1 = require(\"./stream\");\r\nvar WriterUtil = /** @class */ (function () {\r\n    function WriterUtil() {\r\n    }\r\n    /**\r\n     * Writes a reference pointer\r\n     *\r\n     * <obj_id> <generation> R\r\n     *\r\n     * The 'R' and the preceding space is only written in case 'referenced' is true\r\n     * */\r\n    WriterUtil.writeReferencePointer = function (ref, referenced) {\r\n        if (referenced === void 0) { referenced = false; }\r\n        var ret = util_1.Util.convertNumberToCharArray(ref.obj);\r\n        ret.push(util_1.Util.SPACE);\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(ref.generation));\r\n        if (referenced) {\r\n            ret.push(util_1.Util.SPACE);\r\n            ret.push.apply(ret, util_1.Util.R);\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Adds preceding zeros (0) in front of the 'value' to match the length\r\n     * */\r\n    WriterUtil.pad = function (length, value) {\r\n        value = String(value);\r\n        var ret = [];\r\n        for (var i = 0; i < length - value.length; ++i) {\r\n            ret.push(48);\r\n        }\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(value));\r\n        return ret;\r\n    };\r\n    /**\r\n     * Writes a nested number array\r\n     * */\r\n    WriterUtil.writeNestedNumberArray = function (array) {\r\n        var ret = __spreadArray([], util_1.Util.ARRAY_START, true);\r\n        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n            var subArray = array_1[_i];\r\n            ret = ret.concat(WriterUtil.writeNumberArray(subArray));\r\n            ret.push(util_1.Util.SPACE);\r\n        }\r\n        ret.push.apply(ret, util_1.Util.ARRAY_END);\r\n        return ret;\r\n    };\r\n    /**\r\n     * Writes a javascript number array to a PDF number array\r\n     * */\r\n    WriterUtil.writeNumberArray = function (array) {\r\n        var ret = __spreadArray([], util_1.Util.ARRAY_START, true);\r\n        for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {\r\n            var i = array_2[_i];\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(i));\r\n            ret.push(util_1.Util.SPACE);\r\n        }\r\n        ret.push.apply(ret, util_1.Util.ARRAY_END);\r\n        return ret;\r\n    };\r\n    /**\r\n     * Replaces the /Annots field in an page object\r\n     *\r\n     * ptr : Pointer to the page object\r\n     * annot_array_reference : The reference to the annotation array\r\n     * */\r\n    WriterUtil.replaceAnnotsFieldInPageObject = function (data, page, page_ptr, annot_array_reference) {\r\n        var ptr_objend = util_1.Util.locateSequence(util_1.Util.ENDOBJ, data, page_ptr, true);\r\n        var complete_page_object_data = data.slice(page_ptr, ptr_objend + util_1.Util.ENDOBJ.length);\r\n        var ret = [];\r\n        if (page.hasAnnotsField) {\r\n            // in this case the page object directly contains an array of references and\r\n            // does not point to an array array object -- we replace the array of references with a pointer\r\n            // to the reference array\r\n            var ptr_annots = util_1.Util.locateSequence(util_1.Util.ANNOTS, complete_page_object_data, 0, true);\r\n            ret = Array.from(complete_page_object_data.slice(0, ptr_annots + util_1.Util.ANNOTS.length));\r\n            ret.push(util_1.Util.SPACE);\r\n            ret = ret.concat(WriterUtil.writeReferencePointer(annot_array_reference, true));\r\n            ret.push(util_1.Util.SPACE);\r\n            var ptr_annots_array_end = util_1.Util.locateSequence(util_1.Util.ARRAY_END, complete_page_object_data, ptr_annots, true) + util_1.Util.ARRAY_END.length;\r\n            ret = ret.concat(Array.from(complete_page_object_data.slice(ptr_annots_array_end, complete_page_object_data.length)));\r\n        }\r\n        else {\r\n            var ptr_dict_end = util_1.Util.locateSequenceReversed(util_1.Util.DICT_END, complete_page_object_data, complete_page_object_data.length - 1);\r\n            if (-1 === ptr_dict_end)\r\n                throw Error(\"Could not identify dictionary end\");\r\n            ret = Array.from(complete_page_object_data.slice(0, ptr_dict_end));\r\n            ret = ret.concat(util_1.Util.ANNOTS);\r\n            ret.push(util_1.Util.SPACE);\r\n            ret = ret.concat(WriterUtil.writeReferencePointer(annot_array_reference, true));\r\n            ret.push(util_1.Util.SPACE);\r\n            ret = ret.concat(Array.from(complete_page_object_data.slice(ptr_dict_end, complete_page_object_data.length)));\r\n        }\r\n        ret.push(util_1.Util.CR);\r\n        ret.push(util_1.Util.LF);\r\n        return ret;\r\n    };\r\n    /**\r\n     * Writes the given object as stream object. Handels all the necessary stuff\r\n     * object_id: The reference pointer id and generation\r\n     * dict: dictionary fields that must be added to the stream object. Must be already encoded in bytes\r\n     * stream: The stream content. Note, that the stream output will be only compressed if you provide a stream object. Number arrays will be processed unaltered.\r\n     * */\r\n    WriterUtil.writeStreamObject = function (object_id, dict, stream) {\r\n        var streamData = stream;\r\n        var compressed = false;\r\n        if (stream instanceof stream_1.Stream) {\r\n            streamData = Array.from(stream.encode());\r\n            compressed = true;\r\n        }\r\n        var ret = WriterUtil.writeReferencePointer(object_id);\r\n        ret.push(WriterUtil.SPACE);\r\n        ret = ret.concat(WriterUtil.OBJ);\r\n        ret.push(WriterUtil.CR);\r\n        ret.push(WriterUtil.LF);\r\n        ret = ret.concat(WriterUtil.DICT_START);\r\n        ret.push(WriterUtil.SPACE);\r\n        if (compressed) {\r\n            ret = ret.concat(WriterUtil.FILTER);\r\n            ret.push(WriterUtil.SPACE);\r\n            ret = ret.concat(WriterUtil.FLATEDECODE);\r\n            ret.push(WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(WriterUtil.LENGTH);\r\n        ret.push(WriterUtil.SPACE);\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(streamData.length));\r\n        ret.push(WriterUtil.SPACE);\r\n        ret = ret.concat(dict);\r\n        ret = ret.concat(WriterUtil.DICT_END);\r\n        ret = ret.concat(WriterUtil.STREAM);\r\n        ret.push(WriterUtil.CR);\r\n        ret.push(WriterUtil.LF);\r\n        ret = ret.concat(streamData);\r\n        ret.push(WriterUtil.CR);\r\n        ret.push(WriterUtil.LF);\r\n        ret = ret.concat(WriterUtil.ENDSTREAM);\r\n        ret.push(WriterUtil.CR);\r\n        ret.push(WriterUtil.LF);\r\n        ret = ret.concat(WriterUtil.ENDOBJ);\r\n        ret.push(WriterUtil.CR);\r\n        ret.push(WriterUtil.LF);\r\n        return ret;\r\n    };\r\n    WriterUtil.N = 110;\r\n    WriterUtil.F = 102;\r\n    WriterUtil.q = 113;\r\n    WriterUtil.Q = 81;\r\n    WriterUtil.BT = [66, 84]; // = 'BT'\r\n    WriterUtil.ET = [69, 84]; // = 'ET'\r\n    WriterUtil.BMC = [66, 77, 67]; // = 'BMC'\r\n    WriterUtil.EMC = [69, 77, 67]; // = 'EMC'\r\n    WriterUtil.AP_N = [47, 78]; // = '/N'\r\n    WriterUtil.AP_D = [47, 68]; // = '/D'\r\n    WriterUtil.AP_R = [47, 82]; // = '/R'\r\n    WriterUtil.SPACE = 32;\r\n    WriterUtil.CR = 13;\r\n    WriterUtil.LF = 10;\r\n    WriterUtil.AP = [47, 65, 80]; // = '/AP'\r\n    WriterUtil.OBJ = [111, 98, 106];\r\n    WriterUtil.ENDOBJ = [101, 110, 100, 111, 98, 106];\r\n    WriterUtil.ENCRYPT = [47, 69, 110, 99, 114, 121, 112, 116];\r\n    WriterUtil.ARRAY_START = 91;\r\n    WriterUtil.OPEN = [47, 79, 112, 101, 110];\r\n    WriterUtil.ARRAY_END = 93;\r\n    WriterUtil.DICT_START = [60, 60];\r\n    WriterUtil.HEX_STRING_START = [60];\r\n    WriterUtil.HEX_STRING_END = [62];\r\n    WriterUtil.DICT_END = [62, 62];\r\n    WriterUtil.TYPE0 = [47, 84, 121, 112, 101, 48]; // /Type0\r\n    WriterUtil.TYPE1 = [47, 84, 121, 112, 101, 49]; // /Type1\r\n    WriterUtil.TYPE3 = [47, 84, 121, 112, 101, 51]; // /Type3\r\n    WriterUtil.MMTYPE1 = [47, 77, 77, 84, 121, 112, 101, 49]; // /MMType1\r\n    WriterUtil.TRUETYPE = [47, 84, 114, 117, 101, 84, 121, 112, 101]; // /TrueType\r\n    WriterUtil.CIDFONTTYPE0 = [47, 67, 73, 68, 70, 111, 110, 116, 84, 121, 112, 101, 48]; // /CIDFontType0\r\n    WriterUtil.CIDFONTTYPE2 = [47, 67, 73, 68, 70, 111, 110, 116, 84, 121, 112, 101, 50]; // /CIDFontType2\r\n    WriterUtil.TYPE_ANNOT = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 65, 110, 110, 111, 116];\r\n    WriterUtil.TYPE_XOBJECT = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 88, 79, 98, 106, 101, 99, 116];\r\n    WriterUtil.TYPE_EXTGSTATE = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 69, 120, 116, 71, 83, 116, 97, 116, 101];\r\n    WriterUtil.TYPE_FONTDESCRIPTOR = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 70, 111, 110, 116, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114];\r\n    WriterUtil.TYPE_FONT = [47, 84, 121, 112, 101, WriterUtil.SPACE, 47, 70, 111, 110, 116];\r\n    WriterUtil.FONTNAME = [47, 70, 111, 110, 116, 78, 97, 109, 101]; // = '/FontName'\r\n    WriterUtil.FONTFAMILY = [47, 70, 111, 110, 116, 70, 97, 109, 105, 108, 121]; // = '/FontFamily'\r\n    WriterUtil.FONTSTRETCH = [47, 70, 111, 110, 116, 83, 116, 114, 101, 116, 99, 104]; // = '/FontStretch'\r\n    WriterUtil.FLAGS = [47, 70, 108, 97, 103, 115]; // = '/Flags'\r\n    WriterUtil.FONTBBOX = [47, 70, 111, 110, 116, 66, 66, 111, 120]; // = '/FontBBox'\r\n    WriterUtil.ITALICANGLE = [47, 73, 116, 97, 108, 105, 99, 65, 110, 103, 108, 101]; // = '/ItalicAngle'\r\n    WriterUtil.ASCENT = [47, 65, 115, 99, 101, 110, 116]; // = '/Ascent'\r\n    WriterUtil.DESCENT = [47, 68, 101, 115, 99, 101, 110, 116]; // = '/Descent'\r\n    WriterUtil.LEADING = [47, 76, 101, 97, 100, 105, 110, 103]; // = '/Leading'\r\n    WriterUtil.CAPHEIGHT = [47, 67, 97, 112, 72, 101, 105, 103, 104, 116]; // = '/CapHeight'\r\n    WriterUtil.XHEIGHT = [47, 88, 72, 101, 105, 103, 104, 116]; // = '/XHeight'\r\n    WriterUtil.STEMV = [47, 83, 116, 101, 109, 86]; // = '/StemV'\r\n    WriterUtil.ENCODING = [47, 69, 110, 99, 111, 100, 105, 110, 103]; // = '/Encoding'\r\n    WriterUtil.STEMH = [47, 83, 116, 101, 109, 2]; // = '/StemH'\r\n    WriterUtil.AVGWIDTH = [47, 65, 118, 103, 87, 105, 100, 116, 104]; // = '/AvgWidth'\r\n    WriterUtil.MAXWIDTH = [47, 77, 97, 120, 87, 105, 100, 116, 104]; // = '/MaxWidth'\r\n    WriterUtil.MISSINGWIDTH = [47, 77, 105, 115, 115, 105, 110, 103, 87, 105, 100, 116, 104]; // = '/MissingWidth'\r\n    WriterUtil.FIRSTCHAR = [47, 70, 105, 114, 115, 116, 67, 104, 97, 114]; // = '/FirstChar'\r\n    WriterUtil.LASTCHAR = [47, 76, 97, 115, 116, 67, 104, 97, 114]; // = '/LastChar'\r\n    WriterUtil.BASEFONT = [47, 66, 97, 115, 101, 70, 111, 110, 116]; // = '/BaseFont'\r\n    WriterUtil.WIDTHS = [47, 87, 105, 100, 116, 104, 115]; // = '/Widths'\r\n    WriterUtil.FONTDESCRIPTOR = [47, 70, 111, 110, 116, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114]; // = '/FontDescriptor'\r\n    WriterUtil.XOBJECT = [47, 88, 79, 98, 106, 101, 99, 116]; // = '/XObject'\r\n    WriterUtil.EXTGSTATE = [47, 69, 120, 116, 71, 83, 116, 97, 116, 101]; // = '/ExtGState'\r\n    WriterUtil.COLORSPACE = [47, 67, 111, 108, 111, 114, 83, 112, 97, 99, 101]; // = '/ColorSpace'\r\n    WriterUtil.PATTERN = [47, 80, 97, 116, 116, 101, 114, 110]; // = '/Pattern'\r\n    WriterUtil.SHADING = [47, 83, 104, 97, 100, 105, 110, 103]; // = '/Shading'\r\n    WriterUtil.FONT = [47, 70, 111, 110, 116]; // = '/Font'\r\n    WriterUtil.PROCSET = [47, 80, 114, 111, 99, 83, 101, 116]; // = '/ProcSet'\r\n    WriterUtil.PROPERTIES = [47, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115]; // = '/Properties'\r\n    WriterUtil.RECT = [47, 82, 101, 99, 116];\r\n    WriterUtil.RESOURCES = [47, 82, 101, 115, 111, 117, 114, 99, 101, 115]; // = '/Resources'\r\n    WriterUtil.SUBTYPE = [47, 83, 117, 98, 116, 121, 112, 101];\r\n    WriterUtil.FORM = [47, 70, 111, 114, 109]; // = '/Form'\r\n    WriterUtil.UPDATE_DATE = [47, 77]; // = '/M'\r\n    WriterUtil.AUTHOR = [47, 84]; // = '/T'\r\n    WriterUtil.CONTENTS = [47, 67, 111, 110, 116, 101, 110, 116, 115]; // = '/Contents'\r\n    WriterUtil.BRACKET_START = 40;\r\n    WriterUtil.BRACKET_END = 41;\r\n    WriterUtil.FLAG = [47, 70]; // = '/F'\r\n    WriterUtil.ID = [47, 78, 77]; // = '/NM'\r\n    WriterUtil.DOCUMENT_ID = [47, 73, 68]; // = '/ID'\r\n    WriterUtil.COLOR = [47, 67]; // = '/C'\r\n    WriterUtil.FILL = [47, 73, 67]; // = '/IC'\r\n    WriterUtil.STATE = [47, 83, 116, 97, 116, 101]; // = '/State'\r\n    WriterUtil.STATEMODEL = [47, 83, 116, 97, 116, 101, 77, 111, 100, 101, 108]; // = '/StateModel'\r\n    WriterUtil.OPACITY = [47, 67, 65]; // = '/CA'\r\n    WriterUtil._OPACITY = [47, 99, 97]; // = '/ca'\r\n    WriterUtil.BORDER = [47, 66, 111, 114, 100, 101, 114]; // = '/Border'\r\n    WriterUtil.PAGE_REFERENCE = [47, 80]; // = '/P'\r\n    WriterUtil.DEFAULT_APPEARANCE = [47, 68, 65]; // = '/DA'\r\n    WriterUtil.INKLIST = [47, 73, 110, 107, 76, 105, 115, 116]; // = '/InkList'\r\n    WriterUtil.FILTER = [47, 70, 105, 108, 116, 101, 114]; // = '/Filter'\r\n    WriterUtil.FLATEDECODE = [47, 70, 108, 97, 116, 101, 68, 101, 99, 111, 100, 101]; // = '/FlateDecode'\r\n    WriterUtil.LENGTH = [47, 76, 101, 110, 103, 116, 104]; // = '/Length'\r\n    WriterUtil.STREAM = [115, 116, 114, 101, 97, 109]; // = 'stream'\r\n    WriterUtil.ENDSTREAM = [101, 110, 100, 115, 116, 114, 101, 97, 109]; // = 'endstream'\r\n    WriterUtil.FORMTYPE = [47, 70, 111, 114, 109, 84, 121, 112, 101]; // = '/FormType'\r\n    WriterUtil.MATRIX = [47, 77, 97, 116, 114, 105, 120]; // = '/Matrix'\r\n    WriterUtil.BBOX = [47, 66, 66, 111, 120]; // = '/BBox'\r\n    WriterUtil.RC = [47, 82, 67]; // = '/RC'\r\n    WriterUtil.CREATION_DATE = [47, 67, 114, 101, 97, 116, 105, 111, 110, 68, 97, 116, 101]; // = '/CreationDate'\r\n    WriterUtil.SUBJ = [47, 83, 117, 98, 106]; // = '/Subj'\r\n    WriterUtil.TRAILER = [116, 114, 97, 105, 108, 101, 114]; // = 'trailer'\r\n    WriterUtil.SIZE = [47, 83, 105, 122, 101]; // = '/Size'\r\n    WriterUtil.ROOT = [47, 82, 111, 111, 116]; // = '/Root'\r\n    WriterUtil.PREV = [47, 80, 114, 101, 118]; // ='/Prev'\r\n    WriterUtil.STARTXREF = [115, 116, 97, 114, 116, 120, 114, 101, 102]; // = 'startxref'\r\n    WriterUtil.EOF = [37, 37, 69, 79, 70]; // = '%%EOF'\r\n    WriterUtil.TRUE = [116, 114, 117, 101]; // = 'true'\r\n    WriterUtil.XREF = [120, 114, 101, 102]; // = 'xref'\r\n    WriterUtil.TEXT_JUSTIFICATION = [47, 81]; // = '/Q'\r\n    WriterUtil.DEFAULT_STYLE_STRING = [47, 68, 83]; // = '/DS'\r\n    WriterUtil.DIFFERENCE_RECTANGLE = [47, 82, 68]; // = '/RD'\r\n    WriterUtil.IT = [47, 73, 84]; // = '/IT'\r\n    WriterUtil.LINE_ENDING = [47, 76, 69]; // = '/LE'\r\n    WriterUtil.CALLOUT_LINE = [47, 67, 76]; // = '/CL'\r\n    WriterUtil.QUADPOINTS = [47, 81, 117, 97, 100, 80, 111, 105, 110, 116, 115]; // = '/QuadPoints'\r\n    WriterUtil.VERTICES = [47, 86, 101, 114, 116, 105, 99, 101, 115]; // = '/Vertices'\r\n    WriterUtil.NAME = [47, 78, 97, 109, 101]; // = '/Name'\r\n    WriterUtil.DRAFT = [47, 68, 114, 97, 102, 116]; // = '/Draft'\r\n    WriterUtil.SY = [47, 83, 121]; // = '/Sy'\r\n    WriterUtil.P = 80;\r\n    return WriterUtil;\r\n}());\r\nexports.WriterUtil = WriterUtil;\r\n","\"use strict\";\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nexports.__esModule = true;\r\nexports.Writer = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar object_util_1 = require(\"./object-util\");\r\nvar writer_util_1 = require(\"./writer-util\");\r\n/**\r\n * Creats the byte array that must be attached to the end of the document\r\n * */\r\nvar Writer = /** @class */ (function () {\r\n    /**\r\n     * data : The data representing the original PDF document\r\n     * aannotations : The annotations to add to the document\r\n     * */\r\n    function Writer(data, annotations, toDelete, parser) {\r\n        this.data = data;\r\n        this.annotations = annotations;\r\n        this.toDelete = toDelete;\r\n        this.parser = parser;\r\n        /**\r\n         * Holds the crossite reference table\r\n         * */\r\n        this.xrefs = [];\r\n        this.data = new Uint8Array(data);\r\n        this.cryptoInterface = parser.getCryptoInterface();\r\n    }\r\n    /**\r\n     * Sorts the annotations pagewise.\r\n     *\r\n     * This is necessary since the annotation arrays of the sites must be extended\r\n     * and it makes sense to do this update in one step.\r\n     * */\r\n    Writer.prototype.sortPageWise = function (annotations) {\r\n        var pageAnnots = {};\r\n        for (var _i = 0, annotations_1 = annotations; _i < annotations_1.length; _i++) {\r\n            var annot = annotations_1[_i];\r\n            if (!pageAnnots[annot.page])\r\n                pageAnnots[annot.page] = [];\r\n            pageAnnots[annot.page].push(annot);\r\n        }\r\n        return pageAnnots;\r\n    };\r\n    /**\r\n     * It returns the page object either extended by a /Annots field, if this did not exist yet or with the annots field replaced by a rerference pointer\r\n     * to an array if the page object contains the list of annotations directly\r\n     *\r\n     * ptr : Pointer to the page object\r\n     * annot_array_reference : The reference to the annotation array\r\n     * */\r\n    Writer.prototype.adaptPageObject = function (page, annot_array_reference) {\r\n        if (!page.object_id)\r\n            throw Error(\"Page without object id\");\r\n        var ret = [];\r\n        var lookupTable = this.parser.documentHistory.createObjectLookupTable();\r\n        var page_ptr = lookupTable[page.object_id.obj];\r\n        if (page_ptr.compressed) {\r\n            var obj = object_util_1.ObjectUtil.extractObject(this.data, page_ptr, lookupTable);\r\n            var obj_data = obj.stream.getData().slice(obj.pointer_stream_start, obj.pointer_stream_end + 1);\r\n            var ref_ptr = writer_util_1.WriterUtil.writeReferencePointer(obj.id, false).concat(32);\r\n            var new_data = new Uint8Array(ref_ptr.length + writer_util_1.WriterUtil.OBJ.length + obj_data.length + writer_util_1.WriterUtil.ENDOBJ.length);\r\n            new_data.set(ref_ptr);\r\n            new_data.set(writer_util_1.WriterUtil.OBJ, ref_ptr.length);\r\n            new_data.set(obj_data, writer_util_1.WriterUtil.OBJ.length + ref_ptr.length);\r\n            new_data.set(writer_util_1.WriterUtil.ENDOBJ, writer_util_1.WriterUtil.OBJ.length + obj_data.length + ref_ptr.length);\r\n            return writer_util_1.WriterUtil.replaceAnnotsFieldInPageObject(new_data, page, 0, annot_array_reference);\r\n        }\r\n        return writer_util_1.WriterUtil.replaceAnnotsFieldInPageObject(this.data, page, page_ptr.pointer, annot_array_reference);\r\n    };\r\n    /**\r\n     * Takes the annotations of >>one<< page and derives the annotations array from it.\r\n     * Thereby it also considers the potentially existing annotation array.\r\n     *\r\n     * toDelete := contains those annotations that must be deleted. It removes them from the reference array\r\n     * and marks them as removed\r\n     * */\r\n    Writer.prototype.writeAnnotArray = function (annots, toDelete) {\r\n        var page = annots[0].pageReference;\r\n        if (!page)\r\n            throw Error(\"Missing page reference\");\r\n        if (!page.object_id)\r\n            throw Error(\"Page without object id\");\r\n        var references = page.annots;\r\n        references = references.concat(annots.map(function (x) {\r\n            if (!x.object_id)\r\n                throw Error(\"Annotation with object_id null\");\r\n            return x.object_id;\r\n        }));\r\n        // remove annotation references from the array that must be deleted and mark them as deleted\r\n        references = references.filter(function (a) {\r\n            var toDel = toDelete.find(function (t) { return t.object_id.obj === a.obj && t.object_id.generation === a.generation; });\r\n            if (toDel) {\r\n                toDel.is_deleted = true;\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        var refArray_id = page.annotsPointer;\r\n        var page_data = [];\r\n        if (!refArray_id) {\r\n            refArray_id = this.parser.getFreeObjectId();\r\n            page_data = this.adaptPageObject(page, refArray_id);\r\n        }\r\n        var ret = writer_util_1.WriterUtil.writeReferencePointer(refArray_id);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.OBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret.push(writer_util_1.WriterUtil.ARRAY_START);\r\n        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {\r\n            var an = references_1[_i];\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(an, true));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret.push(writer_util_1.WriterUtil.ARRAY_END);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        return { ptr: refArray_id, data: ret, pageReference: page.object_id, pageData: page_data };\r\n    };\r\n    /**\r\n     * Writes an annotation object\r\n     * */\r\n    Writer.prototype.writeAnnotationObject = function (annot) {\r\n        //if ((annot as _Annotation).stampType) {\r\n        //    ret = ret.concat(Writer.NAME)\r\n        //    ret.push(Writer.SPACE)\r\n        //    ret = ret.concat(Writer.DRAFT)\r\n        //    ret.push(Writer.SPACE)\r\n        //}\r\n        //if ((annot as _Annotation).caretSymbol) {\r\n        //    ret = ret.concat(Writer.SY)\r\n        //    ret.push(Writer.SPACE)\r\n        //    ret.push(Writer.P)\r\n        //    ret.push(Writer.SPACE)\r\n        //}\r\n        var ret = annot.writeAnnotationPreamble();\r\n        ret = ret.concat(annot.writeAnnotationObject(this.cryptoInterface));\r\n        ret = ret.concat(annot.writeAnnotationPostamble());\r\n        return { ptr: annot.object_id, data: ret };\r\n    };\r\n    /**\r\n     * Takes all the cross site reference table entries and extracts the consecutive sequences\r\n     * */\r\n    Writer.prototype.computeXrefSequences = function () {\r\n        var seqs = [];\r\n        var ordered_xrefs = this.xrefs.sort(function (a, b) {\r\n            if (a.id < b.id)\r\n                return -1;\r\n            if (a.id > b.id)\r\n                return 1;\r\n            return 0;\r\n        });\r\n        var seq = [ordered_xrefs[0]];\r\n        var last_id = ordered_xrefs[0].id;\r\n        seqs.push(seq);\r\n        for (var i = 1; i < ordered_xrefs.length; ++i) {\r\n            if (ordered_xrefs[i].id === last_id + 1) {\r\n                seq.push(ordered_xrefs[i]);\r\n            }\r\n            else {\r\n                seq = [ordered_xrefs[i]];\r\n                seqs.push(seq);\r\n            }\r\n            last_id = ordered_xrefs[i].id;\r\n        }\r\n        return seqs;\r\n    };\r\n    /**\r\n     * Constructs the pointers of the linked list that contains the ids of freed objects\r\n     * */\r\n    Writer.prototype.applyObjectFreeing = function (refs) {\r\n        // write free object head\r\n        var head = this.parser.documentHistory.createObjectLookupTable()[0];\r\n        var last_freed_object_id = head.id;\r\n        var freed_objs = refs.filter(function (r) { return r.free; });\r\n        freed_objs = freed_objs.sort(function (a, b) {\r\n            if (a.id < b.id)\r\n                return -1;\r\n            if (a.id > b.id)\r\n                return 1;\r\n            return 0;\r\n        });\r\n        var lastobj = undefined;\r\n        for (var _i = 0, freed_objs_1 = freed_objs; _i < freed_objs_1.length; _i++) {\r\n            var obj = freed_objs_1[_i];\r\n            if (!lastobj) {\r\n                // set first object as list header\r\n                head.pointer = obj.id;\r\n            }\r\n            if (lastobj) {\r\n                lastobj.pointer = obj.id;\r\n            }\r\n            lastobj = obj;\r\n        }\r\n        if (freed_objs.length > 0)\r\n            freed_objs[freed_objs.length - 1].pointer = last_freed_object_id;\r\n        refs.push(head);\r\n        return refs;\r\n    };\r\n    /**\r\n     * Writes the crossite reference table\r\n     * */\r\n    Writer.prototype.writeCrossSiteReferenceTable = function () {\r\n        var ret = __spreadArray([], writer_util_1.WriterUtil.XREF, true);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        this.xrefs = this.applyObjectFreeing(this.xrefs);\r\n        var ordered_sequences = this.computeXrefSequences();\r\n        for (var _i = 0, ordered_sequences_1 = ordered_sequences; _i < ordered_sequences_1.length; _i++) {\r\n            var sequence = ordered_sequences_1[_i];\r\n            var head = sequence[0];\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(head.id));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret = ret.concat(util_1.Util.convertNumberToCharArray(sequence.length));\r\n            ret.push(writer_util_1.WriterUtil.CR);\r\n            ret.push(writer_util_1.WriterUtil.LF);\r\n            for (var i = 0; i < sequence.length; ++i) {\r\n                var _ret = [];\r\n                _ret = _ret.concat(writer_util_1.WriterUtil.pad(10, sequence[i].pointer));\r\n                _ret.push(writer_util_1.WriterUtil.SPACE);\r\n                _ret = _ret.concat(writer_util_1.WriterUtil.pad(5, sequence[i].generation));\r\n                _ret.push(writer_util_1.WriterUtil.SPACE);\r\n                if (sequence[i].free)\r\n                    _ret.push(writer_util_1.WriterUtil.F);\r\n                if (sequence[i].update)\r\n                    _ret.push(writer_util_1.WriterUtil.N);\r\n                _ret.push(writer_util_1.WriterUtil.CR);\r\n                _ret.push(writer_util_1.WriterUtil.LF);\r\n                if (_ret.length < 20)\r\n                    throw Error(\"XRef entry < 20 bytes\");\r\n                ret = ret.concat(_ret);\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Writes the trailer\r\n     * */\r\n    Writer.prototype.writeTrailer = function (posXref) {\r\n        var ret = __spreadArray([], writer_util_1.WriterUtil.TRAILER, true);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_START);\r\n        ret = ret.concat(writer_util_1.WriterUtil.SIZE);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.parser.documentHistory.trailerSize));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (this.parser.documentHistory.isEncrypted()) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.ENCRYPT);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            var enc_ref = this.parser.getCryptoInterface().getEncryptionDictReference();\r\n            if (!enc_ref)\r\n                throw Error(\"No reference pointer to encryption dictionary\");\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(enc_ref, true));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        var trailer = this.parser.documentHistory.getRecentUpdate();\r\n        if (trailer.id) {\r\n            ret = ret.concat(writer_util_1.WriterUtil.DOCUMENT_ID);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n            ret.push(writer_util_1.WriterUtil.ARRAY_START);\r\n            for (var _i = 0, _a = trailer.id; _i < _a.length; _i++) {\r\n                var val = _a[_i];\r\n                ret.push(writer_util_1.WriterUtil.SPACE);\r\n                ret = ret.concat(writer_util_1.WriterUtil.HEX_STRING_START);\r\n                ret = ret.concat(util_1.Util.convertStringToAscii(util_1.Util.convertByteArrayToHexString(val)));\r\n                ret = ret.concat(writer_util_1.WriterUtil.HEX_STRING_END);\r\n                ret.push(writer_util_1.WriterUtil.SPACE);\r\n            }\r\n            ret.push(writer_util_1.WriterUtil.ARRAY_END);\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret = ret.concat(writer_util_1.WriterUtil.ROOT);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        if (!trailer.root)\r\n            throw Error(\"No root object in trailer, although this is an cross reference table document\");\r\n        ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(trailer.root, true));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.PREV);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(this.parser.documentHistory.getRecentUpdate().start_pointer));\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.DICT_END);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.STARTXREF);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(util_1.Util.convertNumberToCharArray(posXref));\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.EOF);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        return ret;\r\n    };\r\n    /**\r\n     * Writes the annations at the end of the PDF byte representation and returns\r\n     * the byte array\r\n     * */\r\n    Writer.prototype.write = function () {\r\n        var pageWiseSorted = this.sortPageWise(this.annotations);\r\n        var ptr = this.data.length;\r\n        var new_data = [];\r\n        // Fix case that there is no linebreak after the end of the file\r\n        if (this.data[ptr - 1] === 70) { // 70 = 'F' (from [%%EO]F\r\n            new_data.push(writer_util_1.WriterUtil.CR);\r\n            new_data.push(writer_util_1.WriterUtil.LF);\r\n            ptr += 2;\r\n        }\r\n        for (var key in pageWiseSorted) {\r\n            var pageAnnots = pageWiseSorted[key];\r\n            // write the array referencing to annotations of a certain page\r\n            // it also removes references of annotations that must be deleted\r\n            var annot_array = this.writeAnnotArray(pageAnnots, this.toDelete);\r\n            this.xrefs.push({\r\n                id: annot_array.ptr.obj,\r\n                pointer: ptr,\r\n                generation: annot_array.ptr.generation,\r\n                free: false,\r\n                update: true\r\n            });\r\n            new_data = new_data.concat(annot_array.data);\r\n            ptr += annot_array.data.length;\r\n            // add adapted page object if it exists -- In the case the page had no annotation yet there exists\r\n            // no such array referring to its annotations. A pointer to such an array must be added to the\r\n            // page object. If this was done the `pageData` paramater is set and contains the adapted page object\r\n            if (annot_array.pageData.length > 0) {\r\n                this.xrefs.push({\r\n                    id: annot_array.pageReference.obj,\r\n                    pointer: ptr,\r\n                    generation: annot_array.pageReference.generation,\r\n                    free: false,\r\n                    update: true\r\n                });\r\n                new_data = new_data.concat(annot_array.pageData);\r\n                ptr += annot_array.pageData.length;\r\n            }\r\n            // writes the actual annotation object\r\n            for (var _i = 0, pageAnnots_1 = pageAnnots; _i < pageAnnots_1.length; _i++) {\r\n                var annot = pageAnnots_1[_i];\r\n                /**\r\n                 * write additional objects, that are related to the newly created or adapted annotation\r\n                 * */\r\n                for (var _a = 0, _b = annot.additional_objects_to_write; _a < _b.length; _a++) {\r\n                    var add_obj = _b[_a];\r\n                    var data = add_obj.func(add_obj.obj, this.cryptoInterface);\r\n                    this.xrefs.push({\r\n                        id: add_obj.obj.object_id.obj,\r\n                        pointer: ptr,\r\n                        generation: add_obj.obj.object_id.generation,\r\n                        free: false,\r\n                        update: true\r\n                    });\r\n                    new_data = new_data.concat(data);\r\n                    ptr += data.length;\r\n                }\r\n                var annot_obj = this.writeAnnotationObject(annot);\r\n                this.xrefs.push({\r\n                    id: annot_obj.ptr.obj,\r\n                    pointer: ptr,\r\n                    generation: annot_obj.ptr.generation,\r\n                    free: false,\r\n                    update: true\r\n                });\r\n                new_data = new_data.concat(annot_obj.data);\r\n                ptr += annot_obj.data.length;\r\n            }\r\n        }\r\n        // take all annotations that are not deleted yet\r\n        var _toDelete = this.toDelete.filter(function (t) { return !t.is_deleted; });\r\n        var pageWiseSortedToDelete = this.sortPageWise(_toDelete);\r\n        // adapt the remaining annotation reference tables\r\n        for (var key in pageWiseSortedToDelete) {\r\n            var del_data = this.updatePageAnnotationReferenceArray(pageWiseSortedToDelete[key]);\r\n            this.xrefs.push({\r\n                id: del_data.ptr.obj,\r\n                pointer: ptr,\r\n                generation: del_data.ptr.generation,\r\n                free: false,\r\n                update: true\r\n            });\r\n            new_data = new_data.concat(del_data.data);\r\n            ptr += del_data.data.length;\r\n        }\r\n        // write new fonts\r\n        var fonts = this.parser.getFonts().getFontsToWrite();\r\n        for (var _c = 0, fonts_1 = fonts; _c < fonts_1.length; _c++) {\r\n            var font = fonts_1[_c];\r\n            if (!font.object_id)\r\n                throw Error(\"Font has no object id\");\r\n            var font_data = font.writeFont();\r\n            this.xrefs.push({\r\n                id: font.object_id.obj,\r\n                pointer: ptr,\r\n                generation: font.object_id.generation,\r\n                free: false,\r\n                update: true\r\n            });\r\n            new_data = new_data.concat(font_data);\r\n            ptr += font_data.length;\r\n        }\r\n        // at this point all references to annotation objects in pages should be removed and we can free\r\n        // the annotation object ids\r\n        for (var _d = 0, _e = this.toDelete; _d < _e.length; _d++) {\r\n            var toDel = _e[_d];\r\n            if (!toDel.object_id)\r\n                continue;\r\n            this.xrefs.push({\r\n                id: toDel.object_id.obj,\r\n                pointer: -1,\r\n                generation: toDel.object_id.generation + 1,\r\n                free: true,\r\n                update: false\r\n            });\r\n        }\r\n        var crtable = this.writeCrossSiteReferenceTable();\r\n        new_data = new_data.concat(crtable);\r\n        var trailer = this.writeTrailer(ptr);\r\n        new_data = new_data.concat(trailer);\r\n        var new_data_array = new Uint8Array(new_data);\r\n        var ret_array = new Uint8Array(this.data.length + new_data_array.length);\r\n        ret_array.set(this.data);\r\n        ret_array.set(new_data, this.data.length);\r\n        return ret_array;\r\n    };\r\n    /**\r\n     * Removes the given annotation\r\n     * */\r\n    Writer.prototype.updatePageAnnotationReferenceArray = function (toDelete) {\r\n        var page = toDelete[0].pageReference;\r\n        if (!page)\r\n            throw Error(\"Missing page reference\");\r\n        if (!page.object_id) {\r\n            throw Error(\"Page without object id\");\r\n        }\r\n        var references = page.annots;\r\n        // remove annotation references from the array that must be deleted and mark them as deleted\r\n        references = references.filter(function (a) {\r\n            var toDel = toDelete.find(function (t) { return t.object_id.obj === a.obj && t.object_id.generation === a.generation; });\r\n            if (toDel) {\r\n                toDel.is_deleted = true;\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        var refArray_id = page.annotsPointer;\r\n        var ret = writer_util_1.WriterUtil.writeReferencePointer(refArray_id);\r\n        ret.push(writer_util_1.WriterUtil.SPACE);\r\n        ret = ret.concat(writer_util_1.WriterUtil.OBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret.push(writer_util_1.WriterUtil.ARRAY_START);\r\n        for (var _i = 0, references_2 = references; _i < references_2.length; _i++) {\r\n            var an = references_2[_i];\r\n            ret = ret.concat(writer_util_1.WriterUtil.writeReferencePointer(an, true));\r\n            ret.push(writer_util_1.WriterUtil.SPACE);\r\n        }\r\n        ret.push(writer_util_1.WriterUtil.ARRAY_END);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        ret = ret.concat(writer_util_1.WriterUtil.ENDOBJ);\r\n        ret.push(writer_util_1.WriterUtil.CR);\r\n        ret.push(writer_util_1.WriterUtil.LF);\r\n        return { ptr: refArray_id, data: ret };\r\n    };\r\n    return Writer;\r\n}());\r\nexports.Writer = Writer;\r\n","const {AnnotationFactory} = require(\"./annotate/index.ts\");\r\nclass AnnotateController{\r\n    constructor(PDFViewerApplication,data,up=\"\",op=\"\"){\r\n        this.PDFViewerApplication = PDFViewerApplication;\r\n        this.pdfViewer = PDFViewerApplication.pdfViewer;\r\n\r\n        this.AnnotationFactory = new AnnotationFactory(data,up,op);\r\n        PDFViewerApplication.pdfAnnotator = this.AnnotationFactory;\r\n        this._init();\r\n    }\r\n    getSelectionObject(r){\r\n        const outBounding = JSON.parse(JSON.stringify(r.getRangeAt(0).getBoundingClientRect())); // deep copy\r\n        let innerBounding=[];\r\n        const contentNode = r.getRangeAt(0).cloneContents().children;\r\n        if(contentNode.length==1){\r\n            return {\r\n                outBounding,\r\n                innerBounding:null\r\n            }\r\n        }\r\n        console.log('Select Node',contentNode)\r\n        for(let nodeIndex in contentNode){\r\n            if(contentNode[nodeIndex].tagName!='SPAN') continue;\r\n            let basePos = JSON.parse(JSON.stringify(document.querySelector(`span[style='${contentNode[nodeIndex].getAttribute('style')}']`).getBoundingClientRect()));\r\n            if(nodeIndex==0){\r\n                if(this._lastMouseDown.x>outBounding.left||this._lastMouseUp.x>outBounding.left){\r\n                     // 选区在元素内，要减掉 但是要分情况(可以再化简，懒得弄了。。)\r\n                    if(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y<this._lastMouseUp.y){\r\n                        // 右上到左下\r\n                        basePos.x=this._lastMouseDown.x\r\n                        basePos.width = basePos.width-(this._lastMouseDown.x-outBounding.left)\r\n                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y<this._lastMouseDown.y){\r\n                        // 左下到右上\r\n                        basePos.x=this._lastMouseUp.x\r\n                        basePos.width = basePos.width-(this._lastMouseUp.x-outBounding.left)\r\n                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y>this._lastMouseDown.y){\r\n                        // 左上到右下\r\n                        basePos.x=this._lastMouseDown.x\r\n                        basePos.width = basePos.width-(this._lastMouseDown.x-outBounding.left)\r\n                    }else{\r\n                        // 右下到左上(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y>this._lastMouseUp.y)\r\n                        basePos.x=this._lastMouseUp.x\r\n                        basePos.width = basePos.width-(this._lastMouseUp.x-outBounding.left)\r\n                    }\r\n                    innerBounding.push(\r\n                        this.selectionCoordinates(basePos,true)\r\n                    );\r\n                }\r\n            }else if(nodeIndex == contentNode.length-1){\r\n              \r\n                     // 选区在元素内，要减掉 但是要分情况(可以再化简，懒得弄了。。)\r\n                     if(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y<this._lastMouseUp.y){\r\n                        // 右上到左下\r\n                        //basePos.x=this._lastMouseUp.x\r\n                        basePos.width = basePos.width - (outBounding.right-this._lastMouseUp.x)\r\n                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y<this._lastMouseDown.y){\r\n                        // 左下到右上\r\n                        //basePos.x=this._lastMouseDown.x\r\n                        basePos.width = basePos.width - (outBounding.right-this._lastMouseDown.x)\r\n                    }else if(this._lastMouseUp.x>this._lastMouseDown.x&&this._lastMouseUp.y>this._lastMouseDown.y){\r\n                        // 左上到右下\r\n                        //basePos.x=this._lastMouseUp.x\r\n                        basePos.width = basePos.width - (outBounding.right-this._lastMouseUp.x)\r\n                    }else{\r\n                        // 右下到左上(this._lastMouseDown.x>this._lastMouseUp.x&&this._lastMouseDown.y>this._lastMouseUp.y)\r\n                        //basePos.x=this._lastMouseDown.x\r\n                        basePos.width = basePos.width - (outBounding.right-this._lastMouseDown.x)\r\n                    }\r\n                    innerBounding.push(\r\n                        this.selectionCoordinates(basePos,true)\r\n                    );\r\n              \r\n            }else{\r\n                innerBounding.push(this.selectionCoordinates(basePos,true));\r\n            }\r\n        }\r\n        console.log(`Results `,{\r\n            outBounding,\r\n            innerBounding\r\n        })\r\n        return {\r\n            outBounding,\r\n            innerBounding\r\n        }\r\n    }\r\n    _init(){\r\n        const that=this;\r\n        this.fn = function (e){\r\n\r\n            that._lastMouseUp = {x:e.x,y:e.y};\r\n            const isOnTextLayer = e.path.some(elem=>{return elem.className=='textLayer'})\r\n            if(!isOnTextLayer){\r\n                return;\r\n            }\r\n            // 防止已经出了tooltip在上面点不了\r\n            if(e.path.some((x)=>{\r\n                return x.id=='annotateTooltip'\r\n            })) return;\r\n            var r = \"\";\r\n            if (document.selection) {\r\n                r = document.selection.createRange().text;\r\n            }\r\n            else if (window.getSelection()) {\r\n                r = window.getSelection();\r\n            }\r\n            if (r!= \"\") {\r\n                that._lastSelection = that.getSelectionObject(r);\r\n                if(that.annotateTip){\r\n                    that._removeAnnotateTip();\r\n                }\r\n\r\n                    that._buildAnnotateTip(e);\r\n            }else{\r\n                if(that.annotateTip) that._removeAnnotateTip();\r\n            }\r\n        }\r\n        document.addEventListener(\"mouseup\",this.fn);\r\n        document.addEventListener(\"mousedown\",(e)=>{\r\n            that._lastMouseDown = {x:e.x,y:e.y};\r\n        })\r\n        const {annotationButton} = this.PDFViewerApplication.appConfig;\r\n        console.log(annotationButton);\r\n        if(annotationButton.highLightAnnotation){\r\n            annotationButton.highLightAnnotation.addEventListener('click',this._doHighLightAnnotation)\r\n        }\r\n    }\r\n    _removeAnnotateTip(){\r\n        document.body.removeChild(this.annotateTip);\r\n        this.annotateTip=null;\r\n        //document.addEventListener(\"mouseup\",this.fn);\r\n        this._lastSelection=null;\r\n    }\r\n    _buildAnnotateTip(e){\r\n        //document.removeEventListener(\"mouseup\",this.fn);\r\n        var x=10;\r\n        var y=10;\r\n        const outer = document.createElement('div');\r\n        outer.id=\"annotateTooltip\";\r\n        outer.style.backgroundColor=\"gray\"\r\n        outer.style.top=(e.pageY - y)+'px';\r\n        outer.style.left=(e.pageX + x)+'px';\r\n        outer.style.position=\"absolute\";\r\n        outer.class='annotateTooltip';\r\n        outer.innerHTML=`<span id=\"highLightHere\" style=\"color:red\">高亮此处</span>`;\r\n        this.annotateTip=outer;\r\n        document.body.appendChild(outer);\r\n        document.getElementById('highLightHere').addEventListener('click',()=>{\r\n            console.log(\"highLight!\",this._lastSelection);\r\n            this._doHighLightAnnotation(this._lastSelection);\r\n            this._removeAnnotateTip();\r\n        },true);\r\n        return outer;\r\n    }\r\n    computePageOffset() {\r\n        console.log(\"compute Offset Page\",this.pdfViewer.currentPageNumber);\r\n        \r\n        // 获取相对坐标\r\n        let pg = document.querySelector(`.page[data-page-number=\"${this.pdfViewer.currentPageNumber}\"]`).getElementsByTagName('canvas')[0];\r\n\r\n        var rect = pg.getBoundingClientRect(), bodyElt = document.body;\r\n        return {\r\n                top: rect.top + bodyElt .scrollTop,\r\n                left: rect.left + bodyElt .scrollLeft\r\n        }\r\n    }\r\n    selectionCoordinates(selection,fourPoint=false) {\r\n        let rec = selection\r\n        let ost = this.computePageOffset()\r\n        let x_1 = rec.x - ost.left\r\n        let y_1 = rec.y - ost.top\r\n        let x_2 = x_1 + rec.width\r\n        let y_2 = y_1\r\n        let x_3 = x_1 + rec.width\r\n        let y_3 = y_1 + rec.height\r\n        let x_4 = x_1\r\n        let y_4 = y_3\r\n\r\n        let x_1_y_1 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_1, y_1)\r\n        x_1 = x_1_y_1[0]\r\n        y_1 = x_1_y_1[1]\r\n        let x_2_y_2 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_2, y_2)\r\n        x_2 = x_2_y_2[0]\r\n        y_2 = x_2_y_2[1]\r\n        let x_3_y_3 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_3, y_3)\r\n        x_3 = x_3_y_3[0]\r\n        y_3 = x_3_y_3[1]\r\n        let x_4_y_4 = this.pdfViewer._pages[this.pdfViewer.currentPageNumber - 1].viewport.convertToPdfPoint(x_4, y_4)\r\n        x_4 = x_4_y_4[0]\r\n        y_4 = x_4_y_4[1]\r\n        if(!fourPoint){\r\n            return [x_1, y_1, x_3, y_3]\r\n        }else{\r\n            return [x_4, y_4, x_3, y_3,x_1, y_1, x_2, y_2]\r\n        }\r\n        \r\n}\r\n    _doHighLightAnnotation(selection){\r\n        console.log(\"Request HighLight\",selection);\r\n\r\n        this.AnnotationFactory.createHighlightAnnotation({\r\n            page: this.pdfViewer.currentPageNumber - 1,\r\n            rect:this.selectionCoordinates(selection.outBounding),\r\n            quadPoints: selection.innerBounding?selection.innerBounding.flat():null,\r\n            contents: \"HighLight Text\",\r\n            author: \"SaltDog\",\r\n            color: {r: 128, g: 0, b: 0},\r\n            opacity: 0.3\r\n    }\r\n    );\r\n}\r\n\r\n    getAnnotatedPDFBlob(){\r\n        return this.AnnotationFactory.write();\r\n    }\r\n}\r\nexport {\r\n     AnnotateController\r\n}","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {AnnotationLayer} = require(\"pdfjs-dist\");\r\nconst {NullL10n} = require(\"./l10n_utils.js\");\r\nclass AnnotationLayerBuilder {\r\n constructor({pageDiv, pdfPage, linkService, downloadManager, annotationStorage = null, imageResourcesPath = \"\", renderForms = true, l10n = NullL10n, enableScripting = false, hasJSActionsPromise = null, fieldObjectsPromise = null, mouseState = null, annotationCanvasMap = null}) {\r\n  this.pageDiv = pageDiv;\r\n  this.pdfPage = pdfPage;\r\n  this.linkService = linkService;\r\n  this.downloadManager = downloadManager;\r\n  this.imageResourcesPath = imageResourcesPath;\r\n  this.renderForms = renderForms;\r\n  this.l10n = l10n;\r\n  this.annotationStorage = annotationStorage;\r\n  this.enableScripting = enableScripting;\r\n  this._hasJSActionsPromise = hasJSActionsPromise;\r\n  this._fieldObjectsPromise = fieldObjectsPromise;\r\n  this._mouseState = mouseState;\r\n  this._annotationCanvasMap = annotationCanvasMap;\r\n  this.div = null;\r\n  this._cancelled = false;\r\n }\r\n async render(viewport, intent = \"display\") {\r\n  const [annotations, hasJSActions = false, fieldObjects = null] = await Promise.all([\r\n   this.pdfPage.getAnnotations({ intent }),\r\n   this._hasJSActionsPromise,\r\n   this._fieldObjectsPromise\r\n  ]);\r\n  if (this._cancelled || annotations.length === 0) {\r\n   return;\r\n  }\r\n  const parameters = {\r\n   viewport: viewport.clone({ dontFlip: true }),\r\n   div: this.div,\r\n   annotations,\r\n   page: this.pdfPage,\r\n   imageResourcesPath: this.imageResourcesPath,\r\n   renderForms: this.renderForms,\r\n   linkService: this.linkService,\r\n   downloadManager: this.downloadManager,\r\n   annotationStorage: this.annotationStorage,\r\n   enableScripting: this.enableScripting,\r\n   hasJSActions,\r\n   fieldObjects,\r\n   mouseState: this._mouseState,\r\n   annotationCanvasMap: this._annotationCanvasMap\r\n  };\r\n  if (this.div) {\r\n   AnnotationLayer.update(parameters);\r\n  } else {\r\n   this.div = document.createElement(\"div\");\r\n   this.div.className = \"annotationLayer\";\r\n   this.pageDiv.appendChild(this.div);\r\n   parameters.div = this.div;\r\n   AnnotationLayer.render(parameters);\r\n   this.l10n.translate(this.div);\r\n  }\r\n }\r\n cancel() {\r\n  this._cancelled = true;\r\n }\r\n hide() {\r\n  if (!this.div) {\r\n   return;\r\n  }\r\n  this.div.hidden = true;\r\n }\r\n}\r\nexport {\r\n AnnotationLayerBuilder\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {animationStarted, apiPageLayoutToViewerModes, /*apiPageModeToSidebarView,*/ AutoPrintRegExp, DEFAULT_SCALE_VALUE, getActiveOrFocusedElement, isValidRotation, isValidScrollMode, isValidSpreadMode, noContextMenuHandler, normalizeWheelEventDirection, parseQueryString, ProgressBar, RendererType, RenderingStates, ScrollMode,/* SidebarView,*/ SpreadMode, TextLayerMode} = require(\"./ui_utils.js\");\r\nconst {AppOptions, OptionKind} = require(\"./app_options.js\");\r\nconst {AutomationEventBus, EventBus} = require(\"./event_utils.js\");\r\nconst {build, createPromiseCapability, getDocument, getFilenameFromUrl, getPdfFilenameFromUrl, GlobalWorkerOptions, InvalidPDFException, isPdfFile, loadScript, MissingPDFException, OPS, PDFWorker, shadow, UnexpectedResponseException, UNSUPPORTED_FEATURES, version} = require(\"pdfjs-dist\");\r\nconst {CursorTool, PDFCursorTools} = require(\"./pdf_cursor_tools.js\");\r\nconst {LinkTarget, PDFLinkService} = require(\"./pdf_link_service.js\");\r\nconst {OverlayManager} = require(\"./overlay_manager.js\");\r\nconst {PasswordPrompt} = require(\"./password_prompt.js\");\r\n// sdpdfcore disable sidebar\r\n// const {PDFAttachmentViewer} = require(\"./pdf_attachment_viewer.js\");\r\n// saltdog disable documentProperties\r\n// const {PDFDocumentProperties} = require(\"./pdf_document_properties.js\");\r\nconst {PDFFindBar} = require(\"./pdf_find_bar.js\");\r\nconst {PDFFindController} = require(\"./pdf_find_controller.js\");\r\nconst {PDFHistory} = require(\"./pdf_history.js\");\r\n// const {PDFLayerViewer} = require(\"./pdf_layer_viewer.js\");\r\n// sdpdfcore disable sidebar\r\n// const {PDFOutlineViewer} = require(\"./pdf_outline_viewer.js\");\r\n// saltdog disable presentation\r\n// const {PDFPresentationMode} = require(\"./pdf_presentation_mode.js\");\r\nconst {PDFRenderingQueue} = require(\"./pdf_rendering_queue.js\");\r\nconst {PDFScriptingManager} = require(\"./pdf_scripting_manager.js\");\r\n// sdpdfcore disable sidebar\r\n// const {PDFSidebar} = require(\"./pdf_sidebar.js\");\r\n// const {PDFSidebarResizer} = require(\"./pdf_sidebar_resizer.js\");\r\n// const {PDFThumbnailViewer} = require(\"./pdf_thumbnail_viewer.js\");\r\nconst {PDFViewer} = require(\"./pdf_viewer.js\");\r\nconst {SecondaryToolbar} = require(\"./secondary_toolbar.js\");\r\nconst {Toolbar} = require(\"./toolbar.js\");\r\nconst {ViewHistory} = require(\"./view_history.js\");\r\nconst {AnnotateController} = require(\"./annotate_controller.js\");\r\nconst DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000;\r\nconst FORCE_PAGES_LOADED_TIMEOUT = 10000;\r\nconst WHEEL_ZOOM_DISABLED_TIMEOUT = 1000;\r\nconst ViewOnLoad = {\r\n UNKNOWN: -1,\r\n PREVIOUS: 0,\r\n INITIAL: 1\r\n};\r\nconst ViewerCssTheme = {\r\n AUTOMATIC: 0,\r\n LIGHT: 1,\r\n DARK: 2\r\n};\r\nconst KNOWN_VERSIONS = [\r\n \"1.0\",\r\n \"1.1\",\r\n \"1.2\",\r\n \"1.3\",\r\n \"1.4\",\r\n \"1.5\",\r\n \"1.6\",\r\n \"1.7\",\r\n \"1.8\",\r\n \"1.9\",\r\n \"2.0\",\r\n \"2.1\",\r\n \"2.2\",\r\n \"2.3\"\r\n];\r\nconst KNOWN_GENERATORS = [\r\n \"acrobat distiller\",\r\n \"acrobat pdfwriter\",\r\n \"adobe livecycle\",\r\n \"adobe pdf library\",\r\n \"adobe photoshop\",\r\n \"ghostscript\",\r\n \"tcpdf\",\r\n \"cairo\",\r\n \"dvipdfm\",\r\n \"dvips\",\r\n \"pdftex\",\r\n \"pdfkit\",\r\n \"itext\",\r\n \"prince\",\r\n \"quarkxpress\",\r\n \"mac os x\",\r\n \"microsoft\",\r\n \"openoffice\",\r\n \"oracle\",\r\n \"luradocument\",\r\n \"pdf-xchange\",\r\n \"antenna house\",\r\n \"aspose.cells\",\r\n \"fpdf\"\r\n];\r\nclass DefaultExternalServices {\r\n constructor() {\r\n  throw new Error(\"Cannot initialize DefaultExternalServices.\");\r\n }\r\n static updateFindControlState(data) {\r\n }\r\n static updateFindMatchesCount(data) {\r\n }\r\n static initPassiveLoading(callbacks) {\r\n }\r\n static async fallback(data) {\r\n }\r\n static reportTelemetry(data) {\r\n }\r\n static createDownloadManager(options) {\r\n  throw new Error(\"Not implemented: createDownloadManager\");\r\n }\r\n static createPreferences() {\r\n  throw new Error(\"Not implemented: createPreferences\");\r\n }\r\n static createL10n(options) {\r\n  throw new Error(\"Not implemented: createL10n\");\r\n }\r\n static createScripting(options) {\r\n  throw new Error(\"Not implemented: createScripting\");\r\n }\r\n static get supportsIntegratedFind() {\r\n  return shadow(this, \"supportsIntegratedFind\", false);\r\n }\r\n static get supportsDocumentFonts() {\r\n  return shadow(this, \"supportsDocumentFonts\", true);\r\n }\r\n static get supportedMouseWheelZoomModifierKeys() {\r\n  return shadow(this, \"supportedMouseWheelZoomModifierKeys\", {\r\n   ctrlKey: true,\r\n   metaKey: true\r\n  });\r\n }\r\n static get isInAutomation() {\r\n  return shadow(this, \"isInAutomation\", false);\r\n }\r\n}\r\nconst PDFViewerApplication = {\r\n initialBookmark: document.location.hash.substring(1),\r\n _initializedCapability: createPromiseCapability(),\r\n _fellback: false,\r\n appConfig: null,\r\n pdfDocument: null,\r\n pdfLoadingTask: null,\r\n printService: null,\r\n pdfViewer: null,\r\n//  pdfThumbnailViewer: null,\r\n pdfRenderingQueue: null,\r\n // saltdog disable presentation\r\n//  pdfPresentationMode: null,\r\n // saltdog disable documentProperties\r\n//  pdfDocumentProperties: null,\r\n pdfLinkService: null,\r\n pdfHistory: null,\r\n// sdpdfcore disable sidebar\r\n//  pdfSidebar: null,\r\n//  pdfSidebarResizer: null,\r\n//  pdfOutlineViewer: null,\r\n//  pdfAttachmentViewer: null,\r\n//  pdfLayerViewer: null,\r\n pdfCursorTools: null,\r\n pdfScriptingManager: null,\r\n store: null,\r\n downloadManager: null,\r\n overlayManager: null,\r\n preferences: null,\r\n toolbar: null,\r\n secondaryToolbar: null,\r\n eventBus: null,\r\n l10n: null,\r\n isInitialViewSet: false,\r\n downloadComplete: false,\r\n isViewerEmbedded: window.parent !== window,\r\n url: \"\",\r\n baseUrl: \"\",\r\n _downloadUrl: \"\",\r\n externalServices: DefaultExternalServices,\r\n _boundEvents: Object.create(null),\r\n documentInfo: null,\r\n metadata: null,\r\n _contentDispositionFilename: null,\r\n _contentLength: null,\r\n _saveInProgress: false,\r\n _docStats: null,\r\n _wheelUnusedTicks: 0,\r\n _idleCallbacks: new Set(),\r\n async initialize(appConfig) {\r\n  this.preferences = this.externalServices.createPreferences();\r\n  this.appConfig = appConfig;\r\n  await this._readPreferences();\r\n  await this._parseHashParameters();\r\n  this._forceCssTheme();\r\n  await this._initializeL10n();\r\n  if (this.isViewerEmbedded && AppOptions.get(\"externalLinkTarget\") === LinkTarget.NONE) {\r\n   AppOptions.set(\"externalLinkTarget\", LinkTarget.TOP);\r\n  }\r\n  await this._initializeViewerComponents();\r\n  this.bindEvents();\r\n  this.bindWindowEvents();\r\n  const appContainer = appConfig.appContainer || document.documentElement;\r\n  this.l10n.translate(appContainer).then(() => {\r\n   this.eventBus.dispatch(\"localized\", { source: this });\r\n  });\r\n  this._initializedCapability.resolve();\r\n },\r\n async _readPreferences() {\r\n  if (AppOptions.get(\"disablePreferences\")) {\r\n   return;\r\n  }\r\n  if (AppOptions._hasUserOptions()) {\r\n   console.warn(\"_readPreferences: The Preferences may override manually set AppOptions; \" + 'please use the \"disablePreferences\"-option in order to prevent that.');\r\n  }\r\n  try {\r\n   AppOptions.setAll(await this.preferences.getAll());\r\n  } catch (reason) {\r\n   console.error(`_readPreferences: \"${ reason?.message }\".`);\r\n  }\r\n },\r\n async _parseHashParameters() {\r\n  if (!AppOptions.get(\"pdfBugEnabled\")) {\r\n   return;\r\n  }\r\n  const hash = document.location.hash.substring(1);\r\n  if (!hash) {\r\n   return;\r\n  }\r\n  const params = parseQueryString(hash), waitOn = [];\r\n  if (params.get(\"disableworker\") === \"true\") {\r\n   waitOn.push(loadFakeWorker());\r\n  }\r\n  if (params.has(\"disablerange\")) {\r\n   AppOptions.set(\"disableRange\", params.get(\"disablerange\") === \"true\");\r\n  }\r\n  if (params.has(\"disablestream\")) {\r\n   AppOptions.set(\"disableStream\", params.get(\"disablestream\") === \"true\");\r\n  }\r\n  if (params.has(\"disableautofetch\")) {\r\n   AppOptions.set(\"disableAutoFetch\", params.get(\"disableautofetch\") === \"true\");\r\n  }\r\n  if (params.has(\"disablefontface\")) {\r\n   AppOptions.set(\"disableFontFace\", params.get(\"disablefontface\") === \"true\");\r\n  }\r\n  if (params.has(\"disablehistory\")) {\r\n   AppOptions.set(\"disableHistory\", params.get(\"disablehistory\") === \"true\");\r\n  }\r\n  if (params.has(\"verbosity\")) {\r\n   AppOptions.set(\"verbosity\", params.get(\"verbosity\") | 0);\r\n  }\r\n  if (params.has(\"textlayer\")) {\r\n   switch (params.get(\"textlayer\")) {\r\n   case \"off\":\r\n    AppOptions.set(\"textLayerMode\", TextLayerMode.DISABLE);\r\n    break;\r\n   case \"visible\":\r\n   case \"shadow\":\r\n   case \"hover\":\r\n    const viewer = this.appConfig.viewerContainer;\r\n    viewer.classList.add(`textLayer-${ params.get(\"textlayer\") }`);\r\n    break;\r\n   }\r\n  }\r\n  if (params.has(\"pdfbug\")) {\r\n   AppOptions.set(\"pdfBug\", true);\r\n   AppOptions.set(\"fontExtraProperties\", true);\r\n   const enabled = params.get(\"pdfbug\").split(\",\");\r\n   waitOn.push(initPDFBug(enabled));\r\n  }\r\n  if (params.has(\"locale\")) {\r\n   AppOptions.set(\"locale\", params.get(\"locale\"));\r\n  }\r\n  if (waitOn.length === 0) {\r\n   return;\r\n  }\r\n  try {\r\n   await Promise.all(waitOn);\r\n  } catch (reason) {\r\n   console.error(`_parseHashParameters: \"${ reason.message }\".`);\r\n  }\r\n },\r\n async _initializeL10n() {\r\n  this.l10n = this.externalServices.createL10n({ locale: AppOptions.get(\"locale\") });\r\n  const dir = await this.l10n.getDirection();\r\n  document.getElementsByTagName(\"html\")[0].dir = dir;\r\n },\r\n _forceCssTheme() {\r\n  const cssTheme = AppOptions.get(\"viewerCssTheme\");\r\n  if (cssTheme === ViewerCssTheme.AUTOMATIC || !Object.values(ViewerCssTheme).includes(cssTheme)) {\r\n   return;\r\n  }\r\n  try {\r\n   const styleSheet = document.styleSheets[0];\r\n   const cssRules = styleSheet?.cssRules || [];\r\n   for (let i = 0, ii = cssRules.length; i < ii; i++) {\r\n    const rule = cssRules[i];\r\n    if (rule instanceof CSSMediaRule && rule.media?.[0] === \"(prefers-color-scheme: dark)\") {\r\n     if (cssTheme === ViewerCssTheme.LIGHT) {\r\n      styleSheet.deleteRule(i);\r\n      return;\r\n     }\r\n     const darkRules = /^@media \\(prefers-color-scheme: dark\\) {\\n\\s*([\\w\\s-.,:;/\\\\{}()]+)\\n}$/.exec(rule.cssText);\r\n     if (darkRules?.[1]) {\r\n      styleSheet.deleteRule(i);\r\n      styleSheet.insertRule(darkRules[1], i);\r\n     }\r\n     return;\r\n    }\r\n   }\r\n  } catch (reason) {\r\n   console.error(`_forceCssTheme: \"${ reason?.message }\".`);\r\n  }\r\n },\r\n async _initializeViewerComponents() {\r\n  const {appConfig, externalServices} = this;\r\n  const eventBus = externalServices.isInAutomation ? new AutomationEventBus() : new EventBus();\r\n  this.eventBus = eventBus;\r\n  this.overlayManager = new OverlayManager();\r\n  const pdfRenderingQueue = new PDFRenderingQueue();\r\n  pdfRenderingQueue.onIdle = this._cleanup.bind(this);\r\n  this.pdfRenderingQueue = pdfRenderingQueue;\r\n  const pdfLinkService = new PDFLinkService({\r\n   eventBus,\r\n   externalLinkTarget: AppOptions.get(\"externalLinkTarget\"),\r\n   externalLinkRel: AppOptions.get(\"externalLinkRel\"),\r\n   ignoreDestinationZoom: AppOptions.get(\"ignoreDestinationZoom\")\r\n  });\r\n  this.pdfLinkService = pdfLinkService;\r\n  const downloadManager = externalServices.createDownloadManager();\r\n  this.downloadManager = downloadManager;\r\n  const findController = new PDFFindController({\r\n   linkService: pdfLinkService,\r\n   eventBus\r\n  });\r\n  this.findController = findController;\r\n  const pdfScriptingManager = new PDFScriptingManager({\r\n   eventBus,\r\n   sandboxBundleSrc: AppOptions.get(\"sandboxBundleSrc\"),\r\n   scriptingFactory: externalServices,\r\n   docPropertiesLookup: this._scriptingDocProperties.bind(this)\r\n  });\r\n  this.pdfScriptingManager = pdfScriptingManager;\r\n  const container = appConfig.mainContainer;\r\n  const viewer = appConfig.viewerContainer;\r\n  // 新增pdfAnnotator PDF加载后赋值\r\n  this.pdfAnnotator = {status:\"Not Loaded\"};\r\n  this.pdfViewer = new PDFViewer({\r\n   container,\r\n   viewer,\r\n   eventBus,\r\n   renderingQueue: pdfRenderingQueue,\r\n   linkService: pdfLinkService,\r\n   downloadManager,\r\n   findController,\r\n   scriptingManager: AppOptions.get(\"enableScripting\") && pdfScriptingManager,\r\n   renderer: AppOptions.get(\"renderer\"),\r\n   l10n: this.l10n,\r\n   textLayerMode: AppOptions.get(\"textLayerMode\"),\r\n   annotationMode: AppOptions.get(\"annotationMode\"),\r\n   imageResourcesPath: AppOptions.get(\"imageResourcesPath\"),\r\n   enablePrintAutoRotate: AppOptions.get(\"enablePrintAutoRotate\"),\r\n   useOnlyCssZoom: AppOptions.get(\"useOnlyCssZoom\"),\r\n   maxCanvasPixels: AppOptions.get(\"maxCanvasPixels\"),\r\n   enablePermissions: AppOptions.get(\"enablePermissions\")\r\n  });\r\n  pdfRenderingQueue.setViewer(this.pdfViewer);\r\n  pdfLinkService.setViewer(this.pdfViewer);\r\n  pdfScriptingManager.setViewer(this.pdfViewer);\r\n  // sdpdfcore disable sidebar\r\n  // this.pdfThumbnailViewer = new PDFThumbnailViewer({\r\n  //  container: appConfig.sidebar.thumbnailView,\r\n  //  eventBus,\r\n  //  renderingQueue: pdfRenderingQueue,\r\n  //  linkService: pdfLinkService,\r\n  //  l10n: this.l10n\r\n  // });\r\n  // pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);\r\n  if (!this.isViewerEmbedded && !AppOptions.get(\"disableHistory\")) {\r\n   this.pdfHistory = new PDFHistory({\r\n    linkService: pdfLinkService,\r\n    eventBus\r\n   });\r\n   pdfLinkService.setHistory(this.pdfHistory);\r\n  }\r\n  if (!this.supportsIntegratedFind) {\r\n   this.findBar = new PDFFindBar(appConfig.findBar, eventBus, this.l10n);\r\n  }\r\n  // saltdog disable documentProperties\r\n  // this.pdfDocumentProperties = new PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n);\r\n  this.pdfCursorTools = new PDFCursorTools({\r\n   container,\r\n   eventBus,\r\n   cursorToolOnLoad: AppOptions.get(\"cursorToolOnLoad\")\r\n  });\r\n  this.toolbar = new Toolbar(appConfig.toolbar, eventBus, this.l10n);\r\n  this.secondaryToolbar = new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);\r\n  // saltdog disable presenation\r\n  // if (this.supportsFullscreen) {\r\n  //  this.pdfPresentationMode = new PDFPresentationMode({\r\n  //   container,\r\n  //   pdfViewer: this.pdfViewer,\r\n  //   eventBus\r\n  //  });\r\n  // }\r\n  this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n, this.isViewerEmbedded);\r\n  // sdpdfcore disable sidebar\r\n  // this.pdfOutlineViewer = new PDFOutlineViewer({\r\n  //  container: appConfig.sidebar.outlineView,\r\n  //  eventBus,\r\n  //  linkService: pdfLinkService\r\n  // });\r\n  // this.pdfAttachmentViewer = new PDFAttachmentViewer({\r\n  //  container: appConfig.sidebar.attachmentsView,\r\n  //  eventBus,\r\n  //  downloadManager\r\n  // });\r\n  // this.pdfLayerViewer = new PDFLayerViewer({\r\n  //  container: appConfig.sidebar.layersView,\r\n  //  eventBus,\r\n  //  l10n: this.l10n\r\n  // });\r\n  // sdpdfcore disable sidebar\r\n  // this.pdfSidebar = new PDFSidebar({\r\n  //  elements: appConfig.sidebar,\r\n  //  pdfViewer: this.pdfViewer,\r\n  //  pdfThumbnailViewer: this.pdfThumbnailViewer,\r\n  //  eventBus,\r\n  //  l10n: this.l10n\r\n  // });\r\n  // this.pdfSidebar.onToggled = this.forceRendering.bind(this);\r\n  // this.pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);\r\n },\r\n run(config) {\r\n  this.initialize(config).then(()=>{\r\n    webViewerInitialized();\r\n    // debuglgy\r\n    __sdJSBridge.publish(`SDPDFCore_Ready`);\r\n    this.eventBus.on('SDPDFCore_loadPDF',()=>{\r\n      webViewerInitialized();\r\n    })\r\n  });\r\n },\r\n get initialized() {\r\n  return this._initializedCapability.settled;\r\n },\r\n get initializedPromise() {\r\n  return this._initializedCapability.promise;\r\n },\r\n zoomIn(steps) {\r\n  // saltdog disable presentation\r\n  // if (this.pdfViewer.isInPresentationMode) {\r\n  //  return;\r\n  // }\r\n  this.pdfViewer.increaseScale(steps);\r\n },\r\n zoomOut(steps) {\r\n   // saltdog disable presentation\r\n  // if (this.pdfViewer.isInPresentationMode) {\r\n  //  return;\r\n  // }\r\n  this.pdfViewer.decreaseScale(steps);\r\n },\r\n zoomReset() {\r\n   // saltdog disable presentation\r\n  // if (this.pdfViewer.isInPresentationMode) {\r\n  //  return;\r\n  // }\r\n  this.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE;\r\n },\r\n get pagesCount() {\r\n  return this.pdfDocument ? this.pdfDocument.numPages : 0;\r\n },\r\n get page() {\r\n  return this.pdfViewer.currentPageNumber;\r\n },\r\n set page(val) {\r\n  this.pdfViewer.currentPageNumber = val;\r\n },\r\n get supportsPrinting() {\r\n  return PDFPrintServiceFactory.instance.supportsPrinting;\r\n },\r\n// saltdog disable presenation\r\n//  get supportsFullscreen() {\r\n//   return shadow(this, \"supportsFullscreen\", document.fullscreenEnabled || document.webkitFullscreenEnabled);\r\n//  },\r\n get supportsIntegratedFind() {\r\n  return this.externalServices.supportsIntegratedFind;\r\n },\r\n get supportsDocumentFonts() {\r\n  return this.externalServices.supportsDocumentFonts;\r\n },\r\n get loadingBar() {\r\n  const bar = new ProgressBar(\"#loadingBar\");\r\n  return shadow(this, \"loadingBar\", bar);\r\n },\r\n get supportedMouseWheelZoomModifierKeys() {\r\n  return this.externalServices.supportedMouseWheelZoomModifierKeys;\r\n },\r\n initPassiveLoading() {\r\n  throw new Error(\"Not implemented: initPassiveLoading\");\r\n },\r\n setTitleUsingUrl(url = \"\", downloadUrl = null) {\r\n  this.url = url;\r\n  this.baseUrl = url.split(\"#\")[0];\r\n  if (downloadUrl) {\r\n   this._downloadUrl = downloadUrl === url ? this.baseUrl : downloadUrl.split(\"#\")[0];\r\n  }\r\n  let title = getPdfFilenameFromUrl(url, \"\");\r\n  if (!title) {\r\n   try {\r\n    title = decodeURIComponent(getFilenameFromUrl(url)) || url;\r\n   } catch (ex) {\r\n    title = url;\r\n   }\r\n  }\r\n  this.setTitle(title);\r\n },\r\n setTitle(title) {\r\n  if (this.isViewerEmbedded) {\r\n   return;\r\n  }\r\n  document.title = title;\r\n },\r\n get _docFilename() {\r\n  return this._contentDispositionFilename || getPdfFilenameFromUrl(this.url);\r\n },\r\n _hideViewBookmark() {\r\n  const {toolbar, secondaryToolbar} = this.appConfig;\r\n  toolbar.viewBookmark.hidden = true;\r\n  secondaryToolbar.viewBookmarkButton.hidden = true;\r\n },\r\n _cancelIdleCallbacks() {\r\n  if (!this._idleCallbacks.size) {\r\n   return;\r\n  }\r\n  for (const callback of this._idleCallbacks) {\r\n   window.cancelIdleCallback(callback);\r\n  }\r\n  this._idleCallbacks.clear();\r\n },\r\n async close() {\r\n  this._unblockDocumentLoadEvent();\r\n  this._hideViewBookmark();\r\n  const {container} = this.appConfig.errorWrapper;\r\n  container.hidden = true;\r\n  if (!this.pdfLoadingTask) {\r\n   return;\r\n  }\r\n  if (this.pdfDocument?.annotationStorage.size > 0 && this._annotationStorageModified) {\r\n   try {\r\n    await this.save({ sourceEventType: \"save\" });\r\n   } catch (reason) {\r\n   }\r\n  }\r\n  const promises = [];\r\n  promises.push(this.pdfLoadingTask.destroy());\r\n  this.pdfLoadingTask = null;\r\n  if (this.pdfDocument) {\r\n   this.pdfDocument = null;\r\n   // sdpdfcore disable sidebar\r\n  //  this.pdfThumbnailViewer.setDocument(null);\r\n   this.pdfViewer.setDocument(null);\r\n   this.pdfLinkService.setDocument(null);\r\n   // saltdog disable documentProperties\r\n  //  this.pdfDocumentProperties.setDocument(null);\r\n  }\r\n  this.pdfLinkService.externalLinkEnabled = true;\r\n  this._fellback = false;\r\n  this.store = null;\r\n  this.isInitialViewSet = false;\r\n  this.downloadComplete = false;\r\n  this.url = \"\";\r\n  this.baseUrl = \"\";\r\n  this._downloadUrl = \"\";\r\n  this.documentInfo = null;\r\n  this.metadata = null;\r\n  this._contentDispositionFilename = null;\r\n  this._contentLength = null;\r\n  this._saveInProgress = false;\r\n  this._docStats = null;\r\n  this._cancelIdleCallbacks();\r\n  promises.push(this.pdfScriptingManager.destroyPromise);\r\n  // sdpdfcore disable sidebar\r\n  // this.pdfSidebar.reset();\r\n  // this.pdfOutlineViewer.reset();\r\n  // this.pdfAttachmentViewer.reset();\r\n  // this.pdfLayerViewer.reset();\r\n  this.pdfHistory?.reset();\r\n  this.findBar?.reset();\r\n  this.toolbar.reset();\r\n  this.secondaryToolbar.reset();\r\n  if (typeof PDFBug !== \"undefined\") {\r\n   PDFBug.cleanup();\r\n  }\r\n  await Promise.all(promises);\r\n },\r\n async open(file, args) {\r\n  if (this.pdfLoadingTask) {\r\n   await this.close();\r\n  }\r\n  const workerParameters = AppOptions.getAll(OptionKind.WORKER);\r\n  for (const key in workerParameters) {\r\n   GlobalWorkerOptions[key] = workerParameters[key];\r\n  }\r\n  const parameters = Object.create(null);\r\n  if (typeof file === \"string\") {\r\n   this.setTitleUsingUrl(file, file);\r\n   parameters.url = file;\r\n  } else if (file && \"byteLength\" in file) {\r\n   parameters.data = file;\r\n  } else if (file.url && file.originalUrl) {\r\n   this.setTitleUsingUrl(file.originalUrl, file.url);\r\n   parameters.url = file.url;\r\n  }\r\n  const apiParameters = AppOptions.getAll(OptionKind.API);\r\n  for (const key in apiParameters) {\r\n   let value = apiParameters[key];\r\n   if (key === \"docBaseUrl\" && !value) {\r\n    value = document.URL.split(\"#\")[0];\r\n   }\r\n   parameters[key] = value;\r\n  }\r\n  if (args) {\r\n   for (const key in args) {\r\n    parameters[key] = args[key];\r\n   }\r\n  }\r\n  const loadingTask = getDocument(parameters);\r\n  this.pdfLoadingTask = loadingTask;\r\n  loadingTask.onPassword = (updateCallback, reason) => {\r\n   this.pdfLinkService.externalLinkEnabled = false;\r\n   this.passwordPrompt.setUpdateCallback(updateCallback, reason);\r\n   this.passwordPrompt.open();\r\n  };\r\n  loadingTask.onProgress = ({loaded, total}) => {\r\n   this.progress(loaded / total);\r\n  };\r\n  loadingTask.onUnsupportedFeature = this.fallback.bind(this);\r\n  return loadingTask.promise.then(pdfDocument => {\r\n   this.load(pdfDocument);\r\n   // sdpdfcore 加入实例化批注模块 TODO: 密码\r\n   pdfDocument.getData().then( (data) => {\r\n    PDFViewerApplication.pdfAnnotateController = new AnnotateController(PDFViewerApplication,data);\r\n  })\r\n   \r\n  }, reason => {\r\n   if (loadingTask !== this.pdfLoadingTask) {\r\n    return undefined;\r\n   }\r\n   let key = \"loading_error\";\r\n   if (reason instanceof InvalidPDFException) {\r\n    key = \"invalid_file_error\";\r\n   } else if (reason instanceof MissingPDFException) {\r\n    key = \"missing_file_error\";\r\n   } else if (reason instanceof UnexpectedResponseException) {\r\n    key = \"unexpected_response_error\";\r\n   }\r\n   return this.l10n.get(key).then(msg => {\r\n    this._documentError(msg, { message: reason?.message });\r\n    throw reason;\r\n   });\r\n  });\r\n },\r\n _ensureDownloadComplete() {\r\n  if (this.pdfDocument && this.downloadComplete) {\r\n   return;\r\n  }\r\n  throw new Error(\"PDF document not downloaded.\");\r\n },\r\n async download({\r\n  sourceEventType = \"download\"\r\n } = {}) {\r\n  const url = this._downloadUrl, filename = this._docFilename;\r\n  try {\r\n   this._ensureDownloadComplete();\r\n   // sdpdfcore 批注后下载\r\n  //  const data = await this.pdfDocument.getData();\r\n  //  const blob = new Blob([data], { type: \"application/pdf\" });\r\n  //  await this.downloadManager.download(blob, url, filename, sourceEventType);\r\n  const blob = new Blob([this.pdfAnnotateController.getAnnotatedPDFBlob()], { type: \"application/pdf\" });\r\n  await this.downloadManager.download(blob, url, filename, sourceEventType);\r\n  } catch (reason) {\r\n    console.error(\"Download Failed, reason:\",reason);\r\n  //  await this.downloadManager.downloadUrl(url, filename);\r\n  }\r\n },\r\n async save({\r\n  sourceEventType = \"download\"\r\n } = {}) {\r\n  if (this._saveInProgress) {\r\n   return;\r\n  }\r\n  this._saveInProgress = true;\r\n  await this.pdfScriptingManager.dispatchWillSave();\r\n  const url = this._downloadUrl, filename = this._docFilename;\r\n  try {\r\n   this._ensureDownloadComplete();\r\n   const data = await this.pdfDocument.saveDocument();\r\n   const blob = new Blob([data], { type: \"application/pdf\" });\r\n   await this.downloadManager.download(blob, url, filename, sourceEventType);\r\n  } catch (reason) {\r\n   console.error(`Error when saving the document: ${ reason.message }`);\r\n   await this.download({ sourceEventType });\r\n  } finally {\r\n   await this.pdfScriptingManager.dispatchDidSave();\r\n   this._saveInProgress = false;\r\n  }\r\n },\r\n downloadOrSave(options) {\r\n  if (this.pdfDocument?.annotationStorage.size > 0) {\r\n   this.save(options);\r\n  } else {\r\n   this.download(options);\r\n  }\r\n },\r\n fallback(featureId) {\r\n  this.externalServices.reportTelemetry({\r\n   type: \"unsupportedFeature\",\r\n   featureId\r\n  });\r\n  if (this._fellback) {\r\n   return;\r\n  }\r\n  this._fellback = true;\r\n  this.externalServices.fallback({\r\n   featureId,\r\n   url: this.baseUrl\r\n  }).then(download => {\r\n   if (!download) {\r\n    return;\r\n   }\r\n   this.download({ sourceEventType: \"download\" });\r\n  });\r\n },\r\n _documentError(message, moreInfo = null) {\r\n  this._unblockDocumentLoadEvent();\r\n  this._otherError(message, moreInfo);\r\n  this.eventBus.dispatch(\"documenterror\", {\r\n   source: this,\r\n   message,\r\n   reason: moreInfo?.message ?? null\r\n  });\r\n },\r\n _otherError(message, moreInfo = null) {\r\n  const moreInfoText = [this.l10n.get(\"error_version_info\", {\r\n    version: version || \"?\",\r\n    build: build || \"?\"\r\n   })];\r\n  if (moreInfo) {\r\n   moreInfoText.push(this.l10n.get(\"error_message\", { message: moreInfo.message }));\r\n   if (moreInfo.stack) {\r\n    moreInfoText.push(this.l10n.get(\"error_stack\", { stack: moreInfo.stack }));\r\n   } else {\r\n    if (moreInfo.filename) {\r\n     moreInfoText.push(this.l10n.get(\"error_file\", { file: moreInfo.filename }));\r\n    }\r\n    if (moreInfo.lineNumber) {\r\n     moreInfoText.push(this.l10n.get(\"error_line\", { line: moreInfo.lineNumber }));\r\n    }\r\n   }\r\n  }\r\n  const errorWrapperConfig = this.appConfig.errorWrapper;\r\n  const errorWrapper = errorWrapperConfig.container;\r\n  errorWrapper.hidden = false;\r\n  const errorMessage = errorWrapperConfig.errorMessage;\r\n  errorMessage.textContent = message;\r\n  const closeButton = errorWrapperConfig.closeButton;\r\n  closeButton.onclick = function () {\r\n   errorWrapper.hidden = true;\r\n  };\r\n\r\n\r\n  \r\n  closeButton.oncontextmenu = noContextMenuHandler;\r\n\r\n },\r\n progress(level) {\r\n  if (this.downloadComplete) {\r\n   return;\r\n  }\r\n  const percent = Math.round(level * 100);\r\n  if (percent > this.loadingBar.percent || isNaN(percent)) {\r\n   this.loadingBar.percent = percent;\r\n   const disableAutoFetch = this.pdfDocument ? this.pdfDocument.loadingParams.disableAutoFetch : AppOptions.get(\"disableAutoFetch\");\r\n   if (disableAutoFetch && percent) {\r\n    if (this.disableAutoFetchLoadingBarTimeout) {\r\n     clearTimeout(this.disableAutoFetchLoadingBarTimeout);\r\n     this.disableAutoFetchLoadingBarTimeout = null;\r\n    }\r\n    this.loadingBar.show();\r\n    this.disableAutoFetchLoadingBarTimeout = setTimeout(() => {\r\n     this.loadingBar.hide();\r\n     this.disableAutoFetchLoadingBarTimeout = null;\r\n    }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);\r\n   }\r\n  }\r\n },\r\n load(pdfDocument) {\r\n  this.pdfDocument = pdfDocument;\r\n  pdfDocument.getDownloadInfo().then(({length}) => {\r\n   this._contentLength = length;\r\n   this.downloadComplete = true;\r\n   this.loadingBar.hide();\r\n   firstPagePromise.then(() => {\r\n    this.eventBus.dispatch(\"documentloaded\", { source: this });\r\n   });\r\n  });\r\n  const pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {\r\n  });\r\n  const pageModePromise = pdfDocument.getPageMode().catch(function () {\r\n  });\r\n  const openActionPromise = pdfDocument.getOpenAction().catch(function () {\r\n  });\r\n  this.toolbar.setPagesCount(pdfDocument.numPages, false);\r\n  this.secondaryToolbar.setPagesCount(pdfDocument.numPages);\r\n  let baseDocumentUrl;\r\n  baseDocumentUrl = null;\r\n  this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);\r\n  // saltdog disable documentProperties\r\n  // this.pdfDocumentProperties.setDocument(pdfDocument, this.url);\r\n  const pdfViewer = this.pdfViewer;\r\n  pdfViewer.setDocument(pdfDocument);\r\n  const {firstPagePromise, onePageRendered, pagesPromise} = pdfViewer;\r\n  // sdpdfcore disable sidebar\r\n  // const pdfThumbnailViewer = this.pdfThumbnailViewer;\r\n  // pdfThumbnailViewer.setDocument(pdfDocument);\r\n  const storedPromise = (this.store = new ViewHistory(pdfDocument.fingerprints[0])).getMultiple({\r\n   page: null,\r\n   zoom: DEFAULT_SCALE_VALUE,\r\n   scrollLeft: \"0\",\r\n   scrollTop: \"0\",\r\n   rotation: null,\r\n   // sdpdfcore disable sidebar\r\n  //  sidebarView: SidebarView.UNKNOWN,\r\n   scrollMode: ScrollMode.UNKNOWN,\r\n   spreadMode: SpreadMode.UNKNOWN\r\n  }).catch(() => {\r\n   return Object.create(null);\r\n  });\r\n  firstPagePromise.then(pdfPage => {\r\n   this.loadingBar.setWidth(this.appConfig.viewerContainer);\r\n   this._initializeAnnotationStorageCallbacks(pdfDocument);\r\n   Promise.all([\r\n    animationStarted,\r\n    storedPromise,\r\n    pageLayoutPromise,\r\n    pageModePromise,\r\n    openActionPromise\r\n   ]).then(async ([timeStamp, stored, pageLayout, pageMode, openAction]) => {\r\n    const viewOnLoad = AppOptions.get(\"viewOnLoad\");\r\n    this._initializePdfHistory({\r\n     fingerprint: pdfDocument.fingerprints[0],\r\n     viewOnLoad,\r\n     initialDest: openAction?.dest\r\n    });\r\n    const initialBookmark = this.initialBookmark;\r\n    const zoom = AppOptions.get(\"defaultZoomValue\");\r\n    let hash = zoom ? `zoom=${ zoom }` : null;\r\n    let rotation = null;\r\n    // sdpdfcore disable sidebar\r\n    // let sidebarView = AppOptions.get(\"sidebarViewOnLoad\");\r\n    let scrollMode = AppOptions.get(\"scrollModeOnLoad\");\r\n    let spreadMode = AppOptions.get(\"spreadModeOnLoad\");\r\n    if (stored.page && viewOnLoad !== ViewOnLoad.INITIAL) {\r\n     hash = `page=${ stored.page }&zoom=${ zoom || stored.zoom },` + `${ stored.scrollLeft },${ stored.scrollTop }`;\r\n     rotation = parseInt(stored.rotation, 10);\r\n     // sdpdfcore disable sidebar\r\n    //  if (sidebarView === SidebarView.UNKNOWN) {\r\n    //   sidebarView = stored.sidebarView | 0;\r\n    //  }\r\n     if (scrollMode === ScrollMode.UNKNOWN) {\r\n      scrollMode = stored.scrollMode | 0;\r\n     }\r\n     if (spreadMode === SpreadMode.UNKNOWN) {\r\n      spreadMode = stored.spreadMode | 0;\r\n     }\r\n    }\r\n    // sdpdfcore disable sidebar\r\n    // if (pageMode && sidebarView === SidebarView.UNKNOWN) {\r\n    //  sidebarView = apiPageModeToSidebarView(pageMode);\r\n    // }\r\n    if (pageLayout && scrollMode === ScrollMode.UNKNOWN && spreadMode === SpreadMode.UNKNOWN) {\r\n     const modes = apiPageLayoutToViewerModes(pageLayout);\r\n     spreadMode = modes.spreadMode;\r\n    }\r\n    this.setInitialView(hash, {\r\n     rotation,\r\n     // sdpdfcore disable sidebar\r\n    //  sidebarView,\r\n     scrollMode,\r\n     spreadMode\r\n    });\r\n    this.eventBus.dispatch(\"documentinit\", { source: this });\r\n    if (!this.isViewerEmbedded) {\r\n     pdfViewer.focus();\r\n    }\r\n    await Promise.race([\r\n     pagesPromise,\r\n     new Promise(resolve => {\r\n      setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT);\r\n     })\r\n    ]);\r\n    if (!initialBookmark && !hash) {\r\n     return;\r\n    }\r\n    if (pdfViewer.hasEqualPageSizes) {\r\n     return;\r\n    }\r\n    this.initialBookmark = initialBookmark;\r\n    pdfViewer.currentScaleValue = pdfViewer.currentScaleValue;\r\n    this.setInitialView(hash);\r\n   }).catch(() => {\r\n    this.setInitialView();\r\n   }).then(function () {\r\n    pdfViewer.update();\r\n   });\r\n  });\r\n  pagesPromise.then(() => {\r\n   this._unblockDocumentLoadEvent();\r\n   this._initializeAutoPrint(pdfDocument, openActionPromise);\r\n  }, reason => {\r\n   this.l10n.get(\"loading_error\").then(msg => {\r\n    this._documentError(msg, { message: reason?.message });\r\n   });\r\n  });\r\n  onePageRendered.then(data => {\r\n   this.externalServices.reportTelemetry({\r\n    type: \"pageInfo\",\r\n    timestamp: data.timestamp\r\n   });\r\n   // sdpdfcore disable sidebar\r\n  //  pdfDocument.getOutline().then(outline => {\r\n  //   if (pdfDocument !== this.pdfDocument) {\r\n  //    return;\r\n  //   }\r\n  //   this.pdfOutlineViewer.render({\r\n  //    outline,\r\n  //    pdfDocument\r\n  //   });\r\n  //  });\r\n  //  pdfDocument.getAttachments().then(attachments => {\r\n  //   if (pdfDocument !== this.pdfDocument) {\r\n  //    return;\r\n  //   }\r\n  //   this.pdfAttachmentViewer.render({ attachments });\r\n  //  });\r\n  //  pdfViewer.optionalContentConfigPromise.then(optionalContentConfig => {\r\n  //   if (pdfDocument !== this.pdfDocument) {\r\n  //    return;\r\n  //   }\r\n  //   this.pdfLayerViewer.render({\r\n  //    optionalContentConfig,\r\n  //    pdfDocument\r\n  //   });\r\n  //  });\r\n   if (\"requestIdleCallback\" in window) {\r\n    const callback = window.requestIdleCallback(() => {\r\n     this._collectTelemetry(pdfDocument);\r\n     this._idleCallbacks.delete(callback);\r\n    }, { timeout: 1000 });\r\n    this._idleCallbacks.add(callback);\r\n   }\r\n  });\r\n  this._initializePageLabels(pdfDocument);\r\n  this._initializeMetadata(pdfDocument);\r\n },\r\n async _scriptingDocProperties(pdfDocument) {\r\n  if (!this.documentInfo) {\r\n   await new Promise(resolve => {\r\n    this.eventBus._on(\"metadataloaded\", resolve, { once: true });\r\n   });\r\n   if (pdfDocument !== this.pdfDocument) {\r\n    return null;\r\n   }\r\n  }\r\n  if (!this._contentLength) {\r\n   await new Promise(resolve => {\r\n    this.eventBus._on(\"documentloaded\", resolve, { once: true });\r\n   });\r\n   if (pdfDocument !== this.pdfDocument) {\r\n    return null;\r\n   }\r\n  }\r\n  return {\r\n   ...this.documentInfo,\r\n   baseURL: this.baseUrl,\r\n   filesize: this._contentLength,\r\n   filename: this._docFilename,\r\n   metadata: this.metadata?.getRaw(),\r\n   authors: this.metadata?.get(\"dc:creator\"),\r\n   numPages: this.pagesCount,\r\n   URL: this.url\r\n  };\r\n },\r\n async _collectTelemetry(pdfDocument) {\r\n  const markInfo = await this.pdfDocument.getMarkInfo();\r\n  if (pdfDocument !== this.pdfDocument) {\r\n   return;\r\n  }\r\n  const tagged = markInfo?.Marked || false;\r\n  this.externalServices.reportTelemetry({\r\n   type: \"tagged\",\r\n   tagged\r\n  });\r\n },\r\n async _initializeAutoPrint(pdfDocument, openActionPromise) {\r\n  const [openAction, javaScript] = await Promise.all([\r\n   openActionPromise,\r\n   !this.pdfViewer.enableScripting ? pdfDocument.getJavaScript() : null\r\n  ]);\r\n  if (pdfDocument !== this.pdfDocument) {\r\n   return;\r\n  }\r\n  let triggerAutoPrint = false;\r\n  if (openAction?.action === \"Print\") {\r\n   triggerAutoPrint = true;\r\n  }\r\n  if (javaScript) {\r\n   javaScript.some(js => {\r\n    if (!js) {\r\n     return false;\r\n    }\r\n    console.warn(\"Warning: JavaScript support is not enabled\");\r\n    this.fallback(UNSUPPORTED_FEATURES.javaScript);\r\n    return true;\r\n   });\r\n   if (!triggerAutoPrint) {\r\n    for (const js of javaScript) {\r\n     if (js && AutoPrintRegExp.test(js)) {\r\n      triggerAutoPrint = true;\r\n      break;\r\n     }\r\n    }\r\n   }\r\n  }\r\n  if (triggerAutoPrint) {\r\n   this.triggerPrinting();\r\n  }\r\n },\r\n async _initializeMetadata(pdfDocument) {\r\n  const {info, metadata, contentDispositionFilename, contentLength} = await pdfDocument.getMetadata();\r\n  if (pdfDocument !== this.pdfDocument) {\r\n   return;\r\n  }\r\n  this.documentInfo = info;\r\n  this.metadata = metadata;\r\n  this._contentDispositionFilename ??= contentDispositionFilename;\r\n  this._contentLength ??= contentLength;\r\n  console.log(`PDF ${ pdfDocument.fingerprints[0] } [${ info.PDFFormatVersion } ` + `${ (info.Producer || \"-\").trim() } / ${ (info.Creator || \"-\").trim() }] ` + `(PDF.js: ${ version || \"-\" })`);\r\n  let pdfTitle = info?.Title;\r\n  const metadataTitle = metadata?.get(\"dc:title\");\r\n  if (metadataTitle) {\r\n   if (metadataTitle !== \"Untitled\" && !/[\\uFFF0-\\uFFFF]/g.test(metadataTitle)) {\r\n    pdfTitle = metadataTitle;\r\n   }\r\n  }\r\n  if (pdfTitle) {\r\n   this.setTitle(`${ pdfTitle } - ${ contentDispositionFilename || document.title }`);\r\n  } else if (contentDispositionFilename) {\r\n   this.setTitle(contentDispositionFilename);\r\n  }\r\n  if (info.IsXFAPresent && !info.IsAcroFormPresent && !pdfDocument.isPureXfa) {\r\n   if (pdfDocument.loadingParams.enableXfa) {\r\n    console.warn(\"Warning: XFA Foreground documents are not supported\");\r\n   } else {\r\n    console.warn(\"Warning: XFA support is not enabled\");\r\n   }\r\n   this.fallback(UNSUPPORTED_FEATURES.forms);\r\n  } else if ((info.IsAcroFormPresent || info.IsXFAPresent) && !this.pdfViewer.renderForms) {\r\n   console.warn(\"Warning: Interactive form support is not enabled\");\r\n   this.fallback(UNSUPPORTED_FEATURES.forms);\r\n  }\r\n  if (info.IsSignaturesPresent) {\r\n   console.warn(\"Warning: Digital signatures validation is not supported\");\r\n   this.fallback(UNSUPPORTED_FEATURES.signatures);\r\n  }\r\n  let versionId = \"other\";\r\n  if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {\r\n   versionId = `v${ info.PDFFormatVersion.replace(\".\", \"_\") }`;\r\n  }\r\n  let generatorId = \"other\";\r\n  if (info.Producer) {\r\n   const producer = info.Producer.toLowerCase();\r\n   KNOWN_GENERATORS.some(function (generator) {\r\n    if (!producer.includes(generator)) {\r\n     return false;\r\n    }\r\n    generatorId = generator.replace(/[ .-]/g, \"_\");\r\n    return true;\r\n   });\r\n  }\r\n  let formType = null;\r\n  if (info.IsXFAPresent) {\r\n   formType = \"xfa\";\r\n  } else if (info.IsAcroFormPresent) {\r\n   formType = \"acroform\";\r\n  }\r\n  this.externalServices.reportTelemetry({\r\n   type: \"documentInfo\",\r\n   version: versionId,\r\n   generator: generatorId,\r\n   formType\r\n  });\r\n  this.eventBus.dispatch(\"metadataloaded\", { source: this });\r\n },\r\n async _initializePageLabels(pdfDocument) {\r\n  const labels = await pdfDocument.getPageLabels();\r\n  if (pdfDocument !== this.pdfDocument) {\r\n   return;\r\n  }\r\n  if (!labels || AppOptions.get(\"disablePageLabels\")) {\r\n   return;\r\n  }\r\n  const numLabels = labels.length;\r\n  let standardLabels = 0, emptyLabels = 0;\r\n  for (let i = 0; i < numLabels; i++) {\r\n   const label = labels[i];\r\n   if (label === (i + 1).toString()) {\r\n    standardLabels++;\r\n   } else if (label === \"\") {\r\n    emptyLabels++;\r\n   } else {\r\n    break;\r\n   }\r\n  }\r\n  if (standardLabels >= numLabels || emptyLabels >= numLabels) {\r\n   return;\r\n  }\r\n  // sdpdfcore disable sidebar\r\n  const {pdfViewer, /*pdfThumbnailViewer,*/ toolbar} = this;\r\n  pdfViewer.setPageLabels(labels);\r\n  // pdfThumbnailViewer.setPageLabels(labels);\r\n  toolbar.setPagesCount(numLabels, true);\r\n  toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);\r\n },\r\n _initializePdfHistory({fingerprint, viewOnLoad, initialDest = null}) {\r\n  if (!this.pdfHistory) {\r\n   return;\r\n  }\r\n  this.pdfHistory.initialize({\r\n   fingerprint,\r\n   resetHistory: viewOnLoad === ViewOnLoad.INITIAL,\r\n   updateUrl: AppOptions.get(\"historyUpdateUrl\")\r\n  });\r\n  if (this.pdfHistory.initialBookmark) {\r\n   this.initialBookmark = this.pdfHistory.initialBookmark;\r\n   this.initialRotation = this.pdfHistory.initialRotation;\r\n  }\r\n  if (initialDest && !this.initialBookmark && viewOnLoad === ViewOnLoad.UNKNOWN) {\r\n   this.initialBookmark = JSON.stringify(initialDest);\r\n   this.pdfHistory.push({\r\n    explicitDest: initialDest,\r\n    pageNumber: null\r\n   });\r\n  }\r\n },\r\n _initializeAnnotationStorageCallbacks(pdfDocument) {\r\n  if (pdfDocument !== this.pdfDocument) {\r\n   return;\r\n  }\r\n  const {annotationStorage} = pdfDocument;\r\n  annotationStorage.onSetModified = () => {\r\n   window.addEventListener(\"beforeunload\", beforeUnload);\r\n   this._annotationStorageModified = true;\r\n  };\r\n  annotationStorage.onResetModified = () => {\r\n   window.removeEventListener(\"beforeunload\", beforeUnload);\r\n   delete this._annotationStorageModified;\r\n  };\r\n },\r\n // sdpdfcore disable sidebar\r\n setInitialView(storedHash, {rotation, /*sidebarView,*/ scrollMode, spreadMode} = {}) {\r\n  const setRotation = angle => {\r\n   if (isValidRotation(angle)) {\r\n    this.pdfViewer.pagesRotation = angle;\r\n   }\r\n  };\r\n  const setViewerModes = (scroll, spread) => {\r\n   if (isValidScrollMode(scroll)) {\r\n    this.pdfViewer.scrollMode = scroll;\r\n   }\r\n   if (isValidSpreadMode(spread)) {\r\n    this.pdfViewer.spreadMode = spread;\r\n   }\r\n  };\r\n  this.isInitialViewSet = true;\r\n  // sdpdfcore disable sidebar\r\n  // this.pdfSidebar.setInitialView(sidebarView);\r\n  setViewerModes(scrollMode, spreadMode);\r\n  if (this.initialBookmark) {\r\n   setRotation(this.initialRotation);\r\n   delete this.initialRotation;\r\n   this.pdfLinkService.setHash(this.initialBookmark);\r\n   this.initialBookmark = null;\r\n  } else if (storedHash) {\r\n   setRotation(rotation);\r\n   this.pdfLinkService.setHash(storedHash);\r\n  }\r\n  this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel);\r\n  this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);\r\n  if (!this.pdfViewer.currentScaleValue) {\r\n   this.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE;\r\n  }\r\n },\r\n _cleanup() {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  this.pdfViewer.cleanup();\r\n  // sdpdfcore disable sidebar\r\n  // this.pdfThumbnailViewer.cleanup();\r\n  this.pdfDocument.cleanup(this.pdfViewer.renderer === RendererType.SVG);\r\n },\r\n forceRendering() {\r\n  this.pdfRenderingQueue.printing = !!this.printService;\r\n  // sdpdfcore disable sidebar\r\n  // this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;\r\n  this.pdfRenderingQueue.renderHighestPriority();\r\n },\r\n beforePrint() {\r\n  this.pdfScriptingManager.dispatchWillPrint();\r\n  if (this.printService) {\r\n   return;\r\n  }\r\n  if (!this.supportsPrinting) {\r\n   this.l10n.get(\"printing_not_supported\").then(msg => {\r\n    this._otherError(msg);\r\n   });\r\n   return;\r\n  }\r\n  if (!this.pdfViewer.pageViewsReady) {\r\n   this.l10n.get(\"printing_not_ready\").then(msg => {\r\n    window.alert(msg);\r\n   });\r\n   return;\r\n  }\r\n  const pagesOverview = this.pdfViewer.getPagesOverview();\r\n  const printContainer = this.appConfig.printContainer;\r\n  const printResolution = AppOptions.get(\"printResolution\");\r\n  const optionalContentConfigPromise = this.pdfViewer.optionalContentConfigPromise;\r\n  const printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, this.l10n);\r\n  this.printService = printService;\r\n  this.forceRendering();\r\n  printService.layout();\r\n  this.externalServices.reportTelemetry({ type: \"print\" });\r\n },\r\n afterPrint() {\r\n  this.pdfScriptingManager.dispatchDidPrint();\r\n  if (this.printService) {\r\n   this.printService.destroy();\r\n   this.printService = null;\r\n   this.pdfDocument?.annotationStorage.resetModified();\r\n  }\r\n  this.forceRendering();\r\n },\r\n rotatePages(delta) {\r\n  this.pdfViewer.pagesRotation += delta;\r\n },\r\n // saltdog disable presentation\r\n//  requestPresentationMode() {\r\n//   this.pdfPresentationMode?.request();\r\n//  },\r\n triggerPrinting() {\r\n  if (!this.supportsPrinting) {\r\n   return;\r\n  }\r\n  window.print();\r\n },\r\n bindEvents() {\r\n  const {eventBus, _boundEvents} = this;\r\n  _boundEvents.beforePrint = this.beforePrint.bind(this);\r\n  _boundEvents.afterPrint = this.afterPrint.bind(this);\r\n  eventBus._on(\"resize\", webViewerResize);\r\n  eventBus._on(\"hashchange\", webViewerHashchange);\r\n  eventBus._on(\"beforeprint\", _boundEvents.beforePrint);\r\n  eventBus._on(\"afterprint\", _boundEvents.afterPrint);\r\n  eventBus._on(\"pagerendered\", webViewerPageRendered);\r\n  eventBus._on(\"updateviewarea\", webViewerUpdateViewarea);\r\n  eventBus._on(\"pagechanging\", webViewerPageChanging);\r\n  eventBus._on(\"scalechanging\", webViewerScaleChanging);\r\n  eventBus._on(\"rotationchanging\", webViewerRotationChanging);\r\n  // eventBus._on(\"sidebarviewchanged\", webViewerSidebarViewChanged);\r\n  // sdpdfcore disable sidebar\r\n  // eventBus._on(\"pagemode\", webViewerPageMode);\r\n  eventBus._on(\"namedaction\", webViewerNamedAction);\r\n  // saltdog disable presentation\r\n  // eventBus._on(\"presentationmodechanged\", webViewerPresentationModeChanged);\r\n  // eventBus._on(\"presentationmode\", webViewerPresentationMode);\r\n  eventBus._on(\"print\", webViewerPrint);\r\n  eventBus._on(\"download\", webViewerDownload);\r\n  eventBus._on(\"save\", webViewerSave);\r\n  eventBus._on(\"firstpage\", webViewerFirstPage);\r\n  eventBus._on(\"lastpage\", webViewerLastPage);\r\n  eventBus._on(\"nextpage\", webViewerNextPage);\r\n  eventBus._on(\"previouspage\", webViewerPreviousPage);\r\n  eventBus._on(\"zoomin\", webViewerZoomIn);\r\n  eventBus._on(\"zoomout\", webViewerZoomOut);\r\n  eventBus._on(\"zoomreset\", webViewerZoomReset);\r\n  eventBus._on(\"pagenumberchanged\", webViewerPageNumberChanged);\r\n  eventBus._on(\"scalechanged\", webViewerScaleChanged);\r\n  eventBus._on(\"rotatecw\", webViewerRotateCw);\r\n  eventBus._on(\"rotateccw\", webViewerRotateCcw);\r\n  eventBus._on(\"optionalcontentconfig\", webViewerOptionalContentConfig);\r\n  eventBus._on(\"switchscrollmode\", webViewerSwitchScrollMode);\r\n  eventBus._on(\"scrollmodechanged\", webViewerScrollModeChanged);\r\n  eventBus._on(\"switchspreadmode\", webViewerSwitchSpreadMode);\r\n  eventBus._on(\"spreadmodechanged\", webViewerSpreadModeChanged);\r\n  // saltdog disable documentProperties\r\n  // eventBus._on(\"documentproperties\", webViewerDocumentProperties);\r\n  eventBus._on(\"findfromurlhash\", webViewerFindFromUrlHash);\r\n  eventBus._on(\"updatefindmatchescount\", webViewerUpdateFindMatchesCount);\r\n  eventBus._on(\"updatefindcontrolstate\", webViewerUpdateFindControlState);\r\n  if (AppOptions.get(\"pdfBug\")) {\r\n   _boundEvents.reportPageStatsPDFBug = reportPageStatsPDFBug;\r\n   eventBus._on(\"pagerendered\", _boundEvents.reportPageStatsPDFBug);\r\n   eventBus._on(\"pagechanging\", _boundEvents.reportPageStatsPDFBug);\r\n  }\r\n  eventBus._on(\"fileinputchange\", webViewerFileInputChange);\r\n  eventBus._on(\"openfile\", webViewerOpenFile);\r\n },\r\n bindWindowEvents() {\r\n  const {eventBus, _boundEvents} = this;\r\n  _boundEvents.windowResize = () => {\r\n   eventBus.dispatch(\"resize\", { source: window });\r\n  };\r\n  _boundEvents.windowHashChange = () => {\r\n   eventBus.dispatch(\"hashchange\", {\r\n    source: window,\r\n    hash: document.location.hash.substring(1)\r\n   });\r\n  };\r\n  _boundEvents.windowBeforePrint = () => {\r\n   eventBus.dispatch(\"beforeprint\", { source: window });\r\n  };\r\n  _boundEvents.windowAfterPrint = () => {\r\n   eventBus.dispatch(\"afterprint\", { source: window });\r\n  };\r\n  _boundEvents.windowUpdateFromSandbox = event => {\r\n   eventBus.dispatch(\"updatefromsandbox\", {\r\n    source: window,\r\n    detail: event.detail\r\n   });\r\n  };\r\n  window.addEventListener(\"visibilitychange\", webViewerVisibilityChange);\r\n  window.addEventListener(\"wheel\", webViewerWheel, { passive: false });\r\n  window.addEventListener(\"touchstart\", webViewerTouchStart, { passive: false });\r\n  window.addEventListener(\"click\", webViewerClick);\r\n  window.addEventListener(\"keydown\", webViewerKeyDown);\r\n  window.addEventListener(\"resize\", _boundEvents.windowResize);\r\n  window.addEventListener(\"hashchange\", _boundEvents.windowHashChange);\r\n  window.addEventListener(\"beforeprint\", _boundEvents.windowBeforePrint);\r\n  window.addEventListener(\"afterprint\", _boundEvents.windowAfterPrint);\r\n  window.addEventListener(\"updatefromsandbox\", _boundEvents.windowUpdateFromSandbox);\r\n },\r\n unbindEvents() {\r\n  const {eventBus, _boundEvents} = this;\r\n  eventBus._off(\"resize\", webViewerResize);\r\n  eventBus._off(\"hashchange\", webViewerHashchange);\r\n  eventBus._off(\"beforeprint\", _boundEvents.beforePrint);\r\n  eventBus._off(\"afterprint\", _boundEvents.afterPrint);\r\n  eventBus._off(\"pagerendered\", webViewerPageRendered);\r\n  eventBus._off(\"updateviewarea\", webViewerUpdateViewarea);\r\n  eventBus._off(\"pagechanging\", webViewerPageChanging);\r\n  eventBus._off(\"scalechanging\", webViewerScaleChanging);\r\n  eventBus._off(\"rotationchanging\", webViewerRotationChanging);\r\n  // eventBus._off(\"sidebarviewchanged\", webViewerSidebarViewChanged);\r\n  // sdpdfcore disable sidebar\r\n  // eventBus._off(\"pagemode\", webViewerPageMode);\r\n  eventBus._off(\"namedaction\", webViewerNamedAction);\r\n  // saltdog disable presentation\r\n  // eventBus._off(\"presentationmodechanged\", webViewerPresentationModeChanged);\r\n  // eventBus._off(\"presentationmode\", webViewerPresentationMode);\r\n  eventBus._off(\"print\", webViewerPrint);\r\n  eventBus._off(\"download\", webViewerDownload);\r\n  eventBus._off(\"save\", webViewerSave);\r\n  eventBus._off(\"firstpage\", webViewerFirstPage);\r\n  eventBus._off(\"lastpage\", webViewerLastPage);\r\n  eventBus._off(\"nextpage\", webViewerNextPage);\r\n  eventBus._off(\"previouspage\", webViewerPreviousPage);\r\n  eventBus._off(\"zoomin\", webViewerZoomIn);\r\n  eventBus._off(\"zoomout\", webViewerZoomOut);\r\n  eventBus._off(\"zoomreset\", webViewerZoomReset);\r\n  eventBus._off(\"pagenumberchanged\", webViewerPageNumberChanged);\r\n  eventBus._off(\"scalechanged\", webViewerScaleChanged);\r\n  eventBus._off(\"rotatecw\", webViewerRotateCw);\r\n  eventBus._off(\"rotateccw\", webViewerRotateCcw);\r\n  eventBus._off(\"optionalcontentconfig\", webViewerOptionalContentConfig);\r\n  eventBus._off(\"switchscrollmode\", webViewerSwitchScrollMode);\r\n  eventBus._off(\"scrollmodechanged\", webViewerScrollModeChanged);\r\n  eventBus._off(\"switchspreadmode\", webViewerSwitchSpreadMode);\r\n  eventBus._off(\"spreadmodechanged\", webViewerSpreadModeChanged);\r\n  // saltdog disable documentProperties\r\n  // eventBus._off(\"documentproperties\", webViewerDocumentProperties);\r\n  eventBus._off(\"findfromurlhash\", webViewerFindFromUrlHash);\r\n  eventBus._off(\"updatefindmatchescount\", webViewerUpdateFindMatchesCount);\r\n  eventBus._off(\"updatefindcontrolstate\", webViewerUpdateFindControlState);\r\n  if (_boundEvents.reportPageStatsPDFBug) {\r\n   eventBus._off(\"pagerendered\", _boundEvents.reportPageStatsPDFBug);\r\n   eventBus._off(\"pagechanging\", _boundEvents.reportPageStatsPDFBug);\r\n   _boundEvents.reportPageStatsPDFBug = null;\r\n  }\r\n  eventBus._off(\"fileinputchange\", webViewerFileInputChange);\r\n  eventBus._off(\"openfile\", webViewerOpenFile);\r\n  _boundEvents.beforePrint = null;\r\n  _boundEvents.afterPrint = null;\r\n },\r\n unbindWindowEvents() {\r\n  const {_boundEvents} = this;\r\n  window.removeEventListener(\"visibilitychange\", webViewerVisibilityChange);\r\n  window.removeEventListener(\"wheel\", webViewerWheel, { passive: false });\r\n  window.removeEventListener(\"touchstart\", webViewerTouchStart, { passive: false });\r\n  window.removeEventListener(\"click\", webViewerClick);\r\n  window.removeEventListener(\"keydown\", webViewerKeyDown);\r\n  window.removeEventListener(\"resize\", _boundEvents.windowResize);\r\n  window.removeEventListener(\"hashchange\", _boundEvents.windowHashChange);\r\n  window.removeEventListener(\"beforeprint\", _boundEvents.windowBeforePrint);\r\n  window.removeEventListener(\"afterprint\", _boundEvents.windowAfterPrint);\r\n  window.removeEventListener(\"updatefromsandbox\", _boundEvents.windowUpdateFromSandbox);\r\n  _boundEvents.windowResize = null;\r\n  _boundEvents.windowHashChange = null;\r\n  _boundEvents.windowBeforePrint = null;\r\n  _boundEvents.windowAfterPrint = null;\r\n  _boundEvents.windowUpdateFromSandbox = null;\r\n },\r\n accumulateWheelTicks(ticks) {\r\n  if (this._wheelUnusedTicks > 0 && ticks < 0 || this._wheelUnusedTicks < 0 && ticks > 0) {\r\n   this._wheelUnusedTicks = 0;\r\n  }\r\n  this._wheelUnusedTicks += ticks;\r\n  const wholeTicks = Math.sign(this._wheelUnusedTicks) * Math.floor(Math.abs(this._wheelUnusedTicks));\r\n  this._wheelUnusedTicks -= wholeTicks;\r\n  return wholeTicks;\r\n },\r\n _unblockDocumentLoadEvent() {\r\n  if (document.blockUnblockOnload) {\r\n   document.blockUnblockOnload(false);\r\n  }\r\n  this._unblockDocumentLoadEvent = () => {\r\n  };\r\n },\r\n _reportDocumentStatsTelemetry() {\r\n  const {stats} = this.pdfDocument;\r\n  if (stats !== this._docStats) {\r\n   this._docStats = stats;\r\n   this.externalServices.reportTelemetry({\r\n    type: \"documentStats\",\r\n    stats\r\n   });\r\n  }\r\n },\r\n get scriptingReady() {\r\n  return this.pdfScriptingManager.ready;\r\n }\r\n};\r\nlet validateFileURL;\r\n{\r\n const HOSTED_VIEWER_ORIGINS = [\r\n  \"null\",\r\n  \"http://mozilla.github.io\",\r\n  \"https://mozilla.github.io\"\r\n ];\r\n validateFileURL = function (file) {\r\n  if (file === undefined) {\r\n   return;\r\n  }\r\n  try {\r\n   const viewerOrigin = new URL(window.location.href).origin || \"null\";\r\n   if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) {\r\n    return;\r\n   }\r\n   const {origin, protocol} = new URL(file, window.location.href);\r\n   if (origin !== viewerOrigin && protocol !== \"blob:\") {\r\n    throw new Error(\"file origin does not match viewer's\");\r\n   }\r\n  } catch (ex) {\r\n   PDFViewerApplication.l10n.get(\"loading_error\").then(msg => {\r\n    PDFViewerApplication._documentError(msg, { message: ex?.message });\r\n   });\r\n   throw ex;\r\n  }\r\n };\r\n}\r\nasync function loadFakeWorker() {\r\n if (!GlobalWorkerOptions.workerSrc) {\r\n  GlobalWorkerOptions.workerSrc = AppOptions.get(\"workerSrc\");\r\n }\r\n window.pdfjsWorker = await import(\"pdfjs-dist/build/pdf.worker\");\r\n}\r\nasync function initPDFBug(enabledTabs) {\r\n const {debuggerScriptPath, mainContainer} = PDFViewerApplication.appConfig;\r\n await loadScript(debuggerScriptPath);\r\n PDFBug.init({ OPS }, mainContainer, enabledTabs);\r\n}\r\nfunction reportPageStatsPDFBug({pageNumber}) {\r\n if (typeof Stats === \"undefined\" || !Stats.enabled) {\r\n  return;\r\n }\r\n const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1);\r\n const pageStats = pageView?.pdfPage?.stats;\r\n if (!pageStats) {\r\n  return;\r\n }\r\n Stats.add(pageNumber, pageStats);\r\n}\r\n\r\nfunction webViewerInitialized() {\r\n const appConfig = PDFViewerApplication.appConfig;\r\n let file;\r\n const queryString = document.location.search.substring(1);\r\n const params = parseQueryString(queryString);\r\n // sdpdfcore loadFile\r\n file = params.get(\"file\") ?? AppOptions.get(\"fileBlob\");\r\n //validateFileURL(file);\r\n const fileInput = document.createElement(\"input\");\r\n fileInput.id = appConfig.openFileInputName;\r\n fileInput.className = \"fileInput\";\r\n fileInput.setAttribute(\"type\", \"file\");\r\n fileInput.oncontextmenu = noContextMenuHandler;\r\n document.body.appendChild(fileInput);\r\n if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {\r\n  appConfig.toolbar.openFile.hidden = true;\r\n  appConfig.secondaryToolbar.openFileButton.hidden = true;\r\n } else {\r\n  fileInput.value = null;\r\n }\r\n fileInput.addEventListener(\"change\", function (evt) {\r\n  const files = evt.target.files;\r\n  if (!files || files.length === 0) {\r\n   return;\r\n  }\r\n  PDFViewerApplication.eventBus.dispatch(\"fileinputchange\", {\r\n   source: this,\r\n   fileInput: evt.target\r\n  });\r\n });\r\n appConfig.mainContainer.addEventListener(\"dragover\", function (evt) {\r\n  evt.preventDefault();\r\n  evt.dataTransfer.dropEffect = \"move\";\r\n });\r\n appConfig.mainContainer.addEventListener(\"drop\", function (evt) {\r\n  evt.preventDefault();\r\n  const files = evt.dataTransfer.files;\r\n  if (!files || files.length === 0) {\r\n   return;\r\n  }\r\n  PDFViewerApplication.eventBus.dispatch(\"fileinputchange\", {\r\n   source: this,\r\n   fileInput: evt.dataTransfer\r\n  });\r\n });\r\n if (!PDFViewerApplication.supportsDocumentFonts) {\r\n  AppOptions.set(\"disableFontFace\", true);\r\n  PDFViewerApplication.l10n.get(\"web_fonts_disabled\").then(msg => {\r\n   console.warn(msg);\r\n  });\r\n }\r\n if (!PDFViewerApplication.supportsPrinting) {\r\n  appConfig.toolbar.print.classList.add(\"hidden\");\r\n  appConfig.secondaryToolbar.printButton.classList.add(\"hidden\");\r\n }\r\n // saltdog disable presenation\r\n//  if (!PDFViewerApplication.supportsFullscreen) {\r\n//   appConfig.toolbar.presentationModeButton.classList.add(\"hidden\");\r\n//   appConfig.secondaryToolbar.presentationModeButton.classList.add(\"hidden\");\r\n//  }\r\n if (PDFViewerApplication.supportsIntegratedFind) {\r\n  appConfig.toolbar.viewFind.classList.add(\"hidden\");\r\n }\r\n appConfig.mainContainer.addEventListener(\"transitionend\", function (evt) {\r\n  if (evt.target === this) {\r\n   PDFViewerApplication.eventBus.dispatch(\"resize\", { source: this });\r\n  }\r\n }, true);\r\n try {\r\n  webViewerOpenFileViaURL(file);\r\n } catch (reason) {\r\n  PDFViewerApplication.l10n.get(\"loading_error\").then(msg => {\r\n   PDFViewerApplication._documentError(msg, reason);\r\n  });\r\n }\r\n}\r\nfunction webViewerOpenFileViaURL(file) {\r\n if (file) {\r\n  PDFViewerApplication.open(file);\r\n } else {\r\n  PDFViewerApplication._hideViewBookmark();\r\n }\r\n}\r\nfunction webViewerPageRendered({pageNumber, error}) {\r\n if (pageNumber === PDFViewerApplication.page) {\r\n  PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);\r\n }\r\n // sdpdfcore disable sidebar\r\n//  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {\r\n//   const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1);\r\n//   const thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageNumber - 1);\r\n//   if (pageView && thumbnailView) {\r\n//    thumbnailView.setImage(pageView);\r\n//   }\r\n//  }\r\n if (error) {\r\n  PDFViewerApplication.l10n.get(\"rendering_error\").then(msg => {\r\n   PDFViewerApplication._otherError(msg, error);\r\n  });\r\n }\r\n PDFViewerApplication._reportDocumentStatsTelemetry();\r\n}\r\n// function webViewerPageMode({mode}) {\r\n//  let view;\r\n//  switch (mode) {\r\n//  case \"thumbs\":\r\n//   view = SidebarView.THUMBS;\r\n//   break;\r\n//  case \"bookmarks\":\r\n//  case \"outline\":\r\n//   view = SidebarView.OUTLINE;\r\n//   break;\r\n//  case \"attachments\":\r\n//   view = SidebarView.ATTACHMENTS;\r\n//   break;\r\n//  case \"layers\":\r\n//   view = SidebarView.LAYERS;\r\n//   break;\r\n//  case \"none\":\r\n//   view = SidebarView.NONE;\r\n//   break;\r\n//  default:\r\n//   console.error('Invalid \"pagemode\" hash parameter: ' + mode);\r\n//   return;\r\n//  }\r\n//  PDFViewerApplication.pdfSidebar.switchView(view, true);\r\n// }\r\nfunction webViewerNamedAction(evt) {\r\n switch (evt.action) {\r\n case \"GoToPage\":\r\n  PDFViewerApplication.appConfig.toolbar.pageNumber.select();\r\n  break;\r\n case \"Find\":\r\n  if (!PDFViewerApplication.supportsIntegratedFind) {\r\n   PDFViewerApplication.findBar.toggle();\r\n  }\r\n  break;\r\n case \"Print\":\r\n  PDFViewerApplication.triggerPrinting();\r\n  break;\r\n case \"SaveAs\":\r\n  webViewerSave();\r\n  break;\r\n }\r\n}\r\n// saltdog disable presentation\r\n// function webViewerPresentationModeChanged(evt) {\r\n//  PDFViewerApplication.pdfViewer.presentationModeState = evt.state;\r\n// }\r\n// sdpdfcore disable sidebar\r\n// function webViewerSidebarViewChanged(evt) {\r\n//  PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;\r\n//  if (PDFViewerApplication.isInitialViewSet) {\r\n//   PDFViewerApplication.store?.set(\"sidebarView\", evt.view).catch(() => {\r\n//   });\r\n//  }\r\n// }\r\nfunction webViewerUpdateViewarea(evt) {\r\n const location = evt.location;\r\n if (PDFViewerApplication.isInitialViewSet) {\r\n  PDFViewerApplication.store?.setMultiple({\r\n   page: location.pageNumber,\r\n   zoom: location.scale,\r\n   scrollLeft: location.left,\r\n   scrollTop: location.top,\r\n   rotation: location.rotation\r\n  }).catch(() => {\r\n  });\r\n }\r\n const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams);\r\n PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;\r\n PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href;\r\n const currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1);\r\n const loading = currentPage?.renderingState !== RenderingStates.FINISHED;\r\n PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);\r\n}\r\nfunction webViewerScrollModeChanged(evt) {\r\n if (PDFViewerApplication.isInitialViewSet) {\r\n  PDFViewerApplication.store?.set(\"scrollMode\", evt.mode).catch(() => {\r\n  });\r\n }\r\n}\r\nfunction webViewerSpreadModeChanged(evt) {\r\n if (PDFViewerApplication.isInitialViewSet) {\r\n  PDFViewerApplication.store?.set(\"spreadMode\", evt.mode).catch(() => {\r\n  });\r\n }\r\n}\r\nfunction webViewerResize() {\r\n const {pdfDocument, pdfViewer} = PDFViewerApplication;\r\n if (!pdfDocument) {\r\n  return;\r\n }\r\n const currentScaleValue = pdfViewer.currentScaleValue;\r\n if (currentScaleValue === \"auto\" || currentScaleValue === \"page-fit\" || currentScaleValue === \"page-width\") {\r\n  pdfViewer.currentScaleValue = currentScaleValue;\r\n }\r\n pdfViewer.update();\r\n}\r\nfunction webViewerHashchange(evt) {\r\n const hash = evt.hash;\r\n if (!hash) {\r\n  return;\r\n }\r\n if (!PDFViewerApplication.isInitialViewSet) {\r\n  PDFViewerApplication.initialBookmark = hash;\r\n } else if (!PDFViewerApplication.pdfHistory?.popStateInProgress) {\r\n  PDFViewerApplication.pdfLinkService.setHash(hash);\r\n }\r\n}\r\nlet webViewerFileInputChange, webViewerOpenFile;\r\n{\r\n webViewerFileInputChange = function (evt) {\r\n   // saltdog disable presentation\r\n  // if (PDFViewerApplication.pdfViewer?.isInPresentationMode) {\r\n  //  return;\r\n  // }\r\n  const file = evt.fileInput.files[0];\r\n  let url = URL.createObjectURL(file);\r\n  if (file.name) {\r\n   url = {\r\n    url,\r\n    originalUrl: file.name\r\n   };\r\n  }\r\n  PDFViewerApplication.open(url);\r\n };\r\n webViewerOpenFile = function (evt) {\r\n  const openFileInputName = PDFViewerApplication.appConfig.openFileInputName;\r\n  document.getElementById(openFileInputName).click();\r\n };\r\n}\r\n// saltdog disable presentation\r\n// function webViewerPresentationMode() {\r\n//  PDFViewerApplication.requestPresentationMode();\r\n// }\r\nfunction webViewerPrint() {\r\n PDFViewerApplication.triggerPrinting();\r\n}\r\nfunction webViewerDownload() {\r\n PDFViewerApplication.downloadOrSave({ sourceEventType: \"download\" });\r\n}\r\nfunction webViewerSave() {\r\n PDFViewerApplication.downloadOrSave({ sourceEventType: \"save\" });\r\n}\r\nfunction webViewerFirstPage() {\r\n if (PDFViewerApplication.pdfDocument) {\r\n  PDFViewerApplication.page = 1;\r\n }\r\n}\r\nfunction webViewerLastPage() {\r\n if (PDFViewerApplication.pdfDocument) {\r\n  PDFViewerApplication.page = PDFViewerApplication.pagesCount;\r\n }\r\n}\r\nfunction webViewerNextPage() {\r\n PDFViewerApplication.pdfViewer.nextPage();\r\n}\r\nfunction webViewerPreviousPage() {\r\n PDFViewerApplication.pdfViewer.previousPage();\r\n}\r\nfunction webViewerZoomIn() {\r\n PDFViewerApplication.zoomIn();\r\n}\r\nfunction webViewerZoomOut() {\r\n PDFViewerApplication.zoomOut();\r\n}\r\nfunction webViewerZoomReset() {\r\n PDFViewerApplication.zoomReset();\r\n}\r\n// lgylgylgy20220309\r\nfunction webViewerPageNumberChanged(evt) {\r\n  console.log('webViewerPageNumberChanged',evt);\r\n  // __sdJSBridge&&__sdJSBridge.publish(`pageNumberChanged`,evt.value);\r\n const pdfViewer = PDFViewerApplication.pdfViewer;\r\n    // sdpdfcore parseInt\r\n if (evt.value !== \"\") {\r\n  PDFViewerApplication.pdfLinkService.goToPage(evt.value);\r\n }\r\n if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) {\r\n  PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);\r\n }\r\n}\r\nfunction webViewerScaleChanged(evt) {\r\n  console.log('webViewerScaleChanged',evt);\r\n  window.__sdJSBridge&&__sdJSBridge.publish(`scaleChanged`,evt.value);\r\n PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;\r\n}\r\nfunction webViewerRotateCw() {\r\n PDFViewerApplication.rotatePages(90);\r\n}\r\nfunction webViewerRotateCcw() {\r\n PDFViewerApplication.rotatePages(-90);\r\n}\r\n// ???\r\nfunction webViewerOptionalContentConfig(evt) {\r\n PDFViewerApplication.pdfViewer.optionalContentConfigPromise = evt.promise;\r\n}\r\n\r\nfunction webViewerSwitchScrollMode(evt) {\r\n PDFViewerApplication.pdfViewer.scrollMode = evt.mode;\r\n}\r\nfunction webViewerSwitchSpreadMode(evt) {\r\n PDFViewerApplication.pdfViewer.spreadMode = evt.mode;\r\n}\r\n// saltdog disable documentProperties\r\n// function webViewerDocumentProperties() {\r\n//  PDFViewerApplication.pdfDocumentProperties.open();\r\n// }\r\nfunction webViewerFindFromUrlHash(evt) {\r\n PDFViewerApplication.eventBus.dispatch(\"find\", {\r\n  source: evt.source,\r\n  type: \"\",\r\n  query: evt.query,\r\n  phraseSearch: evt.phraseSearch,\r\n  caseSensitive: false,\r\n  entireWord: false,\r\n  highlightAll: true,\r\n  findPrevious: false,\r\n  matchDiacritics: true\r\n });\r\n}\r\nfunction webViewerUpdateFindMatchesCount({matchesCount}) {\r\n if (PDFViewerApplication.supportsIntegratedFind) {\r\n  PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount);\r\n } else {\r\n  PDFViewerApplication.findBar.updateResultsCount(matchesCount);\r\n }\r\n}\r\nfunction webViewerUpdateFindControlState({state, previous, matchesCount, rawQuery}) {\r\n if (PDFViewerApplication.supportsIntegratedFind) {\r\n  PDFViewerApplication.externalServices.updateFindControlState({\r\n   result: state,\r\n   findPrevious: previous,\r\n   matchesCount,\r\n   rawQuery\r\n  });\r\n } else {\r\n  PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount);\r\n }\r\n}\r\nfunction webViewerScaleChanging(evt) {\r\n PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);\r\n PDFViewerApplication.pdfViewer.update();\r\n}\r\nfunction webViewerRotationChanging(evt) {\r\n  // sdpdfcore disable sidebar\r\n//  PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;\r\n PDFViewerApplication.forceRendering();\r\n PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;\r\n}\r\nfunction webViewerPageChanging({pageNumber, pageLabel}) {\r\n PDFViewerApplication.toolbar.setPageNumber(pageNumber, pageLabel);\r\n PDFViewerApplication.secondaryToolbar.setPageNumber(pageNumber);\r\n // sdpdfcore disable sidebar\r\n//  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {\r\n//   PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(pageNumber);\r\n//  }\r\n}\r\nfunction webViewerVisibilityChange(evt) {\r\n if (document.visibilityState === \"visible\") {\r\n  setZoomDisabledTimeout();\r\n }\r\n}\r\nlet zoomDisabledTimeout = null;\r\nfunction setZoomDisabledTimeout() {\r\n if (zoomDisabledTimeout) {\r\n  clearTimeout(zoomDisabledTimeout);\r\n }\r\n zoomDisabledTimeout = setTimeout(function () {\r\n  zoomDisabledTimeout = null;\r\n }, WHEEL_ZOOM_DISABLED_TIMEOUT);\r\n}\r\nfunction webViewerWheel(evt) {\r\n const {pdfViewer, supportedMouseWheelZoomModifierKeys} = PDFViewerApplication;\r\n // saltdog disable presentation\r\n//  if (pdfViewer.isInPresentationMode) {\r\n//   return;\r\n//  }\r\n if (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey) {\r\n  evt.preventDefault();\r\n  if (zoomDisabledTimeout || document.visibilityState === \"hidden\") {\r\n   return;\r\n  }\r\n  const deltaMode = evt.deltaMode;\r\n  const delta = normalizeWheelEventDirection(evt);\r\n  const previousScale = pdfViewer.currentScale;\r\n  let ticks = 0;\r\n  if (deltaMode === WheelEvent.DOM_DELTA_LINE || deltaMode === WheelEvent.DOM_DELTA_PAGE) {\r\n   if (Math.abs(delta) >= 1) {\r\n    ticks = Math.sign(delta);\r\n   } else {\r\n    ticks = PDFViewerApplication.accumulateWheelTicks(delta);\r\n   }\r\n  } else {\r\n   const PIXELS_PER_LINE_SCALE = 30;\r\n   ticks = PDFViewerApplication.accumulateWheelTicks(delta / PIXELS_PER_LINE_SCALE);\r\n  }\r\n  if (ticks < 0) {\r\n   PDFViewerApplication.zoomOut(-ticks);\r\n  } else if (ticks > 0) {\r\n   PDFViewerApplication.zoomIn(ticks);\r\n  }\r\n  const currentScale = pdfViewer.currentScale;\r\n  if (previousScale !== currentScale) {\r\n   const scaleCorrectionFactor = currentScale / previousScale - 1;\r\n   const rect = pdfViewer.container.getBoundingClientRect();\r\n   const dx = evt.clientX - rect.left;\r\n   const dy = evt.clientY - rect.top;\r\n   pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;\r\n   pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;\r\n  }\r\n } else {\r\n  setZoomDisabledTimeout();\r\n }\r\n}\r\nfunction webViewerTouchStart(evt) {\r\n if (evt.touches.length > 1) {\r\n  evt.preventDefault();\r\n }\r\n}\r\nfunction webViewerClick(evt) {\r\n if (!PDFViewerApplication.secondaryToolbar.isOpen) {\r\n  return;\r\n }\r\n const appConfig = PDFViewerApplication.appConfig;\r\n if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar.toggleButton) {\r\n  PDFViewerApplication.secondaryToolbar.close();\r\n }\r\n}\r\nfunction webViewerKeyDown(evt) {\r\n if (PDFViewerApplication.overlayManager.active) {\r\n  return;\r\n }\r\n const {eventBus, pdfViewer} = PDFViewerApplication;\r\n // saltdog disable presentation\r\n//  const isViewerInPresentationMode = pdfViewer.isInPresentationMode;\r\n let handled = false, ensureViewerFocused = false;\r\n const cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0);\r\n if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {\r\n  switch (evt.keyCode) {\r\n  case 70:\r\n   if (!PDFViewerApplication.supportsIntegratedFind && !evt.shiftKey) {\r\n    PDFViewerApplication.findBar.open();\r\n    handled = true;\r\n   }\r\n   break;\r\n  case 71:\r\n   if (!PDFViewerApplication.supportsIntegratedFind) {\r\n    const {state} = PDFViewerApplication.findController;\r\n    if (state) {\r\n     const eventState = Object.assign(Object.create(null), state, {\r\n      source: window,\r\n      type: \"again\",\r\n      findPrevious: cmd === 5 || cmd === 12\r\n     });\r\n     eventBus.dispatch(\"find\", eventState);\r\n    }\r\n    handled = true;\r\n   }\r\n   break;\r\n  case 61:\r\n  case 107:\r\n  case 187:\r\n  case 171:\r\n  //  if (!isViewerInPresentationMode) {\r\n    PDFViewerApplication.zoomIn();\r\n  //  }\r\n   handled = true;\r\n   break;\r\n  case 173:\r\n  case 109:\r\n  case 189:\r\n  //  if (!isViewerInPresentationMode) {\r\n    PDFViewerApplication.zoomOut();\r\n  //  }\r\n   handled = true;\r\n   break;\r\n  case 48:\r\n  case 96:\r\n  //  if (!isViewerInPresentationMode) {\r\n    setTimeout(function () {\r\n     PDFViewerApplication.zoomReset();\r\n    });\r\n    handled = false;\r\n  //  }\r\n   break;\r\n  case 38:\r\n   if (PDFViewerApplication.page > 1) {\r\n    PDFViewerApplication.page = 1;\r\n    handled = true;\r\n    ensureViewerFocused = true;\r\n   }\r\n   break;\r\n  case 40:\r\n   if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {\r\n    PDFViewerApplication.page = PDFViewerApplication.pagesCount;\r\n    handled = true;\r\n    ensureViewerFocused = true;\r\n   }\r\n   break;\r\n  }\r\n }\r\n if (cmd === 1 || cmd === 8) {\r\n  switch (evt.keyCode) {\r\n  case 83:\r\n   eventBus.dispatch(\"download\", { source: window });\r\n   handled = true;\r\n   break;\r\n  case 79: {\r\n    eventBus.dispatch(\"openfile\", { source: window });\r\n    handled = true;\r\n   }\r\n   break;\r\n  }\r\n }\r\n if (cmd === 3 || cmd === 10) {\r\n  switch (evt.keyCode) {\r\n  case 80:\r\n   \r\n   handled = true;\r\n   break;\r\n  case 71:\r\n   PDFViewerApplication.appConfig.toolbar.pageNumber.select();\r\n   handled = true;\r\n   break;\r\n  }\r\n }\r\n if (handled) {\r\n  if (ensureViewerFocused ) {\r\n   pdfViewer.focus();\r\n  }\r\n  evt.preventDefault();\r\n  return;\r\n }\r\n const curElement = getActiveOrFocusedElement();\r\n const curElementTagName = curElement?.tagName.toUpperCase();\r\n if (curElementTagName === \"INPUT\" || curElementTagName === \"TEXTAREA\" || curElementTagName === \"SELECT\" || curElement?.isContentEditable) {\r\n  if (evt.keyCode !== 27) {\r\n   return;\r\n  }\r\n }\r\n if (cmd === 0) {\r\n  let turnPage = 0, turnOnlyIfPageFit = false;\r\n  switch (evt.keyCode) {\r\n  case 38:\r\n  case 33:\r\n   if (pdfViewer.isVerticalScrollbarEnabled) {\r\n    turnOnlyIfPageFit = true;\r\n   }\r\n   turnPage = -1;\r\n   break;\r\n  case 8:\r\n    turnOnlyIfPageFit = true;\r\n   turnPage = -1;\r\n   break;\r\n  case 37:\r\n   if (pdfViewer.isHorizontalScrollbarEnabled) {\r\n    turnOnlyIfPageFit = true;\r\n   }\r\n  case 75:\r\n  case 80:\r\n   turnPage = -1;\r\n   break;\r\n  case 27:\r\n   if (PDFViewerApplication.secondaryToolbar.isOpen) {\r\n    PDFViewerApplication.secondaryToolbar.close();\r\n    handled = true;\r\n   }\r\n   if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened) {\r\n    PDFViewerApplication.findBar.close();\r\n    handled = true;\r\n   }\r\n   break;\r\n  case 40:\r\n  case 34:\r\n   if (pdfViewer.isVerticalScrollbarEnabled) {\r\n    turnOnlyIfPageFit = true;\r\n   }\r\n   turnPage = 1;\r\n   break;\r\n  case 13:\r\n  case 32:\r\n    turnOnlyIfPageFit = true;\r\n  \r\n   turnPage = 1;\r\n   break;\r\n  case 39:\r\n   if (pdfViewer.isHorizontalScrollbarEnabled) {\r\n    turnOnlyIfPageFit = true;\r\n   }\r\n  case 74:\r\n  case 78:\r\n   turnPage = 1;\r\n   break;\r\n  case 36:\r\n   if (PDFViewerApplication.page > 1) {\r\n    PDFViewerApplication.page = 1;\r\n    handled = true;\r\n    ensureViewerFocused = true;\r\n   }\r\n   break;\r\n  case 35:\r\n   if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {\r\n    PDFViewerApplication.page = PDFViewerApplication.pagesCount;\r\n    handled = true;\r\n    ensureViewerFocused = true;\r\n   }\r\n   break;\r\n  case 83:\r\n   PDFViewerApplication.pdfCursorTools.switchTool(CursorTool.SELECT);\r\n   break;\r\n  case 72:\r\n   PDFViewerApplication.pdfCursorTools.switchTool(CursorTool.HAND);\r\n   break;\r\n  case 82:\r\n   PDFViewerApplication.rotatePages(90);\r\n   break;\r\n  case 115:\r\n    // sdpdfcore disable sidebar\r\n  //  PDFViewerApplication.pdfSidebar.toggle();\r\n   break;\r\n  }\r\n  if (turnPage !== 0 && (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === \"page-fit\")) {\r\n   if (turnPage > 0) {\r\n    pdfViewer.nextPage();\r\n   } else {\r\n    pdfViewer.previousPage();\r\n   }\r\n   handled = true;\r\n  }\r\n }\r\n if (cmd === 4) {\r\n  switch (evt.keyCode) {\r\n  case 13:\r\n  case 32:\r\n   if (pdfViewer.currentScaleValue !== \"page-fit\") {\r\n    break;\r\n   }\r\n   pdfViewer.previousPage();\r\n   handled = true;\r\n   break;\r\n  case 82:\r\n   PDFViewerApplication.rotatePages(-90);\r\n   break;\r\n  }\r\n }\r\n if (!handled ) {\r\n  if (evt.keyCode >= 33 && evt.keyCode <= 40 || evt.keyCode === 32 && curElementTagName !== \"BUTTON\") {\r\n   ensureViewerFocused = true;\r\n  }\r\n }\r\n if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {\r\n  pdfViewer.focus();\r\n }\r\n if (handled) {\r\n  evt.preventDefault();\r\n }\r\n}\r\nfunction beforeUnload(evt) {\r\n evt.preventDefault();\r\n evt.returnValue = \"\";\r\n return false;\r\n}\r\nconst PDFPrintServiceFactory = {\r\n instance: {\r\n  supportsPrinting: false,\r\n  createPrintService() {\r\n   throw new Error(\"Not implemented: createPrintService\");\r\n  }\r\n }\r\n};\r\nexport {\r\n DefaultExternalServices,\r\n PDFPrintServiceFactory,\r\n PDFViewerApplication\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst compatibilityParams = Object.create(null);\r\n{\r\n const userAgent = typeof navigator !== \"undefined\" && navigator.userAgent || \"\";\r\n const platform = typeof navigator !== \"undefined\" && navigator.platform || \"\";\r\n const maxTouchPoints = typeof navigator !== \"undefined\" && navigator.maxTouchPoints || 1;\r\n const isAndroid = /Android/.test(userAgent);\r\n const isIOS = /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === \"MacIntel\" && maxTouchPoints > 1;\r\n (function checkCanvasSizeLimitation() {\r\n  if (isIOS || isAndroid) {\r\n   compatibilityParams.maxCanvasPixels = 5242880;\r\n  }\r\n }());\r\n}\r\nconst OptionKind = {\r\n VIEWER: 0x02,\r\n API: 0x04,\r\n WORKER: 0x08,\r\n PREFERENCE: 0x80\r\n};\r\nconst defaultOptions = {\r\n annotationMode: {\r\n  value: 2,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n cursorToolOnLoad: {\r\n  value: 0,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n findBlob: {\r\n  value: null,\r\n  kind: OptionKind.VIEWER\r\n },\r\n defaultZoomValue: {\r\n  value: \"\",\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n disableHistory: {\r\n  value: false,\r\n  kind: OptionKind.VIEWER\r\n },\r\n disablePageLabels: {\r\n  value: true, //sdpdfcore\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n enablePermissions: {\r\n  value: false,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n enablePrintAutoRotate: {\r\n  value: true,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n enableScripting: {\r\n  value: true,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n externalLinkRel: {\r\n  value: \"noopener noreferrer nofollow\",\r\n  kind: OptionKind.VIEWER\r\n },\r\n externalLinkTarget: {\r\n  value: 0,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n historyUpdateUrl: {\r\n  value: false,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n ignoreDestinationZoom: {\r\n  value: false,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n imageResourcesPath: {\r\n  value: \"./images/\",\r\n  kind: OptionKind.VIEWER\r\n },\r\n maxCanvasPixels: {\r\n  value: 16777216,\r\n  compatibility: compatibilityParams.maxCanvasPixels,\r\n  kind: OptionKind.VIEWER\r\n },\r\n pdfBugEnabled: {\r\n  value: true,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n printResolution: {\r\n  value: 150,\r\n  kind: OptionKind.VIEWER\r\n },\r\n renderer: {\r\n  value: \"canvas\",\r\n  kind: OptionKind.VIEWER\r\n },\r\n sidebarViewOnLoad: {\r\n  value: -1,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n scrollModeOnLoad: {\r\n  value: -1,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n spreadModeOnLoad: {\r\n  value: -1,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n textLayerMode: {\r\n  value: 1,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n useOnlyCssZoom: {\r\n  value: false,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n viewerCssTheme: {\r\n  value: 0,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n viewOnLoad: {\r\n  value: 0,\r\n  kind: OptionKind.VIEWER + OptionKind.PREFERENCE\r\n },\r\n cMapPacked: {\r\n  value: true,\r\n  kind: OptionKind.API\r\n },\r\n cMapUrl: {\r\n  value: \"../external/bcmaps/\",\r\n  kind: OptionKind.API\r\n },\r\n disableAutoFetch: {\r\n  value: false,\r\n  kind: OptionKind.API + OptionKind.PREFERENCE\r\n },\r\n disableFontFace: {\r\n  value: false,\r\n  kind: OptionKind.API + OptionKind.PREFERENCE\r\n },\r\n disableRange: {\r\n  value: false,\r\n  kind: OptionKind.API + OptionKind.PREFERENCE\r\n },\r\n disableStream: {\r\n  value: false,\r\n  kind: OptionKind.API + OptionKind.PREFERENCE\r\n },\r\n docBaseUrl: {\r\n  value: \"\",\r\n  kind: OptionKind.API\r\n },\r\n enableXfa: {\r\n  value: true,\r\n  kind: OptionKind.API + OptionKind.PREFERENCE\r\n },\r\n fontExtraProperties: {\r\n  value: false,\r\n  kind: OptionKind.API\r\n },\r\n isEvalSupported: {\r\n  value: true,\r\n  kind: OptionKind.API\r\n },\r\n maxImageSize: {\r\n  value: -1,\r\n  kind: OptionKind.API\r\n },\r\n pdfBug: {\r\n  value: false,\r\n  kind: OptionKind.API\r\n },\r\n standardFontDataUrl: {\r\n  value: \"../external/standard_fonts/\",\r\n  kind: OptionKind.API\r\n },\r\n verbosity: {\r\n  value: 1,\r\n  kind: OptionKind.API\r\n },\r\n workerPort: {\r\n  value: null,\r\n  kind: OptionKind.WORKER\r\n },\r\n workerSrc: {\r\n  value: \"./pdf.worker.js\",\r\n  kind: OptionKind.WORKER\r\n }\r\n};\r\n{\r\n defaultOptions.disablePreferences = {\r\n  value: false,\r\n  kind: OptionKind.VIEWER\r\n };\r\n defaultOptions.locale = {\r\n  value: typeof navigator !== \"undefined\" ? navigator.language : \"en-US\",\r\n  kind: OptionKind.VIEWER\r\n };\r\n defaultOptions.sandboxBundleSrc = {\r\n  value: \"../build/dev-sandbox/pdf.sandbox.js\",\r\n  kind: OptionKind.VIEWER\r\n };\r\n defaultOptions.renderer.kind += OptionKind.PREFERENCE;\r\n}\r\nconst userOptions = Object.create(null);\r\nclass AppOptions {\r\n constructor() {\r\n  throw new Error(\"Cannot initialize AppOptions.\");\r\n }\r\n static get(name) {\r\n  const userOption = userOptions[name];\r\n  if (userOption !== undefined) {\r\n   return userOption;\r\n  }\r\n  const defaultOption = defaultOptions[name];\r\n  if (defaultOption !== undefined) {\r\n   return defaultOption.compatibility ?? defaultOption.value;\r\n  }\r\n  return undefined;\r\n }\r\n static getAll(kind = null) {\r\n  const options = Object.create(null);\r\n  for (const name in defaultOptions) {\r\n   const defaultOption = defaultOptions[name];\r\n   if (kind) {\r\n    if ((kind & defaultOption.kind) === 0) {\r\n     continue;\r\n    }\r\n    if (kind === OptionKind.PREFERENCE) {\r\n     const value = defaultOption.value, valueType = typeof value;\r\n     if (valueType === \"boolean\" || valueType === \"string\" || valueType === \"number\" && Number.isInteger(value)) {\r\n      options[name] = value;\r\n      continue;\r\n     }\r\n     throw new Error(`Invalid type for preference: ${ name }`);\r\n    }\r\n   }\r\n   const userOption = userOptions[name];\r\n   options[name] = userOption !== undefined ? userOption : defaultOption.compatibility ?? defaultOption.value;\r\n  }\r\n  return options;\r\n }\r\n static set(name, value) {\r\n  userOptions[name] = value;\r\n }\r\n static setAll(options) {\r\n  for (const name in options) {\r\n   userOptions[name] = options[name];\r\n  }\r\n }\r\n static remove(name) {\r\n  delete userOptions[name];\r\n }\r\n static _hasUserOptions() {\r\n  return Object.keys(userOptions).length > 0;\r\n }\r\n}\r\nexport {\r\n AppOptions,\r\n compatibilityParams,\r\n OptionKind\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {AnnotationMode, createPromiseCapability, PermissionFlag, PixelsPerInch, version} = require(\"pdfjs-dist\");\r\nconst {DEFAULT_SCALE, DEFAULT_SCALE_DELTA, DEFAULT_SCALE_VALUE, getVisibleElements, isPortraitOrientation, isValidRotation, isValidScrollMode, isValidSpreadMode, MAX_AUTO_SCALE, MAX_SCALE, MIN_SCALE, RendererType, RenderingStates, SCROLLBAR_PADDING, scrollIntoView, ScrollMode, SpreadMode, TextLayerMode, UNKNOWN_SCALE, VERTICAL_PADDING, watchScroll} = require(\"./ui_utils.js\");\r\nconst {AnnotationLayerBuilder} = require(\"./annotation_layer_builder.js\");\r\nconst {NullL10n} = require(\"./l10n_utils.js\");\r\nconst {PDFPageView} = require(\"./pdf_page_view.js\");\r\nconst {PDFRenderingQueue} = require(\"./pdf_rendering_queue.js\");\r\nconst {SimpleLinkService} = require(\"./pdf_link_service.js\");\r\nconst {StructTreeLayerBuilder} = require(\"./struct_tree_layer_builder.js\");\r\nconst {TextHighlighter} = require(\"./text_highlighter.js\");\r\nconst {TextLayerBuilder} = require(\"./text_layer_builder.js\");\r\nconst {XfaLayerBuilder} = require(\"./xfa_layer_builder.js\");\r\nconst DEFAULT_CACHE_SIZE = 10;\r\nconst ENABLE_PERMISSIONS_CLASS = \"enablePermissions\";\r\nconst PagesCountLimit = {\r\n FORCE_SCROLL_MODE_PAGE: 15000,\r\n FORCE_LAZY_PAGE_INIT: 7500,\r\n PAUSE_EAGER_PAGE_INIT: 250\r\n};\r\nclass PDFPageViewBuffer {\r\n #buf = new Set();\r\n #size = 0;\r\n constructor(size) {\r\n  this.#size = size;\r\n }\r\n push(view) {\r\n  const buf = this.#buf;\r\n  if (buf.has(view)) {\r\n   buf.delete(view);\r\n  }\r\n  buf.add(view);\r\n  if (buf.size > this.#size) {\r\n   this.#destroyFirstView();\r\n  }\r\n }\r\n resize(newSize, idsToKeep = null) {\r\n  this.#size = newSize;\r\n  const buf = this.#buf;\r\n  if (idsToKeep) {\r\n   const ii = buf.size;\r\n   let i = 1;\r\n   for (const view of buf) {\r\n    if (idsToKeep.has(view.id)) {\r\n     buf.delete(view);\r\n     buf.add(view);\r\n    }\r\n    if (++i > ii) {\r\n     break;\r\n    }\r\n   }\r\n  }\r\n  while (buf.size > this.#size) {\r\n   this.#destroyFirstView();\r\n  }\r\n }\r\n has(view) {\r\n  return this.#buf.has(view);\r\n }\r\n [Symbol.iterator]() {\r\n  return this.#buf.keys();\r\n }\r\n #destroyFirstView() {\r\n  const firstView = this.#buf.keys().next().value;\r\n  firstView?.destroy();\r\n  this.#buf.delete(firstView);\r\n }\r\n}\r\nclass BaseViewer {\r\n #buffer = null;\r\n #annotationMode = AnnotationMode.ENABLE_FORMS;\r\n #previousAnnotationMode = null;\r\n #enablePermissions = false;\r\n #previousContainerHeight = 0;\r\n #scrollModePageState = null;\r\n #onVisibilityChange = null;\r\n constructor(options) {\r\n  if (this.constructor === BaseViewer) {\r\n   throw new Error(\"Cannot initialize BaseViewer.\");\r\n  }\r\n  const viewerVersion = '2.12.313';\r\n  if (version !== viewerVersion) {\r\n   throw new Error(`The API version \"${ version }\" does not match the Viewer version \"${ viewerVersion }\".`);\r\n  }\r\n  this.container = options.container;\r\n  this.viewer = options.viewer || options.container.firstElementChild;\r\n  if (!(this.container?.tagName.toUpperCase() === \"DIV\" && this.viewer?.tagName.toUpperCase() === \"DIV\")) {\r\n   throw new Error(\"Invalid `container` and/or `viewer` option.\");\r\n  }\r\n  if (this.container.offsetParent && getComputedStyle(this.container).position !== \"absolute\") {\r\n   throw new Error(\"The `container` must be absolutely positioned.\");\r\n  }\r\n  this.eventBus = options.eventBus;\r\n  this.linkService = options.linkService || new SimpleLinkService();\r\n  this.downloadManager = options.downloadManager || null;\r\n  this.findController = options.findController || null;\r\n  this._scriptingManager = options.scriptingManager || null;\r\n  this.removePageBorders = options.removePageBorders || false;\r\n  this.textLayerMode = options.textLayerMode ?? TextLayerMode.ENABLE;\r\n  this.#annotationMode = options.annotationMode ?? AnnotationMode.ENABLE_FORMS;\r\n  this.imageResourcesPath = options.imageResourcesPath || \"\";\r\n  this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;\r\n  this.renderer = options.renderer || RendererType.CANVAS;\r\n  this.useOnlyCssZoom = options.useOnlyCssZoom || false;\r\n  this.maxCanvasPixels = options.maxCanvasPixels;\r\n  this.l10n = options.l10n || NullL10n;\r\n  this.#enablePermissions = options.enablePermissions || false;\r\n  this.defaultRenderingQueue = !options.renderingQueue;\r\n  if (this.defaultRenderingQueue) {\r\n   this.renderingQueue = new PDFRenderingQueue();\r\n   this.renderingQueue.setViewer(this);\r\n  } else {\r\n   this.renderingQueue = options.renderingQueue;\r\n  }\r\n  this._doc = document.documentElement;\r\n  this.scroll = watchScroll(this.container, this._scrollUpdate.bind(this));\r\n  this._onBeforeDraw = this._onAfterDraw = null;\r\n  this._resetView();\r\n  if (this.removePageBorders) {\r\n   this.viewer.classList.add(\"removePageBorders\");\r\n  }\r\n  Promise.resolve().then(() => {\r\n   this.eventBus.dispatch(\"baseviewerinit\", { source: this });\r\n  });\r\n }\r\n get pagesCount() {\r\n  return this._pages.length;\r\n }\r\n getPageView(index) {\r\n  return this._pages[index];\r\n }\r\n get pageViewsReady() {\r\n  if (!this._pagesCapability.settled) {\r\n   return false;\r\n  }\r\n  return this._pages.every(function (pageView) {\r\n   return pageView?.pdfPage;\r\n  });\r\n }\r\n get renderForms() {\r\n  return this.#annotationMode === AnnotationMode.ENABLE_FORMS;\r\n }\r\n get enableScripting() {\r\n  return !!this._scriptingManager;\r\n }\r\n get currentPageNumber() {\r\n  return this._currentPageNumber;\r\n }\r\n set currentPageNumber(val) {\r\n  if (!Number.isInteger(val)) {\r\n   throw new Error(\"Invalid page number.\");\r\n  }\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  if (!this._setCurrentPageNumber(val, true)) {\r\n   console.error(`currentPageNumber: \"${ val }\" is not a valid page.`);\r\n  }\r\n }\r\n _setCurrentPageNumber(val, resetCurrentPageView = false) {\r\n  if (this._currentPageNumber === val) {\r\n   if (resetCurrentPageView) {\r\n    this._resetCurrentPageView();\r\n   }\r\n   return true;\r\n  }\r\n  if (!(0 < val && val <= this.pagesCount)) {\r\n   return false;\r\n  }\r\n  const previous = this._currentPageNumber;\r\n  this._currentPageNumber = val;\r\n  this.eventBus.dispatch(\"pagechanging\", {\r\n   source: this,\r\n   pageNumber: val,\r\n   pageLabel: this._pageLabels?.[val - 1] ?? null,\r\n   previous\r\n  });\r\n  if (resetCurrentPageView) {\r\n   this._resetCurrentPageView();\r\n  }\r\n  return true;\r\n }\r\n get currentPageLabel() {\r\n  return this._pageLabels?.[this._currentPageNumber - 1] ?? null;\r\n }\r\n set currentPageLabel(val) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  let page = val | 0;\r\n  if (this._pageLabels) {\r\n   const i = this._pageLabels.indexOf(val);\r\n   if (i >= 0) {\r\n    page = i + 1;\r\n   }\r\n  }\r\n  if (!this._setCurrentPageNumber(page, true)) {\r\n   console.error(`currentPageLabel: \"${ val }\" is not a valid page.`);\r\n  }\r\n }\r\n get currentScale() {\r\n  return this._currentScale !== UNKNOWN_SCALE ? this._currentScale : DEFAULT_SCALE;\r\n }\r\n set currentScale(val) {\r\n  if (isNaN(val)) {\r\n   throw new Error(\"Invalid numeric scale.\");\r\n  }\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  this._setScale(val, false);\r\n }\r\n get currentScaleValue() {\r\n  return this._currentScaleValue;\r\n }\r\n set currentScaleValue(val) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  this._setScale(val, false);\r\n }\r\n get pagesRotation() {\r\n  return this._pagesRotation;\r\n }\r\n set pagesRotation(rotation) {\r\n  if (!isValidRotation(rotation)) {\r\n   throw new Error(\"Invalid pages rotation angle.\");\r\n  }\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  rotation %= 360;\r\n  if (rotation < 0) {\r\n   rotation += 360;\r\n  }\r\n  if (this._pagesRotation === rotation) {\r\n   return;\r\n  }\r\n  this._pagesRotation = rotation;\r\n  const pageNumber = this._currentPageNumber;\r\n  const updateArgs = { rotation };\r\n  for (const pageView of this._pages) {\r\n   pageView.update(updateArgs);\r\n  }\r\n  if (this._currentScaleValue) {\r\n   this._setScale(this._currentScaleValue, true);\r\n  }\r\n  this.eventBus.dispatch(\"rotationchanging\", {\r\n   source: this,\r\n   pagesRotation: rotation,\r\n   pageNumber\r\n  });\r\n  if (this.defaultRenderingQueue) {\r\n   this.update();\r\n  }\r\n }\r\n get firstPagePromise() {\r\n  return this.pdfDocument ? this._firstPageCapability.promise : null;\r\n }\r\n get onePageRendered() {\r\n  return this.pdfDocument ? this._onePageRenderedCapability.promise : null;\r\n }\r\n get pagesPromise() {\r\n  return this.pdfDocument ? this._pagesCapability.promise : null;\r\n }\r\n #initializePermissions(permissions) {\r\n  if (!permissions) {\r\n   return;\r\n  }\r\n  if (!permissions.includes(PermissionFlag.COPY)) {\r\n   this.viewer.classList.add(ENABLE_PERMISSIONS_CLASS);\r\n  }\r\n  if (!permissions.includes(PermissionFlag.MODIFY_ANNOTATIONS) && !permissions.includes(PermissionFlag.FILL_INTERACTIVE_FORMS)) {\r\n   if (this.#annotationMode === AnnotationMode.ENABLE_FORMS) {\r\n    this.#previousAnnotationMode = this.#annotationMode;\r\n    this.#annotationMode = AnnotationMode.ENABLE;\r\n   }\r\n  }\r\n }\r\n #onePageRenderedOrForceFetch() {\r\n  if (document.visibilityState === \"hidden\" || !this.container.offsetParent || this._getVisiblePages().views.length === 0) {\r\n   return Promise.resolve();\r\n  }\r\n  const visibilityChangePromise = new Promise(resolve => {\r\n   this.#onVisibilityChange = () => {\r\n    if (document.visibilityState !== \"hidden\") {\r\n     return;\r\n    }\r\n    resolve();\r\n    document.removeEventListener(\"visibilitychange\", this.#onVisibilityChange);\r\n    this.#onVisibilityChange = null;\r\n   };\r\n   document.addEventListener(\"visibilitychange\", this.#onVisibilityChange);\r\n  });\r\n  return Promise.race([\r\n   this._onePageRenderedCapability.promise,\r\n   visibilityChangePromise\r\n  ]);\r\n }\r\n setDocument(pdfDocument) {\r\n  if (this.pdfDocument) {\r\n   this.eventBus.dispatch(\"pagesdestroy\", { source: this });\r\n   this._cancelRendering();\r\n   this._resetView();\r\n   if (this.findController) {\r\n    this.findController.setDocument(null);\r\n   }\r\n   if (this._scriptingManager) {\r\n    this._scriptingManager.setDocument(null);\r\n   }\r\n  }\r\n  this.pdfDocument = pdfDocument;\r\n  if (!pdfDocument) {\r\n   return;\r\n  }\r\n  const isPureXfa = pdfDocument.isPureXfa;\r\n  const pagesCount = pdfDocument.numPages;\r\n  const firstPagePromise = pdfDocument.getPage(1);\r\n  const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();\r\n  const permissionsPromise = this.#enablePermissions ? pdfDocument.getPermissions() : Promise.resolve();\r\n  if (pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {\r\n   console.warn(\"Forcing PAGE-scrolling for performance reasons, given the length of the document.\");\r\n   const mode = this._scrollMode = ScrollMode.PAGE;\r\n   this.eventBus.dispatch(\"scrollmodechanged\", {\r\n    source: this,\r\n    mode\r\n   });\r\n  }\r\n  this._pagesCapability.promise.then(() => {\r\n   this.eventBus.dispatch(\"pagesloaded\", {\r\n    source: this,\r\n    pagesCount\r\n   });\r\n  }, () => {\r\n  });\r\n  this._onBeforeDraw = evt => {\r\n   const pageView = this._pages[evt.pageNumber - 1];\r\n   if (!pageView) {\r\n    return;\r\n   }\r\n   this.#buffer.push(pageView);\r\n  };\r\n  this.eventBus._on(\"pagerender\", this._onBeforeDraw);\r\n  this._onAfterDraw = evt => {\r\n   if (evt.cssTransform || this._onePageRenderedCapability.settled) {\r\n    return;\r\n   }\r\n   this._onePageRenderedCapability.resolve({ timestamp: evt.timestamp });\r\n   this.eventBus._off(\"pagerendered\", this._onAfterDraw);\r\n   this._onAfterDraw = null;\r\n   if (this.#onVisibilityChange) {\r\n    document.removeEventListener(\"visibilitychange\", this.#onVisibilityChange);\r\n    this.#onVisibilityChange = null;\r\n   }\r\n  };\r\n  this.eventBus._on(\"pagerendered\", this._onAfterDraw);\r\n  Promise.all([\r\n   firstPagePromise,\r\n   permissionsPromise\r\n  ]).then(([firstPdfPage, permissions]) => {\r\n   if (pdfDocument !== this.pdfDocument) {\r\n    return;\r\n   }\r\n   this._firstPageCapability.resolve(firstPdfPage);\r\n   this._optionalContentConfigPromise = optionalContentConfigPromise;\r\n   this.#initializePermissions(permissions);\r\n   const viewerElement = this._scrollMode === ScrollMode.PAGE ? null : this.viewer;\r\n   const scale = this.currentScale;\r\n   const viewport = firstPdfPage.getViewport({ scale: scale * PixelsPerInch.PDF_TO_CSS_UNITS });\r\n   const textLayerFactory = this.textLayerMode !== TextLayerMode.DISABLE && !isPureXfa ? this : null;\r\n   const annotationLayerFactory = this.#annotationMode !== AnnotationMode.DISABLE ? this : null;\r\n   const xfaLayerFactory = isPureXfa ? this : null;\r\n   for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {\r\n    const pageView = new PDFPageView({\r\n     container: viewerElement,\r\n     eventBus: this.eventBus,\r\n     id: pageNum,\r\n     scale,\r\n     defaultViewport: viewport.clone(),\r\n     optionalContentConfigPromise,\r\n     renderingQueue: this.renderingQueue,\r\n     textLayerFactory,\r\n     textLayerMode: this.textLayerMode,\r\n     annotationLayerFactory,\r\n     annotationMode: this.#annotationMode,\r\n     xfaLayerFactory,\r\n     textHighlighterFactory: this,\r\n     structTreeLayerFactory: this,\r\n     imageResourcesPath: this.imageResourcesPath,\r\n     renderer: this.renderer,\r\n     useOnlyCssZoom: this.useOnlyCssZoom,\r\n     maxCanvasPixels: this.maxCanvasPixels,\r\n     l10n: this.l10n\r\n    });\r\n    this._pages.push(pageView);\r\n   }\r\n   const firstPageView = this._pages[0];\r\n   if (firstPageView) {\r\n    firstPageView.setPdfPage(firstPdfPage);\r\n    this.linkService.cachePageRef(1, firstPdfPage.ref);\r\n   }\r\n   if (this._scrollMode === ScrollMode.PAGE) {\r\n    this.#ensurePageViewVisible();\r\n   } else if (this._spreadMode !== SpreadMode.NONE) {\r\n    this._updateSpreadMode();\r\n   }\r\n   this.#onePageRenderedOrForceFetch().then(async () => {\r\n    if (this.findController) {\r\n     this.findController.setDocument(pdfDocument);\r\n    }\r\n    if (this._scriptingManager) {\r\n     this._scriptingManager.setDocument(pdfDocument);\r\n    }\r\n    if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > PagesCountLimit.FORCE_LAZY_PAGE_INIT) {\r\n     this._pagesCapability.resolve();\r\n     return;\r\n    }\r\n    let getPagesLeft = pagesCount - 1;\r\n    if (getPagesLeft <= 0) {\r\n     this._pagesCapability.resolve();\r\n     return;\r\n    }\r\n    for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {\r\n     const promise = pdfDocument.getPage(pageNum).then(pdfPage => {\r\n      const pageView = this._pages[pageNum - 1];\r\n      if (!pageView.pdfPage) {\r\n       pageView.setPdfPage(pdfPage);\r\n      }\r\n      this.linkService.cachePageRef(pageNum, pdfPage.ref);\r\n      if (--getPagesLeft === 0) {\r\n       this._pagesCapability.resolve();\r\n      }\r\n     }, reason => {\r\n      console.error(`Unable to get page ${ pageNum } to initialize viewer`, reason);\r\n      if (--getPagesLeft === 0) {\r\n       this._pagesCapability.resolve();\r\n      }\r\n     });\r\n     if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) {\r\n      await promise;\r\n     }\r\n    }\r\n   });\r\n   this.eventBus.dispatch(\"pagesinit\", { source: this });\r\n   pdfDocument.getMetadata().then(({info}) => {\r\n    if (pdfDocument !== this.pdfDocument) {\r\n     return;\r\n    }\r\n    if (info.Language) {\r\n     this.viewer.lang = info.Language;\r\n    }\r\n   });\r\n   if (this.defaultRenderingQueue) {\r\n    this.update();\r\n   }\r\n  }).catch(reason => {\r\n   console.error(\"Unable to initialize viewer\", reason);\r\n   this._pagesCapability.reject(reason);\r\n  });\r\n }\r\n setPageLabels(labels) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  if (!labels) {\r\n   this._pageLabels = null;\r\n  } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {\r\n   this._pageLabels = null;\r\n   console.error(`setPageLabels: Invalid page labels.`);\r\n  } else {\r\n   this._pageLabels = labels;\r\n  }\r\n  for (let i = 0, ii = this._pages.length; i < ii; i++) {\r\n   this._pages[i].setPageLabel(this._pageLabels?.[i] ?? null);\r\n  }\r\n }\r\n _resetView() {\r\n  this._pages = [];\r\n  this._currentPageNumber = 1;\r\n  this._currentScale = UNKNOWN_SCALE;\r\n  this._currentScaleValue = null;\r\n  this._pageLabels = null;\r\n  this.#buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);\r\n  this._location = null;\r\n  this._pagesRotation = 0;\r\n  this._optionalContentConfigPromise = null;\r\n  this._firstPageCapability = createPromiseCapability();\r\n  this._onePageRenderedCapability = createPromiseCapability();\r\n  this._pagesCapability = createPromiseCapability();\r\n  this._scrollMode = ScrollMode.VERTICAL;\r\n  this._previousScrollMode = ScrollMode.UNKNOWN;\r\n  this._spreadMode = SpreadMode.NONE;\r\n  this.#scrollModePageState = {\r\n   previousPageNumber: 1,\r\n   scrollDown: true,\r\n   pages: []\r\n  };\r\n  if (this._onBeforeDraw) {\r\n   this.eventBus._off(\"pagerender\", this._onBeforeDraw);\r\n   this._onBeforeDraw = null;\r\n  }\r\n  if (this._onAfterDraw) {\r\n   this.eventBus._off(\"pagerendered\", this._onAfterDraw);\r\n   this._onAfterDraw = null;\r\n  }\r\n  if (this.#onVisibilityChange) {\r\n   document.removeEventListener(\"visibilitychange\", this.#onVisibilityChange);\r\n   this.#onVisibilityChange = null;\r\n  }\r\n  this.viewer.textContent = \"\";\r\n  this._updateScrollMode();\r\n  this.viewer.removeAttribute(\"lang\");\r\n  this.viewer.classList.remove(ENABLE_PERMISSIONS_CLASS);\r\n  if (this.#previousAnnotationMode !== null) {\r\n   this.#annotationMode = this.#previousAnnotationMode;\r\n   this.#previousAnnotationMode = null;\r\n  }\r\n }\r\n #ensurePageViewVisible() {\r\n  if (this._scrollMode !== ScrollMode.PAGE) {\r\n   throw new Error(\"#ensurePageViewVisible: Invalid scrollMode value.\");\r\n  }\r\n  const pageNumber = this._currentPageNumber, state = this.#scrollModePageState, viewer = this.viewer;\r\n  viewer.textContent = \"\";\r\n  state.pages.length = 0;\r\n  if (this._spreadMode === SpreadMode.NONE) {\r\n   const pageView = this._pages[pageNumber - 1];\r\n\r\n    viewer.appendChild(pageView.div);\r\n   \r\n   state.pages.push(pageView);\r\n  } else {\r\n   const pageIndexSet = new Set(), parity = this._spreadMode - 1;\r\n   if (pageNumber % 2 !== parity) {\r\n    pageIndexSet.add(pageNumber - 1);\r\n    pageIndexSet.add(pageNumber);\r\n   } else {\r\n    pageIndexSet.add(pageNumber - 2);\r\n    pageIndexSet.add(pageNumber - 1);\r\n   }\r\n   let spread = null;\r\n   for (const i of pageIndexSet) {\r\n    const pageView = this._pages[i];\r\n    if (!pageView) {\r\n     continue;\r\n    }\r\n    if (spread === null) {\r\n     spread = document.createElement(\"div\");\r\n     spread.className = \"spread\";\r\n     viewer.appendChild(spread);\r\n    } else if (i % 2 === parity) {\r\n     spread = spread.cloneNode(false);\r\n     viewer.appendChild(spread);\r\n    }\r\n    spread.appendChild(pageView.div);\r\n    state.pages.push(pageView);\r\n   }\r\n  }\r\n  state.scrollDown = pageNumber >= state.previousPageNumber;\r\n  state.previousPageNumber = pageNumber;\r\n }\r\n _scrollUpdate() {\r\n  if (this.pagesCount === 0) {\r\n   return;\r\n  }\r\n  this.update();\r\n }\r\n _scrollIntoView({pageDiv, pageSpot = null, pageNumber = null}) {\r\n  if (this._scrollMode === ScrollMode.PAGE) {\r\n   if (pageNumber) {\r\n    this._setCurrentPageNumber(pageNumber);\r\n   }\r\n   this.#ensurePageViewVisible();\r\n   this.update();\r\n  }\r\n  if (!pageSpot) {\r\n   const left = pageDiv.offsetLeft + pageDiv.clientLeft;\r\n   const right = left + pageDiv.clientWidth;\r\n   const {scrollLeft, clientWidth} = this.container;\r\n   if (this._scrollMode === ScrollMode.HORIZONTAL || left < scrollLeft || right > scrollLeft + clientWidth) {\r\n    pageSpot = {\r\n     left: 0,\r\n     top: 0\r\n    };\r\n   }\r\n  }\r\n  scrollIntoView(pageDiv, pageSpot);\r\n }\r\n #isSameScale(newScale) {\r\n  return newScale === this._currentScale || Math.abs(newScale - this._currentScale) < 1e-15;\r\n }\r\n _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {\r\n  this._currentScaleValue = newValue.toString();\r\n  if (this.#isSameScale(newScale)) {\r\n   if (preset) {\r\n    this.eventBus.dispatch(\"scalechanging\", {\r\n     source: this,\r\n     scale: newScale,\r\n     presetValue: newValue\r\n    });\r\n   }\r\n   return;\r\n  }\r\n  this._doc.style.setProperty(\"--zoom-factor\", newScale);\r\n  this._doc.style.setProperty(\"--viewport-scale-factor\", newScale * PixelsPerInch.PDF_TO_CSS_UNITS);\r\n  const updateArgs = { scale: newScale };\r\n  for (const pageView of this._pages) {\r\n   pageView.update(updateArgs);\r\n  }\r\n  this._currentScale = newScale;\r\n  if (!noScroll) {\r\n   let page = this._currentPageNumber, dest;\r\n   if (this._location) {\r\n    page = this._location.pageNumber;\r\n    dest = [\r\n     null,\r\n     { name: \"XYZ\" },\r\n     this._location.left,\r\n     this._location.top,\r\n     null\r\n    ];\r\n   }\r\n   this.scrollPageIntoView({\r\n    pageNumber: page,\r\n    destArray: dest,\r\n    allowNegativeOffset: true\r\n   });\r\n  }\r\n  this.eventBus.dispatch(\"scalechanging\", {\r\n   source: this,\r\n   scale: newScale,\r\n   presetValue: preset ? newValue : undefined\r\n  });\r\n  if (this.defaultRenderingQueue) {\r\n   this.update();\r\n  }\r\n  this.#previousContainerHeight = this.container.clientHeight;\r\n }\r\n get _pageWidthScaleFactor() {\r\n  if (this._spreadMode !== SpreadMode.NONE && this._scrollMode !== ScrollMode.HORIZONTAL) {\r\n   return 2;\r\n  }\r\n  return 1;\r\n }\r\n _setScale(value, noScroll = false) {\r\n  let scale = parseFloat(value);\r\n  if (scale > 0) {\r\n   this._setScaleUpdatePages(scale, value, noScroll, false);\r\n  } else {\r\n   const currentPage = this._pages[this._currentPageNumber - 1];\r\n   if (!currentPage) {\r\n    return;\r\n   }\r\n   let hPadding = SCROLLBAR_PADDING, vPadding = VERTICAL_PADDING;\r\n  if (this.removePageBorders) {\r\n    hPadding = vPadding = 0;\r\n   }\r\n   if (this._scrollMode === ScrollMode.HORIZONTAL) {\r\n    [hPadding, vPadding] = [\r\n     vPadding,\r\n     hPadding\r\n    ];\r\n   }\r\n   const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor;\r\n   const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;\r\n   switch (value) {\r\n   case \"page-actual\":\r\n    scale = 1;\r\n    break;\r\n   case \"page-width\":\r\n    scale = pageWidthScale;\r\n    break;\r\n   case \"page-height\":\r\n    scale = pageHeightScale;\r\n    break;\r\n   case \"page-fit\":\r\n    scale = Math.min(pageWidthScale, pageHeightScale);\r\n    break;\r\n   case \"auto\":\r\n    const horizontalScale = isPortraitOrientation(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);\r\n    scale = Math.min(MAX_AUTO_SCALE, horizontalScale);\r\n    break;\r\n   default:\r\n    console.error(`_setScale: \"${ value }\" is an unknown zoom value.`);\r\n    return;\r\n   }\r\n   this._setScaleUpdatePages(scale, value, noScroll, true);\r\n  }\r\n }\r\n _resetCurrentPageView() {\r\n\r\n  const pageView = this._pages[this._currentPageNumber - 1];\r\n  this._scrollIntoView({ pageDiv: pageView.div });\r\n }\r\n pageLabelToPageNumber(label) {\r\n  if (!this._pageLabels) {\r\n   return null;\r\n  }\r\n  const i = this._pageLabels.indexOf(label);\r\n  if (i < 0) {\r\n   return null;\r\n  }\r\n  return i + 1;\r\n }\r\n scrollPageIntoView({pageNumber, destArray = null, allowNegativeOffset = false, ignoreDestinationZoom = false}) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];\r\n  if (!pageView) {\r\n   console.error(`scrollPageIntoView: \"${ pageNumber }\" is not a valid pageNumber parameter.`);\r\n   return;\r\n  }\r\n  if (!destArray) {\r\n    this._setCurrentPageNumber(pageNumber, true);\r\n    return;\r\n   }\r\n  let x = 0, y = 0;\r\n  let width = 0, height = 0, widthScale, heightScale;\r\n  const changeOrientation = pageView.rotation % 180 !== 0;\r\n  const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / PixelsPerInch.PDF_TO_CSS_UNITS;\r\n  const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / PixelsPerInch.PDF_TO_CSS_UNITS;\r\n  let scale = 0;\r\n  switch (destArray[1].name) {\r\n  case \"XYZ\":\r\n   x = destArray[2];\r\n   y = destArray[3];\r\n   scale = destArray[4];\r\n   x = x !== null ? x : 0;\r\n   y = y !== null ? y : pageHeight;\r\n   break;\r\n  case \"Fit\":\r\n  case \"FitB\":\r\n   scale = \"page-fit\";\r\n   break;\r\n  case \"FitH\":\r\n  case \"FitBH\":\r\n   y = destArray[2];\r\n   scale = \"page-width\";\r\n   if (y === null && this._location) {\r\n    x = this._location.left;\r\n    y = this._location.top;\r\n   } else if (typeof y !== \"number\" || y < 0) {\r\n    y = pageHeight;\r\n   }\r\n   break;\r\n  case \"FitV\":\r\n  case \"FitBV\":\r\n   x = destArray[2];\r\n   width = pageWidth;\r\n   height = pageHeight;\r\n   scale = \"page-height\";\r\n   break;\r\n  case \"FitR\":\r\n   x = destArray[2];\r\n   y = destArray[3];\r\n   width = destArray[4] - x;\r\n   height = destArray[5] - y;\r\n   const hPadding = this.removePageBorders ? 0 : SCROLLBAR_PADDING;\r\n   const vPadding = this.removePageBorders ? 0 : VERTICAL_PADDING;\r\n   widthScale = (this.container.clientWidth - hPadding) / width / PixelsPerInch.PDF_TO_CSS_UNITS;\r\n   heightScale = (this.container.clientHeight - vPadding) / height / PixelsPerInch.PDF_TO_CSS_UNITS;\r\n   scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));\r\n   break;\r\n  default:\r\n   console.error(`scrollPageIntoView: \"${ destArray[1].name }\" is not a valid destination type.`);\r\n   return;\r\n  }\r\n  if (!ignoreDestinationZoom) {\r\n   if (scale && scale !== this._currentScale) {\r\n    this.currentScaleValue = scale;\r\n   } else if (this._currentScale === UNKNOWN_SCALE) {\r\n    this.currentScaleValue = DEFAULT_SCALE_VALUE;\r\n   }\r\n  }\r\n  if (scale === \"page-fit\" && !destArray[4]) {\r\n   this._scrollIntoView({\r\n    pageDiv: pageView.div,\r\n    pageNumber\r\n   });\r\n   return;\r\n  }\r\n  const boundingRect = [\r\n   pageView.viewport.convertToViewportPoint(x, y),\r\n   pageView.viewport.convertToViewportPoint(x + width, y + height)\r\n  ];\r\n  let left = Math.min(boundingRect[0][0], boundingRect[1][0]);\r\n  let top = Math.min(boundingRect[0][1], boundingRect[1][1]);\r\n  if (!allowNegativeOffset) {\r\n   left = Math.max(left, 0);\r\n   top = Math.max(top, 0);\r\n  }\r\n  this._scrollIntoView({\r\n   pageDiv: pageView.div,\r\n   pageSpot: {\r\n    left,\r\n    top\r\n   },\r\n   pageNumber\r\n  });\r\n }\r\n _updateLocation(firstPage) {\r\n  const currentScale = this._currentScale;\r\n  const currentScaleValue = this._currentScaleValue;\r\n  const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;\r\n  const pageNumber = firstPage.id;\r\n  let pdfOpenParams = \"#page=\" + pageNumber;\r\n  pdfOpenParams += \"&zoom=\" + normalizedScaleValue;\r\n  const currentPageView = this._pages[pageNumber - 1];\r\n  const container = this.container;\r\n  const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);\r\n  const intLeft = Math.round(topLeft[0]);\r\n  const intTop = Math.round(topLeft[1]);\r\n  pdfOpenParams += \",\" + intLeft + \",\" + intTop;\r\n  this._location = {\r\n   pageNumber,\r\n   scale: normalizedScaleValue,\r\n   top: intTop,\r\n   left: intLeft,\r\n   rotation: this._pagesRotation,\r\n   pdfOpenParams\r\n  };\r\n }\r\n update() {\r\n  const visible = this._getVisiblePages();\r\n  const visiblePages = visible.views, numVisiblePages = visiblePages.length;\r\n  if (numVisiblePages === 0) {\r\n   return;\r\n  }\r\n  const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);\r\n  this.#buffer.resize(newCacheSize, visible.ids);\r\n  this.renderingQueue.renderHighestPriority(visible);\r\n\r\n   const isSimpleLayout = this._spreadMode === SpreadMode.NONE && (this._scrollMode === ScrollMode.PAGE || this._scrollMode === ScrollMode.VERTICAL);\r\n   let currentId = this._currentPageNumber;\r\n   let stillFullyVisible = false;\r\n   for (const page of visiblePages) {\r\n    if (page.percent < 100) {\r\n     break;\r\n    }\r\n    if (page.id === currentId && isSimpleLayout) {\r\n     stillFullyVisible = true;\r\n     break;\r\n    }\r\n   }\r\n   if (!stillFullyVisible) {\r\n    currentId = visiblePages[0].id;\r\n   }\r\n   this._setCurrentPageNumber(currentId);\r\n  \r\n  this._updateLocation(visible.first);\r\n  this.eventBus.dispatch(\"updateviewarea\", {\r\n   source: this,\r\n   location: this._location\r\n  });\r\n }\r\n containsElement(element) {\r\n  return this.container.contains(element);\r\n }\r\n focus() {\r\n  this.container.focus();\r\n }\r\n get _isContainerRtl() {\r\n  return getComputedStyle(this.container).direction === \"rtl\";\r\n }\r\n\r\n\r\n get isHorizontalScrollbarEnabled() {\r\n  return this.container.scrollWidth > this.container.clientWidth;\r\n }\r\n get isVerticalScrollbarEnabled() {\r\n  return this.container.scrollHeight > this.container.clientHeight;\r\n }\r\n _getCurrentVisiblePage() {\r\n  if (!this.pagesCount) {\r\n   return { views: [] };\r\n  }\r\n  const pageView = this._pages[this._currentPageNumber - 1];\r\n  const element = pageView.div;\r\n  const view = {\r\n   id: pageView.id,\r\n   x: element.offsetLeft + element.clientLeft,\r\n   y: element.offsetTop + element.clientTop,\r\n   view: pageView\r\n  };\r\n  const ids = new Set([pageView.id]);\r\n  return {\r\n   first: view,\r\n   last: view,\r\n   views: [view],\r\n   ids\r\n  };\r\n }\r\n _getVisiblePages() {\r\n\r\n  const views = this._scrollMode === ScrollMode.PAGE ? this.#scrollModePageState.pages : this._pages, horizontal = this._scrollMode === ScrollMode.HORIZONTAL, rtl = horizontal && this._isContainerRtl;\r\n  return getVisibleElements({\r\n   scrollEl: this.container,\r\n   views,\r\n   sortByVisibility: true,\r\n   horizontal,\r\n   rtl\r\n  });\r\n }\r\n isPageVisible(pageNumber) {\r\n  if (!this.pdfDocument) {\r\n   return false;\r\n  }\r\n  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {\r\n   console.error(`isPageVisible: \"${ pageNumber }\" is not a valid page.`);\r\n   return false;\r\n  }\r\n  return this._getVisiblePages().ids.has(pageNumber);\r\n }\r\n isPageCached(pageNumber) {\r\n  if (!this.pdfDocument) {\r\n   return false;\r\n  }\r\n  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {\r\n   console.error(`isPageCached: \"${ pageNumber }\" is not a valid page.`);\r\n   return false;\r\n  }\r\n  const pageView = this._pages[pageNumber - 1];\r\n  return this.#buffer.has(pageView);\r\n }\r\n cleanup() {\r\n  for (let i = 0, ii = this._pages.length; i < ii; i++) {\r\n   if (this._pages[i] && this._pages[i].renderingState !== RenderingStates.FINISHED) {\r\n    this._pages[i].reset();\r\n   }\r\n  }\r\n }\r\n _cancelRendering() {\r\n  for (let i = 0, ii = this._pages.length; i < ii; i++) {\r\n   if (this._pages[i]) {\r\n    this._pages[i].cancelRendering();\r\n   }\r\n  }\r\n }\r\n async #ensurePdfPageLoaded(pageView) {\r\n  if (pageView.pdfPage) {\r\n   return pageView.pdfPage;\r\n  }\r\n  try {\r\n   const pdfPage = await this.pdfDocument.getPage(pageView.id);\r\n   if (!pageView.pdfPage) {\r\n    pageView.setPdfPage(pdfPage);\r\n   }\r\n   if (!this.linkService._cachedPageNumber?.(pdfPage.ref)) {\r\n    this.linkService.cachePageRef(pageView.id, pdfPage.ref);\r\n   }\r\n   return pdfPage;\r\n  } catch (reason) {\r\n   console.error(\"Unable to get page for page view\", reason);\r\n   return null;\r\n  }\r\n }\r\n #getScrollAhead(visible) {\r\n  if (visible.first?.id === 1) {\r\n   return true;\r\n  } else if (visible.last?.id === this.pagesCount) {\r\n   return false;\r\n  }\r\n  switch (this._scrollMode) {\r\n  case ScrollMode.PAGE:\r\n   return this.#scrollModePageState.scrollDown;\r\n  case ScrollMode.HORIZONTAL:\r\n   return this.scroll.right;\r\n  }\r\n  return this.scroll.down;\r\n }\r\n #toggleLoadingIconSpinner(visibleIds) {\r\n  for (const id of visibleIds) {\r\n   const pageView = this._pages[id - 1];\r\n   pageView?.toggleLoadingIconSpinner(true);\r\n  }\r\n  for (const pageView of this.#buffer) {\r\n   if (visibleIds.has(pageView.id)) {\r\n    continue;\r\n   }\r\n   pageView.toggleLoadingIconSpinner(false);\r\n  }\r\n }\r\n forceRendering(currentlyVisiblePages) {\r\n  const visiblePages = currentlyVisiblePages || this._getVisiblePages();\r\n  const scrollAhead = this.#getScrollAhead(visiblePages);\r\n  const preRenderExtra = this._spreadMode !== SpreadMode.NONE && this._scrollMode !== ScrollMode.HORIZONTAL;\r\n  const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra);\r\n  this.#toggleLoadingIconSpinner(visiblePages.ids);\r\n  if (pageView) {\r\n   this.#ensurePdfPageLoaded(pageView).then(() => {\r\n    this.renderingQueue.renderView(pageView);\r\n   });\r\n   return true;\r\n  }\r\n  return false;\r\n }\r\n createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus, highlighter) {\r\n  return new TextLayerBuilder({\r\n   textLayerDiv,\r\n   eventBus,\r\n   pageIndex,\r\n   viewport,\r\n   enhanceTextSelection:  enhanceTextSelection,\r\n   highlighter\r\n  });\r\n }\r\n createTextHighlighter(pageIndex, eventBus) {\r\n  return new TextHighlighter({\r\n   eventBus,\r\n   pageIndex,\r\n   findController:  this.findController\r\n  });\r\n }\r\n createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = \"\", renderForms = true, l10n = NullL10n, enableScripting = null, hasJSActionsPromise = null, mouseState = null, fieldObjectsPromise = null, annotationCanvasMap = null) {\r\n  return new AnnotationLayerBuilder({\r\n   pageDiv,\r\n   pdfPage,\r\n   annotationStorage: annotationStorage || this.pdfDocument?.annotationStorage,\r\n   imageResourcesPath,\r\n   renderForms,\r\n   linkService: this.linkService,\r\n   downloadManager: this.downloadManager,\r\n   l10n,\r\n   enableScripting: enableScripting ?? this.enableScripting,\r\n   hasJSActionsPromise: hasJSActionsPromise || this.pdfDocument?.hasJSActions(),\r\n   fieldObjectsPromise: fieldObjectsPromise || this.pdfDocument?.getFieldObjects(),\r\n   mouseState: mouseState || this._scriptingManager?.mouseState,\r\n   annotationCanvasMap\r\n  });\r\n }\r\n createXfaLayerBuilder(pageDiv, pdfPage, annotationStorage = null) {\r\n  return new XfaLayerBuilder({\r\n   pageDiv,\r\n   pdfPage,\r\n   annotationStorage: annotationStorage || this.pdfDocument?.annotationStorage,\r\n   linkService: this.linkService\r\n  });\r\n }\r\n createStructTreeLayerBuilder(pdfPage) {\r\n  return new StructTreeLayerBuilder({ pdfPage });\r\n }\r\n get hasEqualPageSizes() {\r\n  const firstPageView = this._pages[0];\r\n  for (let i = 1, ii = this._pages.length; i < ii; ++i) {\r\n   const pageView = this._pages[i];\r\n   if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {\r\n    return false;\r\n   }\r\n  }\r\n  return true;\r\n }\r\n getPagesOverview() {\r\n  return this._pages.map(pageView => {\r\n   const viewport = pageView.pdfPage.getViewport({ scale: 1 });\r\n   if (!this.enablePrintAutoRotate || isPortraitOrientation(viewport)) {\r\n    return {\r\n     width: viewport.width,\r\n     height: viewport.height,\r\n     rotation: viewport.rotation\r\n    };\r\n   }\r\n   return {\r\n    width: viewport.height,\r\n    height: viewport.width,\r\n    rotation: (viewport.rotation - 90) % 360\r\n   };\r\n  });\r\n }\r\n get optionalContentConfigPromise() {\r\n  if (!this.pdfDocument) {\r\n   return Promise.resolve(null);\r\n  }\r\n  if (!this._optionalContentConfigPromise) {\r\n   return this.pdfDocument.getOptionalContentConfig();\r\n  }\r\n  return this._optionalContentConfigPromise;\r\n }\r\n set optionalContentConfigPromise(promise) {\r\n  if (!(promise instanceof Promise)) {\r\n   throw new Error(`Invalid optionalContentConfigPromise: ${ promise }`);\r\n  }\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  if (!this._optionalContentConfigPromise) {\r\n   return;\r\n  }\r\n  this._optionalContentConfigPromise = promise;\r\n  const updateArgs = { optionalContentConfigPromise: promise };\r\n  for (const pageView of this._pages) {\r\n   pageView.update(updateArgs);\r\n  }\r\n  this.update();\r\n  this.eventBus.dispatch(\"optionalcontentconfigchanged\", {\r\n   source: this,\r\n   promise\r\n  });\r\n }\r\n get scrollMode() {\r\n  return this._scrollMode;\r\n }\r\n set scrollMode(mode) {\r\n  if (this._scrollMode === mode) {\r\n   return;\r\n  }\r\n  if (!isValidScrollMode(mode)) {\r\n   throw new Error(`Invalid scroll mode: ${ mode }`);\r\n  }\r\n  if (this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {\r\n   return;\r\n  }\r\n  this._previousScrollMode = this._scrollMode;\r\n  this._scrollMode = mode;\r\n  this.eventBus.dispatch(\"scrollmodechanged\", {\r\n   source: this,\r\n   mode\r\n  });\r\n  this._updateScrollMode(this._currentPageNumber);\r\n }\r\n _updateScrollMode(pageNumber = null) {\r\n  const scrollMode = this._scrollMode, viewer = this.viewer;\r\n  viewer.classList.toggle(\"scrollHorizontal\", scrollMode === ScrollMode.HORIZONTAL);\r\n  viewer.classList.toggle(\"scrollWrapped\", scrollMode === ScrollMode.WRAPPED);\r\n  if (!this.pdfDocument || !pageNumber) {\r\n   return;\r\n  }\r\n  if (scrollMode === ScrollMode.PAGE) {\r\n   this.#ensurePageViewVisible();\r\n  } else if (this._previousScrollMode === ScrollMode.PAGE) {\r\n   this._updateSpreadMode();\r\n  }\r\n  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {\r\n   this._setScale(this._currentScaleValue, true);\r\n  }\r\n  this._setCurrentPageNumber(pageNumber, true);\r\n  this.update();\r\n }\r\n get spreadMode() {\r\n  return this._spreadMode;\r\n }\r\n set spreadMode(mode) {\r\n  if (this._spreadMode === mode) {\r\n   return;\r\n  }\r\n  if (!isValidSpreadMode(mode)) {\r\n   throw new Error(`Invalid spread mode: ${ mode }`);\r\n  }\r\n  this._spreadMode = mode;\r\n  this.eventBus.dispatch(\"spreadmodechanged\", {\r\n   source: this,\r\n   mode\r\n  });\r\n  this._updateSpreadMode(this._currentPageNumber);\r\n }\r\n _updateSpreadMode(pageNumber = null) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  const viewer = this.viewer, pages = this._pages;\r\n  if (this._scrollMode === ScrollMode.PAGE) {\r\n   this.#ensurePageViewVisible();\r\n  } else {\r\n   viewer.textContent = \"\";\r\n   if (this._spreadMode === SpreadMode.NONE) {\r\n    for (let i = 0, ii = pages.length; i < ii; ++i) {\r\n     viewer.appendChild(pages[i].div);\r\n    }\r\n   } else {\r\n    const parity = this._spreadMode - 1;\r\n    let spread = null;\r\n    for (let i = 0, ii = pages.length; i < ii; ++i) {\r\n     if (spread === null) {\r\n      spread = document.createElement(\"div\");\r\n      spread.className = \"spread\";\r\n      viewer.appendChild(spread);\r\n     } else if (i % 2 === parity) {\r\n      spread = spread.cloneNode(false);\r\n      viewer.appendChild(spread);\r\n     }\r\n     spread.appendChild(pages[i].div);\r\n    }\r\n   }\r\n  }\r\n  if (!pageNumber) {\r\n   return;\r\n  }\r\n  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {\r\n   this._setScale(this._currentScaleValue, true);\r\n  }\r\n  this._setCurrentPageNumber(pageNumber, true);\r\n  this.update();\r\n }\r\n _getPageAdvance(currentPageNumber, previous = false) {\r\n  switch (this._scrollMode) {\r\n  case ScrollMode.WRAPPED: {\r\n    const {views} = this._getVisiblePages(), pageLayout = new Map();\r\n    for (const {id, y, percent, widthPercent} of views) {\r\n     if (percent === 0 || widthPercent < 100) {\r\n      continue;\r\n     }\r\n     let yArray = pageLayout.get(y);\r\n     if (!yArray) {\r\n      pageLayout.set(y, yArray ||= []);\r\n     }\r\n     yArray.push(id);\r\n    }\r\n    for (const yArray of pageLayout.values()) {\r\n     const currentIndex = yArray.indexOf(currentPageNumber);\r\n     if (currentIndex === -1) {\r\n      continue;\r\n     }\r\n     const numPages = yArray.length;\r\n     if (numPages === 1) {\r\n      break;\r\n     }\r\n     if (previous) {\r\n      for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {\r\n       const currentId = yArray[i], expectedId = yArray[i + 1] - 1;\r\n       if (currentId < expectedId) {\r\n        return currentPageNumber - expectedId;\r\n       }\r\n      }\r\n     } else {\r\n      for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {\r\n       const currentId = yArray[i], expectedId = yArray[i - 1] + 1;\r\n       if (currentId > expectedId) {\r\n        return expectedId - currentPageNumber;\r\n       }\r\n      }\r\n     }\r\n     if (previous) {\r\n      const firstId = yArray[0];\r\n      if (firstId < currentPageNumber) {\r\n       return currentPageNumber - firstId + 1;\r\n      }\r\n     } else {\r\n      const lastId = yArray[numPages - 1];\r\n      if (lastId > currentPageNumber) {\r\n       return lastId - currentPageNumber + 1;\r\n      }\r\n     }\r\n     break;\r\n    }\r\n    break;\r\n   }\r\n  case ScrollMode.HORIZONTAL: {\r\n    break;\r\n   }\r\n  case ScrollMode.PAGE:\r\n  case ScrollMode.VERTICAL: {\r\n    if (this._spreadMode === SpreadMode.NONE) {\r\n     break;\r\n    }\r\n    const parity = this._spreadMode - 1;\r\n    if (previous && currentPageNumber % 2 !== parity) {\r\n     break;\r\n    } else if (!previous && currentPageNumber % 2 === parity) {\r\n     break;\r\n    }\r\n    const {views} = this._getVisiblePages(), expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;\r\n    for (const {id, percent, widthPercent} of views) {\r\n     if (id !== expectedId) {\r\n      continue;\r\n     }\r\n     if (percent > 0 && widthPercent === 100) {\r\n      return 2;\r\n     }\r\n     break;\r\n    }\r\n    break;\r\n   }\r\n  }\r\n  return 1;\r\n }\r\n nextPage() {\r\n  const currentPageNumber = this._currentPageNumber, pagesCount = this.pagesCount;\r\n  if (currentPageNumber >= pagesCount) {\r\n   return false;\r\n  }\r\n  const advance = this._getPageAdvance(currentPageNumber, false) || 1;\r\n  this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);\r\n  return true;\r\n }\r\n previousPage() {\r\n  const currentPageNumber = this._currentPageNumber;\r\n  if (currentPageNumber <= 1) {\r\n   return false;\r\n  }\r\n  const advance = this._getPageAdvance(currentPageNumber, true) || 1;\r\n  this.currentPageNumber = Math.max(currentPageNumber - advance, 1);\r\n  return true;\r\n }\r\n increaseScale(steps = 1) {\r\n  let newScale = this._currentScale;\r\n  do {\r\n   newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);\r\n   newScale = Math.ceil(newScale * 10) / 10;\r\n   newScale = Math.min(MAX_SCALE, newScale);\r\n  } while (--steps > 0 && newScale < MAX_SCALE);\r\n  this.currentScaleValue = newScale;\r\n }\r\n decreaseScale(steps = 1) {\r\n  let newScale = this._currentScale;\r\n  do {\r\n   newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);\r\n   newScale = Math.floor(newScale * 10) / 10;\r\n   newScale = Math.max(MIN_SCALE, newScale);\r\n  } while (--steps > 0 && newScale > MIN_SCALE);\r\n  this.currentScaleValue = newScale;\r\n }\r\n}\r\nexport {\r\n BaseViewer,\r\n PagesCountLimit,\r\n PDFPageViewBuffer\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst WaitOnType = {\r\n EVENT: \"event\",\r\n TIMEOUT: \"timeout\"\r\n};\r\nfunction waitOnEventOrTimeout({target, name, delay = 0}) {\r\n return new Promise(function (resolve, reject) {\r\n  if (typeof target !== \"object\" || !(name && typeof name === \"string\") || !(Number.isInteger(delay) && delay >= 0)) {\r\n   throw new Error(\"waitOnEventOrTimeout - invalid parameters.\");\r\n  }\r\n  function handler(type) {\r\n   if (target instanceof EventBus) {\r\n    target._off(name, eventHandler);\r\n   } else {\r\n    target.removeEventListener(name, eventHandler);\r\n   }\r\n   if (timeout) {\r\n    clearTimeout(timeout);\r\n   }\r\n   resolve(type);\r\n  }\r\n  const eventHandler = handler.bind(null, WaitOnType.EVENT);\r\n  if (target instanceof EventBus) {\r\n   target._on(name, eventHandler);\r\n  } else {\r\n   target.addEventListener(name, eventHandler);\r\n  }\r\n  const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);\r\n  const timeout = setTimeout(timeoutHandler, delay);\r\n });\r\n}\r\nclass EventBus {\r\n constructor() {\r\n  this._listeners = Object.create(null);\r\n }\r\n on(eventName, listener, options = null) {\r\n  this._on(eventName, listener, {\r\n   external: true,\r\n   once: options?.once\r\n  });\r\n }\r\n off(eventName, listener, options = null) {\r\n  this._off(eventName, listener, {\r\n   external: true,\r\n   once: options?.once\r\n  });\r\n }\r\n dispatch(eventName, data) {\r\n  const eventListeners = this._listeners[eventName];\r\n  if (!eventListeners || eventListeners.length === 0) {\r\n   return;\r\n  }\r\n  let externalListeners;\r\n  for (const {listener, external, once} of eventListeners.slice(0)) {\r\n   if (once) {\r\n    this._off(eventName, listener);\r\n   }\r\n   if (external) {\r\n    (externalListeners ||= []).push(listener);\r\n    continue;\r\n   }\r\n   listener(data);\r\n  }\r\n  if (externalListeners) {\r\n   for (const listener of externalListeners) {\r\n    listener(data);\r\n   }\r\n   externalListeners = null;\r\n  }\r\n }\r\n _on(eventName, listener, options = null) {\r\n  const eventListeners = this._listeners[eventName] ||= [];\r\n  eventListeners.push({\r\n   listener,\r\n   external: options?.external === true,\r\n   once: options?.once === true\r\n  });\r\n }\r\n _off(eventName, listener, options = null) {\r\n  const eventListeners = this._listeners[eventName];\r\n  if (!eventListeners) {\r\n   return;\r\n  }\r\n  for (let i = 0, ii = eventListeners.length; i < ii; i++) {\r\n   if (eventListeners[i].listener === listener) {\r\n    eventListeners.splice(i, 1);\r\n    return;\r\n   }\r\n  }\r\n }\r\n}\r\nclass AutomationEventBus extends EventBus {\r\n dispatch(eventName, data) {\r\n  throw new Error(\"Not implemented: AutomationEventBus.dispatch\");\r\n }\r\n}\r\nexport {\r\n AutomationEventBus,\r\n EventBus,\r\n waitOnEventOrTimeout,\r\n WaitOnType\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst CSS_CLASS_GRAB = \"grab-to-pan-grab\";\r\nclass GrabToPan {\r\n constructor(options) {\r\n  this.element = options.element;\r\n  this.document = options.element.ownerDocument;\r\n  if (typeof options.ignoreTarget === \"function\") {\r\n   this.ignoreTarget = options.ignoreTarget;\r\n  }\r\n  this.onActiveChanged = options.onActiveChanged;\r\n  this.activate = this.activate.bind(this);\r\n  this.deactivate = this.deactivate.bind(this);\r\n  this.toggle = this.toggle.bind(this);\r\n  this._onMouseDown = this.#onMouseDown.bind(this);\r\n  this._onMouseMove = this.#onMouseMove.bind(this);\r\n  this._endPan = this.#endPan.bind(this);\r\n  const overlay = this.overlay = document.createElement(\"div\");\r\n  overlay.className = \"grab-to-pan-grabbing\";\r\n }\r\n activate() {\r\n  if (!this.active) {\r\n   this.active = true;\r\n   this.element.addEventListener(\"mousedown\", this._onMouseDown, true);\r\n   this.element.classList.add(CSS_CLASS_GRAB);\r\n   this.onActiveChanged?.(true);\r\n  }\r\n }\r\n deactivate() {\r\n  if (this.active) {\r\n   this.active = false;\r\n   this.element.removeEventListener(\"mousedown\", this._onMouseDown, true);\r\n   this._endPan();\r\n   this.element.classList.remove(CSS_CLASS_GRAB);\r\n   this.onActiveChanged?.(false);\r\n  }\r\n }\r\n toggle() {\r\n  if (this.active) {\r\n   this.deactivate();\r\n  } else {\r\n   this.activate();\r\n  }\r\n }\r\n ignoreTarget(node) {\r\n  return node.matches(\"a[href], a[href] *, input, textarea, button, button *, select, option\");\r\n }\r\n #onMouseDown(event) {\r\n  if (event.button !== 0 || this.ignoreTarget(event.target)) {\r\n   return;\r\n  }\r\n  if (event.originalTarget) {\r\n   try {\r\n    event.originalTarget.tagName;\r\n   } catch (e) {\r\n    return;\r\n   }\r\n  }\r\n  this.scrollLeftStart = this.element.scrollLeft;\r\n  this.scrollTopStart = this.element.scrollTop;\r\n  this.clientXStart = event.clientX;\r\n  this.clientYStart = event.clientY;\r\n  this.document.addEventListener(\"mousemove\", this._onMouseMove, true);\r\n  this.document.addEventListener(\"mouseup\", this._endPan, true);\r\n  this.element.addEventListener(\"scroll\", this._endPan, true);\r\n  event.preventDefault();\r\n  event.stopPropagation();\r\n  const focusedElement = document.activeElement;\r\n  if (focusedElement && !focusedElement.contains(event.target)) {\r\n   focusedElement.blur();\r\n  }\r\n }\r\n #onMouseMove(event) {\r\n  this.element.removeEventListener(\"scroll\", this._endPan, true);\r\n  if (!(event.buttons & 1)) {\r\n   this._endPan();\r\n   return;\r\n  }\r\n  const xDiff = event.clientX - this.clientXStart;\r\n  const yDiff = event.clientY - this.clientYStart;\r\n  const scrollTop = this.scrollTopStart - yDiff;\r\n  const scrollLeft = this.scrollLeftStart - xDiff;\r\n  if (this.element.scrollTo) {\r\n   this.element.scrollTo({\r\n    top: scrollTop,\r\n    left: scrollLeft,\r\n    behavior: \"instant\"\r\n   });\r\n  } else {\r\n   this.element.scrollTop = scrollTop;\r\n   this.element.scrollLeft = scrollLeft;\r\n  }\r\n  if (!this.overlay.parentNode) {\r\n   document.body.appendChild(this.overlay);\r\n  }\r\n }\r\n #endPan() {\r\n  this.element.removeEventListener(\"scroll\", this._endPan, true);\r\n  this.document.removeEventListener(\"mousemove\", this._onMouseMove, true);\r\n  this.document.removeEventListener(\"mouseup\", this._endPan, true);\r\n  this.overlay.remove();\r\n }\r\n}\r\nexport {\r\n GrabToPan\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst DEFAULT_L10N_STRINGS = {\r\n of_pages: \"of {{pagesCount}}\",\r\n page_of_pages: \"({{pageNumber}} of {{pagesCount}})\",\r\n document_properties_kb: \"{{size_kb}} KB ({{size_b}} bytes)\",\r\n document_properties_mb: \"{{size_mb}} MB ({{size_b}} bytes)\",\r\n document_properties_date_string: \"{{date}}, {{time}}\",\r\n document_properties_page_size_unit_inches: \"in\",\r\n document_properties_page_size_unit_millimeters: \"mm\",\r\n document_properties_page_size_orientation_portrait: \"portrait\",\r\n document_properties_page_size_orientation_landscape: \"landscape\",\r\n document_properties_page_size_name_a3: \"A3\",\r\n document_properties_page_size_name_a4: \"A4\",\r\n document_properties_page_size_name_letter: \"Letter\",\r\n document_properties_page_size_name_legal: \"Legal\",\r\n document_properties_page_size_dimension_string: \"{{width}} × {{height}} {{unit}} ({{orientation}})\",\r\n document_properties_page_size_dimension_name_string: \"{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})\",\r\n document_properties_linearized_yes: \"Yes\",\r\n document_properties_linearized_no: \"No\",\r\n print_progress_percent: \"{{progress}}%\",\r\n \"toggle_sidebar.title\": \"Toggle Sidebar\",\r\n \"toggle_sidebar_notification2.title\": \"Toggle Sidebar (document contains outline/attachments/layers)\",\r\n additional_layers: \"Additional Layers\",\r\n page_landmark: \"Page {{page}}\",\r\n thumb_page_title: \"Page {{page}}\",\r\n thumb_page_canvas: \"Thumbnail of Page {{page}}\",\r\n find_reached_top: \"Reached top of document, continued from bottom\",\r\n find_reached_bottom: \"Reached end of document, continued from top\",\r\n \"find_match_count[one]\": \"{{current}} of {{total}} match\",\r\n \"find_match_count[other]\": \"{{current}} of {{total}} matches\",\r\n \"find_match_count_limit[one]\": \"More than {{limit}} match\",\r\n \"find_match_count_limit[other]\": \"More than {{limit}} matches\",\r\n find_not_found: \"Phrase not found\",\r\n error_version_info: \"PDF.js v{{version}} (build: {{build}})\",\r\n error_message: \"Message: {{message}}\",\r\n error_stack: \"Stack: {{stack}}\",\r\n error_file: \"File: {{file}}\",\r\n error_line: \"Line: {{line}}\",\r\n rendering_error: \"An error occurred while rendering the page.\",\r\n page_scale_width: \"Page Width\",\r\n page_scale_fit: \"Page Fit\",\r\n page_scale_auto: \"Automatic Zoom\",\r\n page_scale_actual: \"Actual Size\",\r\n page_scale_percent: \"{{scale}}%\",\r\n loading: \"Loading…\",\r\n loading_error: \"An error occurred while loading the PDF.\",\r\n invalid_file_error: \"Invalid or corrupted PDF file.\",\r\n missing_file_error: \"Missing PDF file.\",\r\n unexpected_response_error: \"Unexpected server response.\",\r\n printing_not_supported: \"Warning: Printing is not fully supported by this browser.\",\r\n printing_not_ready: \"Warning: The PDF is not fully loaded for printing.\",\r\n web_fonts_disabled: \"Web fonts are disabled: unable to use embedded PDF fonts.\"\r\n};\r\nfunction getL10nFallback(key, args) {\r\n switch (key) {\r\n case \"find_match_count\":\r\n  key = `find_match_count[${ args.total === 1 ? \"one\" : \"other\" }]`;\r\n  break;\r\n case \"find_match_count_limit\":\r\n  key = `find_match_count_limit[${ args.limit === 1 ? \"one\" : \"other\" }]`;\r\n  break;\r\n }\r\n return DEFAULT_L10N_STRINGS[key] || \"\";\r\n}\r\nconst PARTIAL_LANG_CODES = {\r\n en: \"en-US\",\r\n es: \"es-ES\",\r\n fy: \"fy-NL\",\r\n ga: \"ga-IE\",\r\n gu: \"gu-IN\",\r\n hi: \"hi-IN\",\r\n hy: \"hy-AM\",\r\n nb: \"nb-NO\",\r\n ne: \"ne-NP\",\r\n nn: \"nn-NO\",\r\n pa: \"pa-IN\",\r\n pt: \"pt-PT\",\r\n sv: \"sv-SE\",\r\n zh: \"zh-CN\"\r\n};\r\nfunction fixupLangCode(langCode) {\r\n return PARTIAL_LANG_CODES[langCode?.toLowerCase()] || langCode;\r\n}\r\nfunction formatL10nValue(text, args) {\r\n if (!args) {\r\n  return text;\r\n }\r\n return text.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name) => {\r\n  return name in args ? args[name] : \"{{\" + name + \"}}\";\r\n });\r\n}\r\nconst NullL10n = {\r\n async getLanguage() {\r\n  return \"en-us\";\r\n },\r\n async getDirection() {\r\n  return \"ltr\";\r\n },\r\n async get(key, args = null, fallback = getL10nFallback(key, args)) {\r\n  return formatL10nValue(fallback, args);\r\n },\r\n async translate(element) {\r\n }\r\n};\r\nexport {\r\n fixupLangCode,\r\n getL10nFallback,\r\n NullL10n\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nclass OverlayManager {\r\n constructor() {\r\n  this._overlays = {};\r\n  this._active = null;\r\n  this._keyDownBound = this._keyDown.bind(this);\r\n }\r\n get active() {\r\n  return this._active;\r\n }\r\n async register(name, element, callerCloseMethod = null, canForceClose = false) {\r\n  let container;\r\n  if (!name || !element || !(container = element.parentNode)) {\r\n   throw new Error(\"Not enough parameters.\");\r\n  } else if (this._overlays[name]) {\r\n   throw new Error(\"The overlay is already registered.\");\r\n  }\r\n  this._overlays[name] = {\r\n   element,\r\n   container,\r\n   callerCloseMethod,\r\n   canForceClose\r\n  };\r\n }\r\n async unregister(name) {\r\n  if (!this._overlays[name]) {\r\n   throw new Error(\"The overlay does not exist.\");\r\n  } else if (this._active === name) {\r\n   throw new Error(\"The overlay cannot be removed while it is active.\");\r\n  }\r\n  delete this._overlays[name];\r\n }\r\n async open(name) {\r\n  if (!this._overlays[name]) {\r\n   throw new Error(\"The overlay does not exist.\");\r\n  } else if (this._active) {\r\n   if (this._overlays[name].canForceClose) {\r\n    this._closeThroughCaller();\r\n   } else if (this._active === name) {\r\n    throw new Error(\"The overlay is already active.\");\r\n   } else {\r\n    throw new Error(\"Another overlay is currently active.\");\r\n   }\r\n  }\r\n  this._active = name;\r\n  this._overlays[this._active].element.classList.remove(\"hidden\");\r\n  this._overlays[this._active].container.classList.remove(\"hidden\");\r\n  window.addEventListener(\"keydown\", this._keyDownBound);\r\n }\r\n async close(name) {\r\n  if (!this._overlays[name]) {\r\n   throw new Error(\"The overlay does not exist.\");\r\n  } else if (!this._active) {\r\n   throw new Error(\"The overlay is currently not active.\");\r\n  } else if (this._active !== name) {\r\n   throw new Error(\"Another overlay is currently active.\");\r\n  }\r\n  this._overlays[this._active].container.classList.add(\"hidden\");\r\n  this._overlays[this._active].element.classList.add(\"hidden\");\r\n  this._active = null;\r\n  window.removeEventListener(\"keydown\", this._keyDownBound);\r\n }\r\n _keyDown(evt) {\r\n  if (this._active && evt.keyCode === 27) {\r\n   this._closeThroughCaller();\r\n   evt.preventDefault();\r\n  }\r\n }\r\n _closeThroughCaller() {\r\n  if (this._overlays[this._active].callerCloseMethod) {\r\n   this._overlays[this._active].callerCloseMethod();\r\n  }\r\n  if (this._active) {\r\n   this.close(this._active);\r\n  }\r\n }\r\n}\r\nexport {\r\n OverlayManager\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {PasswordResponses} = require(\"pdfjs-dist\");\r\nclass PasswordPrompt {\r\n constructor(options, overlayManager, l10n, isViewerEmbedded = false) {\r\n  this.overlayName = options.overlayName;\r\n  this.container = options.container;\r\n  this.label = options.label;\r\n  this.input = options.input;\r\n  this.submitButton = options.submitButton;\r\n  this.cancelButton = options.cancelButton;\r\n  this.overlayManager = overlayManager;\r\n  this.l10n = l10n;\r\n  this._isViewerEmbedded = isViewerEmbedded;\r\n  this.updateCallback = null;\r\n  this.reason = null;\r\n  this.submitButton.addEventListener(\"click\", this.#verify.bind(this));\r\n  this.cancelButton.addEventListener(\"click\", this.#cancel.bind(this));\r\n  this.input.addEventListener(\"keydown\", e => {\r\n   if (e.keyCode === 13) {\r\n    this.#verify();\r\n   }\r\n  });\r\n  this.overlayManager.register(this.overlayName, this.container, this.#cancel.bind(this), true);\r\n }\r\n async open() {\r\n  await this.overlayManager.open(this.overlayName);\r\n  const passwordIncorrect = this.reason === PasswordResponses.INCORRECT_PASSWORD;\r\n  if (!this._isViewerEmbedded || passwordIncorrect) {\r\n   this.input.focus();\r\n  }\r\n  this.label.textContent = await this.l10n.get(`password_${ passwordIncorrect ? \"invalid\" : \"label\" }`);\r\n }\r\n close() {\r\n  this.overlayManager.close(this.overlayName).then(() => {\r\n   this.input.value = \"\";\r\n  });\r\n }\r\n #verify() {\r\n  const password = this.input.value;\r\n  if (password?.length > 0) {\r\n   this.close();\r\n   this.updateCallback(password);\r\n  }\r\n }\r\n #cancel() {\r\n  this.close();\r\n  this.updateCallback(new Error(\"PasswordPrompt cancelled.\"));\r\n }\r\n setUpdateCallback(updateCallback, reason) {\r\n  this.updateCallback = updateCallback;\r\n  this.reason = reason;\r\n }\r\n}\r\nexport {\r\n PasswordPrompt\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {GrabToPan} = require(\"./grab_to_pan.js\");\r\n\r\nconst CursorTool = {\r\n SELECT: 0,\r\n HAND: 1,\r\n ZOOM: 2\r\n};\r\nclass PDFCursorTools {\r\n constructor({container, eventBus, cursorToolOnLoad = CursorTool.SELECT}) {\r\n  this.container = container;\r\n  this.eventBus = eventBus;\r\n  this.active = CursorTool.SELECT;\r\n  this.activeBeforePresentationMode = null;\r\n  this.handTool = new GrabToPan({ element: this.container });\r\n  this._addEventListeners();\r\n  Promise.resolve().then(() => {\r\n   this.switchTool(cursorToolOnLoad);\r\n  });\r\n }\r\n get activeTool() {\r\n  return this.active;\r\n }\r\n switchTool(tool) {\r\n  if (this.activeBeforePresentationMode !== null) {\r\n   return;\r\n  }\r\n  if (tool === this.active) {\r\n   return;\r\n  }\r\n  const disableActiveTool = () => {\r\n   switch (this.active) {\r\n   case CursorTool.SELECT:\r\n    break;\r\n   case CursorTool.HAND:\r\n    this.handTool.deactivate();\r\n    break;\r\n   case CursorTool.ZOOM:\r\n   }\r\n  };\r\n  switch (tool) {\r\n  case CursorTool.SELECT:\r\n   disableActiveTool();\r\n   break;\r\n  case CursorTool.HAND:\r\n   disableActiveTool();\r\n   this.handTool.activate();\r\n   break;\r\n  case CursorTool.ZOOM:\r\n  default:\r\n   console.error(`switchTool: \"${ tool }\" is an unsupported value.`);\r\n   return;\r\n  }\r\n  this.active = tool;\r\n  this._dispatchEvent();\r\n }\r\n _dispatchEvent() {\r\n  this.eventBus.dispatch(\"cursortoolchanged\", {\r\n   source: this,\r\n   tool: this.active\r\n  });\r\n }\r\n _addEventListeners() {\r\n  this.eventBus._on(\"switchcursortool\", evt => {\r\n   this.switchTool(evt.tool);\r\n  });\r\n  \r\n }\r\n}\r\nexport {\r\n CursorTool,\r\n PDFCursorTools\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {FindState} = require(\"./pdf_find_controller.js\");\r\nconst MATCHES_COUNT_LIMIT = 1000;\r\nclass PDFFindBar {\r\n constructor(options, eventBus, l10n) {\r\n  this.opened = false;\r\n  this.bar = options.bar;\r\n  this.toggleButton = options.toggleButton;\r\n  this.findField = options.findField;\r\n  this.highlightAll = options.highlightAllCheckbox;\r\n  this.caseSensitive = options.caseSensitiveCheckbox;\r\n  this.matchDiacritics = options.matchDiacriticsCheckbox;\r\n  this.entireWord = options.entireWordCheckbox;\r\n  this.findMsg = options.findMsg;\r\n  this.findResultsCount = options.findResultsCount;\r\n  this.findPreviousButton = options.findPreviousButton;\r\n  this.findNextButton = options.findNextButton;\r\n  this.eventBus = eventBus;\r\n  this.l10n = l10n;\r\n  this.toggleButton.addEventListener(\"click\", () => {\r\n   this.toggle();\r\n  });\r\n  this.findField.addEventListener(\"input\", () => {\r\n   this.dispatchEvent(\"\");\r\n  });\r\n  this.bar.addEventListener(\"keydown\", e => {\r\n   switch (e.keyCode) {\r\n   case 13:\r\n    if (e.target === this.findField) {\r\n     this.dispatchEvent(\"again\", e.shiftKey);\r\n    }\r\n    break;\r\n   case 27:\r\n    this.close();\r\n    break;\r\n   }\r\n  });\r\n  this.findPreviousButton.addEventListener(\"click\", () => {\r\n   this.dispatchEvent(\"again\", true);\r\n  });\r\n  this.findNextButton.addEventListener(\"click\", () => {\r\n   this.dispatchEvent(\"again\", false);\r\n  });\r\n  this.highlightAll.addEventListener(\"click\", () => {\r\n   this.dispatchEvent(\"highlightallchange\");\r\n  });\r\n  this.caseSensitive.addEventListener(\"click\", () => {\r\n   this.dispatchEvent(\"casesensitivitychange\");\r\n  });\r\n  this.entireWord.addEventListener(\"click\", () => {\r\n   this.dispatchEvent(\"entirewordchange\");\r\n  });\r\n  this.matchDiacritics.addEventListener(\"click\", () => {\r\n   this.dispatchEvent(\"diacriticmatchingchange\");\r\n  });\r\n  this.eventBus._on(\"resize\", this._adjustWidth.bind(this));\r\n }\r\n reset() {\r\n  this.updateUIState();\r\n }\r\n dispatchEvent(type, findPrev = false) {\r\n     console.log(\"find Event dispatch\",{\r\n        source: this,\r\n        type,\r\n        query: this.findField.value,\r\n        phraseSearch: true,\r\n        caseSensitive: this.caseSensitive.checked,\r\n        entireWord: this.entireWord.checked,\r\n        highlightAll: this.highlightAll.checked,\r\n        findPrevious: findPrev,\r\n        matchDiacritics: this.matchDiacritics.checked\r\n     });\r\n  this.eventBus.dispatch(\"find\", {\r\n   source: this,\r\n   type,\r\n   query: this.findField.value,\r\n   phraseSearch: true,\r\n   caseSensitive: this.caseSensitive.checked,\r\n   entireWord: this.entireWord.checked,\r\n   highlightAll: this.highlightAll.checked,\r\n   findPrevious: findPrev,\r\n   matchDiacritics: this.matchDiacritics.checked\r\n  });\r\n }\r\n updateUIState(state, previous, matchesCount) {\r\n  let findMsg = Promise.resolve(\"\");\r\n  let status = \"\";\r\n  switch (state) {\r\n  case FindState.FOUND:\r\n   break;\r\n  case FindState.PENDING:\r\n   status = \"pending\";\r\n   break;\r\n  case FindState.NOT_FOUND:\r\n   findMsg = this.l10n.get(\"find_not_found\");\r\n   status = \"notFound\";\r\n   break;\r\n  case FindState.WRAPPED:\r\n   findMsg = this.l10n.get(`find_reached_${ previous ? \"top\" : \"bottom\" }`);\r\n   break;\r\n  }\r\n  this.findField.setAttribute(\"data-status\", status);\r\n  findMsg.then(msg => {\r\n   this.findMsg.textContent = msg;\r\n   this._adjustWidth();\r\n  });\r\n  this.updateResultsCount(matchesCount);\r\n }\r\n updateResultsCount({current = 0, total = 0} = {}) {\r\n  const limit = MATCHES_COUNT_LIMIT;\r\n  let matchCountMsg = Promise.resolve(\"\");\r\n  if (total > 0) {\r\n   if (total > limit) {\r\n    let key = \"find_match_count_limit\";\r\n    matchCountMsg = this.l10n.get(key, { limit });\r\n   } else {\r\n    let key = \"find_match_count\";\r\n    matchCountMsg = this.l10n.get(key, {\r\n     current,\r\n     total\r\n    });\r\n   }\r\n  }\r\n  matchCountMsg.then(msg => {\r\n   this.findResultsCount.textContent = msg;\r\n   this._adjustWidth();\r\n  });\r\n }\r\n open() {\r\n  if (!this.opened) {\r\n   this.opened = true;\r\n   this.toggleButton.classList.add(\"toggled\");\r\n   this.toggleButton.setAttribute(\"aria-expanded\", \"true\");\r\n   this.bar.classList.remove(\"hidden\");\r\n  }\r\n  this.findField.select();\r\n  this.findField.focus();\r\n  this._adjustWidth();\r\n }\r\n close() {\r\n  if (!this.opened) {\r\n   return;\r\n  }\r\n  this.opened = false;\r\n  this.toggleButton.classList.remove(\"toggled\");\r\n  this.toggleButton.setAttribute(\"aria-expanded\", \"false\");\r\n  this.bar.classList.add(\"hidden\");\r\n  this.eventBus.dispatch(\"findbarclose\", { source: this });\r\n }\r\n toggle() {\r\n  if (this.opened) {\r\n   this.close();\r\n  } else {\r\n   this.open();\r\n  }\r\n }\r\n _adjustWidth() {\r\n  if (!this.opened) {\r\n   return;\r\n  }\r\n  this.bar.classList.remove(\"wrapContainers\");\r\n  const findbarHeight = this.bar.clientHeight;\r\n  const inputContainerHeight = this.bar.firstElementChild.clientHeight;\r\n  if (findbarHeight > inputContainerHeight) {\r\n   this.bar.classList.add(\"wrapContainers\");\r\n  }\r\n }\r\n}\r\nexport {\r\n PDFFindBar\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst { binarySearchFirstItem, scrollIntoView } = require('./ui_utils.js');\r\nconst { createPromiseCapability } = require('pdfjs-dist');\r\nconst { getCharacterType } = require('./pdf_find_utils.js');\r\nconst FindState = {\r\n    FOUND: 0,\r\n    NOT_FOUND: 1,\r\n    WRAPPED: 2,\r\n    PENDING: 3,\r\n};\r\nconst FIND_TIMEOUT = 250;\r\nconst MATCH_SCROLL_OFFSET_TOP = -50;\r\nconst MATCH_SCROLL_OFFSET_LEFT = -400;\r\nconst CHARACTERS_TO_NORMALIZE = {\r\n    '\\u2010': '-',\r\n    '\\u2018': \"'\",\r\n    '\\u2019': \"'\",\r\n    '\\u201A': \"'\",\r\n    '\\u201B': \"'\",\r\n    '\\u201C': '\"',\r\n    '\\u201D': '\"',\r\n    '\\u201E': '\"',\r\n    '\\u201F': '\"',\r\n    '\\u00BC': '1/4',\r\n    '\\u00BD': '1/2',\r\n    '\\u00BE': '3/4',\r\n};\r\nconst DIACRITICS_EXCEPTION = new Set([\r\n    0x3099, 0x309a, 0x094d, 0x09cd, 0x0a4d, 0x0acd, 0x0b4d, 0x0bcd, 0x0c4d, 0x0ccd, 0x0d3b, 0x0d3c, 0x0d4d, 0x0dca,\r\n    0x0e3a, 0x0eba, 0x0f84, 0x1039, 0x103a, 0x1714, 0x1734, 0x17d2, 0x1a60, 0x1b44, 0x1baa, 0x1bab, 0x1bf2, 0x1bf3,\r\n    0x2d7f, 0xa806, 0xa82c, 0xa8c4, 0xa953, 0xa9c0, 0xaaf6, 0xabed, 0x0c56, 0x0f71, 0x0f72, 0x0f7a, 0x0f7b, 0x0f7c,\r\n    0x0f7d, 0x0f80, 0x0f74,\r\n]);\r\nconst DIACRITICS_EXCEPTION_STR = [...DIACRITICS_EXCEPTION.values()].map((x) => String.fromCharCode(x)).join('');\r\nconst DIACRITICS_REG_EXP = /\\p{M}+/gu;\r\nconst SPECIAL_CHARS_REG_EXP = /([.*+?^${}()|[\\]\\\\])|(\\p{P})|(\\s+)|(\\p{M})|(\\p{L})/gu;\r\nconst NOT_DIACRITIC_FROM_END_REG_EXP = /([^\\p{M}])\\p{M}*$/u;\r\nconst NOT_DIACRITIC_FROM_START_REG_EXP = /^\\p{M}*([^\\p{M}])/u;\r\nlet normalizationRegex = null;\r\nfunction normalize(text) {\r\n    if (!normalizationRegex) {\r\n        const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join('');\r\n        normalizationRegex = new RegExp(`([${replace}])|(\\\\S-\\\\n)|(\\\\n)|(\\\\p{M}+)`, 'gum');\r\n    }\r\n    const rawDiacriticsPositions = [];\r\n    let m;\r\n    while ((m = DIACRITICS_REG_EXP.exec(text)) !== null) {\r\n        rawDiacriticsPositions.push([m[0].length, m.index]);\r\n    }\r\n    let normalized = text.normalize('NFD');\r\n    const positions = [[0, 0]];\r\n    let k = 0;\r\n    let shift = 0;\r\n    let shiftOrigin = 0;\r\n    let eol = 0;\r\n    let hasDiacritics = false;\r\n    normalized = normalized.replace(normalizationRegex, (match, p1, p2, p3, p4, i) => {\r\n        i -= shiftOrigin;\r\n        if (p1) {\r\n            const replacement = CHARACTERS_TO_NORMALIZE[match];\r\n            const jj = replacement.length;\r\n            for (let j = 1; j < jj; j++) {\r\n                positions.push([i - shift + j, shift - j]);\r\n            }\r\n            shift -= jj - 1;\r\n            return replacement;\r\n        }\r\n        if (p2) {\r\n            positions.push([i - shift, 1 + shift]);\r\n            shift += 1;\r\n            shiftOrigin += 1;\r\n            eol += 1;\r\n            return p2.charAt(0);\r\n        }\r\n        if (p3) {\r\n            positions.push([i - shift + 1, shift - 1]);\r\n            shift -= 1;\r\n            shiftOrigin += 1;\r\n            eol += 1;\r\n            return ' ';\r\n        }\r\n        hasDiacritics = true;\r\n        let jj = p4.length;\r\n        if (i + eol === rawDiacriticsPositions[k]?.[1]) {\r\n            jj -= rawDiacriticsPositions[k][0];\r\n            ++k;\r\n        }\r\n        for (let j = 1; j < jj + 1; j++) {\r\n            positions.push([i - 1 - shift + j, shift - j]);\r\n        }\r\n        shift -= jj;\r\n        shiftOrigin += jj;\r\n        return p4;\r\n    });\r\n    positions.push([normalized.length, shift]);\r\n    return [normalized, positions, hasDiacritics];\r\n}\r\nfunction getOriginalIndex(diffs, pos, len) {\r\n    if (!diffs) {\r\n        return [pos, len];\r\n    }\r\n    const start = pos;\r\n    const end = pos + len;\r\n    let i = binarySearchFirstItem(diffs, (x) => x[0] >= start);\r\n    if (diffs[i][0] > start) {\r\n        --i;\r\n    }\r\n    let j = binarySearchFirstItem(diffs, (x) => x[0] >= end, i);\r\n    if (diffs[j][0] > end) {\r\n        --j;\r\n    }\r\n    return [start + diffs[i][1], len + diffs[j][1] - diffs[i][1]];\r\n}\r\nclass PDFFindController {\r\n    constructor({ linkService, eventBus }) {\r\n        this._linkService = linkService;\r\n        this._eventBus = eventBus;\r\n        this._reset();\r\n        eventBus._on('find', this._onFind.bind(this));\r\n        eventBus._on('findbarclose', this._onFindBarClose.bind(this));\r\n        this.executeCommand = (cmd, state) => {\r\n            console.error(\r\n                'Deprecated method `PDFFindController.executeCommand` called, ' +\r\n                    'please dispatch a \"find\"-event using the EventBus instead.'\r\n            );\r\n            const eventState = Object.assign(Object.create(null), state, { type: cmd.substring('find'.length) });\r\n            this._onFind(eventState);\r\n        };\r\n    }\r\n    get highlightMatches() {\r\n        return this._highlightMatches;\r\n    }\r\n    get pageMatches() {\r\n        return this._pageMatches;\r\n    }\r\n    get pageMatchesLength() {\r\n        return this._pageMatchesLength;\r\n    }\r\n    get selected() {\r\n        return this._selected;\r\n    }\r\n    get state() {\r\n        return this._state;\r\n    }\r\n    setDocument(pdfDocument) {\r\n        if (this._pdfDocument) {\r\n            this._reset();\r\n        }\r\n        if (!pdfDocument) {\r\n            return;\r\n        }\r\n        this._pdfDocument = pdfDocument;\r\n        this._firstPageCapability.resolve();\r\n    }\r\n    _onFind(state) {\r\n        if (!state) {\r\n            return;\r\n        }\r\n        const pdfDocument = this._pdfDocument;\r\n        const { type } = state;\r\n        if (this._state === null || this._shouldDirtyMatch(state)) {\r\n            this._dirtyMatch = true;\r\n        }\r\n        this._state = state;\r\n        if (type !== 'highlightallchange') {\r\n            this._updateUIState(FindState.PENDING);\r\n        }\r\n        this._firstPageCapability.promise.then(() => {\r\n            if (!this._pdfDocument || (pdfDocument && this._pdfDocument !== pdfDocument)) {\r\n                return;\r\n            }\r\n            this._extractText();\r\n            const findbarClosed = !this._highlightMatches;\r\n            const pendingTimeout = !!this._findTimeout;\r\n            if (this._findTimeout) {\r\n                clearTimeout(this._findTimeout);\r\n                this._findTimeout = null;\r\n            }\r\n            if (!type) {\r\n                this._findTimeout = setTimeout(() => {\r\n                    this._nextMatch();\r\n                    this._findTimeout = null;\r\n                }, FIND_TIMEOUT);\r\n            } else if (this._dirtyMatch) {\r\n                this._nextMatch();\r\n            } else if (type === 'again') {\r\n                this._nextMatch();\r\n                if (findbarClosed && this._state.highlightAll) {\r\n                    this._updateAllPages();\r\n                }\r\n            } else if (type === 'highlightallchange') {\r\n                if (pendingTimeout) {\r\n                    this._nextMatch();\r\n                } else {\r\n                    this._highlightMatches = true;\r\n                }\r\n                this._updateAllPages();\r\n            } else {\r\n                this._nextMatch();\r\n            }\r\n        });\r\n    }\r\n\r\n    scrollMatchIntoView({ element = null, selectedLeft = 0, pageIndex = -1, matchIndex = -1 }) {\r\n        if (!this._scrollMatches || !element) {\r\n            return;\r\n        } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {\r\n            return;\r\n        } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {\r\n            return;\r\n        }\r\n        this._scrollMatches = false;\r\n        const spot = {\r\n            top: MATCH_SCROLL_OFFSET_TOP,\r\n            left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT,\r\n        };\r\n        scrollIntoView(element, spot, true);\r\n    }\r\n    _reset() {\r\n        this._highlightMatches = false;\r\n        this._scrollMatches = false;\r\n        this._pdfDocument = null;\r\n        this._pageMatches = [];\r\n        this._pageMatchesLength = [];\r\n        this._state = null;\r\n        this._selected = {\r\n            pageIdx: -1,\r\n            matchIdx: -1,\r\n        };\r\n        this._offset = {\r\n            pageIdx: null,\r\n            matchIdx: null,\r\n            wrapped: false,\r\n        };\r\n        this._extractTextPromises = [];\r\n        this._pageContents = [];\r\n        this._pageDiffs = [];\r\n        this._hasDiacritics = [];\r\n        this._matchesCountTotal = 0;\r\n        this._pagesToSearch = null;\r\n        this._pendingFindMatches = new Set();\r\n        this._resumePageIdx = null;\r\n        this._dirtyMatch = false;\r\n        clearTimeout(this._findTimeout);\r\n        this._findTimeout = null;\r\n        this._firstPageCapability = createPromiseCapability();\r\n    }\r\n    get _query() {\r\n        if (this._state.query !== this._rawQuery) {\r\n            this._rawQuery = this._state.query;\r\n            [this._normalizedQuery] = normalize(this._state.query);\r\n        }\r\n        return this._normalizedQuery;\r\n    }\r\n    _shouldDirtyMatch(state) {\r\n        if (state.query !== this._state.query) {\r\n            return true;\r\n        }\r\n        switch (state.type) {\r\n            case 'again':\r\n                const pageNumber = this._selected.pageIdx + 1;\r\n                const linkService = this._linkService;\r\n                if (\r\n                    pageNumber >= 1 &&\r\n                    pageNumber <= linkService.pagesCount &&\r\n                    pageNumber !== linkService.page &&\r\n                    !linkService.isPageVisible(pageNumber)\r\n                ) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            case 'highlightallchange':\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    _isEntireWord(content, startIdx, length) {\r\n        let match = content.slice(0, startIdx).match(NOT_DIACRITIC_FROM_END_REG_EXP);\r\n        if (match) {\r\n            const first = content.charCodeAt(startIdx);\r\n            const limit = match[1].charCodeAt(0);\r\n            if (getCharacterType(first) === getCharacterType(limit)) {\r\n                return false;\r\n            }\r\n        }\r\n        match = content.slice(startIdx + length).match(NOT_DIACRITIC_FROM_START_REG_EXP);\r\n        if (match) {\r\n            const last = content.charCodeAt(startIdx + length - 1);\r\n            const limit = match[1].charCodeAt(0);\r\n            if (getCharacterType(last) === getCharacterType(limit)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _calculateRegExpMatch(query, entireWord, pageIndex, pageContent, sdpdfcoreRequestId = -1) {\r\n        const matches = [],\r\n            matchesLength = [],\r\n            matchesDigests = [];\r\n        let id = 0;\r\n        const diffs = this._pageDiffs[pageIndex];\r\n        let match;\r\n        if (sdpdfcoreRequestId != (this._state.sdpdfcoreRequestId || -1)) return;\r\n        while ((match = query.exec(pageContent)) !== null) {\r\n            if (entireWord && !this._isEntireWord(pageContent, match.index, match[0].length)) {\r\n                continue;\r\n            }\r\n            const [matchPos, matchLen] = getOriginalIndex(diffs, match.index, match[0].length);\r\n            if (matchLen) {\r\n                matches.push(matchPos);\r\n                matchesLength.push(matchLen);\r\n                const predigest = match.input.substring(match.index - 50 > 0 ? match.index - 50 : 0, match.index);\r\n                const middigest = match.input.substring(match.index, match.index + match[0].length);\r\n                const aftdigest = match.input.substring(\r\n                    match.index + match[0].length,\r\n                    match.index + match[0].length + 50 < match.input.length\r\n                        ? match.index + match[0].length + 50\r\n                        : match.input.length - 1\r\n                );\r\n                matchesDigests.push({\r\n                    pageIndex,\r\n                    matchIndex: id,\r\n                    digestHtml: `${predigest}<span class=\"__searchHighLight\">${middigest}</span>${aftdigest}`,\r\n                });\r\n                id++;\r\n            }\r\n        }\r\n\r\n        this._pageMatches[pageIndex] = matches;\r\n        this._pageMatchesLength[pageIndex] = matchesLength;\r\n        if (matches.length != 0) {\r\n            window.__sdJSBridge &&\r\n                __sdJSBridge.publish('find_digests', {\r\n                    requestId: sdpdfcoreRequestId,\r\n                    pageIndex,\r\n                    matchesDigests,\r\n                    matches,\r\n                });\r\n        }\r\n    }\r\n    _convertToRegExpString(query, hasDiacritics) {\r\n        const { matchDiacritics } = this._state;\r\n        let isUnicode = false;\r\n        query = query.replace(SPECIAL_CHARS_REG_EXP, (match, p1, p2, p3, p4, p5) => {\r\n            if (p1) {\r\n                return `[ ]*\\\\${p1}[ ]*`;\r\n            }\r\n            if (p2) {\r\n                return `[ ]*${p2}[ ]*`;\r\n            }\r\n            if (p3) {\r\n                return '[ ]+';\r\n            }\r\n            if (matchDiacritics) {\r\n                return p4 || p5;\r\n            }\r\n            if (p4) {\r\n                return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : '';\r\n            }\r\n            if (hasDiacritics) {\r\n                isUnicode = true;\r\n                return `${p5}\\\\p{M}*`;\r\n            }\r\n            return p5;\r\n        });\r\n        const trailingSpaces = '[ ]*';\r\n        if (query.endsWith(trailingSpaces)) {\r\n            query = query.slice(0, query.length - trailingSpaces.length);\r\n        }\r\n        if (matchDiacritics) {\r\n            if (hasDiacritics) {\r\n                isUnicode = true;\r\n                query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\\\p{M}]|$)`;\r\n            }\r\n        }\r\n        return [isUnicode, query];\r\n    }\r\n    _calculateMatch(pageIndex, sdpdfcoreRequestId = -1) {\r\n        if (sdpdfcoreRequestId != (this._state.sdpdfcoreRequestId || -1)) return;\r\n        let query = this._query;\r\n        if (query.length === 0) {\r\n            return;\r\n        }\r\n        const { caseSensitive, entireWord, phraseSearch } = this._state;\r\n        const pageContent = this._pageContents[pageIndex];\r\n        const hasDiacritics = this._hasDiacritics[pageIndex];\r\n        let isUnicode = false;\r\n        if (phraseSearch) {\r\n            [isUnicode, query] = this._convertToRegExpString(query, hasDiacritics);\r\n        } else {\r\n            const match = query.match(/\\S+/g);\r\n            if (match) {\r\n                query = match\r\n                    .sort()\r\n                    .reverse()\r\n                    .map((q) => {\r\n                        const [isUnicodePart, queryPart] = this._convertToRegExpString(q, hasDiacritics);\r\n                        isUnicode ||= isUnicodePart;\r\n                        return `(${queryPart})`;\r\n                    })\r\n                    .join('|');\r\n            }\r\n        }\r\n        const flags = `g${isUnicode ? 'u' : ''}${caseSensitive ? '' : 'i'}`;\r\n        query = new RegExp(query, flags);\r\n        this._calculateRegExpMatch(query, entireWord, pageIndex, pageContent, sdpdfcoreRequestId);\r\n        if (this._state.highlightAll) {\r\n            this._updatePage(pageIndex);\r\n        }\r\n        if (this._resumePageIdx === pageIndex) {\r\n            this._resumePageIdx = null;\r\n            this._nextPageMatch();\r\n        }\r\n        const pageMatchesCount = this._pageMatches[pageIndex].length;\r\n        if (pageMatchesCount > 0) {\r\n            this._matchesCountTotal += pageMatchesCount;\r\n            this._updateUIResultsCount();\r\n        }\r\n    }\r\n    _extractText() {\r\n        if (this._extractTextPromises.length > 0) {\r\n            return;\r\n        }\r\n        let promise = Promise.resolve();\r\n        for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {\r\n            const extractTextCapability = createPromiseCapability();\r\n            this._extractTextPromises[i] = extractTextCapability.promise;\r\n            promise = promise.then(() => {\r\n                return this._pdfDocument\r\n                    .getPage(i + 1)\r\n                    .then((pdfPage) => {\r\n                        return pdfPage.getTextContent();\r\n                    })\r\n                    .then(\r\n                        (textContent) => {\r\n                            const textItems = textContent.items;\r\n                            const strBuf = [];\r\n                            for (let j = 0, jj = textItems.length; j < jj; j++) {\r\n                                strBuf.push(textItems[j].str);\r\n                                if (textItems[j].hasEOL) {\r\n                                    strBuf.push('\\n');\r\n                                }\r\n                            }\r\n                            [this._pageContents[i], this._pageDiffs[i], this._hasDiacritics[i]] = normalize(\r\n                                strBuf.join('')\r\n                            );\r\n                            extractTextCapability.resolve(i);\r\n                        },\r\n                        (reason) => {\r\n                            console.error(`Unable to get text content for page ${i + 1}`, reason);\r\n                            this._pageContents[i] = '';\r\n                            this._pageDiffs[i] = null;\r\n                            this._hasDiacritics[i] = false;\r\n                            extractTextCapability.resolve(i);\r\n                        }\r\n                    );\r\n            });\r\n        }\r\n    }\r\n    _updatePage(index) {\r\n        if (this._scrollMatches && this._selected.pageIdx === index) {\r\n            this._linkService.page = index + 1;\r\n        }\r\n        this._eventBus.dispatch('updatetextlayermatches', {\r\n            source: this,\r\n            pageIndex: index,\r\n        });\r\n    }\r\n    _updateAllPages() {\r\n        this._eventBus.dispatch('updatetextlayermatches', {\r\n            source: this,\r\n            pageIndex: -1,\r\n        });\r\n    }\r\n\r\n    // sdpdfcore\r\n    _gotoMatch(p, m) {\r\n        this._scrollMatches = true;\r\n        this.selected.pageIdx = p;\r\n        this.selected.matchIdx = m;\r\n        this._selected.pageIdx = p;\r\n        this._selected.matchIdx = m;\r\n        this._offset.pageIdx = p;\r\n        this._offset.matchIdx = m;\r\n        this._offset.wrapped = false;\r\n        this._updatePage(p);\r\n        this._updateUIResultsCount();\r\n    }\r\n\r\n    _nextMatch() {\r\n        const previous = this._state.findPrevious;\r\n        const currentPageIndex = this._linkService.page - 1;\r\n        const numPages = this._linkService.pagesCount;\r\n        this._highlightMatches = true;\r\n        const sdpdfcoreRequestId = this._state.sdpdfcoreRequestId || -1;\r\n        if (this._dirtyMatch) {\r\n            this._dirtyMatch = false;\r\n            this._selected.pageIdx = this._selected.matchIdx = -1;\r\n            this._offset.pageIdx = currentPageIndex;\r\n            this._offset.matchIdx = null;\r\n            this._offset.wrapped = false;\r\n            this._resumePageIdx = null;\r\n            this._pageMatches.length = 0;\r\n            this._pageMatchesLength.length = 0;\r\n            this._matchesCountTotal = 0;\r\n            this._updateAllPages();\r\n            for (let i = 0; i < numPages; i++) {\r\n                if (this._pendingFindMatches.has(i)) {\r\n                    continue;\r\n                }\r\n                this._pendingFindMatches.add(i);\r\n                this._extractTextPromises[i].then((pageIdx) => {\r\n                    this._pendingFindMatches.delete(pageIdx);\r\n                    this._calculateMatch(pageIdx, sdpdfcoreRequestId);\r\n                });\r\n            }\r\n        }\r\n        if (this._query === '') {\r\n            this._updateUIState(FindState.FOUND);\r\n            return;\r\n        }\r\n        if (this._resumePageIdx) {\r\n            return;\r\n        }\r\n        const offset = this._offset;\r\n        this._pagesToSearch = numPages;\r\n        if (offset.matchIdx !== null) {\r\n            const numPageMatches = this._pageMatches[offset.pageIdx].length;\r\n            if ((!previous && offset.matchIdx + 1 < numPageMatches) || (previous && offset.matchIdx > 0)) {\r\n                offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;\r\n                this._updateMatch(true);\r\n                return;\r\n            }\r\n            this._advanceOffsetPage(previous);\r\n        }\r\n        this._nextPageMatch();\r\n    }\r\n\r\n    _matchesReady(matches) {\r\n        const offset = this._offset;\r\n        const numMatches = matches.length;\r\n        const previous = this._state.findPrevious;\r\n        if (numMatches) {\r\n            offset.matchIdx = previous ? numMatches - 1 : 0;\r\n            this._updateMatch(true);\r\n            return true;\r\n        }\r\n        this._advanceOffsetPage(previous);\r\n        if (offset.wrapped) {\r\n            offset.matchIdx = null;\r\n            if (this._pagesToSearch < 0) {\r\n                this._updateMatch(false);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _nextPageMatch() {\r\n        if (this._resumePageIdx !== null) {\r\n            console.error('There can only be one pending page.');\r\n        }\r\n        let matches = null;\r\n        do {\r\n            const pageIdx = this._offset.pageIdx;\r\n            matches = this._pageMatches[pageIdx];\r\n            if (!matches) {\r\n                this._resumePageIdx = pageIdx;\r\n                break;\r\n            }\r\n        } while (!this._matchesReady(matches));\r\n    }\r\n\r\n    _advanceOffsetPage(previous) {\r\n        const offset = this._offset;\r\n        const numPages = this._linkService.pagesCount;\r\n        offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;\r\n        offset.matchIdx = null;\r\n        this._pagesToSearch--;\r\n        if (offset.pageIdx >= numPages || offset.pageIdx < 0) {\r\n            offset.pageIdx = previous ? numPages - 1 : 0;\r\n            offset.wrapped = true;\r\n        }\r\n    }\r\n    _updateMatch(found = false) {\r\n        let state = FindState.NOT_FOUND;\r\n        const wrapped = this._offset.wrapped;\r\n        this._offset.wrapped = false;\r\n        if (found) {\r\n            const previousPage = this._selected.pageIdx;\r\n            this._selected.pageIdx = this._offset.pageIdx;\r\n            this._selected.matchIdx = this._offset.matchIdx;\r\n            state = wrapped ? FindState.WRAPPED : FindState.FOUND;\r\n            if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {\r\n                this._updatePage(previousPage);\r\n            }\r\n        }\r\n        this._updateUIState(state, this._state.findPrevious);\r\n        if (this._selected.pageIdx !== -1) {\r\n            this._scrollMatches = true;\r\n            this._updatePage(this._selected.pageIdx);\r\n        }\r\n    }\r\n    _onFindBarClose(evt) {\r\n        const pdfDocument = this._pdfDocument;\r\n        this._firstPageCapability.promise.then(() => {\r\n            if (!this._pdfDocument || (pdfDocument && this._pdfDocument !== pdfDocument)) {\r\n                return;\r\n            }\r\n            if (this._findTimeout) {\r\n                clearTimeout(this._findTimeout);\r\n                this._findTimeout = null;\r\n            }\r\n            if (this._resumePageIdx) {\r\n                this._resumePageIdx = null;\r\n                this._dirtyMatch = true;\r\n            }\r\n            this._updateUIState(FindState.FOUND);\r\n            this._highlightMatches = false;\r\n            this._updateAllPages();\r\n        });\r\n    }\r\n    _requestMatchesCount() {\r\n        const { pageIdx, matchIdx } = this._selected;\r\n        let current = 0,\r\n            total = this._matchesCountTotal;\r\n        if (matchIdx !== -1) {\r\n            for (let i = 0; i < pageIdx; i++) {\r\n                current += this._pageMatches[i]?.length || 0;\r\n            }\r\n            current += matchIdx + 1;\r\n        }\r\n        if (current < 1 || current > total) {\r\n            current = total = 0;\r\n        }\r\n        return {\r\n            current,\r\n            total,\r\n        };\r\n    }\r\n    _updateUIResultsCount() {\r\n        this._eventBus.dispatch('updatefindmatchescount', {\r\n            source: this,\r\n            matchesCount: this._requestMatchesCount(),\r\n        });\r\n        window.__sdJSBridge && window.__sdJSBridge.publish('find_matchCount', this._requestMatchesCount());\r\n    }\r\n    _updateUIState(state, previous = false) {\r\n        console.log('sdpdfcore updatefindcontrolstate', {\r\n            source: this,\r\n            state,\r\n            previous,\r\n            matchesCount: this._requestMatchesCount(),\r\n            rawQuery: this._state?.query ?? null,\r\n        });\r\n        this._eventBus.dispatch('updatefindcontrolstate', {\r\n            source: this,\r\n            state,\r\n            previous,\r\n            matchesCount: this._requestMatchesCount(),\r\n            rawQuery: this._state?.query ?? null,\r\n        });\r\n    }\r\n}\r\nexport { FindState, PDFFindController };\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst CharacterType = {\r\n SPACE: 0,\r\n ALPHA_LETTER: 1,\r\n PUNCT: 2,\r\n HAN_LETTER: 3,\r\n KATAKANA_LETTER: 4,\r\n HIRAGANA_LETTER: 5,\r\n HALFWIDTH_KATAKANA_LETTER: 6,\r\n THAI_LETTER: 7\r\n};\r\nfunction isAlphabeticalScript(charCode) {\r\n return charCode < 0x2e80;\r\n}\r\nfunction isAscii(charCode) {\r\n return (charCode & 0xff80) === 0;\r\n}\r\nfunction isAsciiAlpha(charCode) {\r\n return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;\r\n}\r\nfunction isAsciiDigit(charCode) {\r\n return charCode >= 0x30 && charCode <= 0x39;\r\n}\r\nfunction isAsciiSpace(charCode) {\r\n return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;\r\n}\r\nfunction isHan(charCode) {\r\n return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;\r\n}\r\nfunction isKatakana(charCode) {\r\n return charCode >= 0x30a0 && charCode <= 0x30ff;\r\n}\r\nfunction isHiragana(charCode) {\r\n return charCode >= 0x3040 && charCode <= 0x309f;\r\n}\r\nfunction isHalfwidthKatakana(charCode) {\r\n return charCode >= 0xff60 && charCode <= 0xff9f;\r\n}\r\nfunction isThai(charCode) {\r\n return (charCode & 0xff80) === 0x0e00;\r\n}\r\nfunction getCharacterType(charCode) {\r\n if (isAlphabeticalScript(charCode)) {\r\n  if (isAscii(charCode)) {\r\n   if (isAsciiSpace(charCode)) {\r\n    return CharacterType.SPACE;\r\n   } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {\r\n    return CharacterType.ALPHA_LETTER;\r\n   }\r\n   return CharacterType.PUNCT;\r\n  } else if (isThai(charCode)) {\r\n   return CharacterType.THAI_LETTER;\r\n  } else if (charCode === 0xa0) {\r\n   return CharacterType.SPACE;\r\n  }\r\n  return CharacterType.ALPHA_LETTER;\r\n }\r\n if (isHan(charCode)) {\r\n  return CharacterType.HAN_LETTER;\r\n } else if (isKatakana(charCode)) {\r\n  return CharacterType.KATAKANA_LETTER;\r\n } else if (isHiragana(charCode)) {\r\n  return CharacterType.HIRAGANA_LETTER;\r\n } else if (isHalfwidthKatakana(charCode)) {\r\n  return CharacterType.HALFWIDTH_KATAKANA_LETTER;\r\n }\r\n return CharacterType.ALPHA_LETTER;\r\n}\r\nexport {\r\n CharacterType,\r\n getCharacterType\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {isValidRotation, parseQueryString} = require(\"./ui_utils.js\");\r\nconst {waitOnEventOrTimeout} = require(\"./event_utils.js\");\r\nconst HASH_CHANGE_TIMEOUT = 1000;\r\nconst POSITION_UPDATED_THRESHOLD = 50;\r\nconst UPDATE_VIEWAREA_TIMEOUT = 1000;\r\nfunction getCurrentHash() {\r\n return document.location.hash;\r\n}\r\nclass PDFHistory {\r\n constructor({linkService, eventBus}) {\r\n  this.linkService = linkService;\r\n  this.eventBus = eventBus;\r\n  this._initialized = false;\r\n  this._fingerprint = \"\";\r\n  this.reset();\r\n  this._boundEvents = null;\r\n\r\n  this.eventBus._on(\"pagesinit\", () => {\r\n   this._isPagesLoaded = false;\r\n   this.eventBus._on(\"pagesloaded\", evt => {\r\n    this._isPagesLoaded = !!evt.pagesCount;\r\n   }, { once: true });\r\n  });\r\n }\r\n initialize({fingerprint, resetHistory = false, updateUrl = false}) {\r\n  if (!fingerprint || typeof fingerprint !== \"string\") {\r\n   console.error('PDFHistory.initialize: The \"fingerprint\" must be a non-empty string.');\r\n   return;\r\n  }\r\n  if (this._initialized) {\r\n   this.reset();\r\n  }\r\n  const reInitialized = this._fingerprint !== \"\" && this._fingerprint !== fingerprint;\r\n  this._fingerprint = fingerprint;\r\n  this._updateUrl = updateUrl === true;\r\n  this._initialized = true;\r\n  this._bindEvents();\r\n  const state = window.history.state;\r\n  this._popStateInProgress = false;\r\n  this._blockHashChange = 0;\r\n  this._currentHash = getCurrentHash();\r\n  this._numPositionUpdates = 0;\r\n  this._uid = this._maxUid = 0;\r\n  this._destination = null;\r\n  this._position = null;\r\n  if (!this._isValidState(state, true) || resetHistory) {\r\n   const {hash, page, rotation} = this._parseCurrentHash(true);\r\n   if (!hash || reInitialized || resetHistory) {\r\n    this._pushOrReplaceState(null, true);\r\n    return;\r\n   }\r\n   this._pushOrReplaceState({\r\n    hash,\r\n    page,\r\n    rotation\r\n   }, true);\r\n   return;\r\n  }\r\n  const destination = state.destination;\r\n  this._updateInternalState(destination, state.uid, true);\r\n  if (destination.rotation !== undefined) {\r\n   this._initialRotation = destination.rotation;\r\n  }\r\n  if (destination.dest) {\r\n   this._initialBookmark = JSON.stringify(destination.dest);\r\n   this._destination.page = null;\r\n  } else if (destination.hash) {\r\n   this._initialBookmark = destination.hash;\r\n  } else if (destination.page) {\r\n   this._initialBookmark = `page=${ destination.page }`;\r\n  }\r\n }\r\n reset() {\r\n  if (this._initialized) {\r\n   this._pageHide();\r\n   this._initialized = false;\r\n   this._unbindEvents();\r\n  }\r\n  if (this._updateViewareaTimeout) {\r\n   clearTimeout(this._updateViewareaTimeout);\r\n   this._updateViewareaTimeout = null;\r\n  }\r\n  this._initialBookmark = null;\r\n  this._initialRotation = null;\r\n }\r\n push({namedDest = null, explicitDest, pageNumber}) {\r\n  if (!this._initialized) {\r\n   return;\r\n  }\r\n  if (namedDest && typeof namedDest !== \"string\") {\r\n   console.error(\"PDFHistory.push: \" + `\"${ namedDest }\" is not a valid namedDest parameter.`);\r\n   return;\r\n  } else if (!Array.isArray(explicitDest)) {\r\n   console.error(\"PDFHistory.push: \" + `\"${ explicitDest }\" is not a valid explicitDest parameter.`);\r\n   return;\r\n  } else if (!this._isValidPage(pageNumber)) {\r\n   if (pageNumber !== null || this._destination) {\r\n    console.error(\"PDFHistory.push: \" + `\"${ pageNumber }\" is not a valid pageNumber parameter.`);\r\n    return;\r\n   }\r\n  }\r\n  const hash = namedDest || JSON.stringify(explicitDest);\r\n  if (!hash) {\r\n   return;\r\n  }\r\n  let forceReplace = false;\r\n  if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {\r\n   if (this._destination.page) {\r\n    return;\r\n   }\r\n   forceReplace = true;\r\n  }\r\n  if (this._popStateInProgress && !forceReplace) {\r\n   return;\r\n  }\r\n  this._pushOrReplaceState({\r\n   dest: explicitDest,\r\n   hash,\r\n   page: pageNumber,\r\n   rotation: this.linkService.rotation\r\n  }, forceReplace);\r\n  if (!this._popStateInProgress) {\r\n   this._popStateInProgress = true;\r\n   Promise.resolve().then(() => {\r\n    this._popStateInProgress = false;\r\n   });\r\n  }\r\n }\r\n pushPage(pageNumber) {\r\n  if (!this._initialized) {\r\n   return;\r\n  }\r\n  if (!this._isValidPage(pageNumber)) {\r\n   console.error(`PDFHistory.pushPage: \"${ pageNumber }\" is not a valid page number.`);\r\n   return;\r\n  }\r\n  if (this._destination?.page === pageNumber) {\r\n   return;\r\n  }\r\n  if (this._popStateInProgress) {\r\n   return;\r\n  }\r\n  this._pushOrReplaceState({\r\n   dest: null,\r\n   hash: `page=${ pageNumber }`,\r\n   page: pageNumber,\r\n   rotation: this.linkService.rotation\r\n  });\r\n  if (!this._popStateInProgress) {\r\n   this._popStateInProgress = true;\r\n   Promise.resolve().then(() => {\r\n    this._popStateInProgress = false;\r\n   });\r\n  }\r\n }\r\n pushCurrentPosition() {\r\n  if (!this._initialized || this._popStateInProgress) {\r\n   return;\r\n  }\r\n  this._tryPushCurrentPosition();\r\n }\r\n back() {\r\n  if (!this._initialized || this._popStateInProgress) {\r\n   return;\r\n  }\r\n  const state = window.history.state;\r\n  if (this._isValidState(state) && state.uid > 0) {\r\n   window.history.back();\r\n  }\r\n }\r\n forward() {\r\n  if (!this._initialized || this._popStateInProgress) {\r\n   return;\r\n  }\r\n  const state = window.history.state;\r\n  if (this._isValidState(state) && state.uid < this._maxUid) {\r\n   window.history.forward();\r\n  }\r\n }\r\n get popStateInProgress() {\r\n  return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);\r\n }\r\n get initialBookmark() {\r\n  return this._initialized ? this._initialBookmark : null;\r\n }\r\n get initialRotation() {\r\n  return this._initialized ? this._initialRotation : null;\r\n }\r\n _pushOrReplaceState(destination, forceReplace = false) {\r\n  const shouldReplace = forceReplace || !this._destination;\r\n  const newState = {\r\n   fingerprint: this._fingerprint,\r\n   uid: shouldReplace ? this._uid : this._uid + 1,\r\n   destination\r\n  };\r\n  this._updateInternalState(destination, newState.uid);\r\n  let newUrl;\r\n  if (this._updateUrl && destination?.hash) {\r\n   const baseUrl = document.location.href.split(\"#\")[0];\r\n   if (!baseUrl.startsWith(\"file://\")) {\r\n    newUrl = `${ baseUrl }#${ destination.hash }`;\r\n   }\r\n  }\r\n  if (shouldReplace) {\r\n   window.history.replaceState(newState, \"\", newUrl);\r\n  } else {\r\n   window.history.pushState(newState, \"\", newUrl);\r\n  }\r\n }\r\n _tryPushCurrentPosition(temporary = false) {\r\n  if (!this._position) {\r\n   return;\r\n  }\r\n  let position = this._position;\r\n  if (temporary) {\r\n   position = Object.assign(Object.create(null), this._position);\r\n   position.temporary = true;\r\n  }\r\n  if (!this._destination) {\r\n   this._pushOrReplaceState(position);\r\n   return;\r\n  }\r\n  if (this._destination.temporary) {\r\n   this._pushOrReplaceState(position, true);\r\n   return;\r\n  }\r\n  if (this._destination.hash === position.hash) {\r\n   return;\r\n  }\r\n  if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {\r\n   return;\r\n  }\r\n  let forceReplace = false;\r\n  if (this._destination.page >= position.first && this._destination.page <= position.page) {\r\n   if (this._destination.dest !== undefined || !this._destination.first) {\r\n    return;\r\n   }\r\n   forceReplace = true;\r\n  }\r\n  this._pushOrReplaceState(position, forceReplace);\r\n }\r\n _isValidPage(val) {\r\n  return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;\r\n }\r\n _isValidState(state, checkReload = false) {\r\n  if (!state) {\r\n   return false;\r\n  }\r\n  if (state.fingerprint !== this._fingerprint) {\r\n   if (checkReload) {\r\n    if (typeof state.fingerprint !== \"string\" || state.fingerprint.length !== this._fingerprint.length) {\r\n     return false;\r\n    }\r\n    const [perfEntry] = performance.getEntriesByType(\"navigation\");\r\n    if (perfEntry?.type !== \"reload\") {\r\n     return false;\r\n    }\r\n   } else {\r\n    return false;\r\n   }\r\n  }\r\n  if (!Number.isInteger(state.uid) || state.uid < 0) {\r\n   return false;\r\n  }\r\n  if (state.destination === null || typeof state.destination !== \"object\") {\r\n   return false;\r\n  }\r\n  return true;\r\n }\r\n _updateInternalState(destination, uid, removeTemporary = false) {\r\n  if (this._updateViewareaTimeout) {\r\n   clearTimeout(this._updateViewareaTimeout);\r\n   this._updateViewareaTimeout = null;\r\n  }\r\n  if (removeTemporary && destination?.temporary) {\r\n   delete destination.temporary;\r\n  }\r\n  this._destination = destination;\r\n  this._uid = uid;\r\n  this._maxUid = Math.max(this._maxUid, uid);\r\n  this._numPositionUpdates = 0;\r\n }\r\n _parseCurrentHash(checkNameddest = false) {\r\n  const hash = unescape(getCurrentHash()).substring(1);\r\n  const params = parseQueryString(hash);\r\n  const nameddest = params.get(\"nameddest\") || \"\";\r\n  let page = params.get(\"page\") | 0;\r\n  if (!this._isValidPage(page) || checkNameddest && nameddest.length > 0) {\r\n   page = null;\r\n  }\r\n  return {\r\n   hash,\r\n   page,\r\n   rotation: this.linkService.rotation\r\n  };\r\n }\r\n _updateViewarea({location}) {\r\n  if (this._updateViewareaTimeout) {\r\n   clearTimeout(this._updateViewareaTimeout);\r\n   this._updateViewareaTimeout = null;\r\n  }\r\n  this._position = {\r\n   hash:  location.pdfOpenParams.substring(1),\r\n   page: this.linkService.page,\r\n   first: location.pageNumber,\r\n   rotation: location.rotation\r\n  };\r\n  if (this._popStateInProgress) {\r\n   return;\r\n  }\r\n  if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {\r\n   this._numPositionUpdates++;\r\n  }\r\n  if (UPDATE_VIEWAREA_TIMEOUT > 0) {\r\n   this._updateViewareaTimeout = setTimeout(() => {\r\n    if (!this._popStateInProgress) {\r\n     this._tryPushCurrentPosition(true);\r\n    }\r\n    this._updateViewareaTimeout = null;\r\n   }, UPDATE_VIEWAREA_TIMEOUT);\r\n  }\r\n }\r\n _popState({state}) {\r\n  const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash;\r\n  this._currentHash = newHash;\r\n  if (!state) {\r\n   this._uid++;\r\n   const {hash, page, rotation} = this._parseCurrentHash();\r\n   this._pushOrReplaceState({\r\n    hash,\r\n    page,\r\n    rotation\r\n   }, true);\r\n   return;\r\n  }\r\n  if (!this._isValidState(state)) {\r\n   return;\r\n  }\r\n  this._popStateInProgress = true;\r\n  if (hashChanged) {\r\n   this._blockHashChange++;\r\n   waitOnEventOrTimeout({\r\n    target: window,\r\n    name: \"hashchange\",\r\n    delay: HASH_CHANGE_TIMEOUT\r\n   }).then(() => {\r\n    this._blockHashChange--;\r\n   });\r\n  }\r\n  const destination = state.destination;\r\n  this._updateInternalState(destination, state.uid, true);\r\n  if (isValidRotation(destination.rotation)) {\r\n   this.linkService.rotation = destination.rotation;\r\n  }\r\n  if (destination.dest) {\r\n   this.linkService.goToDestination(destination.dest);\r\n  } else if (destination.hash) {\r\n   this.linkService.setHash(destination.hash);\r\n  } else if (destination.page) {\r\n   this.linkService.page = destination.page;\r\n  }\r\n  Promise.resolve().then(() => {\r\n   this._popStateInProgress = false;\r\n  });\r\n }\r\n _pageHide() {\r\n  if (!this._destination || this._destination.temporary) {\r\n   this._tryPushCurrentPosition();\r\n  }\r\n }\r\n _bindEvents() {\r\n  if (this._boundEvents) {\r\n   return;\r\n  }\r\n  this._boundEvents = {\r\n   updateViewarea: this._updateViewarea.bind(this),\r\n   popState: this._popState.bind(this),\r\n   pageHide: this._pageHide.bind(this)\r\n  };\r\n  this.eventBus._on(\"updateviewarea\", this._boundEvents.updateViewarea);\r\n  window.addEventListener(\"popstate\", this._boundEvents.popState);\r\n  window.addEventListener(\"pagehide\", this._boundEvents.pageHide);\r\n }\r\n _unbindEvents() {\r\n  if (!this._boundEvents) {\r\n   return;\r\n  }\r\n  this.eventBus._off(\"updateviewarea\", this._boundEvents.updateViewarea);\r\n  window.removeEventListener(\"popstate\", this._boundEvents.popState);\r\n  window.removeEventListener(\"pagehide\", this._boundEvents.pageHide);\r\n  this._boundEvents = null;\r\n }\r\n}\r\nfunction isDestHashesEqual(destHash, pushHash) {\r\n if (typeof destHash !== \"string\" || typeof pushHash !== \"string\") {\r\n  return false;\r\n }\r\n if (destHash === pushHash) {\r\n  return true;\r\n }\r\n const nameddest = parseQueryString(destHash).get(\"nameddest\");\r\n if (nameddest === pushHash) {\r\n  return true;\r\n }\r\n return false;\r\n}\r\nfunction isDestArraysEqual(firstDest, secondDest) {\r\n function isEntryEqual(first, second) {\r\n  if (typeof first !== typeof second) {\r\n   return false;\r\n  }\r\n  if (Array.isArray(first) || Array.isArray(second)) {\r\n   return false;\r\n  }\r\n  if (first !== null && typeof first === \"object\" && second !== null) {\r\n   if (Object.keys(first).length !== Object.keys(second).length) {\r\n    return false;\r\n   }\r\n   for (const key in first) {\r\n    if (!isEntryEqual(first[key], second[key])) {\r\n     return false;\r\n    }\r\n   }\r\n   return true;\r\n  }\r\n  return first === second || Number.isNaN(first) && Number.isNaN(second);\r\n }\r\n if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {\r\n  return false;\r\n }\r\n if (firstDest.length !== secondDest.length) {\r\n  return false;\r\n }\r\n for (let i = 0, ii = firstDest.length; i < ii; i++) {\r\n  if (!isEntryEqual(firstDest[i], secondDest[i])) {\r\n   return false;\r\n  }\r\n }\r\n return true;\r\n}\r\nexport {\r\n isDestArraysEqual,\r\n isDestHashesEqual,\r\n PDFHistory\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {parseQueryString, removeNullCharacters} = require(\"./ui_utils.js\");\r\nconst DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\r\nconst LinkTarget = {\r\n NONE: 0,\r\n SELF: 1,\r\n BLANK: 2,\r\n PARENT: 3,\r\n TOP: 4\r\n};\r\nfunction addLinkAttributes(link, {url, target, rel, enabled = true} = {}) {\r\n if (!url || typeof url !== \"string\") {\r\n  throw new Error('A valid \"url\" parameter must provided.');\r\n }\r\n const urlNullRemoved = removeNullCharacters(url);\r\n if (enabled) {\r\n  link.href = link.title = urlNullRemoved;\r\n } else {\r\n  link.href = \"\";\r\n  link.title = `Disabled: ${ urlNullRemoved }`;\r\n  link.onclick = () => {\r\n   return false;\r\n  };\r\n }\r\n let targetStr = \"\";\r\n switch (target) {\r\n case LinkTarget.NONE:\r\n  break;\r\n case LinkTarget.SELF:\r\n  targetStr = \"_self\";\r\n  break;\r\n case LinkTarget.BLANK:\r\n  targetStr = \"_blank\";\r\n  break;\r\n case LinkTarget.PARENT:\r\n  targetStr = \"_parent\";\r\n  break;\r\n case LinkTarget.TOP:\r\n  targetStr = \"_top\";\r\n  break;\r\n }\r\n link.target = targetStr;\r\n link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\r\n}\r\nclass PDFLinkService {\r\n #pagesRefCache = new Map();\r\n constructor({eventBus, externalLinkTarget = null, externalLinkRel = null, ignoreDestinationZoom = false} = {}) {\r\n  this.eventBus = eventBus;\r\n  this.externalLinkTarget = externalLinkTarget;\r\n  this.externalLinkRel = externalLinkRel;\r\n  this.externalLinkEnabled = true;\r\n  this._ignoreDestinationZoom = ignoreDestinationZoom;\r\n  this.baseUrl = null;\r\n  this.pdfDocument = null;\r\n  this.pdfViewer = null;\r\n  this.pdfHistory = null;\r\n }\r\n setDocument(pdfDocument, baseUrl = null) {\r\n  this.baseUrl = baseUrl;\r\n  this.pdfDocument = pdfDocument;\r\n  this.#pagesRefCache.clear();\r\n }\r\n setViewer(pdfViewer) {\r\n  this.pdfViewer = pdfViewer;\r\n }\r\n setHistory(pdfHistory) {\r\n  this.pdfHistory = pdfHistory;\r\n }\r\n get pagesCount() {\r\n  return this.pdfDocument ? this.pdfDocument.numPages : 0;\r\n }\r\n get page() {\r\n  return this.pdfViewer.currentPageNumber;\r\n }\r\n set page(value) {\r\n  this.pdfViewer.currentPageNumber = value;\r\n }\r\n get rotation() {\r\n  return this.pdfViewer.pagesRotation;\r\n }\r\n set rotation(value) {\r\n  this.pdfViewer.pagesRotation = value;\r\n }\r\n #goToDestinationHelper(rawDest, namedDest = null, explicitDest) {\r\n  const destRef = explicitDest[0];\r\n  let pageNumber;\r\n  if (typeof destRef === \"object\" && destRef !== null) {\r\n   pageNumber = this._cachedPageNumber(destRef);\r\n   if (!pageNumber) {\r\n    this.pdfDocument.getPageIndex(destRef).then(pageIndex => {\r\n     this.cachePageRef(pageIndex + 1, destRef);\r\n     this.#goToDestinationHelper(rawDest, namedDest, explicitDest);\r\n    }).catch(() => {\r\n     console.error(`PDFLinkService.#goToDestinationHelper: \"${ destRef }\" is not ` + `a valid page reference, for dest=\"${ rawDest }\".`);\r\n    });\r\n    return;\r\n   }\r\n  } else if (Number.isInteger(destRef)) {\r\n   pageNumber = destRef + 1;\r\n  } else {\r\n   console.error(`PDFLinkService.#goToDestinationHelper: \"${ destRef }\" is not ` + `a valid destination reference, for dest=\"${ rawDest }\".`);\r\n   return;\r\n  }\r\n  if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {\r\n   console.error(`PDFLinkService.#goToDestinationHelper: \"${ pageNumber }\" is not ` + `a valid page number, for dest=\"${ rawDest }\".`);\r\n   return;\r\n  }\r\n  if (this.pdfHistory) {\r\n   this.pdfHistory.pushCurrentPosition();\r\n   this.pdfHistory.push({\r\n    namedDest,\r\n    explicitDest,\r\n    pageNumber\r\n   });\r\n  }\r\n  this.pdfViewer.scrollPageIntoView({\r\n   pageNumber,\r\n   destArray: explicitDest,\r\n   ignoreDestinationZoom: this._ignoreDestinationZoom\r\n  });\r\n }\r\n async goToDestination(dest) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  let namedDest, explicitDest;\r\n  if (typeof dest === \"string\") {\r\n   namedDest = dest;\r\n   explicitDest = await this.pdfDocument.getDestination(dest);\r\n  } else {\r\n   namedDest = null;\r\n   explicitDest = await dest;\r\n  }\r\n  if (!Array.isArray(explicitDest)) {\r\n   console.error(`PDFLinkService.goToDestination: \"${ explicitDest }\" is not ` + `a valid destination array, for dest=\"${ dest }\".`);\r\n   return;\r\n  }\r\n  this.#goToDestinationHelper(dest, namedDest, explicitDest);\r\n }\r\n goToPage(val) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  const pageNumber = typeof val === \"string\" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;\r\n  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {\r\n   console.error(`PDFLinkService.goToPage: \"${ val }\" is not a valid page.`);\r\n   return;\r\n  }\r\n  if (this.pdfHistory) {\r\n   this.pdfHistory.pushCurrentPosition();\r\n   this.pdfHistory.pushPage(pageNumber);\r\n  }\r\n  this.pdfViewer.scrollPageIntoView({ pageNumber });\r\n }\r\n addLinkAttributes(link, url, newWindow = false) {\r\n  addLinkAttributes(link, {\r\n   url,\r\n   target: newWindow ? LinkTarget.BLANK : this.externalLinkTarget,\r\n   rel: this.externalLinkRel,\r\n   enabled: this.externalLinkEnabled\r\n  });\r\n }\r\n getDestinationHash(dest) {\r\n  if (typeof dest === \"string\") {\r\n   if (dest.length > 0) {\r\n    return this.getAnchorUrl(\"#\" + escape(dest));\r\n   }\r\n  } else if (Array.isArray(dest)) {\r\n   const str = JSON.stringify(dest);\r\n   if (str.length > 0) {\r\n    return this.getAnchorUrl(\"#\" + escape(str));\r\n   }\r\n  }\r\n  return this.getAnchorUrl(\"\");\r\n }\r\n getAnchorUrl(anchor) {\r\n  return (this.baseUrl || \"\") + anchor;\r\n }\r\n setHash(hash) {\r\n  if (!this.pdfDocument) {\r\n   return;\r\n  }\r\n  let pageNumber, dest;\r\n  if (hash.includes(\"=\")) {\r\n   const params = parseQueryString(hash);\r\n   if (params.has(\"search\")) {\r\n    this.eventBus.dispatch(\"findfromurlhash\", {\r\n     source: this,\r\n     query: params.get(\"search\").replace(/\"/g, \"\"),\r\n     phraseSearch: params.get(\"phrase\") === \"true\"\r\n    });\r\n   }\r\n   if (params.has(\"page\")) {\r\n    pageNumber = params.get(\"page\") | 0 || 1;\r\n   }\r\n   if (params.has(\"zoom\")) {\r\n    const zoomArgs = params.get(\"zoom\").split(\",\");\r\n    const zoomArg = zoomArgs[0];\r\n    const zoomArgNumber = parseFloat(zoomArg);\r\n    if (!zoomArg.includes(\"Fit\")) {\r\n     dest = [\r\n      null,\r\n      { name: \"XYZ\" },\r\n      zoomArgs.length > 1 ? zoomArgs[1] | 0 : null,\r\n      zoomArgs.length > 2 ? zoomArgs[2] | 0 : null,\r\n      zoomArgNumber ? zoomArgNumber / 100 : zoomArg\r\n     ];\r\n    } else {\r\n     if (zoomArg === \"Fit\" || zoomArg === \"FitB\") {\r\n      dest = [\r\n       null,\r\n       { name: zoomArg }\r\n      ];\r\n     } else if (zoomArg === \"FitH\" || zoomArg === \"FitBH\" || zoomArg === \"FitV\" || zoomArg === \"FitBV\") {\r\n      dest = [\r\n       null,\r\n       { name: zoomArg },\r\n       zoomArgs.length > 1 ? zoomArgs[1] | 0 : null\r\n      ];\r\n     } else if (zoomArg === \"FitR\") {\r\n      if (zoomArgs.length !== 5) {\r\n       console.error('PDFLinkService.setHash: Not enough parameters for \"FitR\".');\r\n      } else {\r\n       dest = [\r\n        null,\r\n        { name: zoomArg },\r\n        zoomArgs[1] | 0,\r\n        zoomArgs[2] | 0,\r\n        zoomArgs[3] | 0,\r\n        zoomArgs[4] | 0\r\n       ];\r\n      }\r\n     } else {\r\n      console.error(`PDFLinkService.setHash: \"${ zoomArg }\" is not a valid zoom value.`);\r\n     }\r\n    }\r\n   }\r\n   if (dest) {\r\n    this.pdfViewer.scrollPageIntoView({\r\n     pageNumber: pageNumber || this.page,\r\n     destArray: dest,\r\n     allowNegativeOffset: true\r\n    });\r\n   } else if (pageNumber) {\r\n    this.page = pageNumber;\r\n   }\r\n   if (params.has(\"pagemode\")) {\r\n    this.eventBus.dispatch(\"pagemode\", {\r\n     source: this,\r\n     mode: params.get(\"pagemode\")\r\n    });\r\n   }\r\n   if (params.has(\"nameddest\")) {\r\n    this.goToDestination(params.get(\"nameddest\"));\r\n   }\r\n  } else {\r\n   dest = unescape(hash);\r\n   try {\r\n    dest = JSON.parse(dest);\r\n    if (!Array.isArray(dest)) {\r\n     dest = dest.toString();\r\n    }\r\n   } catch (ex) {\r\n   }\r\n   if (typeof dest === \"string\" || PDFLinkService.#isValidExplicitDestination(dest)) {\r\n    this.goToDestination(dest);\r\n    return;\r\n   }\r\n   console.error(`PDFLinkService.setHash: \"${ unescape(hash) }\" is not a valid destination.`);\r\n  }\r\n }\r\n executeNamedAction(action) {\r\n  switch (action) {\r\n  case \"GoBack\":\r\n   this.pdfHistory?.back();\r\n   break;\r\n  case \"GoForward\":\r\n   this.pdfHistory?.forward();\r\n   break;\r\n  case \"NextPage\":\r\n   this.pdfViewer.nextPage();\r\n   break;\r\n  case \"PrevPage\":\r\n   this.pdfViewer.previousPage();\r\n   break;\r\n  case \"LastPage\":\r\n   this.page = this.pagesCount;\r\n   break;\r\n  case \"FirstPage\":\r\n   this.page = 1;\r\n   break;\r\n  default:\r\n   break;\r\n  }\r\n  this.eventBus.dispatch(\"namedaction\", {\r\n   source: this,\r\n   action\r\n  });\r\n }\r\n cachePageRef(pageNum, pageRef) {\r\n  if (!pageRef) {\r\n   return;\r\n  }\r\n  const refStr = pageRef.gen === 0 ? `${ pageRef.num }R` : `${ pageRef.num }R${ pageRef.gen }`;\r\n  this.#pagesRefCache.set(refStr, pageNum);\r\n }\r\n _cachedPageNumber(pageRef) {\r\n  if (!pageRef) {\r\n   return null;\r\n  }\r\n  const refStr = pageRef.gen === 0 ? `${ pageRef.num }R` : `${ pageRef.num }R${ pageRef.gen }`;\r\n  return this.#pagesRefCache.get(refStr) || null;\r\n }\r\n isPageVisible(pageNumber) {\r\n  return this.pdfViewer.isPageVisible(pageNumber);\r\n }\r\n isPageCached(pageNumber) {\r\n  return this.pdfViewer.isPageCached(pageNumber);\r\n }\r\n static #isValidExplicitDestination(dest) {\r\n  if (!Array.isArray(dest)) {\r\n   return false;\r\n  }\r\n  const destLength = dest.length;\r\n  if (destLength < 2) {\r\n   return false;\r\n  }\r\n  const page = dest[0];\r\n  if (!(typeof page === \"object\" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {\r\n   return false;\r\n  }\r\n  const zoom = dest[1];\r\n  if (!(typeof zoom === \"object\" && typeof zoom.name === \"string\")) {\r\n   return false;\r\n  }\r\n  let allowNull = true;\r\n  switch (zoom.name) {\r\n  case \"XYZ\":\r\n   if (destLength !== 5) {\r\n    return false;\r\n   }\r\n   break;\r\n  case \"Fit\":\r\n  case \"FitB\":\r\n   return destLength === 2;\r\n  case \"FitH\":\r\n  case \"FitBH\":\r\n  case \"FitV\":\r\n  case \"FitBV\":\r\n   if (destLength !== 3) {\r\n    return false;\r\n   }\r\n   break;\r\n  case \"FitR\":\r\n   if (destLength !== 6) {\r\n    return false;\r\n   }\r\n   allowNull = false;\r\n   break;\r\n  default:\r\n   return false;\r\n  }\r\n  for (let i = 2; i < destLength; i++) {\r\n   const param = dest[i];\r\n   if (!(typeof param === \"number\" || allowNull && param === null)) {\r\n    return false;\r\n   }\r\n  }\r\n  return true;\r\n }\r\n}\r\nclass SimpleLinkService {\r\n constructor() {\r\n  this.externalLinkEnabled = true;\r\n }\r\n get pagesCount() {\r\n  return 0;\r\n }\r\n get page() {\r\n  return 0;\r\n }\r\n set page(value) {\r\n }\r\n get rotation() {\r\n  return 0;\r\n }\r\n set rotation(value) {\r\n }\r\n async goToDestination(dest) {\r\n }\r\n goToPage(val) {\r\n }\r\n addLinkAttributes(link, url, newWindow = false) {\r\n  addLinkAttributes(link, {\r\n   url,\r\n   enabled: this.externalLinkEnabled\r\n  });\r\n }\r\n getDestinationHash(dest) {\r\n  return \"#\";\r\n }\r\n getAnchorUrl(hash) {\r\n  return \"#\";\r\n }\r\n setHash(hash) {\r\n }\r\n executeNamedAction(action) {\r\n }\r\n cachePageRef(pageNum, pageRef) {\r\n }\r\n isPageVisible(pageNumber) {\r\n  return true;\r\n }\r\n isPageCached(pageNumber) {\r\n  return true;\r\n }\r\n}\r\nexport {\r\n LinkTarget,\r\n PDFLinkService,\r\n SimpleLinkService\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {AnnotationMode, createPromiseCapability, PixelsPerInch, RenderingCancelledException, SVGGraphics} = require(\"pdfjs-dist\");\r\nconst {approximateFraction, DEFAULT_SCALE, getOutputScale, RendererType, RenderingStates, roundToDivide, TextLayerMode} = require(\"./ui_utils.js\");\r\nconst {compatibilityParams} = require(\"./app_options.js\");\r\nconst {NullL10n} = require(\"./l10n_utils.js\");\r\nconst MAX_CANVAS_PIXELS = compatibilityParams.maxCanvasPixels || 16777216;\r\nclass PDFPageView {\r\n #annotationMode = AnnotationMode.ENABLE_FORMS;\r\n constructor(options) {\r\n  const container = options.container;\r\n  const defaultViewport = options.defaultViewport;\r\n  this.id = options.id;\r\n  this.renderingId = \"page\" + this.id;\r\n  this.pdfPage = null;\r\n  this.pageLabel = null;\r\n  this.rotation = 0;\r\n  this.scale = options.scale || DEFAULT_SCALE;\r\n  this.viewport = defaultViewport;\r\n  this.pdfPageRotate = defaultViewport.rotation;\r\n  this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;\r\n  this.hasRestrictedScaling = false;\r\n  this.textLayerMode = options.textLayerMode ?? TextLayerMode.ENABLE;\r\n  this.#annotationMode = options.annotationMode ?? AnnotationMode.ENABLE_FORMS;\r\n  this.imageResourcesPath = options.imageResourcesPath || \"\";\r\n  this.useOnlyCssZoom = options.useOnlyCssZoom || false;\r\n  this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;\r\n  this.eventBus = options.eventBus;\r\n  this.renderingQueue = options.renderingQueue;\r\n  this.textLayerFactory = options.textLayerFactory;\r\n  this.annotationLayerFactory = options.annotationLayerFactory;\r\n  this.xfaLayerFactory = options.xfaLayerFactory;\r\n  this.textHighlighter = options.textHighlighterFactory?.createTextHighlighter(this.id - 1, this.eventBus);\r\n  this.structTreeLayerFactory = options.structTreeLayerFactory;\r\n  this.renderer = options.renderer || RendererType.CANVAS;\r\n  this.l10n = options.l10n || NullL10n;\r\n  this.paintTask = null;\r\n  this.paintedViewportMap = new WeakMap();\r\n  this.renderingState = RenderingStates.INITIAL;\r\n  this.resume = null;\r\n  this._renderError = null;\r\n  this._isStandalone = !this.renderingQueue?.hasViewer();\r\n  this._annotationCanvasMap = null;\r\n  this.annotationLayer = null;\r\n  this.textLayer = null;\r\n  this.zoomLayer = null;\r\n  this.xfaLayer = null;\r\n  this.structTreeLayer = null;\r\n  const div = document.createElement(\"div\");\r\n  div.className = \"page\";\r\n  div.style.width = Math.floor(this.viewport.width) + \"px\";\r\n  div.style.height = Math.floor(this.viewport.height) + \"px\";\r\n  div.setAttribute(\"data-page-number\", this.id);\r\n  div.setAttribute(\"role\", \"region\");\r\n  this.l10n.get(\"page_landmark\", { page: this.id }).then(msg => {\r\n   div.setAttribute(\"aria-label\", msg);\r\n  });\r\n  this.div = div;\r\n  container?.appendChild(div);\r\n }\r\n setPdfPage(pdfPage) {\r\n  this.pdfPage = pdfPage;\r\n  this.pdfPageRotate = pdfPage.rotate;\r\n  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;\r\n  this.viewport = pdfPage.getViewport({\r\n   scale: this.scale * PixelsPerInch.PDF_TO_CSS_UNITS,\r\n   rotation: totalRotation\r\n  });\r\n  this.reset();\r\n }\r\n destroy() {\r\n  this.reset();\r\n  if (this.pdfPage) {\r\n   this.pdfPage.cleanup();\r\n  }\r\n }\r\n async _renderAnnotationLayer() {\r\n  let error = null;\r\n  try {\r\n   await this.annotationLayer.render(this.viewport, \"display\");\r\n  } catch (ex) {\r\n   error = ex;\r\n  } finally {\r\n   this.eventBus.dispatch(\"annotationlayerrendered\", {\r\n    source: this,\r\n    pageNumber: this.id,\r\n    error\r\n   });\r\n  }\r\n }\r\n async _renderXfaLayer() {\r\n  let error = null;\r\n  try {\r\n   const result = await this.xfaLayer.render(this.viewport, \"display\");\r\n   if (this.textHighlighter) {\r\n    this._buildXfaTextContentItems(result.textDivs);\r\n   }\r\n  } catch (ex) {\r\n   error = ex;\r\n  } finally {\r\n   this.eventBus.dispatch(\"xfalayerrendered\", {\r\n    source: this,\r\n    pageNumber: this.id,\r\n    error\r\n   });\r\n  }\r\n }\r\n async _buildXfaTextContentItems(textDivs) {\r\n  const text = await this.pdfPage.getTextContent();\r\n  const items = [];\r\n  for (const item of text.items) {\r\n   items.push(item.str);\r\n  }\r\n  this.textHighlighter.setTextMapping(textDivs, items);\r\n  this.textHighlighter.enable();\r\n }\r\n _resetZoomLayer(removeFromDOM = false) {\r\n  if (!this.zoomLayer) {\r\n   return;\r\n  }\r\n  const zoomLayerCanvas = this.zoomLayer.firstChild;\r\n  this.paintedViewportMap.delete(zoomLayerCanvas);\r\n  zoomLayerCanvas.width = 0;\r\n  zoomLayerCanvas.height = 0;\r\n  if (removeFromDOM) {\r\n   this.zoomLayer.remove();\r\n  }\r\n  this.zoomLayer = null;\r\n }\r\n reset({keepZoomLayer = false, keepAnnotationLayer = false, keepXfaLayer = false} = {}) {\r\n  this.cancelRendering({\r\n   keepAnnotationLayer,\r\n   keepXfaLayer\r\n  });\r\n  this.renderingState = RenderingStates.INITIAL;\r\n  const div = this.div;\r\n  div.style.width = Math.floor(this.viewport.width) + \"px\";\r\n  div.style.height = Math.floor(this.viewport.height) + \"px\";\r\n  const childNodes = div.childNodes, zoomLayerNode = keepZoomLayer && this.zoomLayer || null, annotationLayerNode = keepAnnotationLayer && this.annotationLayer?.div || null, xfaLayerNode = keepXfaLayer && this.xfaLayer?.div || null;\r\n  for (let i = childNodes.length - 1; i >= 0; i--) {\r\n   const node = childNodes[i];\r\n   switch (node) {\r\n   case zoomLayerNode:\r\n   case annotationLayerNode:\r\n   case xfaLayerNode:\r\n    continue;\r\n   }\r\n   node.remove();\r\n  }\r\n  div.removeAttribute(\"data-loaded\");\r\n  if (annotationLayerNode) {\r\n   this.annotationLayer.hide();\r\n  }\r\n  if (xfaLayerNode) {\r\n   this.xfaLayer.hide();\r\n  }\r\n  if (!zoomLayerNode) {\r\n   if (this.canvas) {\r\n    this.paintedViewportMap.delete(this.canvas);\r\n    this.canvas.width = 0;\r\n    this.canvas.height = 0;\r\n    delete this.canvas;\r\n   }\r\n   this._resetZoomLayer();\r\n  }\r\n  if (this.svg) {\r\n   this.paintedViewportMap.delete(this.svg);\r\n   delete this.svg;\r\n  }\r\n  this.loadingIconDiv = document.createElement(\"div\");\r\n  this.loadingIconDiv.className = \"loadingIcon notVisible\";\r\n  if (this._isStandalone) {\r\n   this.toggleLoadingIconSpinner(true);\r\n  }\r\n  this.loadingIconDiv.setAttribute(\"role\", \"img\");\r\n  this.l10n.get(\"loading\").then(msg => {\r\n   this.loadingIconDiv?.setAttribute(\"aria-label\", msg);\r\n  });\r\n  div.appendChild(this.loadingIconDiv);\r\n }\r\n update({scale = 0, rotation = null, optionalContentConfigPromise = null}) {\r\n  if (typeof arguments[0] !== \"object\") {\r\n   console.error(\"PDFPageView.update called with separate parameters, please use an object instead.\");\r\n   this.update({\r\n    scale: arguments[0],\r\n    rotation: arguments[1],\r\n    optionalContentConfigPromise: arguments[2]\r\n   });\r\n   return;\r\n  }\r\n  this.scale = scale || this.scale;\r\n  if (typeof rotation === \"number\") {\r\n   this.rotation = rotation;\r\n  }\r\n  if (optionalContentConfigPromise instanceof Promise) {\r\n   this._optionalContentConfigPromise = optionalContentConfigPromise;\r\n  }\r\n  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;\r\n  const viewportScale = this.scale * PixelsPerInch.PDF_TO_CSS_UNITS;\r\n  this.viewport = this.viewport.clone({\r\n   scale: viewportScale,\r\n   rotation: totalRotation\r\n  });\r\n  if (this._isStandalone) {\r\n   const {style} = document.documentElement;\r\n   style.setProperty(\"--zoom-factor\", this.scale);\r\n   style.setProperty(\"--viewport-scale-factor\", viewportScale);\r\n  }\r\n  if (this.svg) {\r\n   this.cssTransform({\r\n    target: this.svg,\r\n    redrawAnnotationLayer: true,\r\n    redrawXfaLayer: true\r\n   });\r\n   this.eventBus.dispatch(\"pagerendered\", {\r\n    source: this,\r\n    pageNumber: this.id,\r\n    cssTransform: true,\r\n    timestamp: performance.now(),\r\n    error: this._renderError\r\n   });\r\n   return;\r\n  }\r\n  let isScalingRestricted = false;\r\n  if (this.canvas && this.maxCanvasPixels > 0) {\r\n   const outputScale = this.outputScale;\r\n   if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {\r\n    isScalingRestricted = true;\r\n   }\r\n  }\r\n  if (this.canvas) {\r\n   if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {\r\n    this.cssTransform({\r\n     target: this.canvas,\r\n     redrawAnnotationLayer: true,\r\n     redrawXfaLayer: true\r\n    });\r\n    this.eventBus.dispatch(\"pagerendered\", {\r\n     source: this,\r\n     pageNumber: this.id,\r\n     cssTransform: true,\r\n     timestamp: performance.now(),\r\n     error: this._renderError\r\n    });\r\n    return;\r\n   }\r\n   if (!this.zoomLayer && !this.canvas.hidden) {\r\n    this.zoomLayer = this.canvas.parentNode;\r\n    this.zoomLayer.style.position = \"absolute\";\r\n   }\r\n  }\r\n  if (this.zoomLayer) {\r\n   this.cssTransform({ target: this.zoomLayer.firstChild });\r\n  }\r\n  this.reset({\r\n   keepZoomLayer: true,\r\n   keepAnnotationLayer: true,\r\n   keepXfaLayer: true\r\n  });\r\n }\r\n cancelRendering({keepAnnotationLayer = false, keepXfaLayer = false} = {}) {\r\n  if (this.paintTask) {\r\n   this.paintTask.cancel();\r\n   this.paintTask = null;\r\n  }\r\n  this.resume = null;\r\n  if (this.textLayer) {\r\n   this.textLayer.cancel();\r\n   this.textLayer = null;\r\n  }\r\n  if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) {\r\n   this.annotationLayer.cancel();\r\n   this.annotationLayer = null;\r\n   this._annotationCanvasMap = null;\r\n  }\r\n  if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) {\r\n   this.xfaLayer.cancel();\r\n   this.xfaLayer = null;\r\n   this.textHighlighter?.disable();\r\n  }\r\n  if (this._onTextLayerRendered) {\r\n   this.eventBus._off(\"textlayerrendered\", this._onTextLayerRendered);\r\n   this._onTextLayerRendered = null;\r\n  }\r\n }\r\n cssTransform({target, redrawAnnotationLayer = false, redrawXfaLayer = false}) {\r\n  const width = this.viewport.width;\r\n  const height = this.viewport.height;\r\n  const div = this.div;\r\n  target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + \"px\";\r\n  target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + \"px\";\r\n  const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;\r\n  const absRotation = Math.abs(relativeRotation);\r\n  let scaleX = 1, scaleY = 1;\r\n  if (absRotation === 90 || absRotation === 270) {\r\n   scaleX = height / width;\r\n   scaleY = width / height;\r\n  }\r\n  target.style.transform = `rotate(${ relativeRotation }deg) scale(${ scaleX }, ${ scaleY })`;\r\n  if (this.textLayer) {\r\n   const textLayerViewport = this.textLayer.viewport;\r\n   const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;\r\n   const textAbsRotation = Math.abs(textRelativeRotation);\r\n   let scale = width / textLayerViewport.width;\r\n   if (textAbsRotation === 90 || textAbsRotation === 270) {\r\n    scale = width / textLayerViewport.height;\r\n   }\r\n   const textLayerDiv = this.textLayer.textLayerDiv;\r\n   let transX, transY;\r\n   switch (textAbsRotation) {\r\n   case 0:\r\n    transX = transY = 0;\r\n    break;\r\n   case 90:\r\n    transX = 0;\r\n    transY = \"-\" + textLayerDiv.style.height;\r\n    break;\r\n   case 180:\r\n    transX = \"-\" + textLayerDiv.style.width;\r\n    transY = \"-\" + textLayerDiv.style.height;\r\n    break;\r\n   case 270:\r\n    transX = \"-\" + textLayerDiv.style.width;\r\n    transY = 0;\r\n    break;\r\n   default:\r\n    console.error(\"Bad rotation value.\");\r\n    break;\r\n   }\r\n   textLayerDiv.style.transform = `rotate(${ textAbsRotation }deg) ` + `scale(${ scale }) ` + `translate(${ transX }, ${ transY })`;\r\n   textLayerDiv.style.transformOrigin = \"0% 0%\";\r\n  }\r\n  if (redrawAnnotationLayer && this.annotationLayer) {\r\n   this._renderAnnotationLayer();\r\n  }\r\n  if (redrawXfaLayer && this.xfaLayer) {\r\n   this._renderXfaLayer();\r\n  }\r\n }\r\n get width() {\r\n  return this.viewport.width;\r\n }\r\n get height() {\r\n  return this.viewport.height;\r\n }\r\n getPagePoint(x, y) {\r\n  return this.viewport.convertToPdfPoint(x, y);\r\n }\r\n toggleLoadingIconSpinner(viewVisible = false) {\r\n  this.loadingIconDiv?.classList.toggle(\"notVisible\", !viewVisible);\r\n }\r\n draw() {\r\n  if (this.renderingState !== RenderingStates.INITIAL) {\r\n   console.error(\"Must be in new state before drawing\");\r\n   this.reset();\r\n  }\r\n  const {div, pdfPage} = this;\r\n  if (!pdfPage) {\r\n   this.renderingState = RenderingStates.FINISHED;\r\n   if (this.loadingIconDiv) {\r\n    this.loadingIconDiv.remove();\r\n    delete this.loadingIconDiv;\r\n   }\r\n   return Promise.reject(new Error(\"pdfPage is not loaded\"));\r\n  }\r\n  this.renderingState = RenderingStates.RUNNING;\r\n  const canvasWrapper = document.createElement(\"div\");\r\n  canvasWrapper.style.width = div.style.width;\r\n  canvasWrapper.style.height = div.style.height;\r\n  canvasWrapper.classList.add(\"canvasWrapper\");\r\n  if (this.annotationLayer?.div) {\r\n   div.insertBefore(canvasWrapper, this.annotationLayer.div);\r\n  } else {\r\n   div.appendChild(canvasWrapper);\r\n  }\r\n  let textLayer = null;\r\n  if (this.textLayerMode !== TextLayerMode.DISABLE && this.textLayerFactory) {\r\n   const textLayerDiv = document.createElement(\"div\");\r\n   textLayerDiv.className = \"textLayer\";\r\n   textLayerDiv.style.width = canvasWrapper.style.width;\r\n   textLayerDiv.style.height = canvasWrapper.style.height;\r\n   if (this.annotationLayer?.div) {\r\n    div.insertBefore(textLayerDiv, this.annotationLayer.div);\r\n   } else {\r\n    div.appendChild(textLayerDiv);\r\n   }\r\n   textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === TextLayerMode.ENABLE_ENHANCE, this.eventBus, this.textHighlighter);\r\n  }\r\n  this.textLayer = textLayer;\r\n  if (this.#annotationMode !== AnnotationMode.DISABLE && this.annotationLayerFactory) {\r\n   this._annotationCanvasMap ||= new Map();\r\n   this.annotationLayer ||= this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, null, this.imageResourcesPath, this.#annotationMode === AnnotationMode.ENABLE_FORMS, this.l10n, null, null, null, null, this._annotationCanvasMap);\r\n  }\r\n  if (this.xfaLayer?.div) {\r\n   div.appendChild(this.xfaLayer.div);\r\n  }\r\n  let renderContinueCallback = null;\r\n  if (this.renderingQueue) {\r\n   renderContinueCallback = cont => {\r\n    if (!this.renderingQueue.isHighestPriority(this)) {\r\n     this.renderingState = RenderingStates.PAUSED;\r\n     this.resume = () => {\r\n      this.renderingState = RenderingStates.RUNNING;\r\n      cont();\r\n     };\r\n     return;\r\n    }\r\n    cont();\r\n   };\r\n  }\r\n  const finishPaintTask = async (error = null) => {\r\n   if (paintTask === this.paintTask) {\r\n    this.paintTask = null;\r\n   }\r\n   if (error instanceof RenderingCancelledException) {\r\n    this._renderError = null;\r\n    return;\r\n   }\r\n   this._renderError = error;\r\n   this.renderingState = RenderingStates.FINISHED;\r\n   if (this.loadingIconDiv) {\r\n    this.loadingIconDiv.remove();\r\n    delete this.loadingIconDiv;\r\n   }\r\n   this._resetZoomLayer(true);\r\n   this.eventBus.dispatch(\"pagerendered\", {\r\n    source: this,\r\n    pageNumber: this.id,\r\n    cssTransform: false,\r\n    timestamp: performance.now(),\r\n    error: this._renderError\r\n   });\r\n   if (error) {\r\n    throw error;\r\n   }\r\n  };\r\n  const paintTask = this.renderer === RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);\r\n  paintTask.onRenderContinue = renderContinueCallback;\r\n  this.paintTask = paintTask;\r\n  const resultPromise = paintTask.promise.then(() => {\r\n   return finishPaintTask(null).then(() => {\r\n    if (textLayer) {\r\n     const readableStream = pdfPage.streamTextContent({ includeMarkedContent: true });\r\n     textLayer.setTextContentStream(readableStream);\r\n     textLayer.render();\r\n    }\r\n    if (this.annotationLayer) {\r\n     this._renderAnnotationLayer();\r\n    }\r\n   });\r\n  }, function (reason) {\r\n   return finishPaintTask(reason);\r\n  });\r\n  if (this.xfaLayerFactory) {\r\n   if (!this.xfaLayer) {\r\n    this.xfaLayer = this.xfaLayerFactory.createXfaLayerBuilder(div, pdfPage, null);\r\n   }\r\n   this._renderXfaLayer();\r\n  }\r\n  if (this.structTreeLayerFactory && this.textLayer && this.canvas) {\r\n   this._onTextLayerRendered = event => {\r\n    if (event.pageNumber !== this.id) {\r\n     return;\r\n    }\r\n    this.eventBus._off(\"textlayerrendered\", this._onTextLayerRendered);\r\n    this._onTextLayerRendered = null;\r\n    if (!this.canvas) {\r\n     return;\r\n    }\r\n    this.pdfPage.getStructTree().then(tree => {\r\n     if (!tree) {\r\n      return;\r\n     }\r\n     if (!this.canvas) {\r\n      return;\r\n     }\r\n     const treeDom = this.structTreeLayer.render(tree);\r\n     treeDom.classList.add(\"structTree\");\r\n     this.canvas.appendChild(treeDom);\r\n    });\r\n   };\r\n   this.eventBus._on(\"textlayerrendered\", this._onTextLayerRendered);\r\n   this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder(pdfPage);\r\n  }\r\n  div.setAttribute(\"data-loaded\", true);\r\n  this.eventBus.dispatch(\"pagerender\", {\r\n   source: this,\r\n   pageNumber: this.id\r\n  });\r\n  return resultPromise;\r\n }\r\n paintOnCanvas(canvasWrapper) {\r\n  const renderCapability = createPromiseCapability();\r\n  const result = {\r\n   promise: renderCapability.promise,\r\n   onRenderContinue(cont) {\r\n    cont();\r\n   },\r\n   cancel() {\r\n    renderTask.cancel();\r\n   }\r\n  };\r\n  const viewport = this.viewport;\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.hidden = true;\r\n  let isCanvasHidden = true;\r\n  const showCanvas = function () {\r\n   if (isCanvasHidden) {\r\n    canvas.hidden = false;\r\n    isCanvasHidden = false;\r\n   }\r\n  };\r\n  canvasWrapper.appendChild(canvas);\r\n  this.canvas = canvas;\r\n  canvas.mozOpaque = true;\r\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\r\n  const outputScale = getOutputScale(ctx);\r\n  this.outputScale = outputScale;\r\n  if (this.useOnlyCssZoom) {\r\n   const actualSizeViewport = viewport.clone({ scale: PixelsPerInch.PDF_TO_CSS_UNITS });\r\n   outputScale.sx *= actualSizeViewport.width / viewport.width;\r\n   outputScale.sy *= actualSizeViewport.height / viewport.height;\r\n   outputScale.scaled = true;\r\n  }\r\n  if (this.maxCanvasPixels > 0) {\r\n   const pixelsInViewport = viewport.width * viewport.height;\r\n   const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);\r\n   if (outputScale.sx > maxScale || outputScale.sy > maxScale) {\r\n    outputScale.sx = maxScale;\r\n    outputScale.sy = maxScale;\r\n    outputScale.scaled = true;\r\n    this.hasRestrictedScaling = true;\r\n   } else {\r\n    this.hasRestrictedScaling = false;\r\n   }\r\n  }\r\n  const sfx = approximateFraction(outputScale.sx);\r\n  const sfy = approximateFraction(outputScale.sy);\r\n  canvas.width = roundToDivide(viewport.width * outputScale.sx, sfx[0]);\r\n  canvas.height = roundToDivide(viewport.height * outputScale.sy, sfy[0]);\r\n  canvas.style.width = roundToDivide(viewport.width, sfx[1]) + \"px\";\r\n  canvas.style.height = roundToDivide(viewport.height, sfy[1]) + \"px\";\r\n  this.paintedViewportMap.set(canvas, viewport);\r\n  const transform = !outputScale.scaled ? null : [\r\n   outputScale.sx,\r\n   0,\r\n   0,\r\n   outputScale.sy,\r\n   0,\r\n   0\r\n  ];\r\n  const renderContext = {\r\n   canvasContext: ctx,\r\n   transform,\r\n   viewport: this.viewport,\r\n   annotationMode: this.#annotationMode,\r\n   optionalContentConfigPromise: this._optionalContentConfigPromise,\r\n   annotationCanvasMap: this._annotationCanvasMap\r\n  };\r\n  const renderTask = this.pdfPage.render(renderContext);\r\n  renderTask.onContinue = function (cont) {\r\n   showCanvas();\r\n   if (result.onRenderContinue) {\r\n    result.onRenderContinue(cont);\r\n   } else {\r\n    cont();\r\n   }\r\n  };\r\n  renderTask.promise.then(function () {\r\n   showCanvas();\r\n   renderCapability.resolve();\r\n  }, function (error) {\r\n   showCanvas();\r\n   renderCapability.reject(error);\r\n  });\r\n  return result;\r\n }\r\n paintOnSvg(wrapper) {\r\n  let cancelled = false;\r\n  const ensureNotCancelled = () => {\r\n   if (cancelled) {\r\n    throw new RenderingCancelledException(`Rendering cancelled, page ${ this.id }`, \"svg\");\r\n   }\r\n  };\r\n  const pdfPage = this.pdfPage;\r\n  const actualSizeViewport = this.viewport.clone({ scale: PixelsPerInch.PDF_TO_CSS_UNITS });\r\n  const promise = pdfPage.getOperatorList({ annotationMode: this.#annotationMode }).then(opList => {\r\n   ensureNotCancelled();\r\n   const svgGfx = new SVGGraphics(pdfPage.commonObjs, pdfPage.objs);\r\n   return svgGfx.getSVG(opList, actualSizeViewport).then(svg => {\r\n    ensureNotCancelled();\r\n    this.svg = svg;\r\n    this.paintedViewportMap.set(svg, actualSizeViewport);\r\n    svg.style.width = wrapper.style.width;\r\n    svg.style.height = wrapper.style.height;\r\n    this.renderingState = RenderingStates.FINISHED;\r\n    wrapper.appendChild(svg);\r\n   });\r\n  });\r\n  return {\r\n   promise,\r\n   onRenderContinue(cont) {\r\n    cont();\r\n   },\r\n   cancel() {\r\n    cancelled = true;\r\n   }\r\n  };\r\n }\r\n setPageLabel(label) {\r\n  this.pageLabel = typeof label === \"string\" ? label : null;\r\n  if (this.pageLabel !== null) {\r\n   this.div.setAttribute(\"data-page-label\", this.pageLabel);\r\n  } else {\r\n   this.div.removeAttribute(\"data-page-label\");\r\n  }\r\n }\r\n}\r\nexport {\r\n PDFPageView\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {AnnotationMode, PixelsPerInch} = require(\"pdfjs-dist\");\r\nconst {PDFPrintServiceFactory, PDFViewerApplication} = require(\"./app.js\");\r\nconst {getXfaHtmlForPrinting} = require(\"./print_utils.js\");\r\nlet activeService = null;\r\nlet overlayManager = null;\r\nfunction renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size, printResolution, optionalContentConfigPromise) {\r\n const scratchCanvas = activeService.scratchCanvas;\r\n const PRINT_UNITS = printResolution / PixelsPerInch.PDF;\r\n scratchCanvas.width = Math.floor(size.width * PRINT_UNITS);\r\n scratchCanvas.height = Math.floor(size.height * PRINT_UNITS);\r\n const ctx = scratchCanvas.getContext(\"2d\");\r\n ctx.save();\r\n ctx.fillStyle = \"rgb(255, 255, 255)\";\r\n ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);\r\n ctx.restore();\r\n return pdfDocument.getPage(pageNumber).then(function (pdfPage) {\r\n  const renderContext = {\r\n   canvasContext: ctx,\r\n   transform: [\r\n    PRINT_UNITS,\r\n    0,\r\n    0,\r\n    PRINT_UNITS,\r\n    0,\r\n    0\r\n   ],\r\n   viewport: pdfPage.getViewport({\r\n    scale: 1,\r\n    rotation: size.rotation\r\n   }),\r\n   intent: \"print\",\r\n   annotationMode: AnnotationMode.ENABLE_STORAGE,\r\n   optionalContentConfigPromise\r\n  };\r\n  return pdfPage.render(renderContext).promise;\r\n });\r\n}\r\nfunction PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise = null, l10n) {\r\n this.pdfDocument = pdfDocument;\r\n this.pagesOverview = pagesOverview;\r\n this.printContainer = printContainer;\r\n this._printResolution = printResolution || 150;\r\n this._optionalContentConfigPromise = optionalContentConfigPromise || pdfDocument.getOptionalContentConfig();\r\n this.l10n = l10n;\r\n this.currentPage = -1;\r\n this.scratchCanvas = document.createElement(\"canvas\");\r\n}\r\nPDFPrintService.prototype = {\r\n layout() {\r\n  this.throwIfInactive();\r\n  const body = document.querySelector(\"body\");\r\n  body.setAttribute(\"data-pdfjsprinting\", true);\r\n  const hasEqualPageSizes = this.pagesOverview.every(function (size) {\r\n   return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height;\r\n  }, this);\r\n  if (!hasEqualPageSizes) {\r\n   console.warn(\"Not all pages have the same size. The printed \" + \"result may be incorrect!\");\r\n  }\r\n  this.pageStyleSheet = document.createElement(\"style\");\r\n  const pageSize = this.pagesOverview[0];\r\n  this.pageStyleSheet.textContent = \"@page { size: \" + pageSize.width + \"pt \" + pageSize.height + \"pt;}\";\r\n  body.appendChild(this.pageStyleSheet);\r\n },\r\n destroy() {\r\n  if (activeService !== this) {\r\n   return;\r\n  }\r\n  this.printContainer.textContent = \"\";\r\n  const body = document.querySelector(\"body\");\r\n  body.removeAttribute(\"data-pdfjsprinting\");\r\n  if (this.pageStyleSheet) {\r\n   this.pageStyleSheet.remove();\r\n   this.pageStyleSheet = null;\r\n  }\r\n  this.scratchCanvas.width = this.scratchCanvas.height = 0;\r\n  this.scratchCanvas = null;\r\n  activeService = null;\r\n  ensureOverlay().then(function () {\r\n   if (overlayManager.active !== \"printServiceOverlay\") {\r\n    return;\r\n   }\r\n   overlayManager.close(\"printServiceOverlay\");\r\n  });\r\n },\r\n renderPages() {\r\n  if (this.pdfDocument.isPureXfa) {\r\n   getXfaHtmlForPrinting(this.printContainer, this.pdfDocument);\r\n   return Promise.resolve();\r\n  }\r\n  const pageCount = this.pagesOverview.length;\r\n  const renderNextPage = (resolve, reject) => {\r\n   this.throwIfInactive();\r\n   if (++this.currentPage >= pageCount) {\r\n    renderProgress(pageCount, pageCount, this.l10n);\r\n    resolve();\r\n    return;\r\n   }\r\n   const index = this.currentPage;\r\n   renderProgress(index, pageCount, this.l10n);\r\n   renderPage(this, this.pdfDocument, index + 1, this.pagesOverview[index], this._printResolution, this._optionalContentConfigPromise).then(this.useRenderedPage.bind(this)).then(function () {\r\n    renderNextPage(resolve, reject);\r\n   }, reject);\r\n  };\r\n  return new Promise(renderNextPage);\r\n },\r\n useRenderedPage() {\r\n  this.throwIfInactive();\r\n  const img = document.createElement(\"img\");\r\n  const scratchCanvas = this.scratchCanvas;\r\n  if (\"toBlob\" in scratchCanvas) {\r\n   scratchCanvas.toBlob(function (blob) {\r\n    img.src = URL.createObjectURL(blob);\r\n   });\r\n  } else {\r\n   img.src = scratchCanvas.toDataURL();\r\n  }\r\n  const wrapper = document.createElement(\"div\");\r\n  wrapper.className = \"printedPage\";\r\n  wrapper.appendChild(img);\r\n  this.printContainer.appendChild(wrapper);\r\n  return new Promise(function (resolve, reject) {\r\n   img.onload = resolve;\r\n   img.onerror = reject;\r\n  });\r\n },\r\n performPrint() {\r\n  this.throwIfInactive();\r\n  return new Promise(resolve => {\r\n   setTimeout(() => {\r\n    if (!this.active) {\r\n     resolve();\r\n     return;\r\n    }\r\n    print.call(window);\r\n    setTimeout(resolve, 20);\r\n   }, 0);\r\n  });\r\n },\r\n get active() {\r\n  return this === activeService;\r\n },\r\n throwIfInactive() {\r\n  if (!this.active) {\r\n   throw new Error(\"This print request was cancelled or completed.\");\r\n  }\r\n }\r\n};\r\nconst print = window.print;\r\nwindow.print = function () {\r\n if (activeService) {\r\n  console.warn(\"Ignored window.print() because of a pending print job.\");\r\n  return;\r\n }\r\n ensureOverlay().then(function () {\r\n  if (activeService) {\r\n   overlayManager.open(\"printServiceOverlay\");\r\n  }\r\n });\r\n try {\r\n  dispatchEvent(\"beforeprint\");\r\n } finally {\r\n  if (!activeService) {\r\n   console.error(\"Expected print service to be initialized.\");\r\n   ensureOverlay().then(function () {\r\n    if (overlayManager.active === \"printServiceOverlay\") {\r\n     overlayManager.close(\"printServiceOverlay\");\r\n    }\r\n   });\r\n   return;\r\n  }\r\n  const activeServiceOnEntry = activeService;\r\n  activeService.renderPages().then(function () {\r\n   return activeServiceOnEntry.performPrint();\r\n  }).catch(function () {\r\n  }).then(function () {\r\n   if (activeServiceOnEntry.active) {\r\n    abort();\r\n   }\r\n  });\r\n }\r\n};\r\nfunction dispatchEvent(eventType) {\r\n const event = document.createEvent(\"CustomEvent\");\r\n event.initCustomEvent(eventType, false, false, \"custom\");\r\n window.dispatchEvent(event);\r\n}\r\nfunction abort() {\r\n if (activeService) {\r\n  activeService.destroy();\r\n  dispatchEvent(\"afterprint\");\r\n }\r\n}\r\nfunction renderProgress(index, total, l10n) {\r\n const progressContainer = document.getElementById(\"printServiceOverlay\");\r\n const progress = Math.round(100 * index / total);\r\n const progressBar = progressContainer.querySelector(\"progress\");\r\n const progressPerc = progressContainer.querySelector(\".relative-progress\");\r\n progressBar.value = progress;\r\n l10n.get(\"print_progress_percent\", { progress }).then(msg => {\r\n  progressPerc.textContent = msg;\r\n });\r\n}\r\nwindow.addEventListener(\"keydown\", function (event) {\r\n if (event.keyCode === 80 && (event.ctrlKey || event.metaKey) && !event.altKey && (!event.shiftKey || window.chrome || window.opera)) {\r\n  window.print();\r\n  event.preventDefault();\r\n  if (event.stopImmediatePropagation) {\r\n   event.stopImmediatePropagation();\r\n  } else {\r\n   event.stopPropagation();\r\n  }\r\n }\r\n}, true);\r\nif (\"onbeforeprint\" in window) {\r\n const stopPropagationIfNeeded = function (event) {\r\n  if (event.detail !== \"custom\" && event.stopImmediatePropagation) {\r\n   event.stopImmediatePropagation();\r\n  }\r\n };\r\n window.addEventListener(\"beforeprint\", stopPropagationIfNeeded);\r\n window.addEventListener(\"afterprint\", stopPropagationIfNeeded);\r\n}\r\nlet overlayPromise;\r\nfunction ensureOverlay() {\r\n if (!overlayPromise) {\r\n  overlayManager = PDFViewerApplication.overlayManager;\r\n  if (!overlayManager) {\r\n   throw new Error(\"The overlay manager has not yet been initialized.\");\r\n  }\r\n  overlayPromise = overlayManager.register(\"printServiceOverlay\", document.getElementById(\"printServiceOverlay\"), abort, true);\r\n  document.getElementById(\"printCancel\").onclick = abort;\r\n }\r\n return overlayPromise;\r\n}\r\nPDFPrintServiceFactory.instance = {\r\n supportsPrinting: true,\r\n createPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, l10n) {\r\n  if (activeService) {\r\n   throw new Error(\"The print service is created and active.\");\r\n  }\r\n  activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, l10n);\r\n  return activeService;\r\n }\r\n};\r\nexport {\r\n PDFPrintService\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {RenderingCancelledException} = require(\"pdfjs-dist\");\r\nconst {RenderingStates} = require(\"./ui_utils.js\");\r\nconst CLEANUP_TIMEOUT = 30000;\r\nclass PDFRenderingQueue {\r\n constructor() {\r\n  this.pdfViewer = null;\r\n  this.pdfThumbnailViewer = null;\r\n  this.onIdle = null;\r\n  this.highestPriorityPage = null;\r\n  this.idleTimeout = null;\r\n  this.printing = false;\r\n  this.isThumbnailViewEnabled = false;\r\n }\r\n setViewer(pdfViewer) {\r\n  this.pdfViewer = pdfViewer;\r\n }\r\n setThumbnailViewer(pdfThumbnailViewer) {\r\n  this.pdfThumbnailViewer = pdfThumbnailViewer;\r\n }\r\n isHighestPriority(view) {\r\n  return this.highestPriorityPage === view.renderingId;\r\n }\r\n hasViewer() {\r\n  return !!this.pdfViewer;\r\n }\r\n renderHighestPriority(currentlyVisiblePages) {\r\n  if (this.idleTimeout) {\r\n   clearTimeout(this.idleTimeout);\r\n   this.idleTimeout = null;\r\n  }\r\n  if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {\r\n   return;\r\n  }\r\n  if (this.isThumbnailViewEnabled && this.pdfThumbnailViewer?.forceRendering()) {\r\n   return;\r\n  }\r\n  if (this.printing) {\r\n   return;\r\n  }\r\n  if (this.onIdle) {\r\n   this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);\r\n  }\r\n }\r\n getHighestPriority(visible, views, scrolledDown, preRenderExtra = false) {\r\n  const visibleViews = visible.views, numVisible = visibleViews.length;\r\n  if (numVisible === 0) {\r\n   return null;\r\n  }\r\n  for (let i = 0; i < numVisible; i++) {\r\n   const view = visibleViews[i].view;\r\n   if (!this.isViewFinished(view)) {\r\n    return view;\r\n   }\r\n  }\r\n  const firstId = visible.first.id, lastId = visible.last.id;\r\n  if (lastId - firstId + 1 > numVisible) {\r\n   const visibleIds = visible.ids;\r\n   for (let i = 1, ii = lastId - firstId; i < ii; i++) {\r\n    const holeId = scrolledDown ? firstId + i : lastId - i;\r\n    if (visibleIds.has(holeId)) {\r\n     continue;\r\n    }\r\n    const holeView = views[holeId - 1];\r\n    if (!this.isViewFinished(holeView)) {\r\n     return holeView;\r\n    }\r\n   }\r\n  }\r\n  let preRenderIndex = scrolledDown ? lastId : firstId - 2;\r\n  let preRenderView = views[preRenderIndex];\r\n  if (preRenderView && !this.isViewFinished(preRenderView)) {\r\n   return preRenderView;\r\n  }\r\n  if (preRenderExtra) {\r\n   preRenderIndex += scrolledDown ? 1 : -1;\r\n   preRenderView = views[preRenderIndex];\r\n   if (preRenderView && !this.isViewFinished(preRenderView)) {\r\n    return preRenderView;\r\n   }\r\n  }\r\n  return null;\r\n }\r\n isViewFinished(view) {\r\n  return view.renderingState === RenderingStates.FINISHED;\r\n }\r\n renderView(view) {\r\n  switch (view.renderingState) {\r\n  case RenderingStates.FINISHED:\r\n   return false;\r\n  case RenderingStates.PAUSED:\r\n   this.highestPriorityPage = view.renderingId;\r\n   view.resume();\r\n   break;\r\n  case RenderingStates.RUNNING:\r\n   this.highestPriorityPage = view.renderingId;\r\n   break;\r\n  case RenderingStates.INITIAL:\r\n   this.highestPriorityPage = view.renderingId;\r\n   view.draw().finally(() => {\r\n    this.renderHighestPriority();\r\n   }).catch(reason => {\r\n    if (reason instanceof RenderingCancelledException) {\r\n     return;\r\n    }\r\n    console.error(`renderView: \"${ reason }\"`);\r\n   });\r\n   break;\r\n  }\r\n  return true;\r\n }\r\n}\r\nexport {\r\n PDFRenderingQueue\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {apiPageLayoutToViewerModes, RenderingStates} = require(\"./ui_utils.js\");\r\nconst {createPromiseCapability, shadow} = require(\"pdfjs-dist\");\r\nclass PDFScriptingManager {\r\n constructor({eventBus, sandboxBundleSrc = null, scriptingFactory = null, docPropertiesLookup = null}) {\r\n  this._pdfDocument = null;\r\n  this._pdfViewer = null;\r\n  this._closeCapability = null;\r\n  this._destroyCapability = null;\r\n  this._scripting = null;\r\n  this._mouseState = Object.create(null);\r\n  this._ready = false;\r\n  this._eventBus = eventBus;\r\n  this._sandboxBundleSrc = sandboxBundleSrc;\r\n  this._scriptingFactory = scriptingFactory;\r\n  this._docPropertiesLookup = docPropertiesLookup;\r\n }\r\n setViewer(pdfViewer) {\r\n  this._pdfViewer = pdfViewer;\r\n }\r\n async setDocument(pdfDocument) {\r\n  if (this._pdfDocument) {\r\n   await this._destroyScripting();\r\n  }\r\n  this._pdfDocument = pdfDocument;\r\n  if (!pdfDocument) {\r\n   return;\r\n  }\r\n  const [objects, calculationOrder, docActions] = await Promise.all([\r\n   pdfDocument.getFieldObjects(),\r\n   pdfDocument.getCalculationOrderIds(),\r\n   pdfDocument.getJSActions()\r\n  ]);\r\n  if (!objects && !docActions) {\r\n   await this._destroyScripting();\r\n   return;\r\n  }\r\n  if (pdfDocument !== this._pdfDocument) {\r\n   return;\r\n  }\r\n  try {\r\n   this._scripting = this._createScripting();\r\n  } catch (error) {\r\n   console.error(`PDFScriptingManager.setDocument: \"${ error?.message }\".`);\r\n   await this._destroyScripting();\r\n   return;\r\n  }\r\n  this._internalEvents.set(\"updatefromsandbox\", event => {\r\n   if (event?.source !== window) {\r\n    return;\r\n   }\r\n   this._updateFromSandbox(event.detail);\r\n  });\r\n  this._internalEvents.set(\"dispatcheventinsandbox\", event => {\r\n   this._scripting?.dispatchEventInSandbox(event.detail);\r\n  });\r\n  this._internalEvents.set(\"pagechanging\", ({pageNumber, previous}) => {\r\n   if (pageNumber === previous) {\r\n    return;\r\n   }\r\n   this._dispatchPageClose(previous);\r\n   this._dispatchPageOpen(pageNumber);\r\n  });\r\n  this._internalEvents.set(\"pagerendered\", ({pageNumber}) => {\r\n   if (!this._pageOpenPending.has(pageNumber)) {\r\n    return;\r\n   }\r\n   if (pageNumber !== this._pdfViewer.currentPageNumber) {\r\n    return;\r\n   }\r\n   this._dispatchPageOpen(pageNumber);\r\n  });\r\n  this._internalEvents.set(\"pagesdestroy\", async event => {\r\n   await this._dispatchPageClose(this._pdfViewer.currentPageNumber);\r\n   await this._scripting?.dispatchEventInSandbox({\r\n    id: \"doc\",\r\n    name: \"WillClose\"\r\n   });\r\n   this._closeCapability?.resolve();\r\n  });\r\n  this._domEvents.set(\"mousedown\", event => {\r\n   this._mouseState.isDown = true;\r\n  });\r\n  this._domEvents.set(\"mouseup\", event => {\r\n   this._mouseState.isDown = false;\r\n  });\r\n  for (const [name, listener] of this._internalEvents) {\r\n   this._eventBus._on(name, listener);\r\n  }\r\n  for (const [name, listener] of this._domEvents) {\r\n   window.addEventListener(name, listener);\r\n  }\r\n  try {\r\n   const docProperties = await this._getDocProperties();\r\n   if (pdfDocument !== this._pdfDocument) {\r\n    return;\r\n   }\r\n   await this._scripting.createSandbox({\r\n    objects,\r\n    calculationOrder,\r\n    appInfo: {\r\n     platform: navigator.platform,\r\n     language: navigator.language\r\n    },\r\n    docInfo: {\r\n     ...docProperties,\r\n     actions: docActions\r\n    }\r\n   });\r\n   this._eventBus.dispatch(\"sandboxcreated\", { source: this });\r\n  } catch (error) {\r\n   console.error(`PDFScriptingManager.setDocument: \"${ error?.message }\".`);\r\n   await this._destroyScripting();\r\n   return;\r\n  }\r\n  await this._scripting?.dispatchEventInSandbox({\r\n   id: \"doc\",\r\n   name: \"Open\"\r\n  });\r\n  await this._dispatchPageOpen(this._pdfViewer.currentPageNumber, true);\r\n  Promise.resolve().then(() => {\r\n   if (pdfDocument === this._pdfDocument) {\r\n    this._ready = true;\r\n   }\r\n  });\r\n }\r\n async dispatchWillSave(detail) {\r\n  return this._scripting?.dispatchEventInSandbox({\r\n   id: \"doc\",\r\n   name: \"WillSave\"\r\n  });\r\n }\r\n async dispatchDidSave(detail) {\r\n  return this._scripting?.dispatchEventInSandbox({\r\n   id: \"doc\",\r\n   name: \"DidSave\"\r\n  });\r\n }\r\n async dispatchWillPrint(detail) {\r\n  return this._scripting?.dispatchEventInSandbox({\r\n   id: \"doc\",\r\n   name: \"WillPrint\"\r\n  });\r\n }\r\n async dispatchDidPrint(detail) {\r\n  return this._scripting?.dispatchEventInSandbox({\r\n   id: \"doc\",\r\n   name: \"DidPrint\"\r\n  });\r\n }\r\n get mouseState() {\r\n  return this._mouseState;\r\n }\r\n get destroyPromise() {\r\n  return this._destroyCapability?.promise || null;\r\n }\r\n get ready() {\r\n  return this._ready;\r\n }\r\n get _internalEvents() {\r\n  return shadow(this, \"_internalEvents\", new Map());\r\n }\r\n get _domEvents() {\r\n  return shadow(this, \"_domEvents\", new Map());\r\n }\r\n get _pageOpenPending() {\r\n  return shadow(this, \"_pageOpenPending\", new Set());\r\n }\r\n get _visitedPages() {\r\n  return shadow(this, \"_visitedPages\", new Map());\r\n }\r\n async _updateFromSandbox(detail) {\r\n  const {id, siblings, command, value} = detail;\r\n  if (!id) {\r\n   switch (command) {\r\n   case \"clear\":\r\n    console.clear();\r\n    break;\r\n   case \"error\":\r\n    console.error(value);\r\n    break;\r\n   case \"layout\":\r\n\r\n    const modes = apiPageLayoutToViewerModes(value);\r\n    this._pdfViewer.spreadMode = modes.spreadMode;\r\n    break;\r\n   case \"page-num\":\r\n    this._pdfViewer.currentPageNumber = value + 1;\r\n    break;\r\n   case \"print\":\r\n    await this._pdfViewer.pagesPromise;\r\n    this._eventBus.dispatch(\"print\", { source: this });\r\n    break;\r\n   case \"println\":\r\n    console.log(value);\r\n    break;\r\n   case \"zoom\":\r\n\r\n    this._pdfViewer.currentScaleValue = value;\r\n    break;\r\n   case \"SaveAs\":\r\n    this._eventBus.dispatch(\"save\", { source: this });\r\n    break;\r\n   case \"FirstPage\":\r\n    this._pdfViewer.currentPageNumber = 1;\r\n    break;\r\n   case \"LastPage\":\r\n    this._pdfViewer.currentPageNumber = this._pdfViewer.pagesCount;\r\n    break;\r\n   case \"NextPage\":\r\n    this._pdfViewer.nextPage();\r\n    break;\r\n   case \"PrevPage\":\r\n    this._pdfViewer.previousPage();\r\n    break;\r\n   case \"ZoomViewIn\":\r\n  \r\n    this._pdfViewer.increaseScale();\r\n    break;\r\n   case \"ZoomViewOut\":\r\n  \r\n    this._pdfViewer.decreaseScale();\r\n    break;\r\n   }\r\n   return;\r\n  }\r\n\r\n  delete detail.id;\r\n  delete detail.siblings;\r\n  const ids = siblings ? [\r\n   id,\r\n   ...siblings\r\n  ] : [id];\r\n  for (const elementId of ids) {\r\n   const element = document.getElementById(elementId);\r\n   if (element) {\r\n    element.dispatchEvent(new CustomEvent(\"updatefromsandbox\", { detail }));\r\n   } else {\r\n    this._pdfDocument?.annotationStorage.setValue(elementId, detail);\r\n   }\r\n  }\r\n }\r\n async _dispatchPageOpen(pageNumber, initialize = false) {\r\n  const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;\r\n  if (initialize) {\r\n   this._closeCapability = createPromiseCapability();\r\n  }\r\n  if (!this._closeCapability) {\r\n   return;\r\n  }\r\n  const pageView = this._pdfViewer.getPageView(pageNumber - 1);\r\n  if (pageView?.renderingState !== RenderingStates.FINISHED) {\r\n   this._pageOpenPending.add(pageNumber);\r\n   return;\r\n  }\r\n  this._pageOpenPending.delete(pageNumber);\r\n  const actionsPromise = ((async () => {\r\n   const actions = await (!visitedPages.has(pageNumber) ? pageView.pdfPage?.getJSActions() : null);\r\n   if (pdfDocument !== this._pdfDocument) {\r\n    return;\r\n   }\r\n   await this._scripting?.dispatchEventInSandbox({\r\n    id: \"page\",\r\n    name: \"PageOpen\",\r\n    pageNumber,\r\n    actions\r\n   });\r\n  })());\r\n  visitedPages.set(pageNumber, actionsPromise);\r\n }\r\n async _dispatchPageClose(pageNumber) {\r\n  const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;\r\n  if (!this._closeCapability) {\r\n   return;\r\n  }\r\n  if (this._pageOpenPending.has(pageNumber)) {\r\n   return;\r\n  }\r\n  const actionsPromise = visitedPages.get(pageNumber);\r\n  if (!actionsPromise) {\r\n   return;\r\n  }\r\n  visitedPages.set(pageNumber, null);\r\n  await actionsPromise;\r\n  if (pdfDocument !== this._pdfDocument) {\r\n   return;\r\n  }\r\n  await this._scripting?.dispatchEventInSandbox({\r\n   id: \"page\",\r\n   name: \"PageClose\",\r\n   pageNumber\r\n  });\r\n }\r\n async _getDocProperties() {\r\n  if (this._docPropertiesLookup) {\r\n   return this._docPropertiesLookup(this._pdfDocument);\r\n  }\r\n  throw new Error(\"_getDocProperties: Unable to lookup properties.\");\r\n }\r\n _createScripting() {\r\n  this._destroyCapability = createPromiseCapability();\r\n  if (this._scripting) {\r\n   throw new Error(\"_createScripting: Scripting already exists.\");\r\n  }\r\n  if (this._scriptingFactory) {\r\n   return this._scriptingFactory.createScripting({ sandboxBundleSrc: this._sandboxBundleSrc });\r\n  }\r\n  throw new Error(\"_createScripting: Cannot create scripting.\");\r\n }\r\n async _destroyScripting() {\r\n  if (!this._scripting) {\r\n   this._pdfDocument = null;\r\n   this._destroyCapability?.resolve();\r\n   return;\r\n  }\r\n  if (this._closeCapability) {\r\n   await Promise.race([\r\n    this._closeCapability.promise,\r\n    new Promise(resolve => {\r\n     setTimeout(resolve, 1000);\r\n    })\r\n   ]).catch(reason => {\r\n   });\r\n   this._closeCapability = null;\r\n  }\r\n  this._pdfDocument = null;\r\n  try {\r\n   await this._scripting.destroySandbox();\r\n  } catch (ex) {\r\n  }\r\n  for (const [name, listener] of this._internalEvents) {\r\n   this._eventBus._off(name, listener);\r\n  }\r\n  this._internalEvents.clear();\r\n  for (const [name, listener] of this._domEvents) {\r\n   window.removeEventListener(name, listener);\r\n  }\r\n  this._domEvents.clear();\r\n  this._pageOpenPending.clear();\r\n  this._visitedPages.clear();\r\n  this._scripting = null;\r\n  delete this._mouseState.isDown;\r\n  this._ready = false;\r\n  this._destroyCapability?.resolve();\r\n }\r\n}\r\nexport {\r\n PDFScriptingManager\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {ScrollMode, SpreadMode} = require(\"./ui_utils.js\");\r\nconst {BaseViewer} = require(\"./base_viewer.js\");\r\nclass PDFViewer extends BaseViewer {\r\n}\r\nclass PDFSinglePageViewer extends BaseViewer {\r\n _resetView() {\r\n  super._resetView();\r\n  this._scrollMode = ScrollMode.PAGE;\r\n  this._spreadMode = SpreadMode.NONE;\r\n }\r\n set scrollMode(mode) {\r\n }\r\n _updateScrollMode() {\r\n }\r\n set spreadMode(mode) {\r\n }\r\n _updateSpreadMode() {\r\n }\r\n}\r\nexport {\r\n PDFSinglePageViewer,\r\n PDFViewer\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {getXfaPageViewport, PixelsPerInch} = require(\"pdfjs-dist\");\r\nconst {SimpleLinkService} = require(\"./pdf_link_service.js\");\r\nconst {XfaLayerBuilder} = require(\"./xfa_layer_builder.js\");\r\nfunction getXfaHtmlForPrinting(printContainer, pdfDocument) {\r\n const xfaHtml = pdfDocument.allXfaHtml;\r\n const linkService = new SimpleLinkService();\r\n const scale = Math.round(PixelsPerInch.PDF_TO_CSS_UNITS * 100) / 100;\r\n for (const xfaPage of xfaHtml.children) {\r\n  const page = document.createElement(\"div\");\r\n  page.className = \"xfaPrintedPage\";\r\n  printContainer.appendChild(page);\r\n  const builder = new XfaLayerBuilder({\r\n   pageDiv: page,\r\n   pdfPage: null,\r\n   annotationStorage: pdfDocument.annotationStorage,\r\n   linkService,\r\n   xfaHtml: xfaPage\r\n  });\r\n  const viewport = getXfaPageViewport(xfaPage, { scale });\r\n  builder.render(viewport, \"print\");\r\n }\r\n}\r\nexport {\r\n getXfaHtmlForPrinting\r\n};\r\n","const {AppOptions} = require(\"./app_options.js\");\r\n\r\nclass SDPDFCore {\r\n    // this.PDFViewerApplication = app;\r\n    // this.PDFViewerApplicationConfig = config;\r\n    // this.pdfTabId;\r\n    // this.callbackId;\r\n    // this.callbackMap;\r\n\r\n    init(app,config){\r\n        this.PDFViewerApplication = app;\r\n        this.PDFViewerApplicationConfig = config;\r\n        this.callbackId=0;\r\n        this.callbackMap={};\r\n        window.addEventListener('message',(msg)=>{\r\n            const {type,callbackId} = msg;\r\n            let rt;\r\n            switch(type){\r\n                case 'RENDERER_TO_SDPDFCORE_CALLBACK':\r\n                    this.handleCallback(msg);\r\n                    break;\r\n                case 'RENDERER_TO_SDPDFCORE_INVOKE':\r\n                    this.handleInvoke(msg);\r\n                    break;\r\n                default:\r\n                    console.warn(`INVALID TYPE ${type}`);\r\n            }\r\n        })\r\n    }\r\n\r\n    loadPDF(msg,callback){\r\n        this.pdfTabId = msg.data.pdfTabId\r\n        AppOptions.set('fileBlob',msg.data.fileBlob);\r\n        this.PDFViewerApplication.run(this.PDFViewerApplicationConfig);\r\n        callback('initReady');\r\n    }\r\n\r\n    getOutLine(msg,callback){\r\n        this.PDFViewerApplication.pdfDocument.getOutline().then((o)=>{\r\n            callback(o);\r\n        });\r\n    }\r\n    callbackToRenderer(callbackId,data){\r\n        window.postMessage({\r\n            type:'SDPDFCORE_TO_RENDERER_CALLBACK',\r\n            callbackId:`${callbackId}`,\r\n            data\r\n        })\r\n    }\r\n    postMessageToRenderer(data,callback){\r\n        let callbackId=-1;\r\n        if(callback&&typeof callback=='function'){\r\n            callbackId = this.callbackId;\r\n            this.callbackMap[`${callbackId}`] = callback;\r\n            this.callbackId++;\r\n        }\r\n        window.postMessage({\r\n            type:'SDPDFCORE_TO_RENDERER_INVOKE',\r\n            callbackId:`${callbackId}`,\r\n            data\r\n        })\r\n    }\r\n    handleInvoke(msg){\r\n        switch(msg.method){\r\n            case 'loadPDF':\r\n                this.loadPDF(msg,this.generalCallback(msg.callbackId));\r\n                break;\r\n            case 'getOutline':\r\n                this.getOutLine(msg,this.generalCallback(msg.callbackId));\r\n                break;\r\n            default:\r\n                console.warn(`Unknown invoke ${msg.method}`)\r\n        }\r\n    }\r\n    generalCallback(callbackId){\r\n        if(callbackId==-1){\r\n            return function(){}\r\n        }else{\r\n            return function(data){\r\n                this.callbackToRenderer(callbackId,data);\r\n            }\r\n        }\r\n    }\r\n    handleCallback(msg){\r\n        const {callbackId} = msg\r\n        if(callbackId!='-1'&&this.callbackMap[callbackId]&&typeof this.callbackMap[callbackId]=='function'){\r\n            this.callbackMap[callbackId](msg.data)\r\n        }\r\n    }\r\n}","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {SCROLLBAR_PADDING, ScrollMode, SpreadMode} = require(\"./ui_utils.js\");\r\nconst {CursorTool} = require(\"./pdf_cursor_tools.js\");\r\nconst {PagesCountLimit} = require(\"./base_viewer.js\");\r\nclass SecondaryToolbar {\r\n constructor(options, mainContainer, eventBus) {\r\n  this.toolbar = options.toolbar;\r\n  this.toggleButton = options.toggleButton;\r\n  this.toolbarButtonContainer = options.toolbarButtonContainer;\r\n  this.buttons = [\r\n\r\n  //  {\r\n  //   element: options.openFileButton,\r\n  //   eventName: \"openfile\",\r\n  //   close: true\r\n  //  },\r\n  //  {\r\n  //   element: options.printButton,\r\n  //   eventName: \"print\",\r\n  //   close: true\r\n  //  },\r\n  //  {\r\n  //   element: options.downloadButton,\r\n  //   eventName: \"download\",\r\n  //   close: true\r\n  //  },\r\n   {\r\n    element: options.viewBookmarkButton,\r\n    eventName: null,\r\n    close: true\r\n   },\r\n   {\r\n    element: options.firstPageButton,\r\n    eventName: \"firstpage\",\r\n    close: true\r\n   },\r\n   {\r\n    element: options.lastPageButton,\r\n    eventName: \"lastpage\",\r\n    close: true\r\n   },\r\n   {\r\n    element: options.pageRotateCwButton,\r\n    eventName: \"rotatecw\",\r\n    close: false\r\n   },\r\n   {\r\n    element: options.pageRotateCcwButton,\r\n    eventName: \"rotateccw\",\r\n    close: false\r\n   },\r\n   {\r\n    element: options.cursorSelectToolButton,\r\n    eventName: \"switchcursortool\",\r\n    eventDetails: { tool: CursorTool.SELECT },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.cursorHandToolButton,\r\n    eventName: \"switchcursortool\",\r\n    eventDetails: { tool: CursorTool.HAND },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.scrollPageButton,\r\n    eventName: \"switchscrollmode\",\r\n    eventDetails: { mode: ScrollMode.PAGE },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.scrollVerticalButton,\r\n    eventName: \"switchscrollmode\",\r\n    eventDetails: { mode: ScrollMode.VERTICAL },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.scrollHorizontalButton,\r\n    eventName: \"switchscrollmode\",\r\n    eventDetails: { mode: ScrollMode.HORIZONTAL },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.scrollWrappedButton,\r\n    eventName: \"switchscrollmode\",\r\n    eventDetails: { mode: ScrollMode.WRAPPED },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.spreadNoneButton,\r\n    eventName: \"switchspreadmode\",\r\n    eventDetails: { mode: SpreadMode.NONE },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.spreadOddButton,\r\n    eventName: \"switchspreadmode\",\r\n    eventDetails: { mode: SpreadMode.ODD },\r\n    close: true\r\n   },\r\n   {\r\n    element: options.spreadEvenButton,\r\n    eventName: \"switchspreadmode\",\r\n    eventDetails: { mode: SpreadMode.EVEN },\r\n    close: true\r\n   }\r\n   // saltdog disable documentProperties\r\n//    ,\r\n//    {\r\n//     element: options.documentPropertiesButton,\r\n//     eventName: \"documentproperties\",\r\n//     close: true\r\n//    }\r\n  ];\r\n  this.items = {\r\n   firstPage: options.firstPageButton,\r\n   lastPage: options.lastPageButton,\r\n   pageRotateCw: options.pageRotateCwButton,\r\n   pageRotateCcw: options.pageRotateCcwButton\r\n  };\r\n  this.mainContainer = mainContainer;\r\n  this.eventBus = eventBus;\r\n  this.opened = false;\r\n  this.containerHeight = null;\r\n  this.previousContainerHeight = null;\r\n  this.reset();\r\n  this._bindClickListeners();\r\n  this._bindCursorToolsListener(options);\r\n  this._bindScrollModeListener(options);\r\n  this._bindSpreadModeListener(options);\r\n  this.eventBus._on(\"resize\", this._setMaxHeight.bind(this));\r\n }\r\n get isOpen() {\r\n  return this.opened;\r\n }\r\n setPageNumber(pageNumber) {\r\n  this.pageNumber = pageNumber;\r\n  this._updateUIState();\r\n }\r\n setPagesCount(pagesCount) {\r\n  this.pagesCount = pagesCount;\r\n  this._updateUIState();\r\n }\r\n reset() {\r\n  this.pageNumber = 0;\r\n  this.pagesCount = 0;\r\n  this._updateUIState();\r\n  this.eventBus.dispatch(\"secondarytoolbarreset\", { source: this });\r\n }\r\n _updateUIState() {\r\n  this.items.firstPage.disabled = this.pageNumber <= 1;\r\n  this.items.lastPage.disabled = this.pageNumber >= this.pagesCount;\r\n  this.items.pageRotateCw.disabled = this.pagesCount === 0;\r\n  this.items.pageRotateCcw.disabled = this.pagesCount === 0;\r\n }\r\n _bindClickListeners() {\r\n  this.toggleButton.addEventListener(\"click\", this.toggle.bind(this));\r\n  for (const {element, eventName, close, eventDetails} of this.buttons) {\r\n   element.addEventListener(\"click\", evt => {\r\n    if (eventName !== null) {\r\n     const details = { source: this };\r\n     for (const property in eventDetails) {\r\n      details[property] = eventDetails[property];\r\n     }\r\n     this.eventBus.dispatch(eventName, details);\r\n    }\r\n    if (close) {\r\n     this.close();\r\n    }\r\n   });\r\n  }\r\n }\r\n _bindCursorToolsListener(buttons) {\r\n  this.eventBus._on(\"cursortoolchanged\", function ({tool}) {\r\n   buttons.cursorSelectToolButton.classList.toggle(\"toggled\", tool === CursorTool.SELECT);\r\n   buttons.cursorHandToolButton.classList.toggle(\"toggled\", tool === CursorTool.HAND);\r\n  });\r\n }\r\n _bindScrollModeListener(buttons) {\r\n  const scrollModeChanged = ({mode}) => {\r\n   buttons.scrollPageButton.classList.toggle(\"toggled\", mode === ScrollMode.PAGE);\r\n   buttons.scrollVerticalButton.classList.toggle(\"toggled\", mode === ScrollMode.VERTICAL);\r\n   buttons.scrollHorizontalButton.classList.toggle(\"toggled\", mode === ScrollMode.HORIZONTAL);\r\n   buttons.scrollWrappedButton.classList.toggle(\"toggled\", mode === ScrollMode.WRAPPED);\r\n   const forceScrollModePage = this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE;\r\n   buttons.scrollPageButton.disabled = forceScrollModePage;\r\n   buttons.scrollVerticalButton.disabled = forceScrollModePage;\r\n   buttons.scrollHorizontalButton.disabled = forceScrollModePage;\r\n   buttons.scrollWrappedButton.disabled = forceScrollModePage;\r\n   const isScrollModeHorizontal = mode === ScrollMode.HORIZONTAL;\r\n   buttons.spreadNoneButton.disabled = isScrollModeHorizontal;\r\n   buttons.spreadOddButton.disabled = isScrollModeHorizontal;\r\n   buttons.spreadEvenButton.disabled = isScrollModeHorizontal;\r\n  };\r\n  this.eventBus._on(\"scrollmodechanged\", scrollModeChanged);\r\n  this.eventBus._on(\"secondarytoolbarreset\", evt => {\r\n   if (evt.source === this) {\r\n    scrollModeChanged({ mode: ScrollMode.VERTICAL });\r\n   }\r\n  });\r\n }\r\n _bindSpreadModeListener(buttons) {\r\n  function spreadModeChanged({mode}) {\r\n   buttons.spreadNoneButton.classList.toggle(\"toggled\", mode === SpreadMode.NONE);\r\n   buttons.spreadOddButton.classList.toggle(\"toggled\", mode === SpreadMode.ODD);\r\n   buttons.spreadEvenButton.classList.toggle(\"toggled\", mode === SpreadMode.EVEN);\r\n  }\r\n  this.eventBus._on(\"spreadmodechanged\", spreadModeChanged);\r\n  this.eventBus._on(\"secondarytoolbarreset\", evt => {\r\n   if (evt.source === this) {\r\n    spreadModeChanged({ mode: SpreadMode.NONE });\r\n   }\r\n  });\r\n }\r\n open() {\r\n  if (this.opened) {\r\n   return;\r\n  }\r\n  this.opened = true;\r\n  this._setMaxHeight();\r\n  this.toggleButton.classList.add(\"toggled\");\r\n  this.toggleButton.setAttribute(\"aria-expanded\", \"true\");\r\n  this.toolbar.classList.remove(\"hidden\");\r\n }\r\n close() {\r\n  if (!this.opened) {\r\n   return;\r\n  }\r\n  this.opened = false;\r\n  this.toolbar.classList.add(\"hidden\");\r\n  this.toggleButton.classList.remove(\"toggled\");\r\n  this.toggleButton.setAttribute(\"aria-expanded\", \"false\");\r\n }\r\n toggle() {\r\n  if (this.opened) {\r\n   this.close();\r\n  } else {\r\n   this.open();\r\n  }\r\n }\r\n _setMaxHeight() {\r\n  if (!this.opened) {\r\n   return;\r\n  }\r\n  this.containerHeight = this.mainContainer.clientHeight;\r\n  if (this.containerHeight === this.previousContainerHeight) {\r\n   return;\r\n  }\r\n  this.toolbarButtonContainer.style.maxHeight = `${ this.containerHeight - SCROLLBAR_PADDING }px`;\r\n  this.previousContainerHeight = this.containerHeight;\r\n }\r\n}\r\nexport {\r\n SecondaryToolbar\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst PDF_ROLE_TO_HTML_ROLE = {\r\n Document: null,\r\n DocumentFragment: null,\r\n Part: \"group\",\r\n Sect: \"group\",\r\n Div: \"group\",\r\n Aside: \"note\",\r\n NonStruct: \"none\",\r\n P: null,\r\n H: \"heading\",\r\n Title: null,\r\n FENote: \"note\",\r\n Sub: \"group\",\r\n Lbl: null,\r\n Span: null,\r\n Em: null,\r\n Strong: null,\r\n Link: \"link\",\r\n Annot: \"note\",\r\n Form: \"form\",\r\n Ruby: null,\r\n RB: null,\r\n RT: null,\r\n RP: null,\r\n Warichu: null,\r\n WT: null,\r\n WP: null,\r\n L: \"list\",\r\n LI: \"listitem\",\r\n LBody: null,\r\n Table: \"table\",\r\n TR: \"row\",\r\n TH: \"columnheader\",\r\n TD: \"cell\",\r\n THead: \"columnheader\",\r\n TBody: null,\r\n TFoot: null,\r\n Caption: null,\r\n Figure: \"figure\",\r\n Formula: null,\r\n Artifact: null\r\n};\r\nconst HEADING_PATTERN = /^H(\\d+)$/;\r\nclass StructTreeLayerBuilder {\r\n constructor({pdfPage}) {\r\n  this.pdfPage = pdfPage;\r\n }\r\n render(structTree) {\r\n  return this._walk(structTree);\r\n }\r\n _setAttributes(structElement, htmlElement) {\r\n  if (structElement.alt !== undefined) {\r\n   htmlElement.setAttribute(\"aria-label\", structElement.alt);\r\n  }\r\n  if (structElement.id !== undefined) {\r\n   htmlElement.setAttribute(\"aria-owns\", structElement.id);\r\n  }\r\n  if (structElement.lang !== undefined) {\r\n   htmlElement.setAttribute(\"lang\", structElement.lang);\r\n  }\r\n }\r\n _walk(node) {\r\n  if (!node) {\r\n   return null;\r\n  }\r\n  const element = document.createElement(\"span\");\r\n  if (\"role\" in node) {\r\n   const {role} = node;\r\n   const match = role.match(HEADING_PATTERN);\r\n   if (match) {\r\n    element.setAttribute(\"role\", \"heading\");\r\n    element.setAttribute(\"aria-level\", match[1]);\r\n   } else if (PDF_ROLE_TO_HTML_ROLE[role]) {\r\n    element.setAttribute(\"role\", PDF_ROLE_TO_HTML_ROLE[role]);\r\n   }\r\n  }\r\n  this._setAttributes(node, element);\r\n  if (node.children) {\r\n   if (node.children.length === 1 && \"id\" in node.children[0]) {\r\n    this._setAttributes(node.children[0], element);\r\n   } else {\r\n    for (const kid of node.children) {\r\n     element.appendChild(this._walk(kid));\r\n    }\r\n   }\r\n  }\r\n  return element;\r\n }\r\n}\r\nexport {\r\n StructTreeLayerBuilder\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nclass TextHighlighter {\r\n constructor({findController, eventBus, pageIndex}) {\r\n  this.findController = findController;\r\n  this.matches = [];\r\n  this.eventBus = eventBus;\r\n  this.pageIdx = pageIndex;\r\n  this._onUpdateTextLayerMatches = null;\r\n  this.textDivs = null;\r\n  this.textContentItemsStr = null;\r\n  this.enabled = false;\r\n }\r\n setTextMapping(divs, texts) {\r\n  this.textDivs = divs;\r\n  this.textContentItemsStr = texts;\r\n }\r\n enable() {\r\n  if (!this.textDivs || !this.textContentItemsStr) {\r\n   throw new Error(\"Text divs and strings have not been set.\");\r\n  }\r\n  if (this.enabled) {\r\n   throw new Error(\"TextHighlighter is already enabled.\");\r\n  }\r\n  this.enabled = true;\r\n  if (!this._onUpdateTextLayerMatches) {\r\n   this._onUpdateTextLayerMatches = evt => {\r\n    if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {\r\n     this._updateMatches();\r\n    }\r\n   };\r\n   this.eventBus._on(\"updatetextlayermatches\", this._onUpdateTextLayerMatches);\r\n  }\r\n  this._updateMatches();\r\n }\r\n disable() {\r\n  if (!this.enabled) {\r\n   return;\r\n  }\r\n  this.enabled = false;\r\n  if (this._onUpdateTextLayerMatches) {\r\n   this.eventBus._off(\"updatetextlayermatches\", this._onUpdateTextLayerMatches);\r\n   this._onUpdateTextLayerMatches = null;\r\n  }\r\n }\r\n _convertMatches(matches, matchesLength) {\r\n  if (!matches) {\r\n   return [];\r\n  }\r\n  const {textContentItemsStr} = this;\r\n  let i = 0, iIndex = 0;\r\n  const end = textContentItemsStr.length - 1;\r\n  const result = [];\r\n  for (let m = 0, mm = matches.length; m < mm; m++) {\r\n   let matchIdx = matches[m];\r\n   while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {\r\n    iIndex += textContentItemsStr[i].length;\r\n    i++;\r\n   }\r\n   if (i === textContentItemsStr.length) {\r\n    console.error(\"Could not find a matching mapping\");\r\n   }\r\n   const match = {\r\n    begin: {\r\n     divIdx: i,\r\n     offset: matchIdx - iIndex\r\n    }\r\n   };\r\n   matchIdx += matchesLength[m];\r\n   while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {\r\n    iIndex += textContentItemsStr[i].length;\r\n    i++;\r\n   }\r\n   match.end = {\r\n    divIdx: i,\r\n    offset: matchIdx - iIndex\r\n   };\r\n   result.push(match);\r\n  }\r\n  return result;\r\n }\r\n\r\n _renderMatches(matches) {\r\n  if (matches.length === 0) {\r\n   return;\r\n  }\r\n  const {findController, pageIdx} = this;\r\n  const {textContentItemsStr, textDivs} = this;\r\n  const isSelectedPage = pageIdx === findController.selected.pageIdx;\r\n  const selectedMatchIdx = findController.selected.matchIdx;\r\n  const highlightAll = findController.state.highlightAll;\r\n  let prevEnd = null;\r\n  const infinity = {\r\n   divIdx: -1,\r\n   offset: undefined\r\n  };\r\n  function beginText(begin, className) {\r\n   const divIdx = begin.divIdx;\r\n   textDivs[divIdx].textContent = \"\";\r\n   return appendTextToDiv(divIdx, 0, begin.offset, className);\r\n  }\r\n  function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\r\n   let div = textDivs[divIdx];\r\n   if (div.nodeType === Node.TEXT_NODE) {\r\n    const span = document.createElement(\"span\");\r\n    div.parentNode.insertBefore(span, div);\r\n    span.appendChild(div);\r\n    textDivs[divIdx] = span;\r\n    div = span;\r\n   }\r\n   const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);\r\n   const node = document.createTextNode(content);\r\n   if (className) {\r\n    const span = document.createElement(\"span\");\r\n    span.className = `${ className } appended`;\r\n    span.appendChild(node);\r\n    div.appendChild(span);\r\n    return className.includes(\"selected\") ? span.offsetLeft : 0;\r\n   }\r\n   div.appendChild(node);\r\n   return 0;\r\n  }\r\n  let i0 = selectedMatchIdx, i1 = i0 + 1;\r\n  if (highlightAll) {\r\n   i0 = 0;\r\n   i1 = matches.length;\r\n  } else if (!isSelectedPage) {\r\n   return;\r\n  }\r\n  for (let i = i0; i < i1; i++) {\r\n   const match = matches[i];\r\n   const begin = match.begin;\r\n   const end = match.end;\r\n   const isSelected = isSelectedPage && i === selectedMatchIdx;\r\n   const highlightSuffix = isSelected ? \" selected\" : \"\";\r\n   let selectedLeft = 0;\r\n   if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\r\n    if (prevEnd !== null) {\r\n     appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\r\n    }\r\n    beginText(begin);\r\n   } else {\r\n    appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\r\n   }\r\n   if (begin.divIdx === end.divIdx) {\r\n    selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, \"highlight\" + highlightSuffix);\r\n   } else {\r\n    selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, \"highlight begin\" + highlightSuffix);\r\n    for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\r\n     textDivs[n0].className = \"highlight middle\" + highlightSuffix;\r\n    }\r\n    beginText(end, \"highlight end\" + highlightSuffix);\r\n   }\r\n   prevEnd = end;\r\n   if (isSelected) {\r\n    findController.scrollMatchIntoView({\r\n     element: textDivs[begin.divIdx],\r\n     selectedLeft,\r\n     pageIndex: pageIdx,\r\n     matchIndex: selectedMatchIdx\r\n    });\r\n   }\r\n  }\r\n  if (prevEnd) {\r\n   appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\r\n  }\r\n }\r\n\r\n\r\n _updateMatches() {\r\n  if (!this.enabled) {\r\n   return;\r\n  }\r\n  const {findController, matches, pageIdx} = this;\r\n  const {textContentItemsStr, textDivs} = this;\r\n  let clearedUntilDivIdx = -1;\r\n  for (let i = 0, ii = matches.length; i < ii; i++) {\r\n   const match = matches[i];\r\n   const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);\r\n   for (let n = begin, end = match.end.divIdx; n <= end; n++) {\r\n    const div = textDivs[n];\r\n    div.textContent = textContentItemsStr[n];\r\n    div.className = \"\";\r\n   }\r\n   clearedUntilDivIdx = match.end.divIdx + 1;\r\n  }\r\n  if (!findController?.highlightMatches) {\r\n   return;\r\n  }\r\n  const pageMatches = findController.pageMatches[pageIdx] || null;\r\n  const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;\r\n  this.matches = this._convertMatches(pageMatches, pageMatchesLength);\r\n  this._renderMatches(this.matches);\r\n }\r\n\r\n _moveToHere(selectedMatchIdx) {\r\n    const matches = this.matches;\r\n    const {findController, pageIdx} = this;\r\n    const {textContentItemsStr, textDivs} = this;\r\n    const isSelectedPage = true;\r\n    const highlightAll = false;\r\n    let prevEnd = null;\r\n    const infinity = {\r\n     divIdx: -1,\r\n     offset: undefined\r\n    };\r\n    function beginText(begin, className) {\r\n     const divIdx = begin.divIdx;\r\n     textDivs[divIdx].textContent = \"\";\r\n     return appendTextToDiv(divIdx, 0, begin.offset, className);\r\n    }\r\n    function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\r\n     let div = textDivs[divIdx];\r\n     if (div.nodeType === Node.TEXT_NODE) {\r\n      const span = document.createElement(\"span\");\r\n      div.parentNode.insertBefore(span, div);\r\n      span.appendChild(div);\r\n      textDivs[divIdx] = span;\r\n      div = span;\r\n     }\r\n     const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);\r\n     const node = document.createTextNode(content);\r\n     if (className) {\r\n      const span = document.createElement(\"span\");\r\n      span.className = `${ className } appended`;\r\n      span.appendChild(node);\r\n      div.appendChild(span);\r\n      return className.includes(\"selected\") ? span.offsetLeft : 0;\r\n     }\r\n     div.appendChild(node);\r\n     return 0;\r\n    }\r\n    let i0 = selectedMatchIdx, i1 = i0 + 1;\r\n\r\n     const match = matches[selectedMatchIdx];\r\n     const begin = match.begin;\r\n     const end = match.end;\r\n     const isSelected = true;\r\n     const highlightSuffix = isSelected ? \" selected\" : \"\";\r\n     let selectedLeft = 0;\r\n     if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\r\n      if (prevEnd !== null) {\r\n       appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\r\n      }\r\n      beginText(begin);\r\n     } else {\r\n      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\r\n     }\r\n     if (begin.divIdx === end.divIdx) {\r\n      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, \"highlight\" + highlightSuffix);\r\n     } else {\r\n      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, \"highlight begin\" + highlightSuffix);\r\n      for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\r\n       textDivs[n0].className = \"highlight middle\" + highlightSuffix;\r\n      }\r\n      beginText(end, \"highlight end\" + highlightSuffix);\r\n     }\r\n     prevEnd = end;\r\n     if (isSelected) {\r\n      findController.whatEverScrollMatchIntoView({\r\n       element: textDivs[begin.divIdx],\r\n       selectedLeft,\r\n       pageIndex: pageIdx,\r\n       matchIndex: selectedMatchIdx\r\n      });\r\n     }\r\n    if (prevEnd) {\r\n     appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\r\n    }\r\n   }\r\n \r\n}\r\nexport {\r\n TextHighlighter\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {renderTextLayer} = require(\"pdfjs-dist\");\r\nconst EXPAND_DIVS_TIMEOUT = 300;\r\nclass TextLayerBuilder {\r\n constructor({textLayerDiv, eventBus, pageIndex, viewport, highlighter = null, enhanceTextSelection = false}) {\r\n  this.textLayerDiv = textLayerDiv;\r\n  this.eventBus = eventBus;\r\n  this.textContent = null;\r\n  this.textContentItemsStr = [];\r\n  this.textContentStream = null;\r\n  this.renderingDone = false;\r\n  this.pageNumber = pageIndex + 1;\r\n  this.viewport = viewport;\r\n  this.textDivs = [];\r\n  this.textLayerRenderTask = null;\r\n  this.highlighter = highlighter;\r\n  this.enhanceTextSelection = enhanceTextSelection;\r\n  this._bindMouse();\r\n }\r\n _finishRendering() {\r\n  this.renderingDone = true;\r\n  if (!this.enhanceTextSelection) {\r\n   const endOfContent = document.createElement(\"div\");\r\n   endOfContent.className = \"endOfContent\";\r\n   this.textLayerDiv.appendChild(endOfContent);\r\n  }\r\n  this.eventBus.dispatch(\"textlayerrendered\", {\r\n   source: this,\r\n   pageNumber: this.pageNumber,\r\n   numTextDivs: this.textDivs.length\r\n  });\r\n }\r\n render(timeout = 0) {\r\n  if (!(this.textContent || this.textContentStream) || this.renderingDone) {\r\n   return;\r\n  }\r\n  this.cancel();\r\n  this.textDivs.length = 0;\r\n  this.highlighter?.setTextMapping(this.textDivs, this.textContentItemsStr);\r\n  const textLayerFrag = document.createDocumentFragment();\r\n  this.textLayerRenderTask = renderTextLayer({\r\n   textContent: this.textContent,\r\n   textContentStream: this.textContentStream,\r\n   container: textLayerFrag,\r\n   viewport: this.viewport,\r\n   textDivs: this.textDivs,\r\n   textContentItemsStr: this.textContentItemsStr,\r\n   timeout,\r\n   enhanceTextSelection: this.enhanceTextSelection\r\n  });\r\n  this.textLayerRenderTask.promise.then(() => {\r\n   this.textLayerDiv.appendChild(textLayerFrag);\r\n   this._finishRendering();\r\n   this.highlighter?.enable();\r\n  }, function (reason) {\r\n  });\r\n }\r\n cancel() {\r\n  if (this.textLayerRenderTask) {\r\n   this.textLayerRenderTask.cancel();\r\n   this.textLayerRenderTask = null;\r\n  }\r\n  this.highlighter?.disable();\r\n }\r\n setTextContentStream(readableStream) {\r\n  this.cancel();\r\n  this.textContentStream = readableStream;\r\n }\r\n setTextContent(textContent) {\r\n  this.cancel();\r\n  this.textContent = textContent;\r\n }\r\n _bindMouse() {\r\n  const div = this.textLayerDiv;\r\n  let expandDivsTimer = null;\r\n  div.addEventListener(\"mousedown\", evt => {\r\n   if (this.enhanceTextSelection && this.textLayerRenderTask) {\r\n    this.textLayerRenderTask.expandTextDivs(true);\r\n    if (expandDivsTimer) {\r\n     clearTimeout(expandDivsTimer);\r\n     expandDivsTimer = null;\r\n    }\r\n    return;\r\n   }\r\n   const end = div.querySelector(\".endOfContent\");\r\n   if (!end) {\r\n    return;\r\n   }\r\n   let adjustTop = evt.target !== div;\r\n   adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue(\"-moz-user-select\") !== \"none\";\r\n   if (adjustTop) {\r\n    const divBounds = div.getBoundingClientRect();\r\n    const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);\r\n    end.style.top = (r * 100).toFixed(2) + \"%\";\r\n   }\r\n   end.classList.add(\"active\");\r\n  });\r\n  div.addEventListener(\"mouseup\", () => {\r\n   if (this.enhanceTextSelection && this.textLayerRenderTask) {\r\n    expandDivsTimer = setTimeout(() => {\r\n     if (this.textLayerRenderTask) {\r\n      this.textLayerRenderTask.expandTextDivs(false);\r\n     }\r\n     expandDivsTimer = null;\r\n    }, EXPAND_DIVS_TIMEOUT);\r\n    return;\r\n   }\r\n   const end = div.querySelector(\".endOfContent\");\r\n   if (!end) {\r\n    return;\r\n   }\r\n   end.style.top = \"\";\r\n   end.classList.remove(\"active\");\r\n  });\r\n }\r\n}\r\nexport {\r\n TextLayerBuilder\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {animationStarted, DEFAULT_SCALE, DEFAULT_SCALE_VALUE, MAX_SCALE, MIN_SCALE, noContextMenuHandler} = require(\"./ui_utils.js\");\r\nconst PAGE_NUMBER_LOADING_INDICATOR = \"visiblePageIsLoading\";\r\nclass Toolbar {\r\n constructor(options, eventBus, l10n) {\r\n  this.toolbar = options.container;\r\n  this.eventBus = eventBus;\r\n  this.l10n = l10n;\r\n  this.buttons = [\r\n   {\r\n    element: options.previous,\r\n    eventName: \"previouspage\"\r\n   },\r\n   {\r\n    element: options.next,\r\n    eventName: \"nextpage\"\r\n   },\r\n   {\r\n    element: options.zoomIn,\r\n    eventName: \"zoomin\"\r\n   },\r\n   {\r\n    element: options.zoomOut,\r\n    eventName: \"zoomout\"\r\n   },\r\n   {\r\n    element: options.openFile,\r\n    eventName: \"openfile\"\r\n   },\r\n   {\r\n    element: options.print,\r\n    eventName: \"print\"\r\n   },\r\n   {\r\n    element: options.download,\r\n    eventName: \"download\"\r\n   },\r\n   {\r\n    element: options.viewBookmark,\r\n    eventName: null\r\n   }\r\n  ];\r\n  this.items = {\r\n   numPages: options.numPages,\r\n   pageNumber: options.pageNumber,\r\n   scaleSelect: options.scaleSelect,\r\n   scaleSelectOptions:options.scaleSelectOptions,\r\n   scaleSelectShowOptionsButton:options.scaleSelectShowOptionsButton,\r\n   previous: options.previous,\r\n   next: options.next,\r\n   zoomIn: options.zoomIn,\r\n   zoomOut: options.zoomOut\r\n  };\r\n  this._wasLocalized = false;\r\n  this.reset();\r\n  this._bindListeners();\r\n }\r\n setPageNumber(pageNumber, pageLabel) {\r\n  this.pageNumber = pageNumber;\r\n  this.pageLabel = pageLabel;\r\n  this._updateUIState(false);\r\n }\r\n setPagesCount(pagesCount, hasPageLabels) {\r\n  this.pagesCount = pagesCount;\r\n  this.hasPageLabels = hasPageLabels;\r\n  this._updateUIState(true);\r\n }\r\n setPageScale(pageScaleValue, pageScale) {\r\n  this.pageScaleValue = (pageScaleValue || pageScale).toString();\r\n  this.pageScale = pageScale;\r\n  this._updateUIState(false);\r\n }\r\n reset() {\r\n  this.pageNumber = 0;\r\n  this.pageLabel = null;\r\n  this.hasPageLabels = false;\r\n  this.pagesCount = 0;\r\n  this.pageScaleValue = DEFAULT_SCALE_VALUE;\r\n  this.pageScale = DEFAULT_SCALE;\r\n  this._updateUIState(true);\r\n  this.updateLoadingIndicatorState();\r\n }\r\n _bindListeners() {\r\n  const {pageNumber, scaleSelect,scaleSelectOptions,scaleSelectShowOptionsButton} = this.items;\r\n  const self = this;\r\n  for (const {element, eventName} of this.buttons) {\r\n   element.addEventListener(\"click\", evt => {\r\n    if (eventName !== null) {\r\n     this.eventBus.dispatch(eventName, { source: this });\r\n    }\r\n   });\r\n  }\r\n\r\n  pageNumber.addEventListener(\"click\", function () {\r\n   this.select();\r\n  });\r\n  pageNumber.addEventListener(\"change\", function () {\r\n   self.eventBus.dispatch(\"pagenumberchanged\", {\r\n    source: self,\r\n    value: parseInt(this.value)\r\n   });\r\n  });\r\n\r\n  const scaleOptionBtns=Array.from(scaleSelectOptions.children).filter((ele)=>{\r\n      return ele.tagName=='BUTTON';\r\n  })\r\n\r\n  for(const ele of scaleOptionBtns){\r\n    ele.addEventListener('click',function(){\r\n        if (ele.ariaLabel === \"custom\") {\r\n            return;\r\n           }\r\n           let disPatchValue = ele.ariaLabel;\r\n           if(!isNaN(parseInt(ele.ariaLabel))){\r\n            disPatchValue = parseInt(ele.ariaLabel)/100\r\n           }\r\n           self.eventBus.dispatch(\"scalechanged\", {\r\n            source: self,\r\n            value: disPatchValue\r\n           });\r\n           Array.from(scaleSelectOptions.children).forEach((e)=>{\r\n            e.classList.remove('selected');\r\n        });\r\n\r\n           ele.classList.add(\"selected\");\r\n           scaleSelect.value=ele.ariaLabel;\r\n           scaleSelectOptions.classList.add('closed');\r\n    })\r\n  }\r\n  scaleSelect.addEventListener(\"change\", function () {\r\n   if (this.value === \"custom\") {\r\n    return;\r\n   }\r\n   let disPatchValue = this.value;\r\n   if(!isNaN(parseInt(this.value))){\r\n    disPatchValue = parseInt(this.value)/100\r\n   }\r\n   self.eventBus.dispatch(\"scalechanged\", {\r\n    source: self,\r\n    value: disPatchValue\r\n   });\r\n  });\r\n  scaleSelectShowOptionsButton.addEventListener('click',()=>{\r\n      if(scaleSelectOptions.classList.contains('closed')){\r\n        scaleSelectOptions.classList.remove('closed');\r\n      }else{\r\n        scaleSelectOptions.classList.add('closed');\r\n      }\r\n    \r\n  })\r\n  scaleSelect.addEventListener(\"click\", function (evt) {\r\n   const target = evt.target;\r\n   if (this.value === self.pageScaleValue && target.tagName.toUpperCase() === \"OPTION\") {\r\n    this.blur();\r\n   }\r\n  });\r\n  scaleSelect.oncontextmenu = noContextMenuHandler;\r\n  this.eventBus._on(\"localized\", () => {\r\n   this._wasLocalized = true;\r\n   this._adjustScaleWidth();\r\n   this._updateUIState(true);\r\n  });\r\n }\r\n _updateUIState(resetNumPages = false) {\r\n  if (!this._wasLocalized) {\r\n   return;\r\n  }\r\n  const {pageNumber, pagesCount, pageScaleValue, pageScale, items} = this;\r\n  if (resetNumPages) {\r\n   if (this.hasPageLabels) {\r\n    items.pageNumber.type = \"text\";\r\n   } else {\r\n    items.pageNumber.type = \"text\";\r\n    this.l10n.get(\"of_pages\", { pagesCount }).then(msg => {\r\n     items.numPages.textContent = msg;\r\n    });\r\n   }\r\n\r\n   items.pageNumber.max = pagesCount;\r\n  }\r\n  if (this.hasPageLabels) {\r\n   items.pageNumber.value = this.pageLabel;\r\n   this.l10n.get(\"page_of_pages\", {\r\n    pageNumber,\r\n    pagesCount\r\n   }).then(msg => {\r\n    items.numPages.textContent = msg;\r\n   });\r\n  } else {\r\n   items.pageNumber.value = pageNumber;\r\n  }\r\n  items.previous.disabled = pageNumber <= 1;\r\n  items.next.disabled = pageNumber >= pagesCount;\r\n  items.zoomOut.disabled = pageScale <= MIN_SCALE;\r\n  items.zoomIn.disabled = pageScale >= MAX_SCALE;\r\n  let predefinedValueFound = false;\r\n\r\n\r\n  this.l10n.get(\"page_scale_percent\", { scale: Math.round(pageScale * 10000) / 100 }).then(msg => {\r\n    let predefinedValueFound = false;\r\n    for (const option of items.scaleSelect.children) {\r\n        if (parseInt(option.ariaLabel)/100 !== pageScaleValue) {\r\n            option.classList.remove('selected');\r\n            continue;\r\n           }\r\n           option.classList.add('selected');\r\n     predefinedValueFound = true;\r\n    }\r\n    if (!predefinedValueFound) {\r\n     scaleSelect.value = Math.round(pageScale * 10000) / 100;\r\n    }\r\n   });\r\n }\r\n updateLoadingIndicatorState(loading = false) {\r\n  const pageNumberInput = this.items.pageNumber;\r\n  pageNumberInput.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading);\r\n }\r\n async _adjustScaleWidth() {\r\n  const {items, l10n} = this;\r\n  const predefinedValuesPromise = Promise.all([\r\n   l10n.get(\"page_scale_auto\"),\r\n   l10n.get(\"page_scale_actual\"),\r\n   l10n.get(\"page_scale_fit\"),\r\n   l10n.get(\"page_scale_width\")\r\n  ]);\r\n  const style = getComputedStyle(items.scaleSelect), scaleSelectContainerWidth = parseInt(style.getPropertyValue(\"--scale-select-container-width\"), 10), scaleSelectOverflow = parseInt(style.getPropertyValue(\"--scale-select-overflow\"), 10);\r\n  let canvas = document.createElement(\"canvas\");\r\n  canvas.mozOpaque = true;\r\n  let ctx = canvas.getContext(\"2d\", { alpha: false });\r\n  await animationStarted;\r\n  ctx.font = `${ style.fontSize } ${ style.fontFamily }`;\r\n  let maxWidth = 0;\r\n  for (const predefinedValue of await predefinedValuesPromise) {\r\n   const {width} = ctx.measureText(predefinedValue);\r\n   if (width > maxWidth) {\r\n    maxWidth = width;\r\n   }\r\n  }\r\n  maxWidth += 2 * scaleSelectOverflow;\r\n  if (maxWidth > scaleSelectContainerWidth) {\r\n   const doc = document.documentElement;\r\n   doc.style.setProperty(\"--scale-select-container-width\", `${ maxWidth }px`);\r\n  }\r\n  canvas.width = 0;\r\n  canvas.height = 0;\r\n  canvas = ctx = null;\r\n }\r\n}\r\nexport {\r\n Toolbar\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst DEFAULT_SCALE_VALUE = \"auto\";\r\nconst DEFAULT_SCALE = 1.0;\r\nconst DEFAULT_SCALE_DELTA = 1.1;\r\nconst MIN_SCALE = 0.1;\r\nconst MAX_SCALE = 10.0;\r\nconst UNKNOWN_SCALE = 0;\r\nconst MAX_AUTO_SCALE = 1.25;\r\nconst SCROLLBAR_PADDING = 40;\r\nconst VERTICAL_PADDING = 5;\r\nconst LOADINGBAR_END_OFFSET_VAR = \"--loadingBar-end-offset\";\r\nconst RenderingStates = {\r\n INITIAL: 0,\r\n RUNNING: 1,\r\n PAUSED: 2,\r\n FINISHED: 3\r\n};\r\nconst SidebarView = {\r\n UNKNOWN: -1,\r\n NONE: 0,\r\n THUMBS: 1,\r\n OUTLINE: 2,\r\n ATTACHMENTS: 3,\r\n LAYERS: 4\r\n};\r\nconst RendererType = {\r\n CANVAS: \"canvas\",\r\n SVG: \"svg\"\r\n};\r\nconst TextLayerMode = {\r\n DISABLE: 0,\r\n ENABLE: 1,\r\n ENABLE_ENHANCE: 2\r\n};\r\nconst ScrollMode = {\r\n UNKNOWN: -1,\r\n VERTICAL: 0,\r\n HORIZONTAL: 1,\r\n WRAPPED: 2,\r\n PAGE: 3\r\n};\r\nconst SpreadMode = {\r\n UNKNOWN: -1,\r\n NONE: 0,\r\n ODD: 1,\r\n EVEN: 2\r\n};\r\nconst AutoPrintRegExp = /\\bprint\\s*\\(/;\r\nfunction getOutputScale(ctx) {\r\n const devicePixelRatio = window.devicePixelRatio || 1;\r\n const backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\r\n const pixelRatio = devicePixelRatio / backingStoreRatio;\r\n return {\r\n  sx: pixelRatio,\r\n  sy: pixelRatio,\r\n  scaled: pixelRatio !== 1\r\n };\r\n}\r\nfunction scrollIntoView(element, spot, scrollMatches = false) {\r\n let parent = element.offsetParent;\r\n if (!parent) {\r\n  console.error(\"offsetParent is not set -- cannot scroll\");\r\n  return;\r\n }\r\n let offsetY = element.offsetTop + element.clientTop;\r\n let offsetX = element.offsetLeft + element.clientLeft;\r\n while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains(\"markedContent\") || getComputedStyle(parent).overflow === \"hidden\")) {\r\n  offsetY += parent.offsetTop;\r\n  offsetX += parent.offsetLeft;\r\n  parent = parent.offsetParent;\r\n  if (!parent) {\r\n   return;\r\n  }\r\n }\r\n if (spot) {\r\n  if (spot.top !== undefined) {\r\n   offsetY += spot.top;\r\n  }\r\n  if (spot.left !== undefined) {\r\n   offsetX += spot.left;\r\n   parent.scrollLeft = offsetX;\r\n  }\r\n }\r\n parent.scrollTop = offsetY;\r\n}\r\nfunction watchScroll(viewAreaElement, callback) {\r\n const debounceScroll = function (evt) {\r\n  if (rAF) {\r\n   return;\r\n  }\r\n  rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {\r\n   rAF = null;\r\n   const currentX = viewAreaElement.scrollLeft;\r\n   const lastX = state.lastX;\r\n   if (currentX !== lastX) {\r\n    state.right = currentX > lastX;\r\n   }\r\n   state.lastX = currentX;\r\n   const currentY = viewAreaElement.scrollTop;\r\n   const lastY = state.lastY;\r\n   if (currentY !== lastY) {\r\n    state.down = currentY > lastY;\r\n   }\r\n   state.lastY = currentY;\r\n   callback(state);\r\n  });\r\n };\r\n const state = {\r\n  right: true,\r\n  down: true,\r\n  lastX: viewAreaElement.scrollLeft,\r\n  lastY: viewAreaElement.scrollTop,\r\n  _eventHandler: debounceScroll\r\n };\r\n let rAF = null;\r\n viewAreaElement.addEventListener(\"scroll\", debounceScroll, true);\r\n return state;\r\n}\r\nfunction parseQueryString(query) {\r\n const params = new Map();\r\n for (const [key, value] of new URLSearchParams(query)) {\r\n  params.set(key.toLowerCase(), value);\r\n }\r\n return params;\r\n}\r\nconst NullCharactersRegExp = /\\x00/g;\r\nconst InvisibleCharactersRegExp = /[\\x01-\\x1F]/g;\r\nfunction removeNullCharacters(str, replaceInvisible = false) {\r\n if (typeof str !== \"string\") {\r\n  console.error(`The argument must be a string.`);\r\n  return str;\r\n }\r\n if (replaceInvisible) {\r\n  str = str.replace(InvisibleCharactersRegExp, \" \");\r\n }\r\n return str.replace(NullCharactersRegExp, \"\");\r\n}\r\nfunction binarySearchFirstItem(items, condition, start = 0) {\r\n let minIndex = start;\r\n let maxIndex = items.length - 1;\r\n if (maxIndex < 0 || !condition(items[maxIndex])) {\r\n  return items.length;\r\n }\r\n if (condition(items[minIndex])) {\r\n  return minIndex;\r\n }\r\n while (minIndex < maxIndex) {\r\n  const currentIndex = minIndex + maxIndex >> 1;\r\n  const currentItem = items[currentIndex];\r\n  if (condition(currentItem)) {\r\n   maxIndex = currentIndex;\r\n  } else {\r\n   minIndex = currentIndex + 1;\r\n  }\r\n }\r\n return minIndex;\r\n}\r\nfunction approximateFraction(x) {\r\n if (Math.floor(x) === x) {\r\n  return [\r\n   x,\r\n   1\r\n  ];\r\n }\r\n const xinv = 1 / x;\r\n const limit = 8;\r\n if (xinv > limit) {\r\n  return [\r\n   1,\r\n   limit\r\n  ];\r\n } else if (Math.floor(xinv) === xinv) {\r\n  return [\r\n   1,\r\n   xinv\r\n  ];\r\n }\r\n const x_ = x > 1 ? xinv : x;\r\n let a = 0, b = 1, c = 1, d = 1;\r\n while (true) {\r\n  const p = a + c, q = b + d;\r\n  if (q > limit) {\r\n   break;\r\n  }\r\n  if (x_ <= p / q) {\r\n   c = p;\r\n   d = q;\r\n  } else {\r\n   a = p;\r\n   b = q;\r\n  }\r\n }\r\n let result;\r\n if (x_ - a / b < c / d - x_) {\r\n  result = x_ === x ? [\r\n   a,\r\n   b\r\n  ] : [\r\n   b,\r\n   a\r\n  ];\r\n } else {\r\n  result = x_ === x ? [\r\n   c,\r\n   d\r\n  ] : [\r\n   d,\r\n   c\r\n  ];\r\n }\r\n return result;\r\n}\r\nfunction roundToDivide(x, div) {\r\n const r = x % div;\r\n return r === 0 ? x : Math.round(x - r + div);\r\n}\r\nfunction getPageSizeInches({view, userUnit, rotate}) {\r\n const [x1, y1, x2, y2] = view;\r\n const changeOrientation = rotate % 180 !== 0;\r\n const width = (x2 - x1) / 72 * userUnit;\r\n const height = (y2 - y1) / 72 * userUnit;\r\n return {\r\n  width: changeOrientation ? height : width,\r\n  height: changeOrientation ? width : height\r\n };\r\n}\r\nfunction backtrackBeforeAllVisibleElements(index, views, top) {\r\n if (index < 2) {\r\n  return index;\r\n }\r\n let elt = views[index].div;\r\n let pageTop = elt.offsetTop + elt.clientTop;\r\n if (pageTop >= top) {\r\n  elt = views[index - 1].div;\r\n  pageTop = elt.offsetTop + elt.clientTop;\r\n }\r\n for (let i = index - 2; i >= 0; --i) {\r\n  elt = views[i].div;\r\n  if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {\r\n   break;\r\n  }\r\n  index = i;\r\n }\r\n return index;\r\n}\r\nfunction getVisibleElements({scrollEl, views, sortByVisibility = false, horizontal = false, rtl = false}) {\r\n const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;\r\n const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;\r\n function isElementBottomAfterViewTop(view) {\r\n  const element = view.div;\r\n  const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;\r\n  return elementBottom > top;\r\n }\r\n function isElementNextAfterViewHorizontally(view) {\r\n  const element = view.div;\r\n  const elementLeft = element.offsetLeft + element.clientLeft;\r\n  const elementRight = elementLeft + element.clientWidth;\r\n  return rtl ? elementLeft < right : elementRight > left;\r\n }\r\n const visible = [], ids = new Set(), numViews = views.length;\r\n let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);\r\n if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {\r\n  firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);\r\n }\r\n let lastEdge = horizontal ? right : -1;\r\n for (let i = firstVisibleElementInd; i < numViews; i++) {\r\n  const view = views[i], element = view.div;\r\n  const currentWidth = element.offsetLeft + element.clientLeft;\r\n  const currentHeight = element.offsetTop + element.clientTop;\r\n  const viewWidth = element.clientWidth, viewHeight = element.clientHeight;\r\n  const viewRight = currentWidth + viewWidth;\r\n  const viewBottom = currentHeight + viewHeight;\r\n  if (lastEdge === -1) {\r\n   if (viewBottom >= bottom) {\r\n    lastEdge = viewBottom;\r\n   }\r\n  } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {\r\n   break;\r\n  }\r\n  if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {\r\n   continue;\r\n  }\r\n  const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);\r\n  const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);\r\n  const fractionHeight = (viewHeight - hiddenHeight) / viewHeight, fractionWidth = (viewWidth - hiddenWidth) / viewWidth;\r\n  const percent = fractionHeight * fractionWidth * 100 | 0;\r\n  visible.push({\r\n   id: view.id,\r\n   x: currentWidth,\r\n   y: currentHeight,\r\n   view,\r\n   percent,\r\n   widthPercent: fractionWidth * 100 | 0\r\n  });\r\n  ids.add(view.id);\r\n }\r\n const first = visible[0], last = visible[visible.length - 1];\r\n if (sortByVisibility) {\r\n  visible.sort(function (a, b) {\r\n   const pc = a.percent - b.percent;\r\n   if (Math.abs(pc) > 0.001) {\r\n    return -pc;\r\n   }\r\n   return a.id - b.id;\r\n  });\r\n }\r\n return {\r\n  first,\r\n  last,\r\n  views: visible,\r\n  ids\r\n };\r\n}\r\nfunction noContextMenuHandler(evt) {\r\n evt.preventDefault();\r\n}\r\nfunction normalizeWheelEventDirection(evt) {\r\n let delta = Math.hypot(evt.deltaX, evt.deltaY);\r\n const angle = Math.atan2(evt.deltaY, evt.deltaX);\r\n if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {\r\n  delta = -delta;\r\n }\r\n return delta;\r\n}\r\nfunction normalizeWheelEventDelta(evt) {\r\n let delta = normalizeWheelEventDirection(evt);\r\n const MOUSE_DOM_DELTA_PIXEL_MODE = 0;\r\n const MOUSE_DOM_DELTA_LINE_MODE = 1;\r\n const MOUSE_PIXELS_PER_LINE = 30;\r\n const MOUSE_LINES_PER_PAGE = 30;\r\n if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {\r\n  delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;\r\n } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {\r\n  delta /= MOUSE_LINES_PER_PAGE;\r\n }\r\n return delta;\r\n}\r\nfunction isValidRotation(angle) {\r\n return Number.isInteger(angle) && angle % 90 === 0;\r\n}\r\nfunction isValidScrollMode(mode) {\r\n return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;\r\n}\r\nfunction isValidSpreadMode(mode) {\r\n return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;\r\n}\r\nfunction isPortraitOrientation(size) {\r\n return size.width <= size.height;\r\n}\r\nconst animationStarted = new Promise(function (resolve) {\r\n if (typeof window === \"undefined\") {\r\n  setTimeout(resolve, 20);\r\n  return;\r\n }\r\n window.requestAnimationFrame(resolve);\r\n});\r\nfunction clamp(v, min, max) {\r\n return Math.min(Math.max(v, min), max);\r\n}\r\nclass ProgressBar {\r\n constructor(id, {height, width, units} = {}) {\r\n  this.visible = true;\r\n  this.div = document.querySelector(id + \" .progress\");\r\n  this.bar = this.div.parentNode;\r\n  this.height = height || 100;\r\n  this.width = width || 100;\r\n  this.units = units || \"%\";\r\n  this.div.style.height = this.height + this.units;\r\n  this.percent = 0;\r\n }\r\n _updateBar() {\r\n  if (this._indeterminate) {\r\n   this.div.classList.add(\"indeterminate\");\r\n   this.div.style.width = this.width + this.units;\r\n   return;\r\n  }\r\n  this.div.classList.remove(\"indeterminate\");\r\n  const progressSize = this.width * this._percent / 100;\r\n  this.div.style.width = progressSize + this.units;\r\n }\r\n get percent() {\r\n  return this._percent;\r\n }\r\n set percent(val) {\r\n  this._indeterminate = isNaN(val);\r\n  this._percent = clamp(val, 0, 100);\r\n  this._updateBar();\r\n }\r\n setWidth(viewer) {\r\n  if (!viewer) {\r\n   return;\r\n  }\r\n  const container = viewer.parentNode;\r\n  const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;\r\n  if (scrollbarWidth > 0) {\r\n   const doc = document.documentElement;\r\n   doc.style.setProperty(LOADINGBAR_END_OFFSET_VAR, `${ scrollbarWidth }px`);\r\n  }\r\n }\r\n hide() {\r\n  if (!this.visible) {\r\n   return;\r\n  }\r\n  this.visible = false;\r\n  this.bar.classList.add(\"hidden\");\r\n }\r\n show() {\r\n  if (this.visible) {\r\n   return;\r\n  }\r\n  this.visible = true;\r\n  this.bar.classList.remove(\"hidden\");\r\n }\r\n}\r\nfunction getActiveOrFocusedElement() {\r\n let curRoot = document;\r\n let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(\":focus\");\r\n while (curActiveOrFocused?.shadowRoot) {\r\n  curRoot = curActiveOrFocused.shadowRoot;\r\n  curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(\":focus\");\r\n }\r\n return curActiveOrFocused;\r\n}\r\nfunction apiPageLayoutToViewerModes(layout) {\r\n let scrollMode = ScrollMode.VERTICAL, spreadMode = SpreadMode.NONE;\r\n switch (layout) {\r\n case \"SinglePage\":\r\n  scrollMode = ScrollMode.PAGE;\r\n  break;\r\n case \"OneColumn\":\r\n  break;\r\n case \"TwoPageLeft\":\r\n  scrollMode = ScrollMode.PAGE;\r\n case \"TwoColumnLeft\":\r\n  spreadMode = SpreadMode.ODD;\r\n  break;\r\n case \"TwoPageRight\":\r\n  scrollMode = ScrollMode.PAGE;\r\n case \"TwoColumnRight\":\r\n  spreadMode = SpreadMode.EVEN;\r\n  break;\r\n }\r\n return {\r\n  scrollMode,\r\n  spreadMode\r\n };\r\n}\r\nfunction apiPageModeToSidebarView(mode) {\r\n switch (mode) {\r\n case \"UseNone\":\r\n  return SidebarView.NONE;\r\n case \"UseThumbs\":\r\n  return SidebarView.THUMBS;\r\n case \"UseOutlines\":\r\n  return SidebarView.OUTLINE;\r\n case \"UseAttachments\":\r\n  return SidebarView.ATTACHMENTS;\r\n case \"UseOC\":\r\n  return SidebarView.LAYERS;\r\n }\r\n return SidebarView.NONE;\r\n}\r\nexport {\r\n animationStarted,\r\n apiPageLayoutToViewerModes,\r\n apiPageModeToSidebarView,\r\n approximateFraction,\r\n AutoPrintRegExp,\r\n backtrackBeforeAllVisibleElements,\r\n binarySearchFirstItem,\r\n DEFAULT_SCALE,\r\n DEFAULT_SCALE_DELTA,\r\n DEFAULT_SCALE_VALUE,\r\n getActiveOrFocusedElement,\r\n getOutputScale,\r\n getPageSizeInches,\r\n getVisibleElements,\r\n isPortraitOrientation,\r\n isValidRotation,\r\n isValidScrollMode,\r\n isValidSpreadMode,\r\n MAX_AUTO_SCALE,\r\n MAX_SCALE,\r\n MIN_SCALE,\r\n noContextMenuHandler,\r\n normalizeWheelEventDelta,\r\n normalizeWheelEventDirection,\r\n parseQueryString,\r\n ProgressBar,\r\n removeNullCharacters,\r\n RendererType,\r\n RenderingStates,\r\n roundToDivide,\r\n SCROLLBAR_PADDING,\r\n scrollIntoView,\r\n ScrollMode,\r\n SidebarView,\r\n SpreadMode,\r\n TextLayerMode,\r\n UNKNOWN_SCALE,\r\n VERTICAL_PADDING,\r\n watchScroll\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20;\r\nclass ViewHistory {\r\n constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) {\r\n  this.fingerprint = fingerprint;\r\n  this.cacheSize = cacheSize;\r\n  this._initializedPromise = this._readFromStorage().then(databaseStr => {\r\n   const database = JSON.parse(databaseStr || \"{}\");\r\n   let index = -1;\r\n   if (!Array.isArray(database.files)) {\r\n    database.files = [];\r\n   } else {\r\n    while (database.files.length >= this.cacheSize) {\r\n     database.files.shift();\r\n    }\r\n    for (let i = 0, ii = database.files.length; i < ii; i++) {\r\n     const branch = database.files[i];\r\n     if (branch.fingerprint === this.fingerprint) {\r\n      index = i;\r\n      break;\r\n     }\r\n    }\r\n   }\r\n   if (index === -1) {\r\n    index = database.files.push({ fingerprint: this.fingerprint }) - 1;\r\n   }\r\n   this.file = database.files[index];\r\n   this.database = database;\r\n  });\r\n }\r\n async _writeToStorage() {\r\n  const databaseStr = JSON.stringify(this.database);\r\n  localStorage.setItem(\"pdfjs.history\", databaseStr);\r\n }\r\n async _readFromStorage() {\r\n  return localStorage.getItem(\"pdfjs.history\");\r\n }\r\n async set(name, val) {\r\n  await this._initializedPromise;\r\n  this.file[name] = val;\r\n  return this._writeToStorage();\r\n }\r\n async setMultiple(properties) {\r\n  await this._initializedPromise;\r\n  for (const name in properties) {\r\n   this.file[name] = properties[name];\r\n  }\r\n  return this._writeToStorage();\r\n }\r\n async get(name, defaultValue) {\r\n  await this._initializedPromise;\r\n  const val = this.file[name];\r\n  return val !== undefined ? val : defaultValue;\r\n }\r\n async getMultiple(properties) {\r\n  await this._initializedPromise;\r\n  const values = Object.create(null);\r\n  for (const name in properties) {\r\n   const val = this.file[name];\r\n   values[name] = val !== undefined ? val : properties[name];\r\n  }\r\n  return values;\r\n }\r\n}\r\nexport {\r\n ViewHistory\r\n};\r\n","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {XfaLayer} = require(\"pdfjs-dist\");\r\nclass XfaLayerBuilder {\r\n constructor({pageDiv, pdfPage, annotationStorage = null, linkService, xfaHtml = null}) {\r\n  this.pageDiv = pageDiv;\r\n  this.pdfPage = pdfPage;\r\n  this.annotationStorage = annotationStorage;\r\n  this.linkService = linkService;\r\n  this.xfaHtml = xfaHtml;\r\n  this.div = null;\r\n  this._cancelled = false;\r\n }\r\n render(viewport, intent = \"display\") {\r\n  if (intent === \"print\") {\r\n   const parameters = {\r\n    viewport: viewport.clone({ dontFlip: true }),\r\n    div: this.div,\r\n    xfaHtml: this.xfaHtml,\r\n    annotationStorage: this.annotationStorage,\r\n    linkService: this.linkService,\r\n    intent\r\n   };\r\n   const div = document.createElement(\"div\");\r\n   this.pageDiv.appendChild(div);\r\n   parameters.div = div;\r\n   const result = XfaLayer.render(parameters);\r\n   return Promise.resolve(result);\r\n  }\r\n  return this.pdfPage.getXfa().then(xfaHtml => {\r\n   if (this._cancelled || !xfaHtml) {\r\n    return { textDivs: [] };\r\n   }\r\n   const parameters = {\r\n    viewport: viewport.clone({ dontFlip: true }),\r\n    div: this.div,\r\n    xfaHtml,\r\n    annotationStorage: this.annotationStorage,\r\n    linkService: this.linkService,\r\n    intent\r\n   };\r\n   if (this.div) {\r\n    return XfaLayer.update(parameters);\r\n   }\r\n   this.div = document.createElement(\"div\");\r\n   this.pageDiv.appendChild(this.div);\r\n   parameters.div = this.div;\r\n   return XfaLayer.render(parameters);\r\n  }).catch(error => {\r\n   console.error(error);\r\n  });\r\n }\r\n cancel() {\r\n  this._cancelled = true;\r\n }\r\n hide() {\r\n  if (!this.div) {\r\n   return;\r\n  }\r\n  this.div.hidden = true;\r\n }\r\n}\r\nexport {\r\n XfaLayerBuilder\r\n};\r\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });\n\t}\n\tdef['default'] = function() { return value; };\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".SDPDFCore.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","var inProgress = {};\nvar dataWebpackPrefix = \"saltdogreader:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = function(url, done, key, chunkId) {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = function(prev, event) {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach(function(fn) { return fn(event); });\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n__webpack_require__.f.j = function(chunkId, promises) {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = function(event) {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunksaltdogreader\"] = self[\"webpackChunksaltdogreader\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","/* Copyright 2022 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Edited 2022 SaltDog Project\r\n */\r\n/* eslint-disable */\r\n\r\n//\r\n// THIS FILE IS GENERATED AUTOMATICALLY, DO NOT EDIT MANUALLY!\r\n//\r\n\r\nconst {AppOptions} = require(\"./app_options.js\");\r\nconst {PDFViewerApplication} = require(\"./app.js\");\r\nconst {SDPDFCore} = require(\"./sdpdfcore.js\");\r\nconst pdfjsVersion = '2.12.313';\r\nconst pdfjsBuild = '2.12.313';\r\nwindow.PDFViewerApplication = PDFViewerApplication;\r\nwindow.PDFViewerApplicationOptions = AppOptions;\r\n;\r\n{\r\n require(\"./pdf_print_service.js\");\r\n}\r\nconst fakediv = document.createElement('div')\r\nconst fakebutton = document.createElement('button')\r\nconst faketxtarea = document.createElement('textarea')\r\nconst fakeselect = document.createElement('select')\r\nconst fakeoption = document.createElement('option')\r\nconst fakea = document.createElement('a')\r\nconst fakeinput = document.createElement('input')\r\nconst fakespan = document.createElement('span')\r\nconst fakep = document.createElement('p')\r\nfunction getViewerConfiguration() {\r\n let errorWrapper = null;\r\n errorWrapper = {\r\n  container: document.getElementById(\"errorWrapper\")||fakediv,\r\n  errorMessage: document.getElementById(\"errorMessage\")||fakediv,\r\n  closeButton: document.getElementById(\"errorClose\")||fakebutton\r\n };\r\n return {\r\n  appContainer: document.body,\r\n  mainContainer: document.getElementById(\"viewerContainer\")||fakediv,\r\n  viewerContainer: document.getElementById(\"viewer\")||fakediv,\r\n  toolbar: {\r\n   container: document.getElementById(\"toolbarViewer\")||fakediv,\r\n   numPages: document.getElementById(\"numPages\")||fakespan,\r\n   pageNumber: document.getElementById(\"pageNumber\")||fakeinput,\r\n   scaleSelect: document.getElementById(\"scaleSelect\")||fakeselect,\r\n   scaleSelectOptions:document.getElementById(\"scaleSelectOptions\"),\r\n   scaleSelectShowOptionsButton:document.getElementById('scaleSelectShowOptionsButton'),\r\n   previous: document.getElementById(\"previous\")||fakebutton,\r\n   next: document.getElementById(\"next\")||fakebutton,\r\n   zoomIn: document.getElementById(\"zoomIn\")||fakebutton,\r\n   zoomOut: document.getElementById(\"zoomOut\")||fakebutton,\r\n   viewFind: document.getElementById(\"viewFind\")||fakebutton,//TODO:\r\n   openFile: document.getElementById(\"openFile\")||fakebutton,//TODO:\r\n   print: document.getElementById(\"print\")||fakebutton,//TODO:\r\n\r\n   download: document.getElementById(\"download\")||fakebutton,//TODO:\r\n   viewBookmark: document.getElementById(\"viewBookmark\")||fakea//TODO:\r\n  },\r\n  secondaryToolbar: {\r\n   toolbar: document.getElementById(\"secondaryToolbar\")||fakediv,\r\n   toggleButton: document.getElementById(\"secondaryToolbarToggle\")||fakebutton,\r\n   toolbarButtonContainer: document.getElementById(\"secondaryToolbarButtonContainer\")||fakediv,\r\n\r\n   openFileButton: document.getElementById(\"secondaryOpenFile\")||fakebutton,\r\n   printButton: document.getElementById(\"secondaryPrint\")||fakebutton,\r\n   downloadButton: document.getElementById(\"secondaryDownload\")||fakebutton,\r\n   viewBookmarkButton: document.getElementById(\"secondaryViewBookmark\")||fakea,\r\n   firstPageButton: document.getElementById(\"firstPage\")||fakebutton,\r\n   lastPageButton: document.getElementById(\"lastPage\")||fakebutton,\r\n   pageRotateCwButton: document.getElementById(\"pageRotateCw\")||fakebutton,\r\n   pageRotateCcwButton: document.getElementById(\"pageRotateCcw\")||fakebutton,\r\n   cursorSelectToolButton: document.getElementById(\"cursorSelectTool\")||fakebutton,\r\n   cursorHandToolButton: document.getElementById(\"cursorHandTool\")||fakebutton,\r\n   scrollPageButton: document.getElementById(\"scrollPage\")||fakebutton,\r\n   scrollVerticalButton: document.getElementById(\"scrollVertical\")||fakebutton,\r\n   scrollHorizontalButton: document.getElementById(\"scrollHorizontal\")||fakebutton,\r\n   scrollWrappedButton: document.getElementById(\"scrollWrapped\")||fakebutton,\r\n   spreadNoneButton: document.getElementById(\"spreadNone\")||fakebutton,\r\n   spreadOddButton: document.getElementById(\"spreadOdd\")||fakebutton,\r\n   spreadEvenButton: document.getElementById(\"spreadEven\")||fakebutton,\r\n   // saltdog disable documentProperties\r\n  //  documentPropertiesButton: document.getElementById(\"documentProperties\")\r\n  },\r\n  // sdpdfcore disable sidebar\r\n//   sidebar: {\r\n//    outerContainer: document.getElementById(\"outerContainer\"),\r\n//    viewerContainer: document.getElementById(\"viewerContainer\"),\r\n//    toggleButton: document.getElementById(\"sidebarToggle\"),\r\n//    thumbnailButton: document.getElementById(\"viewThumbnail\"),\r\n//    outlineButton: document.getElementById(\"viewOutline\"),\r\n//    attachmentsButton: document.getElementById(\"viewAttachments\"),\r\n//    layersButton: document.getElementById(\"viewLayers\"),\r\n//    thumbnailView: document.getElementById(\"thumbnailView\"),\r\n//    outlineView: document.getElementById(\"outlineView\"),\r\n//    attachmentsView: document.getElementById(\"attachmentsView\"),\r\n//    layersView: document.getElementById(\"layersView\"),\r\n//    outlineOptionsContainer: document.getElementById(\"outlineOptionsContainer\"),\r\n//    currentOutlineItemButton: document.getElementById(\"currentOutlineItem\")\r\n//   },\r\n//   sidebarResizer: {\r\n//    outerContainer: document.getElementById(\"outerContainer\"),\r\n//    resizer: document.getElementById(\"sidebarResizer\")\r\n//   },\r\n  findBar: {\r\n   bar: document.getElementById(\"findbar\")||fakediv,\r\n   toggleButton: document.getElementById(\"viewFind\")||fakebutton,\r\n   findField: document.getElementById(\"findInput\")||fakeinput,\r\n   highlightAllCheckbox: document.getElementById(\"findHighlightAll\")||fakeinput,\r\n   caseSensitiveCheckbox: document.getElementById(\"findMatchCase\")||fakeinput,\r\n   matchDiacriticsCheckbox: document.getElementById(\"findMatchDiacritics\")||fakeinput,\r\n   entireWordCheckbox: document.getElementById(\"findEntireWord\")||fakeinput,\r\n   findMsg: document.getElementById(\"findMsg\")||fakespan,\r\n   findResultsCount: document.getElementById(\"findResultsCount\")||fakespan,\r\n   findPreviousButton: document.getElementById(\"findPrevious\")||fakebutton,\r\n   findNextButton: document.getElementById(\"findNext\")||fakebutton\r\n  },\r\n  passwordOverlay: {\r\n   overlayName: \"passwordOverlay\",\r\n   container: document.getElementById(\"passwordOverlay\")||fakediv,\r\n   label: document.getElementById(\"passwordText\")||fakep,\r\n   input: document.getElementById(\"password\")||fakeinput,\r\n   submitButton: document.getElementById(\"passwordSubmit\")||fakebutton,\r\n   cancelButton: document.getElementById(\"passwordCancel\")||fakebutton\r\n  },\r\n  // saltdog disable documentProperties\r\n  // documentProperties: {\r\n  //  overlayName: \"documentPropertiesOverlay\",\r\n  //  container: document.getElementById(\"documentPropertiesOverlay\"),\r\n  //  closeButton: document.getElementById(\"documentPropertiesClose\"),\r\n  //  fields: {\r\n  //   fileName: document.getElementById(\"fileNameField\"),\r\n  //   fileSize: document.getElementById(\"fileSizeField\"),\r\n  //   title: document.getElementById(\"titleField\"),\r\n  //   author: document.getElementById(\"authorField\"),\r\n  //   subject: document.getElementById(\"subjectField\"),\r\n  //   keywords: document.getElementById(\"keywordsField\"),\r\n  //   creationDate: document.getElementById(\"creationDateField\"),\r\n  //   modificationDate: document.getElementById(\"modificationDateField\"),\r\n  //   creator: document.getElementById(\"creatorField\"),\r\n  //   producer: document.getElementById(\"producerField\"),\r\n  //   version: document.getElementById(\"versionField\"),\r\n  //   pageCount: document.getElementById(\"pageCountField\"),\r\n  //   pageSize: document.getElementById(\"pageSizeField\"),\r\n  //   linearized: document.getElementById(\"linearizedField\")\r\n  //  }\r\n  // },\r\n  annotationButton:{\r\n      highLightAnnotation:document.getElementById(\"highLightAnno\")||fakebutton\r\n  },\r\n  errorWrapper,\r\n  printContainer: document.getElementById(\"printContainer\")||fakediv,\r\n  openFileInputName: \"fileInput\",\r\n  debuggerScriptPath: \"./debugger.js\"\r\n };\r\n}\r\n\r\nfunction webViewerLoad() {\r\n    console.log(`webViewerLoad`);\r\n const config = getViewerConfiguration();\r\n Promise.all([\r\n  import(\"./genericcom.js\"),\r\n  import(\"./pdf_print_service.js\")\r\n ]).then(function ([genericCom, pdfPrintService]) {\r\n  console.log(`SDPDFCore Ready`);\r\n  // wait to run app\r\n    PDFViewerApplication.run(config)\r\n });\r\n}\r\nif (document.blockUnblockOnload) {\r\n document.blockUnblockOnload(true);\r\n}\r\nif (document.readyState === \"interactive\" || document.readyState === \"complete\") {\r\n webViewerLoad();\r\n} else {\r\n document.addEventListener(\"DOMContentLoaded\", webViewerLoad, true);\r\n}\r\nexport {\r\n PDFViewerApplication,\r\n AppOptions as PDFViewerApplicationOptions\r\n};\r\n"],"names":[],"sourceRoot":""}